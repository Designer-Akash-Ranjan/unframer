diff --git a/unframer/scripts/download.ts b/unframer/scripts/download.ts
index ce59015..f15976c 100644
--- a/unframer/scripts/download.ts
+++ b/unframer/scripts/download.ts
@@ -121,7 +121,7 @@ export async function fixFramerCode({ resultFile }) {
             // purePlugin,
         ],
         filename: '',
-        compact: false,
+        compact: true,
         
         sourceMaps: false,
     })
diff --git a/unframer/src/framer.js b/unframer/src/framer.js
index 8e6f685..a4713c7 100644
--- a/unframer/src/framer.js
+++ b/unframer/src/framer.js
@@ -18,49 +18,27 @@ var __getOwnPropNames = Object.getOwnPropertyNames;
 var __getProtoOf = Object.getPrototypeOf;
 var __hasOwnProp = Object.prototype.hasOwnProperty;
 var __defNormalProp = (obj, key7, value,) =>
-  key7 in obj
-    ? __defProp(obj, key7, {
-      enumerable: true,
-      configurable: true,
-      writable: true,
-      value,
-    },)
-    : obj[key7] = value;
+  key7 in obj ? __defProp(obj, key7, { enumerable: true, configurable: true, writable: true, value, },) : obj[key7] = value;
 var __commonJS = (cb, mod,) =>
   function __require() {
-    return mod || (0, cb[__getOwnPropNames(cb,)[0]])(
-      (mod = {
-        exports: {},
-      }).exports,
-      mod,
-    ),
-      mod.exports;
+    return mod || (0, cb[__getOwnPropNames(cb,)[0]])((mod = { exports: {}, }).exports, mod,), mod.exports;
   };
 var __copyProps = (to, from, except, desc,) => {
   if (from && typeof from === 'object' || typeof from === 'function') {
     for (let key7 of __getOwnPropNames(from,)) {
       if (!__hasOwnProp.call(to, key7,) && key7 !== except) {
-        __defProp(to, key7, {
-          get: () => from[key7],
-          enumerable: !(desc = __getOwnPropDesc(from, key7,)) || desc.enumerable,
-        },);
+        __defProp(to, key7, { get: () => from[key7], enumerable: !(desc = __getOwnPropDesc(from, key7,)) || desc.enumerable, },);
       }
     }
   }
   return to;
 };
 var __toESM = (mod, isNodeMode, target,) => (target = mod != null ? __create(__getProtoOf(mod,),) : {},
-  __copyProps(
-    // If the importer is in node compatibility mode or this is not an ESM
+  __copyProps( // If the importer is in node compatibility mode or this is not an ESM
     // file that has been converted to a CommonJS file using a Babel-
     // compatible transform (i.e. "__esModule" has not been set), then set
     // "default" to the CommonJS "module.exports" for node compatibility.
-    isNodeMode || !mod || !mod.__esModule
-      ? __defProp(target, 'default', {
-        value: mod,
-        enumerable: true,
-      },)
-      : target,
+    isNodeMode || !mod || !mod.__esModule ? __defProp(target, 'default', { value: mod, enumerable: true, },) : target,
     mod,
   ));
 var __publicField = (obj, key7, value,) => {
@@ -86,10 +64,7 @@ var __privateSet = (obj, member, value, setter,) => {
 var require_memoize_browser_cjs = __commonJS({
   '../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js'(exports,) {
     'use strict';
-
-    Object.defineProperty(exports, '__esModule', {
-      value: true,
-    },);
+    Object.defineProperty(exports, '__esModule', { value: true, },);
     function memoize3(fn,) {
       var cache3 = {};
       return function (arg,) {
@@ -103,10 +78,7 @@ var require_memoize_browser_cjs = __commonJS({
 var require_is_prop_valid_browser_cjs = __commonJS({
   '../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js'(exports,) {
     'use strict';
-
-    Object.defineProperty(exports, '__esModule', {
-      value: true,
-    },);
+    Object.defineProperty(exports, '__esModule', { value: true, },);
     function _interopDefault(ex,) {
       return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
     }
@@ -115,16 +87,11 @@ var require_is_prop_valid_browser_cjs = __commonJS({
       /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
     var index = memoize3(function (prop,) {
       return reactPropsRegex2.test(prop,) || prop.charCodeAt(0,) === 111 && prop.charCodeAt(1,) === 110 && prop.charCodeAt(2,) < 91;
-    },/* Z+1 */
-    );
+    }, /* Z+1 */);
     exports.default = index;
   },
 },);
-var MotionConfigContext = createContext({
-  transformPagePoint: (p) => p,
-  isStatic: false,
-  reducedMotion: 'never',
-},);
+var MotionConfigContext = createContext({ transformPagePoint: (p) => p, isStatic: false, reducedMotion: 'never', },);
 var MotionContext = createContext({},);
 var PresenceContext = createContext(null,);
 var isBrowser = typeof document !== 'undefined';
@@ -132,15 +99,10 @@ var useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;
 var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, '$1-$2',).toLowerCase();
 var optimizedAppearDataId = 'framerAppearId';
 var optimizedAppearDataAttribute = 'data-' + camelToDash(optimizedAppearDataId,);
-var MotionGlobalConfig = {
-  skipAnimations: false,
-  useManualTiming: false,
-};
+var MotionGlobalConfig = { skipAnimations: false, useManualTiming: false, };
 var LayoutGroupContext = createContext({},);
 var SwitchLayoutGroupContext = createContext({},);
-var LazyContext = createContext({
-  strict: false,
-},);
+var LazyContext = createContext({ strict: false, },);
 var Queue = class {
   constructor() {
     this.order = [];
@@ -175,24 +137,19 @@ function createRenderStep(runNextFrame,) {
   const step2 = {
     /**
      * Schedule a process to run on the next frame.
-     */
-    schedule: (callback, keepAlive = false, immediate = false,) => {
+     */ schedule: (callback, keepAlive = false, immediate = false,) => {
       const addToCurrentFrame = immediate && isProcessing;
       const queue = addToCurrentFrame ? thisFrame : nextFrame;
       if (keepAlive) toKeepAlive.add(callback,);
-      if (queue.add(callback,) && addToCurrentFrame && isProcessing) {
-        numToRun = thisFrame.order.length;
-      }
+      if (queue.add(callback,) && addToCurrentFrame && isProcessing) numToRun = thisFrame.order.length;
       return callback;
-    },
-    /**
+    }, /**
      * Cancel the provided callback from running on the next frame.
      */
     cancel: (callback) => {
       nextFrame.remove(callback,);
       toKeepAlive.delete(callback,);
-    },
-    /**
+    }, /**
      * Execute all schedule callbacks.
      */
     process: (frameData2) => {
@@ -228,11 +185,7 @@ var maxElapsed = 40;
 function createRenderBatcher(scheduleNextBatch, allowKeepAlive,) {
   let runNextFrame = false;
   let useDefaultElapsed = true;
-  const state = {
-    delta: 0,
-    timestamp: 0,
-    isProcessing: false,
-  };
+  const state = { delta: 0, timestamp: 0, isProcessing: false, };
   const steps2 = stepsOrder.reduce((acc, key7,) => {
     acc[key7] = createRenderStep(() => runNextFrame = true);
     return acc;
@@ -256,9 +209,7 @@ function createRenderBatcher(scheduleNextBatch, allowKeepAlive,) {
   const wake = () => {
     runNextFrame = true;
     useDefaultElapsed = true;
-    if (!state.isProcessing) {
-      scheduleNextBatch(processBatch,);
-    }
+    if (!state.isProcessing) scheduleNextBatch(processBatch,);
   };
   const schedule = stepsOrder.reduce((acc, key7,) => {
     const step2 = steps2[key7];
@@ -269,21 +220,11 @@ function createRenderBatcher(scheduleNextBatch, allowKeepAlive,) {
     return acc;
   }, {},);
   const cancel = (process2) => stepsOrder.forEach((key7) => steps2[key7].cancel(process2,));
-  return {
-    schedule,
-    cancel,
-    state,
-    steps: steps2,
-  };
+  return { schedule, cancel, state, steps: steps2, };
 }
-var {
-  schedule: microtask,
-  cancel: cancelMicrotask,
-} = createRenderBatcher(queueMicrotask, false,);
+var { schedule: microtask, cancel: cancelMicrotask, } = createRenderBatcher(queueMicrotask, false,);
 function useVisualElement(Component23, visualState, props, createVisualElement2,) {
-  const {
-    visualElement: parent,
-  } = useContext3(MotionContext,);
+  const { visualElement: parent, } = useContext3(MotionContext,);
   const lazyContext = useContext3(LazyContext,);
   const presenceContext = useContext3(PresenceContext,);
   const reducedMotionConfig = useContext3(MotionConfigContext,).reducedMotion;
@@ -307,16 +248,12 @@ function useVisualElement(Component23, visualState, props, createVisualElement2,
   useIsomorphicLayoutEffect(() => {
     if (!visualElement) return;
     microtask.postRender(visualElement.render,);
-    if (wantsHandoff.current && visualElement.animationState) {
-      visualElement.animationState.animateChanges();
-    }
+    if (wantsHandoff.current && visualElement.animationState) visualElement.animationState.animateChanges();
   },);
   useEffect(() => {
     if (!visualElement) return;
     visualElement.updateFeatures();
-    if (!wantsHandoff.current && visualElement.animationState) {
-      visualElement.animationState.animateChanges();
-    }
+    if (!wantsHandoff.current && visualElement.animationState) visualElement.animationState.animateChanges();
     if (wantsHandoff.current) {
       wantsHandoff.current = false;
       window.HandoffComplete = true;
@@ -330,22 +267,16 @@ function isRefObject(ref,) {
 function useMotionRef(visualState, visualElement, externalRef,) {
   return useCallback((instance) => {
     instance && visualState.mount && visualState.mount(instance,);
-    if (visualElement) {
-      instance ? visualElement.mount(instance,) : visualElement.unmount();
-    }
+    if (visualElement) instance ? visualElement.mount(instance,) : visualElement.unmount();
     if (externalRef) {
-      if (typeof externalRef === 'function') {
-        externalRef(instance,);
-      } else if (isRefObject(externalRef,)) {
-        externalRef.current = instance;
-      }
+      if (typeof externalRef === 'function') externalRef(instance,);
+      else if (isRefObject(externalRef,)) externalRef.current = instance;
     }
   }, /**
    * Only pass a new ref callback to React if we've received a visual element
    * factory. Otherwise we'll be mounting/remounting every time externalRef
    * or other dependencies change.
-   */
-  [visualElement,],);
+   */ [visualElement,],);
 }
 function isVariantLabel(v,) {
   return typeof v === 'string' || Array.isArray(v,);
@@ -363,10 +294,7 @@ function isVariantNode(props,) {
 }
 function getCurrentTreeVariants(props, context,) {
   if (isControllingVariants(props,)) {
-    const {
-      initial,
-      animate: animate22,
-    } = props;
+    const { initial, animate: animate22, } = props;
     return {
       initial: initial === false || isVariantLabel(initial,) ? initial : void 0,
       animate: isVariantLabel(animate22,) ? animate22 : void 0,
@@ -375,14 +303,8 @@ function getCurrentTreeVariants(props, context,) {
   return props.inherit !== false ? context : {};
 }
 function useCreateMotionContext(props,) {
-  const {
-    initial,
-    animate: animate22,
-  } = getCurrentTreeVariants(props, useContext3(MotionContext,),);
-  return useMemo(() => ({
-    initial,
-    animate: animate22,
-  }), [variantLabelsAsDependency(initial,), variantLabelsAsDependency(animate22,),],);
+  const { initial, animate: animate22, } = getCurrentTreeVariants(props, useContext3(MotionContext,),);
+  return useMemo(() => ({ initial, animate: animate22, }), [variantLabelsAsDependency(initial,), variantLabelsAsDependency(animate22,),],);
 }
 function variantLabelsAsDependency(prop,) {
   return Array.isArray(prop,) ? prop.join(' ',) : prop;
@@ -399,38 +321,25 @@ var featureProps = {
   layout: ['layout', 'layoutId',],
 };
 var featureDefinitions = {};
-for (const key7 in featureProps) {
-  featureDefinitions[key7] = {
-    isEnabled: (props) => featureProps[key7].some((name) => !!props[name]),
-  };
-}
+for (const key7 in featureProps) featureDefinitions[key7] = { isEnabled: (props) => featureProps[key7].some((name) => !!props[name]), };
 function loadFeatures(features,) {
-  for (const key7 in features) {
-    featureDefinitions[key7] = {
-      ...featureDefinitions[key7],
-      ...features[key7],
-    };
-  }
+  for (const key7 in features) featureDefinitions[key7] = { ...featureDefinitions[key7], ...features[key7], };
 }
 var motionComponentSymbol = Symbol.for('motionComponentSymbol',);
-function createMotionComponent({
-  preloadedFeatures: preloadedFeatures2,
-  createVisualElement: createVisualElement2,
-  useRender,
-  useVisualState: useVisualState2,
-  Component: Component23,
-},) {
+function createMotionComponent(
+  {
+    preloadedFeatures: preloadedFeatures2,
+    createVisualElement: createVisualElement2,
+    useRender,
+    useVisualState: useVisualState2,
+    Component: Component23,
+  },
+) {
   preloadedFeatures2 && loadFeatures(preloadedFeatures2,);
   function MotionComponent(props, externalRef,) {
     let MeasureLayout2;
-    const configAndProps = {
-      ...useContext3(MotionConfigContext,),
-      ...props,
-      layoutId: useLayoutId(props,),
-    };
-    const {
-      isStatic,
-    } = configAndProps;
+    const configAndProps = { ...useContext3(MotionConfigContext,), ...props, layoutId: useLayoutId(props,), };
+    const { isStatic, } = configAndProps;
     const context = useCreateMotionContext(props,);
     const visualState = useVisualState2(props, isStatic,);
     if (!isStatic && isBrowser) {
@@ -438,8 +347,7 @@ function createMotionComponent({
       const initialLayoutGroupConfig = useContext3(SwitchLayoutGroupContext,);
       const isStrict = useContext3(LazyContext,).strict;
       if (context.visualElement) {
-        MeasureLayout2 = context.visualElement.loadFeatures(
-          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
+        MeasureLayout2 = context.visualElement.loadFeatures( // Note: Pass the full new combined props to correctly re-render dynamic feature components.
           configAndProps,
           isStrict,
           preloadedFeatures2,
@@ -449,14 +357,9 @@ function createMotionComponent({
     }
     return React.createElement(
       MotionContext.Provider,
-      {
-        value: context,
-      },
+      { value: context, },
       MeasureLayout2 && context.visualElement
-        ? React.createElement(MeasureLayout2, {
-          visualElement: context.visualElement,
-          ...configAndProps,
-        },)
+        ? React.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps, },)
         : null,
       useRender(
         Component23,
@@ -472,9 +375,7 @@ function createMotionComponent({
   ForwardRefComponent[motionComponentSymbol] = Component23;
   return ForwardRefComponent;
 }
-function useLayoutId({
-  layoutId,
-},) {
+function useLayoutId({ layoutId, },) {
   const layoutGroupId = useContext3(LayoutGroupContext,).id;
   return layoutGroupId && layoutId !== void 0 ? layoutGroupId + '-' + layoutId : layoutId;
 }
@@ -503,19 +404,11 @@ var transformPropOrder = [
   'skewY',
 ];
 var transformProps = new Set(transformPropOrder,);
-var translateAlias = {
-  x: 'translateX',
-  y: 'translateY',
-  z: 'translateZ',
-  transformPerspective: 'perspective',
-};
+var translateAlias = { x: 'translateX', y: 'translateY', z: 'translateZ', transformPerspective: 'perspective', };
 var numTransforms = transformPropOrder.length;
 function buildTransform(
   transform2,
-  {
-    enableHardwareAcceleration = true,
-    allowTransformNone = true,
-  },
+  { enableHardwareAcceleration = true, allowTransformNone = true, },
   transformIsDefault,
   transformTemplate2,
 ) {
@@ -527,15 +420,10 @@ function buildTransform(
       transformString2 += `${transformName}(${transform2[key7]}) `;
     }
   }
-  if (enableHardwareAcceleration && !transform2.z) {
-    transformString2 += 'translateZ(0)';
-  }
+  if (enableHardwareAcceleration && !transform2.z) transformString2 += 'translateZ(0)';
   transformString2 = transformString2.trim();
-  if (transformTemplate2) {
-    transformString2 = transformTemplate2(transform2, transformIsDefault ? '' : transformString2,);
-  } else if (allowTransformNone && transformIsDefault) {
-    transformString2 = 'none';
-  }
+  if (transformTemplate2) transformString2 = transformTemplate2(transform2, transformIsDefault ? '' : transformString2,);
+  else if (allowTransformNone && transformIsDefault) transformString2 = 'none';
   return transformString2;
 }
 var clamp = (min, max, v,) => {
@@ -561,11 +449,7 @@ var percent = createUnitType('%',);
 var px = createUnitType('px',);
 var vh = createUnitType('vh',);
 var vw = createUnitType('vw',);
-var progressPercentage = {
-  ...percent,
-  parse: (v) => percent.parse(v,) / 100,
-  transform: (v) => percent.transform(v * 100,),
-};
+var progressPercentage = { ...percent, parse: (v) => percent.parse(v,) / 100, transform: (v) => percent.transform(v * 100,), };
 var validMotionProps = /* @__PURE__ */ new Set([
   'animate',
   'exit',
@@ -615,12 +499,9 @@ function filterProps(props, isDom, forwardMotionProps,) {
   for (const key7 in props) {
     if (key7 === 'values' && typeof props.values === 'object') continue;
     if (
-      shouldForward(key7,) || forwardMotionProps === true && isValidMotionProp(key7,) || !isDom && !isValidMotionProp(key7,) ||
-      // If trying to use native HTML drag events, forward drag listeners
+      shouldForward(key7,) || forwardMotionProps === true && isValidMotionProp(key7,) || !isDom && !isValidMotionProp(key7,) || // If trying to use native HTML drag events, forward drag listeners
       props['draggable'] && key7.startsWith('onDrag',)
-    ) {
-      filteredProps2[key7] = props[key7];
-    }
+    ) filteredProps2[key7] = props[key7];
   }
   return filteredProps2;
 }
@@ -638,30 +519,18 @@ function resolveMotionValue(value,) {
   return isCustomValue(unwrappedValue,) ? unwrappedValue.toValue() : unwrappedValue;
 }
 function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {},) {
-  if (typeof definition === 'function') {
-    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
-  }
-  if (typeof definition === 'string') {
-    definition = props.variants && props.variants[definition];
-  }
-  if (typeof definition === 'function') {
-    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
-  }
+  if (typeof definition === 'function') definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
+  if (typeof definition === 'string') definition = props.variants && props.variants[definition];
+  if (typeof definition === 'function') definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
   return definition;
 }
 function useConstant(init,) {
   const ref = useRef(null,);
-  if (ref.current === null) {
-    ref.current = init();
-  }
+  if (ref.current === null) ref.current = init();
   return ref.current;
 }
 function makeState(
-  {
-    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3,
-    createRenderState,
-    onMount,
-  },
+  { scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount, },
   props,
   context,
   presenceContext,
@@ -670,9 +539,7 @@ function makeState(
     latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3,),
     renderState: createRenderState(),
   };
-  if (onMount) {
-    state.mount = (instance) => onMount(props, instance, state,);
-  }
+  if (onMount) state.mount = (instance) => onMount(props, instance, state,);
   return state;
 }
 var makeUseVisualState = (config) => (props, isStatic,) => {
@@ -684,13 +551,8 @@ var makeUseVisualState = (config) => (props, isStatic,) => {
 function makeLatestValues(props, context, presenceContext, scrapeMotionValues,) {
   const values = {};
   const motionValues = scrapeMotionValues(props, {},);
-  for (const key7 in motionValues) {
-    values[key7] = resolveMotionValue(motionValues[key7],);
-  }
-  let {
-    initial,
-    animate: animate22,
-  } = props;
+  for (const key7 in motionValues) values[key7] = resolveMotionValue(motionValues[key7],);
+  let { initial, animate: animate22, } = props;
   const isControllingVariants$1 = isControllingVariants(props,);
   const isVariantNode$1 = isVariantNode(props,);
   if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
@@ -705,20 +567,14 @@ function makeLatestValues(props, context, presenceContext, scrapeMotionValues,)
     list.forEach((definition) => {
       const resolved = resolveVariantFromProps(props, definition,);
       if (!resolved) return;
-      const {
-        transitionEnd,
-        transition,
-        ...target
-      } = resolved;
+      const { transitionEnd, transition, ...target } = resolved;
       for (const key7 in target) {
         let valueTarget = target[key7];
         if (Array.isArray(valueTarget,)) {
           const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
           valueTarget = valueTarget[index];
         }
-        if (valueTarget !== null) {
-          values[key7] = valueTarget;
-        }
+        if (valueTarget !== null) values[key7] = valueTarget;
       }
       for (const key7 in transitionEnd) values[key7] = transitionEnd[key7];
     },);
@@ -726,33 +582,21 @@ function makeLatestValues(props, context, presenceContext, scrapeMotionValues,)
   return values;
 }
 var noop = (any) => any;
-var {
-  schedule: frame,
-  cancel: cancelFrame,
-  state: frameData,
-  steps,
-} = createRenderBatcher(typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : noop, true,);
+var { schedule: frame, cancel: cancelFrame, state: frameData, steps, } = createRenderBatcher(
+  typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : noop,
+  true,
+);
 var isPrimaryPointer = (event) => {
-  if (event.pointerType === 'mouse') {
-    return typeof event.button !== 'number' || event.button <= 0;
-  } else {
-    return event.isPrimary !== false;
-  }
+  if (event.pointerType === 'mouse') return typeof event.button !== 'number' || event.button <= 0;
+  else return event.isPrimary !== false;
 };
 function extractEventInfo(event, pointType = 'page',) {
-  return {
-    point: {
-      x: event[pointType + 'X'],
-      y: event[pointType + 'Y'],
-    },
-  };
+  return { point: { x: event[pointType + 'X'], y: event[pointType + 'Y'], }, };
 }
 var addPointerInfo = (handler) => {
   return (event) => isPrimaryPointer(event,) && handler(event, extractEventInfo(event,),);
 };
-function addDomEvent(target, eventName, handler, options = {
-  passive: true,
-},) {
+function addDomEvent(target, eventName, handler, options = { passive: true, },) {
   target.addEventListener(eventName, handler, options,);
   return () => target.removeEventListener(eventName, handler,);
 }
@@ -778,11 +622,9 @@ var globalHorizontalLock = createLock('dragHorizontal',);
 var globalVerticalLock = createLock('dragVertical',);
 function getGlobalLock(drag2,) {
   let lock = false;
-  if (drag2 === 'y') {
-    lock = globalVerticalLock();
-  } else if (drag2 === 'x') {
-    lock = globalHorizontalLock();
-  } else {
+  if (drag2 === 'y') lock = globalVerticalLock();
+  else if (drag2 === 'x') lock = globalHorizontalLock();
+  else {
     const openHorizontal = globalHorizontalLock();
     const openVertical = globalVerticalLock();
     if (openHorizontal && openVertical) {
@@ -807,14 +649,10 @@ var warning = noop;
 var invariant = noop;
 if (false) {
   warning = (check, message,) => {
-    if (!check && typeof console !== 'undefined') {
-      console.warn(message,);
-    }
+    if (!check && typeof console !== 'undefined') console.warn(message,);
   };
   invariant = (check, message,) => {
-    if (!check) {
-      throw new Error(message,);
-    }
+    if (!check) throw new Error(message,);
   };
 }
 var calcBezier = (t, a1, a2,) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
@@ -827,11 +665,8 @@ function binarySubdivide(x, lowerBound, upperBound, mX1, mX2,) {
   do {
     currentT = lowerBound + (upperBound - lowerBound) / 2;
     currentX = calcBezier(currentT, mX1, mX2,) - x;
-    if (currentX > 0) {
-      upperBound = currentT;
-    } else {
-      lowerBound = currentT;
-    }
+    if (currentX > 0) upperBound = currentT;
+    else lowerBound = currentT;
   } while (Math.abs(currentX,) > subdivisionPrecision && ++i < subdivisionMaxIterations);
   return currentT;
 }
@@ -856,19 +691,9 @@ var progress = (from, to, value,) => {
   const toFromDifference = to - from;
   return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
 };
-var number = {
-  test: (v) => typeof v === 'number',
-  parse: parseFloat,
-  transform: (v) => v,
-};
-var alpha = {
-  ...number,
-  transform: (v) => clamp(0, 1, v,),
-};
-var scale = {
-  ...number,
-  default: 1,
-};
+var number = { test: (v) => typeof v === 'number', parse: parseFloat, transform: (v) => v, };
+var alpha = { ...number, transform: (v) => clamp(0, 1, v,), };
+var scale = { ...number, default: 1, };
 var isColorString = (type, testProp,) => (v) => {
   return Boolean(
     isString(v,) && singleColorRegex.test(v,) && v.startsWith(type,) || testProp && Object.prototype.hasOwnProperty.call(v, testProp,),
@@ -877,27 +702,14 @@ var isColorString = (type, testProp,) => (v) => {
 var splitColor = (aName, bName, cName,) => (v) => {
   if (!isString(v,)) return v;
   const [a, b, c, alpha2,] = v.match(floatRegex,);
-  return {
-    [aName]: parseFloat(a,),
-    [bName]: parseFloat(b,),
-    [cName]: parseFloat(c,),
-    alpha: alpha2 !== void 0 ? parseFloat(alpha2,) : 1,
-  };
+  return { [aName]: parseFloat(a,), [bName]: parseFloat(b,), [cName]: parseFloat(c,), alpha: alpha2 !== void 0 ? parseFloat(alpha2,) : 1, };
 };
 var clampRgbUnit = (v) => clamp(0, 255, v,);
-var rgbUnit = {
-  ...number,
-  transform: (v) => Math.round(clampRgbUnit(v,),),
-};
+var rgbUnit = { ...number, transform: (v) => Math.round(clampRgbUnit(v,),), };
 var rgba = {
   test: isColorString('rgb', 'red',),
   parse: splitColor('red', 'green', 'blue',),
-  transform: ({
-    red,
-    green,
-    blue,
-    alpha: alpha$1 = 1,
-  },) =>
+  transform: ({ red, green, blue, alpha: alpha$1 = 1, },) =>
     'rgba(' + rgbUnit.transform(red,) + ', ' + rgbUnit.transform(green,) + ', ' + rgbUnit.transform(blue,) + ', ' +
     sanitize(alpha.transform(alpha$1,),) + ')',
 };
@@ -921,27 +733,13 @@ function parseHex(v,) {
     b += b;
     a += a;
   }
-  return {
-    red: parseInt(r, 16,),
-    green: parseInt(g, 16,),
-    blue: parseInt(b, 16,),
-    alpha: a ? parseInt(a, 16,) / 255 : 1,
-  };
+  return { red: parseInt(r, 16,), green: parseInt(g, 16,), blue: parseInt(b, 16,), alpha: a ? parseInt(a, 16,) / 255 : 1, };
 }
-var hex = {
-  test: isColorString('#',),
-  parse: parseHex,
-  transform: rgba.transform,
-};
+var hex = { test: isColorString('#',), parse: parseHex, transform: rgba.transform, };
 var hsla = {
   test: isColorString('hsl', 'hue',),
   parse: splitColor('hue', 'saturation', 'lightness',),
-  transform: ({
-    hue,
-    saturation,
-    lightness,
-    alpha: alpha$1 = 1,
-  },) => {
+  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1, },) => {
     return 'hsla(' + Math.round(hue,) + ', ' + percent.transform(sanitize(saturation,),) + ', ' + percent.transform(sanitize(lightness,),) +
       ', ' + sanitize(alpha.transform(alpha$1,),) + ')';
   },
@@ -949,13 +747,9 @@ var hsla = {
 var color = {
   test: (v) => rgba.test(v,) || hex.test(v,) || hsla.test(v,),
   parse: (v) => {
-    if (rgba.test(v,)) {
-      return rgba.parse(v,);
-    } else if (hsla.test(v,)) {
-      return hsla.parse(v,);
-    } else {
-      return hex.parse(v,);
-    }
+    if (rgba.test(v,)) return rgba.parse(v,);
+    else if (hsla.test(v,)) return hsla.parse(v,);
+    else return hex.parse(v,);
   },
   transform: (v) => {
     return isString(v,) ? v : v.hasOwnProperty('red',) ? rgba.transform(v,) : hsla.transform(v,);
@@ -977,11 +771,7 @@ var complexRegex =
 function analyseComplexValue(value,) {
   const originalValue = value.toString();
   const values = [];
-  const indexes = {
-    color: [],
-    number: [],
-    var: [],
-  };
+  const indexes = { color: [], number: [], var: [], };
   const types2 = [];
   let i = 0;
   const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
@@ -1002,21 +792,13 @@ function analyseComplexValue(value,) {
     return SPLIT_TOKEN;
   },);
   const split = tokenised.split(SPLIT_TOKEN,);
-  return {
-    values,
-    split,
-    indexes,
-    types: types2,
-  };
+  return { values, split, indexes, types: types2, };
 }
 function parseComplexValue(v,) {
   return analyseComplexValue(v,).values;
 }
 function createTransformer(source,) {
-  const {
-    split,
-    types: types2,
-  } = analyseComplexValue(source,);
+  const { split, types: types2, } = analyseComplexValue(source,);
   const numSections = split.length;
   return (v) => {
     let output = '';
@@ -1024,13 +806,9 @@ function createTransformer(source,) {
       output += split[i];
       if (v[i] !== void 0) {
         const type = types2[i];
-        if (type === NUMBER_TOKEN) {
-          output += sanitize(v[i],);
-        } else if (type === COLOR_TOKEN) {
-          output += color.transform(v[i],);
-        } else {
-          output += v[i];
-        }
+        if (type === NUMBER_TOKEN) output += sanitize(v[i],);
+        else if (type === COLOR_TOKEN) output += color.transform(v[i],);
+        else output += v[i];
       }
     }
     return output;
@@ -1042,12 +820,7 @@ function getAnimatableNone(v,) {
   const transformer = createTransformer(v,);
   return transformer(parsed.map(convertNumbersToZero,),);
 }
-var complex = {
-  test,
-  parse: parseComplexValue,
-  createTransformer,
-  getAnimatableNone,
-};
+var complex = { test, parse: parseComplexValue, createTransformer, getAnimatableNone, };
 var mixNumber = (from, to, progress2,) => {
   return from + (to - from) * progress2;
 };
@@ -1059,33 +832,22 @@ function hueToRgb(p, q, t,) {
   if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
   return p;
 }
-function hslaToRgba({
-  hue,
-  saturation,
-  lightness,
-  alpha: alpha2,
-},) {
+function hslaToRgba({ hue, saturation, lightness, alpha: alpha2, },) {
   hue /= 360;
   saturation /= 100;
   lightness /= 100;
   let red = 0;
   let green = 0;
   let blue = 0;
-  if (!saturation) {
-    red = green = blue = lightness;
-  } else {
+  if (!saturation) red = green = blue = lightness;
+  else {
     const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
     const p = 2 * lightness - q;
     red = hueToRgb(p, q, hue + 1 / 3,);
     green = hueToRgb(p, q, hue,);
     blue = hueToRgb(p, q, hue - 1 / 3,);
   }
-  return {
-    red: Math.round(red * 255,),
-    green: Math.round(green * 255,),
-    blue: Math.round(blue * 255,),
-    alpha: alpha2,
-  };
+  return { red: Math.round(red * 255,), green: Math.round(green * 255,), blue: Math.round(blue * 255,), alpha: alpha2, };
 }
 var mixLinearColor = (from, to, v,) => {
   const fromExpo = from * from;
@@ -1098,17 +860,13 @@ function asRGBA(color2,) {
   const type = getColorType(color2,);
   invariant(Boolean(type,), `'${color2}' is not an animatable color. Use the equivalent color code instead.`,);
   let model = type.parse(color2,);
-  if (type === hsla) {
-    model = hslaToRgba(model,);
-  }
+  if (type === hsla) model = hslaToRgba(model,);
   return model;
 }
 var mixColor = (from, to,) => {
   const fromRGBA = asRGBA(from,);
   const toRGBA = asRGBA(to,);
-  const blended = {
-    ...fromRGBA,
-  };
+  const blended = { ...fromRGBA, };
   return (v) => {
     blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v,);
     blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v,);
@@ -1133,15 +891,10 @@ function mixNumber2(a, b,) {
   return (p) => mixNumber(a, b, p,);
 }
 function getMixer(a,) {
-  if (typeof a === 'number') {
-    return mixNumber2;
-  } else if (typeof a === 'string') {
-    return isCSSVariableToken(a,) ? mixImmediate : color.test(a,) ? mixColor : mixComplex;
-  } else if (Array.isArray(a,)) {
-    return mixArray;
-  } else if (typeof a === 'object') {
-    return color.test(a,) ? mixColor : mixObject;
-  }
+  if (typeof a === 'number') return mixNumber2;
+  else if (typeof a === 'string') return isCSSVariableToken(a,) ? mixImmediate : color.test(a,) ? mixColor : mixComplex;
+  else if (Array.isArray(a,)) return mixArray;
+  else if (typeof a === 'object') return color.test(a,) ? mixColor : mixObject;
   return mixImmediate;
 }
 function mixArray(a, b,) {
@@ -1149,38 +902,23 @@ function mixArray(a, b,) {
   const numValues = output.length;
   const blendValue = a.map((v, i,) => getMixer(v,)(v, b[i],));
   return (p) => {
-    for (let i = 0; i < numValues; i++) {
-      output[i] = blendValue[i](p,);
-    }
+    for (let i = 0; i < numValues; i++) output[i] = blendValue[i](p,);
     return output;
   };
 }
 function mixObject(a, b,) {
-  const output = {
-    ...a,
-    ...b,
-  };
+  const output = { ...a, ...b, };
   const blendValue = {};
-  for (const key7 in output) {
-    if (a[key7] !== void 0 && b[key7] !== void 0) {
-      blendValue[key7] = getMixer(a[key7],)(a[key7], b[key7],);
-    }
-  }
+  for (const key7 in output) if (a[key7] !== void 0 && b[key7] !== void 0) blendValue[key7] = getMixer(a[key7],)(a[key7], b[key7],);
   return (v) => {
-    for (const key7 in blendValue) {
-      output[key7] = blendValue[key7](v,);
-    }
+    for (const key7 in blendValue) output[key7] = blendValue[key7](v,);
     return output;
   };
 }
 function matchOrder(origin, target,) {
   var _a;
   const orderedOrigin = [];
-  const pointers = {
-    color: 0,
-    var: 0,
-    number: 0,
-  };
+  const pointers = { color: 0, var: 0, number: 0, };
   for (let i = 0; i < target.values.length; i++) {
     const type = target.types[i];
     const originIndex = origin.indexes[type][pointers[type]];
@@ -1197,9 +935,8 @@ var mixComplex = (origin, target,) => {
   const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&
     originStats.indexes.color.length === targetStats.indexes.color.length &&
     originStats.indexes.number.length >= targetStats.indexes.number.length;
-  if (canInterpolate) {
-    return pipe(mixArray(matchOrder(originStats, targetStats,), targetStats.values,), template,);
-  } else {
+  if (canInterpolate) return pipe(mixArray(matchOrder(originStats, targetStats,), targetStats.values,), template,);
+  else {
     warning(
       true,
       `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,
@@ -1208,9 +945,7 @@ var mixComplex = (origin, target,) => {
   }
 };
 function mix(from, to, p,) {
-  if (typeof from === 'number' && typeof to === 'number' && typeof p === 'number') {
-    return mixNumber(from, to, p,);
-  }
+  if (typeof from === 'number' && typeof to === 'number' && typeof p === 'number') return mixNumber(from, to, p,);
   const mixer = getMixer(from,);
   return mixer(from, to,);
 }
@@ -1228,11 +963,7 @@ function createMixers(output, ease2, customMixer,) {
   }
   return mixers;
 }
-function interpolate(input, output, {
-  clamp: isClamp = true,
-  ease: ease2,
-  mixer,
-} = {},) {
+function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer, } = {},) {
   const inputLength = input.length;
   invariant(inputLength === output.length, 'Both input and output ranges must be the same length',);
   if (inputLength === 1) return () => output[0];
@@ -1244,11 +975,7 @@ function interpolate(input, output, {
   const numMixers = mixers.length;
   const interpolator = (v) => {
     let i = 0;
-    if (numMixers > 1) {
-      for (; i < input.length - 2; i++) {
-        if (v < input[i + 1]) break;
-      }
-    }
+    if (numMixers > 1) for (; i < input.length - 2; i++) if (v < input[i + 1]) break;
     const progressInRange = progress(input[i], input[i + 1], v,);
     return mixers[i](progressInRange,);
   };
@@ -1269,12 +996,7 @@ var minDuration = 0.01;
 var maxDuration = 10;
 var minDamping = 0.05;
 var maxDamping = 1;
-function findSpring({
-  duration = 800,
-  bounce = 0.25,
-  velocity = 0,
-  mass = 1,
-},) {
+function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, },) {
   let envelope;
   let derivative;
   warning(duration <= secondsToMilliseconds(maxDuration,), 'Spring duration must be 10 seconds or less',);
@@ -1315,27 +1037,16 @@ function findSpring({
   const initialGuess = 5 / duration;
   const undampedFreq = approximateRoot(envelope, derivative, initialGuess,);
   duration = secondsToMilliseconds(duration,);
-  if (isNaN(undampedFreq,)) {
-    return {
-      stiffness: 100,
-      damping: 10,
-      duration,
-    };
-  } else {
+  if (isNaN(undampedFreq,)) return { stiffness: 100, damping: 10, duration, };
+  else {
     const stiffness = Math.pow(undampedFreq, 2,) * mass;
-    return {
-      stiffness,
-      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness,),
-      duration,
-    };
+    return { stiffness, damping: dampingRatio * 2 * Math.sqrt(mass * stiffness,), duration, };
   }
 }
 var rootIterations = 12;
 function approximateRoot(envelope, derivative, initialGuess,) {
   let result = initialGuess;
-  for (let i = 1; i < rootIterations; i++) {
-    result = result - envelope(result,) / derivative(result,);
-  }
+  for (let i = 1; i < rootIterations; i++) result = result - envelope(result,) / derivative(result,);
   return result;
 }
 function calcAngularFreq(undampedFreq, dampingRatio,) {
@@ -1347,45 +1058,19 @@ function isSpringType(options, keys23,) {
   return keys23.some((key7) => options[key7] !== void 0);
 }
 function getSpringOptions(options,) {
-  let springOptions = {
-    velocity: 0,
-    stiffness: 100,
-    damping: 10,
-    mass: 1,
-    isResolvedFromDuration: false,
-    ...options,
-  };
+  let springOptions = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false, ...options, };
   if (!isSpringType(options, physicsKeys,) && isSpringType(options, durationKeys,)) {
     const derived = findSpring(options,);
-    springOptions = {
-      ...springOptions,
-      ...derived,
-      mass: 1,
-    };
+    springOptions = { ...springOptions, ...derived, mass: 1, };
     springOptions.isResolvedFromDuration = true;
   }
   return springOptions;
 }
-function spring({
-  keyframes: keyframes2,
-  restDelta,
-  restSpeed,
-  ...options
-},) {
+function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options },) {
   const origin = keyframes2[0];
   const target = keyframes2[keyframes2.length - 1];
-  const state = {
-    done: false,
-    value: origin,
-  };
-  const {
-    stiffness,
-    damping,
-    mass,
-    duration,
-    velocity,
-    isResolvedFromDuration,
-  } = getSpringOptions({
+  const state = { done: false, value: origin, };
+  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({
     ...options,
     velocity: -millisecondsToSeconds(options.velocity || 0,),
   },);
@@ -1428,18 +1113,13 @@ function spring({
       if (!isResolvedFromDuration) {
         let currentVelocity = initialVelocity;
         if (t !== 0) {
-          if (dampingRatio < 1) {
-            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current,);
-          } else {
-            currentVelocity = 0;
-          }
+          if (dampingRatio < 1) currentVelocity = calcGeneratorVelocity(resolveSpring, t, current,);
+          else currentVelocity = 0;
         }
         const isBelowVelocityThreshold = Math.abs(currentVelocity,) <= restSpeed;
         const isBelowDisplacementThreshold = Math.abs(target - current,) <= restDelta;
         state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
-      } else {
-        state.done = t >= duration;
-      }
+      } else state.done = t >= duration;
       state.value = state.done ? target : current;
       return state;
     },
@@ -1448,19 +1128,7 @@ function spring({
 var isEasingArray = (ease2) => {
   return Array.isArray(ease2,) && typeof ease2[0] !== 'number';
 };
-var easingLookup = {
-  linear: noop,
-  easeIn,
-  easeInOut,
-  easeOut,
-  circIn,
-  circInOut,
-  circOut,
-  backIn,
-  backInOut,
-  backOut,
-  anticipate,
-};
+var easingLookup = { linear: noop, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate, };
 var easingDefinitionToFunction = (definition) => {
   if (Array.isArray(definition,)) {
     invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`,);
@@ -1490,19 +1158,10 @@ function convertOffsetToTimes(offset, duration,) {
 function defaultEasing(values, easing,) {
   return values.map(() => easing || easeInOut).splice(0, values.length - 1,);
 }
-function keyframes({
-  duration = 300,
-  keyframes: keyframeValues,
-  times,
-  ease: ease2 = 'easeInOut',
-},) {
+function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = 'easeInOut', },) {
   const easingFunctions = isEasingArray(ease2,) ? ease2.map(easingDefinitionToFunction,) : easingDefinitionToFunction(ease2,);
-  const state = {
-    done: false,
-    value: keyframeValues[0],
-  };
-  const absoluteTimes = convertOffsetToTimes(
-    // Only use the provided offsets if they're the correct length
+  const state = { done: false, value: keyframeValues[0], };
+  const absoluteTimes = convertOffsetToTimes( // Only use the provided offsets if they're the correct length
     // TODO Maybe we should warn here if there's a length mismatch
     times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues,),
     duration,
@@ -1519,24 +1178,23 @@ function keyframes({
     },
   };
 }
-function inertia({
-  keyframes: keyframes2,
-  velocity = 0,
-  power = 0.8,
-  timeConstant: timeConstant2 = 325,
-  bounceDamping = 10,
-  bounceStiffness = 500,
-  modifyTarget,
-  min,
-  max,
-  restDelta = 0.5,
-  restSpeed,
-},) {
+function inertia(
+  {
+    keyframes: keyframes2,
+    velocity = 0,
+    power = 0.8,
+    timeConstant: timeConstant2 = 325,
+    bounceDamping = 10,
+    bounceStiffness = 500,
+    modifyTarget,
+    min,
+    max,
+    restDelta = 0.5,
+    restSpeed,
+  },
+) {
   const origin = keyframes2[0];
-  const state = {
-    done: false,
-    value: origin,
-  };
+  const state = { done: false, value: origin, };
   const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
   const nearestBoundary = (v) => {
     if (min === void 0) return max;
@@ -1579,9 +1237,8 @@ function inertia({
         applyFriction(t,);
         checkCatchBoundary(t,);
       }
-      if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) {
-        return spring$1.next(t - timeReachedBoundary,);
-      } else {
+      if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) return spring$1.next(t - timeReachedBoundary,);
+      else {
         !hasUpdatedFrame && applyFriction(t,);
         return state;
       }
@@ -1594,9 +1251,7 @@ function clearTime() {
 }
 var time = {
   now: () => {
-    if (now === void 0) {
-      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now(),);
-    }
+    if (now === void 0) time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now(),);
     return now;
   },
   set: (newTime) => {
@@ -1605,13 +1260,10 @@ var time = {
   },
 };
 var frameloopDriver = (update) => {
-  const passTimestamp = ({
-    timestamp,
-  },) => update(timestamp,);
+  const passTimestamp = ({ timestamp, },) => update(timestamp,);
   return {
     start: () => frame.update(passTimestamp, true,),
-    stop: () => cancelFrame(passTimestamp,),
-    /**
+    stop: () => cancelFrame(passTimestamp,), /**
      * If we're processing this frame we can use the
      * framelocked timestamp to keep things in sync.
      */
@@ -1629,29 +1281,25 @@ function calcGeneratorDuration(generator,) {
   }
   return duration >= maxGeneratorDuration ? Infinity : duration;
 }
-var types = {
-  decay: inertia,
-  inertia,
-  tween: keyframes,
-  keyframes,
-  spring,
-};
+var types = { decay: inertia, inertia, tween: keyframes, keyframes, spring, };
 var percentToProgress = (percent2) => percent2 / 100;
-function animateValue({
-  autoplay = true,
-  delay: delay2 = 0,
-  driver = frameloopDriver,
-  keyframes: keyframes$1,
-  type = 'keyframes',
-  repeat = 0,
-  repeatDelay = 0,
-  repeatType = 'loop',
-  onPlay,
-  onStop,
-  onComplete,
-  onUpdate,
-  ...options
-},) {
+function animateValue(
+  {
+    autoplay = true,
+    delay: delay2 = 0,
+    driver = frameloopDriver,
+    keyframes: keyframes$1,
+    type = 'keyframes',
+    repeat = 0,
+    repeatDelay = 0,
+    repeatType = 'loop',
+    onPlay,
+    onStop,
+    onComplete,
+    onUpdate,
+    ...options
+  },
+) {
   let speed = 1;
   let hasStopped = false;
   let resolveFinishedPromise;
@@ -1675,28 +1323,17 @@ function animateValue({
     mapNumbersToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1],),);
     keyframes$1 = [0, 100,];
   }
-  const generator = generatorFactory({
-    ...options,
-    keyframes: keyframes$1,
-  },);
+  const generator = generatorFactory({ ...options, keyframes: keyframes$1, },);
   let mirroredGenerator;
   if (repeatType === 'mirror') {
-    mirroredGenerator = generatorFactory({
-      ...options,
-      keyframes: [...keyframes$1,].reverse(),
-      velocity: -(options.velocity || 0),
-    },);
+    mirroredGenerator = generatorFactory({ ...options, keyframes: [...keyframes$1,].reverse(), velocity: -(options.velocity || 0), },);
   }
   let playState = 'idle';
   let holdTime = null;
   let startTime = null;
   let cancelTime = null;
-  if (generator.calculatedDuration === null && repeat) {
-    generator.calculatedDuration = calcGeneratorDuration(generator,);
-  }
-  const {
-    calculatedDuration,
-  } = generator;
+  if (generator.calculatedDuration === null && repeat) generator.calculatedDuration = calcGeneratorDuration(generator,);
+  const { calculatedDuration, } = generator;
   let resolvedDuration = Infinity;
   let totalDuration = Infinity;
   if (calculatedDuration !== null) {
@@ -1708,63 +1345,37 @@ function animateValue({
     if (startTime === null) return;
     if (speed > 0) startTime = Math.min(startTime, timestamp,);
     if (speed < 0) startTime = Math.min(timestamp - totalDuration / speed, startTime,);
-    if (holdTime !== null) {
-      currentTime = holdTime;
-    } else {
-      currentTime = Math.round(timestamp - startTime,) * speed;
-    }
+    if (holdTime !== null) currentTime = holdTime;
+    else currentTime = Math.round(timestamp - startTime,) * speed;
     const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
     const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
     currentTime = Math.max(timeWithoutDelay, 0,);
-    if (playState === 'finished' && holdTime === null) {
-      currentTime = totalDuration;
-    }
+    if (playState === 'finished' && holdTime === null) currentTime = totalDuration;
     let elapsed = currentTime;
     let frameGenerator = generator;
     if (repeat) {
       const progress2 = Math.min(currentTime, totalDuration,) / resolvedDuration;
       let currentIteration = Math.floor(progress2,);
       let iterationProgress = progress2 % 1;
-      if (!iterationProgress && progress2 >= 1) {
-        iterationProgress = 1;
-      }
+      if (!iterationProgress && progress2 >= 1) iterationProgress = 1;
       iterationProgress === 1 && currentIteration--;
       currentIteration = Math.min(currentIteration, repeat + 1,);
       const isOddIteration = Boolean(currentIteration % 2,);
       if (isOddIteration) {
         if (repeatType === 'reverse') {
           iterationProgress = 1 - iterationProgress;
-          if (repeatDelay) {
-            iterationProgress -= repeatDelay / resolvedDuration;
-          }
-        } else if (repeatType === 'mirror') {
-          frameGenerator = mirroredGenerator;
-        }
+          if (repeatDelay) iterationProgress -= repeatDelay / resolvedDuration;
+        } else if (repeatType === 'mirror') frameGenerator = mirroredGenerator;
       }
       elapsed = clamp(0, 1, iterationProgress,) * resolvedDuration;
     }
-    const state = isInDelayPhase
-      ? {
-        done: false,
-        value: keyframes$1[0],
-      }
-      : frameGenerator.next(elapsed,);
-    if (mapNumbersToKeyframes) {
-      state.value = mapNumbersToKeyframes(state.value,);
-    }
-    let {
-      done,
-    } = state;
-    if (!isInDelayPhase && calculatedDuration !== null) {
-      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
-    }
+    const state = isInDelayPhase ? { done: false, value: keyframes$1[0], } : frameGenerator.next(elapsed,);
+    if (mapNumbersToKeyframes) state.value = mapNumbersToKeyframes(state.value,);
+    let { done, } = state;
+    if (!isInDelayPhase && calculatedDuration !== null) done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
     const isAnimationFinished = holdTime === null && (playState === 'finished' || playState === 'running' && done);
-    if (onUpdate) {
-      onUpdate(state.value,);
-    }
-    if (isAnimationFinished) {
-      finish();
-    }
+    if (onUpdate) onUpdate(state.value,);
+    if (isAnimationFinished) finish();
     return state;
   };
   const stopAnimationDriver = () => {
@@ -1789,22 +1400,15 @@ function animateValue({
     if (!animationDriver) animationDriver = driver(tick,);
     const now2 = animationDriver.now();
     onPlay && onPlay();
-    if (holdTime !== null) {
-      startTime = now2 - holdTime;
-    } else if (!startTime || playState === 'finished') {
-      startTime = now2;
-    }
-    if (playState === 'finished') {
-      updateFinishedPromise();
-    }
+    if (holdTime !== null) startTime = now2 - holdTime;
+    else if (!startTime || playState === 'finished') startTime = now2;
+    if (playState === 'finished') updateFinishedPromise();
     cancelTime = startTime;
     holdTime = null;
     playState = 'running';
     animationDriver.start();
   };
-  if (autoplay) {
-    play();
-  }
+  if (autoplay) play();
   const controls = {
     then(resolve, reject,) {
       return currentFinishedPromise.then(resolve, reject,);
@@ -1815,11 +1419,8 @@ function animateValue({
     set time(newTime,) {
       newTime = secondsToMilliseconds(newTime,);
       currentTime = newTime;
-      if (holdTime !== null || !animationDriver || speed === 0) {
-        holdTime = newTime;
-      } else {
-        startTime = animationDriver.now() - newTime / speed;
-      }
+      if (holdTime !== null || !animationDriver || speed === 0) holdTime = newTime;
+      else startTime = animationDriver.now() - newTime / speed;
     },
     get duration() {
       const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator,) : generator.calculatedDuration;
@@ -1889,14 +1490,11 @@ var SubscriptionManager = class {
   notify(a, b, c,) {
     const numSubscriptions = this.subscriptions.length;
     if (!numSubscriptions) return;
-    if (numSubscriptions === 1) {
-      this.subscriptions[0](a, b, c,);
-    } else {
-      for (let i = 0; i < numSubscriptions; i++) {
+    if (numSubscriptions === 1) this.subscriptions[0](a, b, c,);
+    else {for (let i = 0; i < numSubscriptions; i++) {
         const handler = this.subscriptions[i];
         handler && handler(a, b, c,);
-      }
-    }
+      }}
   }
   getSize() {
     return this.subscriptions.length;
@@ -1909,9 +1507,7 @@ var MAX_VELOCITY_DELTA = 30;
 var isFloat = (value) => {
   return !isNaN(parseFloat(value,),);
 };
-var collectMotionValues = {
-  current: void 0,
-};
+var collectMotionValues = { current: void 0, };
 var MotionValue = class {
   /**
    * @param init - The initiating value
@@ -1920,24 +1516,17 @@ var MotionValue = class {
    * -  `transformer`: A function to transform incoming values with.
    *
    * @internal
-   */
-  constructor(init, options = {},) {
+   */ constructor(init, options = {},) {
     this.version = '11.0.11-sync.5';
     this.canTrackVelocity = false;
     this.events = {};
     this.updateAndNotify = (v, render = true,) => {
       const currentTime = time.now();
-      if (this.updatedAt !== currentTime) {
-        this.setPrevFrameValue();
-      }
+      if (this.updatedAt !== currentTime) this.setPrevFrameValue();
       this.prev = this.current;
       this.setCurrent(v,);
-      if (this.current !== this.prev && this.events.change) {
-        this.events.change.notify(this.current,);
-      }
-      if (render && this.events.renderRequest) {
-        this.events.renderRequest.notify(this.current,);
-      }
+      if (this.current !== this.prev && this.events.change) this.events.change.notify(this.current,);
+      if (render && this.events.renderRequest) this.events.renderRequest.notify(this.current,);
     };
     this.hasAnimated = false;
     this.setCurrent(init,);
@@ -1951,8 +1540,7 @@ var MotionValue = class {
   setPrevFrameValue(prevFrameValue = this.current,) {
     this.prevFrameValue = prevFrameValue;
     this.prevUpdatedAt = this.updatedAt;
-  }
-  /**
+  } /**
    * Adds a function that will be notified when the `MotionValue` is updated.
    *
    * It returns a function that, when called, will cancel the subscription.
@@ -1992,44 +1580,36 @@ var MotionValue = class {
    *
    * @deprecated
    */
+
   onChange(subscription,) {
-    if (false) {
-      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`,);
-    }
+    if (false) warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`,);
     return this.on('change', subscription,);
   }
   on(eventName, callback,) {
-    if (!this.events[eventName]) {
-      this.events[eventName] = new SubscriptionManager();
-    }
+    if (!this.events[eventName]) this.events[eventName] = new SubscriptionManager();
     const unsubscribe = this.events[eventName].add(callback,);
     if (eventName === 'change') {
       return () => {
         unsubscribe();
         frame.read(() => {
-          if (!this.events.change.getSize()) {
-            this.stop();
-          }
+          if (!this.events.change.getSize()) this.stop();
         },);
       };
     }
     return unsubscribe;
   }
   clearListeners() {
-    for (const eventManagers in this.events) {
-      this.events[eventManagers].clear();
-    }
-  }
-  /**
+    for (const eventManagers in this.events) this.events[eventManagers].clear();
+  } /**
    * Attaches a passive effect to the `MotionValue`.
    *
    * @internal
    */
+
   attach(passiveEffect, stopPassiveEffect,) {
     this.passiveEffect = passiveEffect;
     this.stopPassiveEffect = stopPassiveEffect;
-  }
-  /**
+  } /**
    * Sets the state of the `MotionValue`.
    *
    * @remarks
@@ -2044,65 +1624,58 @@ var MotionValue = class {
    *
    * @public
    */
+
   set(v, render = true,) {
-    if (!render || !this.passiveEffect) {
-      this.updateAndNotify(v, render,);
-    } else {
-      this.passiveEffect(v, this.updateAndNotify,);
-    }
+    if (!render || !this.passiveEffect) this.updateAndNotify(v, render,);
+    else this.passiveEffect(v, this.updateAndNotify,);
   }
   setWithVelocity(prev, current, delta,) {
     this.set(current,);
     this.prev = void 0;
     this.prevFrameValue = prev;
     this.prevUpdatedAt = this.updatedAt - delta;
-  }
-  /**
+  } /**
    * Set the state of the `MotionValue`, stopping any active animations,
    * effects, and resets velocity to `0`.
    */
+
   jump(v,) {
     this.updateAndNotify(v,);
     this.prev = v;
     this.prevUpdatedAt = this.prevFrameValue = void 0;
     this.stop();
     if (this.stopPassiveEffect) this.stopPassiveEffect();
-  }
-  /**
+  } /**
    * Returns the latest state of `MotionValue`
    *
    * @returns - The latest state of `MotionValue`
    *
    * @public
    */
+
   get() {
-    if (collectMotionValues.current) {
-      collectMotionValues.current.push(this,);
-    }
+    if (collectMotionValues.current) collectMotionValues.current.push(this,);
     return this.current;
-  }
-  /**
+  } /**
    * @public
    */
+
   getPrevious() {
     return this.prev;
-  }
-  /**
+  } /**
    * Returns the latest velocity of `MotionValue`
    *
    * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
    *
    * @public
    */
+
   getVelocity() {
     const currentTime = time.now();
-    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
-      return 0;
-    }
+    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) return 0;
     const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA,);
     return velocityPerSecond(parseFloat(this.current,) - parseFloat(this.prevFrameValue,), delta,);
-  }
-  /**
+  } /**
    * Registers a new animation to control this `MotionValue`. Only one
    * animation can drive a `MotionValue` at one time.
    *
@@ -2114,47 +1687,41 @@ var MotionValue = class {
    *
    * @internal
    */
+
   start(startAnimation2,) {
     this.stop();
     return new Promise((resolve) => {
       this.hasAnimated = true;
       this.animation = startAnimation2(resolve,);
-      if (this.events.animationStart) {
-        this.events.animationStart.notify();
-      }
+      if (this.events.animationStart) this.events.animationStart.notify();
     },).then(() => {
-      if (this.events.animationComplete) {
-        this.events.animationComplete.notify();
-      }
+      if (this.events.animationComplete) this.events.animationComplete.notify();
       this.clearAnimation();
     },);
-  }
-  /**
+  } /**
    * Stop the currently active animation.
    *
    * @public
    */
+
   stop() {
     if (this.animation) {
       this.animation.stop();
-      if (this.events.animationCancel) {
-        this.events.animationCancel.notify();
-      }
+      if (this.events.animationCancel) this.events.animationCancel.notify();
     }
     this.clearAnimation();
-  }
-  /**
+  } /**
    * Returns `true` if this value is currently animating.
    *
    * @public
    */
+
   isAnimating() {
     return !!this.animation;
   }
   clearAnimation() {
     delete this.animation;
-  }
-  /**
+  } /**
    * Destroy and clean up subscribers to this `MotionValue`.
    *
    * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
@@ -2163,12 +1730,11 @@ var MotionValue = class {
    *
    * @public
    */
+
   destroy() {
     this.clearListeners();
     this.stop();
-    if (this.stopPassiveEffect) {
-      this.stopPassiveEffect();
-    }
+    if (this.stopPassiveEffect) this.stopPassiveEffect();
   }
 };
 function motionValue(init, options,) {
@@ -2195,12 +1761,8 @@ var filter = {
     return functions ? functions.map(applyDefaultFilter,).join(' ',) : v;
   },
 };
-var int = {
-  ...number,
-  transform: Math.round,
-};
-var numberValueTypes = {
-  // Border props
+var int = { ...number, transform: Math.round, };
+var numberValueTypes = { // Border props
   borderWidth: px,
   borderTopWidth: px,
   borderRightWidth: px,
@@ -2211,8 +1773,7 @@ var numberValueTypes = {
   borderTopLeftRadius: px,
   borderTopRightRadius: px,
   borderBottomRightRadius: px,
-  borderBottomLeftRadius: px,
-  // Positioning props
+  borderBottomLeftRadius: px, // Positioning props
   width: px,
   maxWidth: px,
   height: px,
@@ -2221,8 +1782,7 @@ var numberValueTypes = {
   top: px,
   right: px,
   bottom: px,
-  left: px,
-  // Spacing props
+  left: px, // Spacing props
   padding: px,
   paddingTop: px,
   paddingRight: px,
@@ -2232,8 +1792,7 @@ var numberValueTypes = {
   marginTop: px,
   marginRight: px,
   marginBottom: px,
-  marginLeft: px,
-  // Transform props
+  marginLeft: px, // Transform props
   rotate: degrees,
   rotateX: degrees,
   rotateY: degrees,
@@ -2257,23 +1816,19 @@ var numberValueTypes = {
   opacity: alpha,
   originX: progressPercentage,
   originY: progressPercentage,
-  originZ: px,
-  // Misc
-  zIndex: int,
-  // SVG
+  originZ: px, // Misc
+  zIndex: int, // SVG
   fillOpacity: alpha,
   strokeOpacity: alpha,
   numOctaves: int,
 };
 var defaultValueTypes = {
-  ...numberValueTypes,
-  // Color props
+  ...numberValueTypes, // Color props
   color,
   backgroundColor: color,
   outlineColor: color,
   fill: color,
-  stroke: color,
-  // Border props
+  stroke: color, // Border props
   borderColor: color,
   borderTopColor: color,
   borderRightColor: color,
@@ -2289,10 +1844,7 @@ function getAnimatableNone2(key7, value,) {
   return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value,) : void 0;
 }
 var testValueType = (v) => (type) => type.test(v,);
-var auto = {
-  test: (v) => v === 'auto',
-  parse: (v) => v,
-};
+var auto = { test: (v) => v === 'auto', parse: (v) => v, };
 var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto,];
 var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v,),);
 var valueTypes = [...dimensionValueTypes, color, complex,];
@@ -2318,23 +1870,13 @@ function resolveVariant(visualElement, definition, custom,) {
   );
 }
 function setMotionValue(visualElement, key7, value,) {
-  if (visualElement.hasValue(key7,)) {
-    visualElement.getValue(key7,).set(value,);
-  } else {
-    visualElement.addValue(key7, motionValue(value,),);
-  }
+  if (visualElement.hasValue(key7,)) visualElement.getValue(key7,).set(value,);
+  else visualElement.addValue(key7, motionValue(value,),);
 }
 function setTarget(visualElement, definition,) {
   const resolved = resolveVariant(visualElement, definition,);
-  let {
-    transitionEnd = {},
-    transition = {},
-    ...target
-  } = resolved ? visualElement.makeTargetAnimatable(resolved, false,) : {};
-  target = {
-    ...target,
-    ...transitionEnd,
-  };
+  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false,) : {};
+  target = { ...target, ...transitionEnd, };
   for (const key7 in target) {
     const value = resolveFinalValueInKeyframes(target[key7],);
     setMotionValue(visualElement, key7, value,);
@@ -2353,13 +1895,9 @@ function setVariants(visualElement, variantLabels,) {
   },);
 }
 function setValues(visualElement, definition,) {
-  if (Array.isArray(definition,)) {
-    return setVariants(visualElement, definition,);
-  } else if (typeof definition === 'string') {
-    return setVariants(visualElement, [definition,],);
-  } else {
-    setTarget(visualElement, definition,);
-  }
+  if (Array.isArray(definition,)) return setVariants(visualElement, definition,);
+  else if (typeof definition === 'string') return setVariants(visualElement, [definition,],);
+  else setTarget(visualElement, definition,);
 }
 function checkTargetForNewValues(visualElement, target, origin,) {
   var _a, _b;
@@ -2370,29 +1908,17 @@ function checkTargetForNewValues(visualElement, target, origin,) {
     const key7 = newValueKeys[i];
     const targetValue = target[key7];
     let value = null;
-    if (Array.isArray(targetValue,)) {
-      value = targetValue[0];
-    }
+    if (Array.isArray(targetValue,)) value = targetValue[0];
     if (value === null) {
       value = (_b = (_a = origin[key7]) !== null && _a !== void 0 ? _a : visualElement.readValue(key7,)) !== null && _b !== void 0
         ? _b
         : target[key7];
     }
     if (value === void 0 || value === null) continue;
-    if (typeof value === 'string' && (isNumericalString(value,) || isZeroValueString(value,))) {
-      value = parseFloat(value,);
-    } else if (!findValueType(value,) && complex.test(targetValue,)) {
-      value = getAnimatableNone2(key7, targetValue,);
-    }
-    visualElement.addValue(
-      key7,
-      motionValue(value, {
-        owner: visualElement,
-      },),
-    );
-    if (origin[key7] === void 0) {
-      origin[key7] = value;
-    }
+    if (typeof value === 'string' && (isNumericalString(value,) || isZeroValueString(value,))) value = parseFloat(value,);
+    else if (!findValueType(value,) && complex.test(targetValue,)) value = getAnimatableNone2(key7, targetValue,);
+    visualElement.addValue(key7, motionValue(value, { owner: visualElement, },),);
+    if (origin[key7] === void 0) origin[key7] = value;
     if (value !== null) visualElement.setBaseTarget(key7, value,);
   }
 }
@@ -2405,20 +1931,15 @@ function getOrigin(target, transition, visualElement,) {
   const origin = {};
   for (const key7 in target) {
     const transitionOrigin = getOriginFromTransition(key7, transition,);
-    if (transitionOrigin !== void 0) {
-      origin[key7] = transitionOrigin;
-    } else {
+    if (transitionOrigin !== void 0) origin[key7] = transitionOrigin;
+    else {
       const value = visualElement.getValue(key7,);
-      if (value) {
-        origin[key7] = value.get();
-      }
+      if (value) origin[key7] = value.get();
     }
   }
   return origin;
 }
-var instantAnimationState = {
-  current: false,
-};
+var instantAnimationState = { current: false, };
 var isBezierDefinition = (easing) => Array.isArray(easing,) && typeof easing[0] === 'number';
 function isWaapiSupportedEasing(easing,) {
   return Boolean(
@@ -2446,17 +1967,13 @@ function mapEasingToNativeEasing(easing,) {
     ? easing.map(mapEasingToNativeEasing,)
     : supportedWaapiEasing[easing];
 }
-function animateStyle(element, valueName, keyframes2, {
-  delay: delay2 = 0,
-  duration,
-  repeat = 0,
-  repeatType = 'loop',
-  ease: ease2,
-  times,
-} = {},) {
-  const keyframeOptions = {
-    [valueName]: keyframes2,
-  };
+function animateStyle(
+  element,
+  valueName,
+  keyframes2,
+  { delay: delay2 = 0, duration, repeat = 0, repeatType = 'loop', ease: ease2, times, } = {},
+) {
+  const keyframeOptions = { [valueName]: keyframes2, };
   if (times) keyframeOptions.offset = times;
   const easing = mapEasingToNativeEasing(ease2,);
   if (Array.isArray(easing,)) keyframeOptions.easing = easing;
@@ -2469,10 +1986,7 @@ function animateStyle(element, valueName, keyframes2, {
     direction: repeatType === 'reverse' ? 'alternate' : 'normal',
   },);
 }
-function getFinalKeyframe(keyframes2, {
-  repeat,
-  repeatType = 'loop',
-},) {
+function getFinalKeyframe(keyframes2, { repeat, repeatType = 'loop', },) {
   const index = repeat && repeatType !== 'loop' && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
   return keyframes2[index];
 }
@@ -2489,11 +2003,7 @@ var sampleDelta = 10;
 var maxDuration2 = 2e4;
 var requiresPregeneratedKeyframes = (valueName, options,) =>
   options.type === 'spring' || valueName === 'backgroundColor' || !isWaapiSupportedEasing(options.ease,);
-function createAcceleratedAnimation(value, valueName, {
-  onUpdate,
-  onComplete,
-  ...options
-},) {
+function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options },) {
   const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName,) && !options.repeatDelay &&
     options.repeatType !== 'mirror' && options.damping !== 0 && options.type !== 'inertia';
   if (!canAccelerateAnimation) return false;
@@ -2507,22 +2017,10 @@ function createAcceleratedAnimation(value, valueName, {
     },);
   };
   updateFinishedPromise();
-  let {
-    keyframes: keyframes2,
-    duration = 300,
-    ease: ease2,
-    times,
-  } = options;
+  let { keyframes: keyframes2, duration = 300, ease: ease2, times, } = options;
   if (requiresPregeneratedKeyframes(valueName, options,)) {
-    const sampleAnimation = animateValue({
-      ...options,
-      repeat: 0,
-      delay: 0,
-    },);
-    let state = {
-      done: false,
-      value: keyframes2[0],
-    };
+    const sampleAnimation = animateValue({ ...options, repeat: 0, delay: 0, },);
+    let state = { done: false, value: keyframes2[0], };
     const pregeneratedKeyframes = [];
     let t = 0;
     while (!state.done && t < maxDuration2) {
@@ -2537,8 +2035,7 @@ function createAcceleratedAnimation(value, valueName, {
   }
   const animation = animateStyle(value.owner.current, valueName, keyframes2, {
     ...options,
-    duration,
-    /**
+    duration, /**
      * This function is currently not called if ease is provided
      * as a function so the cast is safe.
      *
@@ -2598,14 +2095,9 @@ function createAcceleratedAnimation(value, valueName, {
     stop: () => {
       hasStopped = true;
       if (animation.playState === 'idle') return;
-      const {
-        currentTime,
-      } = animation;
+      const { currentTime, } = animation;
       if (currentTime) {
-        const sampleAnimation = animateValue({
-          ...options,
-          autoplay: false,
-        },);
+        const sampleAnimation = animateValue({ ...options, autoplay: false, },);
         value.setWithVelocity(
           sampleAnimation.sample(currentTime - sampleDelta,).value,
           sampleAnimation.sample(currentTime,).value,
@@ -2622,12 +2114,7 @@ function createAcceleratedAnimation(value, valueName, {
   };
   return controls;
 }
-function createInstantAnimation({
-  keyframes: keyframes2,
-  delay: delay2,
-  onUpdate,
-  onComplete,
-},) {
+function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete, },) {
   const setValue = () => {
     onUpdate && onUpdate(keyframes2[keyframes2.length - 1],);
     onComplete && onComplete();
@@ -2646,89 +2133,49 @@ function createInstantAnimation({
       complete: noop,
     };
   };
-  return delay2
-    ? animateValue({
-      keyframes: [0, 1,],
-      duration: 0,
-      delay: delay2,
-      onComplete: setValue,
-    },)
-    : setValue();
+  return delay2 ? animateValue({ keyframes: [0, 1,], duration: 0, delay: delay2, onComplete: setValue, },) : setValue();
 }
-var underDampedSpring = {
-  type: 'spring',
-  stiffness: 500,
-  damping: 25,
-  restSpeed: 10,
-};
+var underDampedSpring = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10, };
 var criticallyDampedSpring = (target) => ({
   type: 'spring',
   stiffness: 550,
   damping: target === 0 ? 2 * Math.sqrt(550,) : 30,
   restSpeed: 10,
 });
-var keyframesTransition = {
-  type: 'keyframes',
-  duration: 0.8,
-};
-var ease = {
-  type: 'keyframes',
-  ease: [0.25, 0.1, 0.35, 1,],
-  duration: 0.3,
-};
-var getDefaultTransition = (valueKey, {
-  keyframes: keyframes2,
-},) => {
-  if (keyframes2.length > 2) {
-    return keyframesTransition;
-  } else if (transformProps.has(valueKey,)) {
-    return valueKey.startsWith('scale',) ? criticallyDampedSpring(keyframes2[1],) : underDampedSpring;
-  }
+var keyframesTransition = { type: 'keyframes', duration: 0.8, };
+var ease = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1,], duration: 0.3, };
+var getDefaultTransition = (valueKey, { keyframes: keyframes2, },) => {
+  if (keyframes2.length > 2) return keyframesTransition;
+  else if (transformProps.has(valueKey,)) return valueKey.startsWith('scale',) ? criticallyDampedSpring(keyframes2[1],) : underDampedSpring;
   return ease;
 };
 var isAnimatable = (key7, value,) => {
   if (key7 === 'zIndex') return false;
   if (typeof value === 'number' || Array.isArray(value,)) return true;
   if (
-    typeof value === 'string' && (
-      // It's animatable if we have a string
+    typeof value === 'string' && ( // It's animatable if we have a string
       complex.test(value,) || value === '0'
-    ) &&
-    // And it contains numbers and/or colors
+    ) && // And it contains numbers and/or colors
     !value.startsWith('url(',)
-  ) {
-    return true;
-  }
+  ) return true;
   return false;
 };
 function isNone(value,) {
-  if (typeof value === 'number') {
-    return value === 0;
-  } else if (value !== null) {
-    return value === 'none' || value === '0' || isZeroValueString(value,);
-  }
+  if (typeof value === 'number') return value === 0;
+  else if (value !== null) return value === 'none' || value === '0' || isZeroValueString(value,);
 }
 function getKeyframes(value, valueName, target, transition,) {
   const isTargetAnimatable = isAnimatable(valueName, target,);
   let keyframes2;
-  if (Array.isArray(target,)) {
-    keyframes2 = [...target,];
-  } else {
-    keyframes2 = [null, target,];
-  }
+  if (Array.isArray(target,)) keyframes2 = [...target,];
+  else keyframes2 = [null, target,];
   const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
   let animatableTemplateValue = void 0;
   const noneKeyframeIndexes = [];
   for (let i = 0; i < keyframes2.length; i++) {
-    if (keyframes2[i] === null) {
-      keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1];
-    }
-    if (isNone(keyframes2[i],)) {
-      noneKeyframeIndexes.push(i,);
-    }
-    if (typeof keyframes2[i] === 'string' && keyframes2[i] !== 'none' && keyframes2[i] !== '0') {
-      animatableTemplateValue = keyframes2[i];
-    }
+    if (keyframes2[i] === null) keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1];
+    if (isNone(keyframes2[i],)) noneKeyframeIndexes.push(i,);
+    if (typeof keyframes2[i] === 'string' && keyframes2[i] !== 'none' && keyframes2[i] !== '0') animatableTemplateValue = keyframes2[i];
   }
   if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
     for (let i = 0; i < noneKeyframeIndexes.length; i++) {
@@ -2738,19 +2185,9 @@ function getKeyframes(value, valueName, target, transition,) {
   }
   return keyframes2;
 }
-function isTransitionDefined({
-  when,
-  delay: _delay,
-  delayChildren,
-  staggerChildren,
-  staggerDirection,
-  repeat,
-  repeatType,
-  repeatDelay,
-  from,
-  elapsed,
-  ...transition
-},) {
+function isTransitionDefined(
+  { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition },
+) {
   return !!Object.keys(transition,).length;
 }
 function getValueTransition(transition, key7,) {
@@ -2760,9 +2197,7 @@ var animateMotionValue = (valueName, value, target, transition = {},) => {
   return (onComplete) => {
     const valueTransition = getValueTransition(transition, valueName,) || {};
     const delay2 = valueTransition.delay || transition.delay || 0;
-    let {
-      elapsed = 0,
-    } = transition;
+    let { elapsed = 0, } = transition;
     elapsed = elapsed - secondsToMilliseconds(delay2,);
     const keyframes2 = getKeyframes(value, valueName, target, valueTransition,);
     const originKeyframe = keyframes2[0];
@@ -2788,43 +2223,23 @@ var animateMotionValue = (valueName, value, target, transition = {},) => {
         valueTransition.onComplete && valueTransition.onComplete();
       },
     };
-    if (!isTransitionDefined(valueTransition,)) {
-      options = {
-        ...options,
-        ...getDefaultTransition(valueName, options,),
-      };
-    }
-    if (options.duration) {
-      options.duration = secondsToMilliseconds(options.duration,);
-    }
-    if (options.repeatDelay) {
-      options.repeatDelay = secondsToMilliseconds(options.repeatDelay,);
-    }
+    if (!isTransitionDefined(valueTransition,)) options = { ...options, ...getDefaultTransition(valueName, options,), };
+    if (options.duration) options.duration = secondsToMilliseconds(options.duration,);
+    if (options.repeatDelay) options.repeatDelay = secondsToMilliseconds(options.repeatDelay,);
     if (
       !isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false ||
       MotionGlobalConfig.skipAnimations
-    ) {
-      return createInstantAnimation(
-        instantAnimationState.current
-          ? {
-            ...options,
-            delay: 0,
-          }
-          : options,
-      );
-    }
+    ) return createInstantAnimation(instantAnimationState.current ? { ...options, delay: 0, } : options,);
     if (
       /**
        * If this is a handoff animation, the optimised animation will be running via
        * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
        * optimised animation.
-       */
-      !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement &&
-      /**
+       */ !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
        * If we're outputting values to onUpdate then we can't use WAAPI as there's
        * no way to read the value from WAAPI every frame.
        */
-      !value.owner.getProps().onUpdate
+        !value.owner.getProps().onUpdate
     ) {
       const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options,);
       if (acceleratedAnimation) return acceleratedAnimation;
@@ -2835,34 +2250,18 @@ var animateMotionValue = (valueName, value, target, transition = {},) => {
 function isWillChangeMotionValue(value,) {
   return Boolean(isMotionValue(value,) && value.add,);
 }
-function shouldBlockAnimation({
-  protectedKeys,
-  needsAnimating,
-}, key7,) {
+function shouldBlockAnimation({ protectedKeys, needsAnimating, }, key7,) {
   const shouldBlock = protectedKeys.hasOwnProperty(key7,) && needsAnimating[key7] !== true;
   needsAnimating[key7] = false;
   return shouldBlock;
 }
 function hasKeyframesChanged(value, target,) {
   const current = value.get();
-  if (Array.isArray(target,)) {
-    for (let i = 0; i < target.length; i++) {
-      if (target[i] !== current) return true;
-    }
-  } else {
-    return current !== target;
-  }
+  if (Array.isArray(target,)) for (let i = 0; i < target.length; i++) if (target[i] !== current) return true;
+  else return current !== target;
 }
-function animateTarget(visualElement, definition, {
-  delay: delay2 = 0,
-  transitionOverride,
-  type,
-} = {},) {
-  let {
-    transition = visualElement.getDefaultTransition(),
-    transitionEnd,
-    ...target
-  } = visualElement.makeTargetAnimatable(definition,);
+function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type, } = {},) {
+  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition,);
   const willChange = visualElement.getValue('willChange',);
   if (transitionOverride) transition = transitionOverride;
   const animations2 = [];
@@ -2870,14 +2269,8 @@ function animateTarget(visualElement, definition, {
   for (const key7 in target) {
     const value = visualElement.getValue(key7,);
     const valueTarget = target[key7];
-    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key7,)) {
-      continue;
-    }
-    const valueTransition = {
-      delay: delay2,
-      elapsed: 0,
-      ...getValueTransition(transition || {}, key7,),
-    };
+    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key7,)) continue;
+    const valueTransition = { delay: delay2, elapsed: 0, ...getValueTransition(transition || {}, key7,), };
     if (window.HandoffAppearAnimations) {
       const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
       if (appearId) {
@@ -2889,23 +2282,17 @@ function animateTarget(visualElement, definition, {
       }
     }
     let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget,);
-    if (valueTransition.type === 'spring' && (value.getVelocity() || valueTransition.velocity)) {
-      canSkip = false;
-    }
-    if (value.animation) {
-      canSkip = false;
-    }
+    if (valueTransition.type === 'spring' && (value.getVelocity() || valueTransition.velocity)) canSkip = false;
+    if (value.animation) canSkip = false;
     if (canSkip) continue;
-    value.start(animateMotionValue(
-      key7,
-      value,
-      valueTarget,
-      visualElement.shouldReduceMotion && transformProps.has(key7,)
-        ? {
-          type: false,
-        }
-        : valueTransition,
-    ),);
+    value.start(
+      animateMotionValue(
+        key7,
+        value,
+        valueTarget,
+        visualElement.shouldReduceMotion && transformProps.has(key7,) ? { type: false, } : valueTransition,
+      ),
+    );
     const animation = value.animation;
     if (isWillChangeMotionValue(willChange,)) {
       willChange.add(key7,);
@@ -2922,32 +2309,20 @@ function animateTarget(visualElement, definition, {
 }
 function animateVariant(visualElement, variant, options = {},) {
   const resolved = resolveVariant(visualElement, variant, options.custom,);
-  let {
-    transition = visualElement.getDefaultTransition() || {},
-  } = resolved || {};
-  if (options.transitionOverride) {
-    transition = options.transitionOverride;
-  }
+  let { transition = visualElement.getDefaultTransition() || {}, } = resolved || {};
+  if (options.transitionOverride) transition = options.transitionOverride;
   const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options,),) : () => Promise.resolve();
   const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size
     ? (forwardDelay = 0,) => {
-      const {
-        delayChildren = 0,
-        staggerChildren,
-        staggerDirection,
-      } = transition;
+      const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;
       return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options,);
     }
     : () => Promise.resolve();
-  const {
-    when,
-  } = transition;
+  const { when, } = transition;
   if (when) {
     const [first, last,] = when === 'beforeChildren' ? [getAnimation, getChildAnimations,] : [getChildAnimations, getAnimation,];
     return first().then(() => last());
-  } else {
-    return Promise.all([getAnimation(), getChildAnimations(options.delay,),],);
-  }
+  } else return Promise.all([getAnimation(), getChildAnimations(options.delay,),],);
 }
 function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options,) {
   const animations2 = [];
@@ -2958,10 +2333,9 @@ function animateChildren(visualElement, variant, delayChildren = 0, staggerChild
   Array.from(visualElement.variantChildren,).sort(sortByTreeOrder,).forEach((child, i,) => {
     child.notify('AnimationStart', variant,);
     animations2.push(
-      animateVariant(child, variant, {
-        ...options,
-        delay: delayChildren + generateStaggerDuration(i,),
-      },).then(() => child.notify('AnimationComplete', variant,)),
+      animateVariant(child, variant, { ...options, delay: delayChildren + generateStaggerDuration(i,), },).then(() =>
+        child.notify('AnimationComplete', variant,)
+      ),
     );
   },);
   return Promise.all(animations2,);
@@ -2975,9 +2349,8 @@ function animateVisualElement(visualElement, definition, options = {},) {
   if (Array.isArray(definition,)) {
     const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options,));
     animation = Promise.all(animations2,);
-  } else if (typeof definition === 'string') {
-    animation = animateVariant(visualElement, definition, options,);
-  } else {
+  } else if (typeof definition === 'string') animation = animateVariant(visualElement, definition, options,);
+  else {
     const resolvedDefinition = typeof definition === 'function' ? resolveVariant(visualElement, definition, options.custom,) : definition;
     animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options,),);
   }
@@ -2987,19 +2360,14 @@ function shallowCompare(next, prev,) {
   if (!Array.isArray(prev,)) return false;
   const prevLength = prev.length;
   if (prevLength !== next.length) return false;
-  for (let i = 0; i < prevLength; i++) {
-    if (prev[i] !== next[i]) return false;
-  }
+  for (let i = 0; i < prevLength; i++) if (prev[i] !== next[i]) return false;
   return true;
 }
 var reversePriorityOrder = [...variantPriorityOrder,].reverse();
 var numAnimationTypes = variantPriorityOrder.length;
 function animateList(visualElement,) {
   return (animations2) =>
-    Promise.all(animations2.map(({
-      animation,
-      options,
-    },) => animateVisualElement(visualElement, animation, options,)),);
+    Promise.all(animations2.map(({ animation, options, },) => animateVisualElement(visualElement, animation, options,)),);
 }
 function createAnimationState(visualElement,) {
   let animate22 = animateList(visualElement,);
@@ -3008,16 +2376,8 @@ function createAnimationState(visualElement,) {
   const buildResolvedTypeValues = (acc, definition,) => {
     const resolved = resolveVariant(visualElement, definition,);
     if (resolved) {
-      const {
-        transition,
-        transitionEnd,
-        ...target
-      } = resolved;
-      acc = {
-        ...acc,
-        ...target,
-        ...transitionEnd,
-      };
+      const { transition, transitionEnd, ...target } = resolved;
+      acc = { ...acc, ...target, ...transitionEnd, };
     }
     return acc;
   };
@@ -3039,39 +2399,24 @@ function createAnimationState(visualElement,) {
       const activeDelta = type === changedActiveType ? typeState.isActive : null;
       if (activeDelta === false) removedVariantIndex = i;
       let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
-      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
-        isInherited = false;
-      }
-      typeState.protectedKeys = {
-        ...encounteredKeys,
-      };
+      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) isInherited = false;
+      typeState.protectedKeys = { ...encounteredKeys, };
       if (
         // If it isn't active and hasn't *just* been set as inactive
-        !typeState.isActive && activeDelta === null ||
-        // If we didn't and don't have any defined prop for this animation type
-        !prop && !typeState.prevProp ||
-        // Or if the prop doesn't define an animation
+        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
+        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
         isAnimationControls(prop,) || typeof prop === 'boolean'
-      ) {
-        continue;
-      }
+      ) continue;
       const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop,);
-      let shouldAnimateType = variantDidChange ||
-        // If we're making this variant active, we want to always make it active
-        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
-        // If we removed a higher-priority variant (i is in reverse order)
+      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
+        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
         i > removedVariantIndex && propIsVariant;
       let handledRemovedValues = false;
       const definitionList = Array.isArray(prop,) ? prop : [prop,];
       let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {},);
       if (activeDelta === false) resolvedValues = {};
-      const {
-        prevResolvedValues = {},
-      } = typeState;
-      const allKeys = {
-        ...prevResolvedValues,
-        ...resolvedValues,
-      };
+      const { prevResolvedValues = {}, } = typeState;
+      const allKeys = { ...prevResolvedValues, ...resolvedValues, };
       const markToAnimate = (key7) => {
         shouldAnimateType = true;
         if (removedKeys.has(key7,)) {
@@ -3087,57 +2432,31 @@ function createAnimationState(visualElement,) {
         const prev = prevResolvedValues[key7];
         if (encounteredKeys.hasOwnProperty(key7,)) continue;
         let valueHasChanged = false;
-        if (isKeyframesTarget(next,) && isKeyframesTarget(prev,)) {
-          valueHasChanged = !shallowCompare(next, prev,);
-        } else {
-          valueHasChanged = next !== prev;
-        }
+        if (isKeyframesTarget(next,) && isKeyframesTarget(prev,)) valueHasChanged = !shallowCompare(next, prev,);
+        else valueHasChanged = next !== prev;
         if (valueHasChanged) {
-          if (next !== void 0) {
-            markToAnimate(key7,);
-          } else {
-            removedKeys.add(key7,);
-          }
-        } else if (next !== void 0 && removedKeys.has(key7,)) {
-          markToAnimate(key7,);
-        } else {
-          typeState.protectedKeys[key7] = true;
-        }
+          if (next !== void 0) markToAnimate(key7,);
+          else removedKeys.add(key7,);
+        } else if (next !== void 0 && removedKeys.has(key7,)) markToAnimate(key7,);
+        else typeState.protectedKeys[key7] = true;
       }
       typeState.prevProp = prop;
       typeState.prevResolvedValues = resolvedValues;
-      if (typeState.isActive) {
-        encounteredKeys = {
-          ...encounteredKeys,
-          ...resolvedValues,
-        };
-      }
-      if (isInitialRender && visualElement.blockInitialAnimation) {
-        shouldAnimateType = false;
-      }
+      if (typeState.isActive) encounteredKeys = { ...encounteredKeys, ...resolvedValues, };
+      if (isInitialRender && visualElement.blockInitialAnimation) shouldAnimateType = false;
       if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
-        animations2.push(...definitionList.map((animation) => ({
-          animation,
-          options: {
-            type,
-            ...options,
-          },
-        })),);
+        animations2.push(...definitionList.map((animation) => ({ animation, options: { type, ...options, }, })),);
       }
     }
     if (removedKeys.size) {
       const fallbackAnimation = {};
       removedKeys.forEach((key7) => {
         const fallbackTarget = visualElement.getBaseTarget(key7,);
-        if (fallbackTarget !== void 0) {
-          fallbackAnimation[key7] = fallbackTarget;
-        }
+        if (fallbackTarget !== void 0) fallbackAnimation[key7] = fallbackTarget;
         const motionValue2 = visualElement.getValue(key7,);
         if (motionValue2) motionValue2.liveStyle = true;
       },);
-      animations2.push({
-        animation: fallbackAnimation,
-      },);
+      animations2.push({ animation: fallbackAnimation, },);
     }
     let shouldAnimate = Boolean(animations2.length,);
     if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
@@ -3155,33 +2474,18 @@ function createAnimationState(visualElement,) {
     },);
     state[type].isActive = isActive;
     const animations2 = animateChanges(options, type,);
-    for (const key7 in state) {
-      state[key7].protectedKeys = {};
-    }
+    for (const key7 in state) state[key7].protectedKeys = {};
     return animations2;
   }
-  return {
-    animateChanges,
-    setActive,
-    setAnimateFunction,
-    getState: () => state,
-  };
+  return { animateChanges, setActive, setAnimateFunction, getState: () => state, };
 }
 function checkVariantsDidChange(prev, next,) {
-  if (typeof next === 'string') {
-    return next !== prev;
-  } else if (Array.isArray(next,)) {
-    return !shallowCompare(next, prev,);
-  }
+  if (typeof next === 'string') return next !== prev;
+  else if (Array.isArray(next,)) return !shallowCompare(next, prev,);
   return false;
 }
 function createTypeState(isActive = false,) {
-  return {
-    isActive,
-    protectedKeys: {},
-    needsAnimating: {},
-    prevResolvedValues: {},
-  };
+  return { isActive, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {}, };
 }
 function createState() {
   return {
@@ -3206,36 +2510,25 @@ var AnimationFeature = class extends Feature {
    * We dynamically generate the AnimationState manager as it contains a reference
    * to the underlying animation library. We only want to load that if we load this,
    * so people can optionally code split it out using the `m` component.
-   */
-  constructor(node,) {
+   */ constructor(node,) {
     super(node,);
     node.animationState || (node.animationState = createAnimationState(node,));
   }
   updateAnimationControlsSubscription() {
-    const {
-      animate: animate22,
-    } = this.node.getProps();
+    const { animate: animate22, } = this.node.getProps();
     this.unmount();
-    if (isAnimationControls(animate22,)) {
-      this.unmount = animate22.subscribe(this.node,);
-    }
-  }
-  /**
+    if (isAnimationControls(animate22,)) this.unmount = animate22.subscribe(this.node,);
+  } /**
    * Subscribe any provided AnimationControls to the component's VisualElement
    */
+
   mount() {
     this.updateAnimationControlsSubscription();
   }
   update() {
-    const {
-      animate: animate22,
-    } = this.node.getProps();
-    const {
-      animate: prevAnimate,
-    } = this.node.prevProps || {};
-    if (animate22 !== prevAnimate) {
-      this.updateAnimationControlsSubscription();
-    }
+    const { animate: animate22, } = this.node.getProps();
+    const { animate: prevAnimate, } = this.node.prevProps || {};
+    if (animate22 !== prevAnimate) this.updateAnimationControlsSubscription();
   }
   unmount() {}
 };
@@ -3247,42 +2540,21 @@ var ExitAnimationFeature = class extends Feature {
   }
   update() {
     if (!this.node.presenceContext) return;
-    const {
-      isPresent: isPresent2,
-      onExitComplete,
-      custom,
-    } = this.node.presenceContext;
-    const {
-      isPresent: prevIsPresent,
-    } = this.node.prevPresenceContext || {};
-    if (!this.node.animationState || isPresent2 === prevIsPresent) {
-      return;
-    }
+    const { isPresent: isPresent2, onExitComplete, custom, } = this.node.presenceContext;
+    const { isPresent: prevIsPresent, } = this.node.prevPresenceContext || {};
+    if (!this.node.animationState || isPresent2 === prevIsPresent) return;
     const exitAnimation = this.node.animationState.setActive('exit', !isPresent2, {
       custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom,
     },);
-    if (onExitComplete && !isPresent2) {
-      exitAnimation.then(() => onExitComplete(this.id,));
-    }
+    if (onExitComplete && !isPresent2) exitAnimation.then(() => onExitComplete(this.id,));
   }
   mount() {
-    const {
-      register,
-    } = this.node.presenceContext || {};
-    if (register) {
-      this.unmount = register(this.id,);
-    }
+    const { register, } = this.node.presenceContext || {};
+    if (register) this.unmount = register(this.id,);
   }
   unmount() {}
 };
-var animations = {
-  animation: {
-    Feature: AnimationFeature,
-  },
-  exit: {
-    Feature: ExitAnimationFeature,
-  },
-};
+var animations = { animation: { Feature: AnimationFeature, }, exit: { Feature: ExitAnimationFeature, }, };
 var distance = (a, b,) => Math.abs(a - b,);
 function distance2D(a, b,) {
   const xDelta = distance(a.x, b.x,);
@@ -3323,32 +2595,14 @@ function calcRelativePosition(target, layout2, parent,) {
   calcRelativeAxisPosition(target.x, layout2.x, parent.x,);
   calcRelativeAxisPosition(target.y, layout2.y, parent.y,);
 }
-var createAxisDelta = () => ({
-  translate: 0,
-  scale: 1,
-  origin: 0,
-  originPoint: 0,
-});
-var createDelta = () => ({
-  x: createAxisDelta(),
-  y: createAxisDelta(),
-});
-var createAxis = () => ({
-  min: 0,
-  max: 0,
-});
-var createBox = () => ({
-  x: createAxis(),
-  y: createAxis(),
-});
+var createAxisDelta = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0, });
+var createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta(), });
+var createAxis = () => ({ min: 0, max: 0, });
+var createBox = () => ({ x: createAxis(), y: createAxis(), });
 function usePresence() {
   const context = useContext3(PresenceContext,);
   if (context === null) return [true, null,];
-  const {
-    isPresent: isPresent2,
-    onExitComplete,
-    register,
-  } = context;
+  const { isPresent: isPresent2, onExitComplete, register, } = context;
   const id4 = useId();
   useEffect(() => register(id4,), [],);
   const safeToRemove = () => onExitComplete && onExitComplete(id4,);
@@ -3382,9 +2636,7 @@ var FlatTree = class {
 };
 function delay(callback, timeout,) {
   const start = time.now();
-  const checkElapsed = ({
-    timestamp,
-  },) => {
+  const checkElapsed = ({ timestamp, },) => {
     const elapsed = timestamp - start;
     if (elapsed >= timeout) {
       cancelFrame(checkElapsed,);
@@ -3395,12 +2647,8 @@ function delay(callback, timeout,) {
   return () => cancelFrame(checkElapsed,);
 }
 var visualElementStore = /* @__PURE__ */ new WeakMap();
-var prefersReducedMotion = {
-  current: null,
-};
-var hasReducedMotionListener = {
-  current: false,
-};
+var prefersReducedMotion = { current: null, };
+var hasReducedMotionListener = { current: false, };
 function initPrefersReducedMotion() {
   hasReducedMotionListener.current = true;
   if (!isBrowser) return;
@@ -3409,22 +2657,16 @@ function initPrefersReducedMotion() {
     const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
     motionMediaQuery.addListener(setReducedMotionPreferences,);
     setReducedMotionPreferences();
-  } else {
-    prefersReducedMotion.current = false;
-  }
+  } else prefersReducedMotion.current = false;
 }
 function updateMotionValuesFromProps(element, next, prev,) {
-  const {
-    willChange,
-  } = next;
+  const { willChange, } = next;
   for (const key7 in next) {
     const nextValue = next[key7];
     const prevValue = prev[key7];
     if (isMotionValue(nextValue,)) {
       element.addValue(key7, nextValue,);
-      if (isWillChangeMotionValue(willChange,)) {
-        willChange.add(key7,);
-      }
+      if (isWillChangeMotionValue(willChange,)) willChange.add(key7,);
       if (false) {
         warnOnce(
           nextValue.version === '11.0.11-sync.5',
@@ -3432,37 +2674,20 @@ function updateMotionValuesFromProps(element, next, prev,) {
         );
       }
     } else if (isMotionValue(prevValue,)) {
-      element.addValue(
-        key7,
-        motionValue(nextValue, {
-          owner: element,
-        },),
-      );
-      if (isWillChangeMotionValue(willChange,)) {
-        willChange.remove(key7,);
-      }
+      element.addValue(key7, motionValue(nextValue, { owner: element, },),);
+      if (isWillChangeMotionValue(willChange,)) willChange.remove(key7,);
     } else if (prevValue !== nextValue) {
       if (element.hasValue(key7,)) {
         const existingValue = element.getValue(key7,);
-        if (existingValue.liveStyle === true) {
-          existingValue.jump(nextValue,);
-        } else if (!existingValue.hasAnimated) {
-          existingValue.set(nextValue,);
-        }
+        if (existingValue.liveStyle === true) existingValue.jump(nextValue,);
+        else if (!existingValue.hasAnimated) existingValue.set(nextValue,);
       } else {
         const latestValue = element.getStaticValue(key7,);
-        element.addValue(
-          key7,
-          motionValue(latestValue !== void 0 ? latestValue : nextValue, {
-            owner: element,
-          },),
-        );
+        element.addValue(key7, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element, },),);
       }
     }
   }
-  for (const key7 in prev) {
-    if (next[key7] === void 0) element.removeValue(key7,);
-  }
+  for (const key7 in prev) if (next[key7] === void 0) element.removeValue(key7,);
   return next;
 }
 var featureNames = Object.keys(featureDefinitions,);
@@ -3482,13 +2707,7 @@ var propEventHandlers = [
 ];
 var numVariantProps = variantProps.length;
 var VisualElement = class {
-  constructor({
-    parent,
-    props,
-    presenceContext,
-    reducedMotionConfig,
-    visualState,
-  }, options = {},) {
+  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState, }, options = {},) {
     this.current = null;
     this.children = /* @__PURE__ */ new Set();
     this.isVariantNode = false;
@@ -3507,19 +2726,10 @@ var VisualElement = class {
       this.renderInstance(this.current, this.renderState, this.props.style, this.projection,);
     };
     this.scheduleRender = () => frame.render(this.render, false, true,);
-    const {
-      latestValues,
-      renderState,
-    } = visualState;
+    const { latestValues, renderState, } = visualState;
     this.latestValues = latestValues;
-    this.baseTarget = {
-      ...latestValues,
-    };
-    this.initialValues = props.initial
-      ? {
-        ...latestValues,
-      }
-      : {};
+    this.baseTarget = { ...latestValues, };
+    this.initialValues = props.initial ? { ...latestValues, } : {};
     this.renderState = renderState;
     this.parent = parent;
     this.props = props;
@@ -3529,47 +2739,34 @@ var VisualElement = class {
     this.options = options;
     this.isControllingVariants = isControllingVariants(props,);
     this.isVariantNode = isVariantNode(props,);
-    if (this.isVariantNode) {
-      this.variantChildren = /* @__PURE__ */ new Set();
-    }
+    if (this.isVariantNode) this.variantChildren = /* @__PURE__ */ new Set();
     this.manuallyAnimateOnMount = Boolean(parent && parent.current,);
-    const {
-      willChange,
-      ...initialMotionValues
-    } = this.scrapeMotionValuesFromProps(props, {}, this,);
+    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this,);
     for (const key7 in initialMotionValues) {
       const value = initialMotionValues[key7];
       if (latestValues[key7] !== void 0 && isMotionValue(value,)) {
         value.set(latestValues[key7], false,);
-        if (isWillChangeMotionValue(willChange,)) {
-          willChange.add(key7,);
-        }
+        if (isWillChangeMotionValue(willChange,)) willChange.add(key7,);
       }
     }
-  }
-  /**
+  } /**
    * This method takes React props and returns found MotionValues. For example, HTML
    * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
    *
    * This isn't an abstract method as it needs calling in the constructor, but it is
    * intended to be one.
    */
+
   scrapeMotionValuesFromProps(_props, _prevProps, _visualElement,) {
     return {};
   }
   mount(instance,) {
     this.current = instance;
     visualElementStore.set(instance, this,);
-    if (this.projection && !this.projection.instance) {
-      this.projection.mount(instance,);
-    }
-    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
-      this.removeFromVariantTree = this.parent.addVariantChild(this,);
-    }
+    if (this.projection && !this.projection.instance) this.projection.mount(instance,);
+    if (this.parent && this.isVariantNode && !this.isControllingVariants) this.removeFromVariantTree = this.parent.addVariantChild(this,);
     this.values.forEach((value, key7,) => this.bindToMotionValue(key7, value,));
-    if (!hasReducedMotionListener.current) {
-      initPrefersReducedMotion();
-    }
+    if (!hasReducedMotionListener.current) initPrefersReducedMotion();
     this.shouldReduceMotion = this.reducedMotionConfig === 'never'
       ? false
       : this.reducedMotionConfig === 'always'
@@ -3589,12 +2786,8 @@ var VisualElement = class {
     this.valueSubscriptions.forEach((remove2) => remove2());
     this.removeFromVariantTree && this.removeFromVariantTree();
     this.parent && this.parent.children.delete(this,);
-    for (const key7 in this.events) {
-      this.events[key7].clear();
-    }
-    for (const key7 in this.features) {
-      this.features[key7].unmount();
-    }
+    for (const key7 in this.events) this.events[key7].clear();
+    for (const key7 in this.features) this.features[key7].unmount();
     this.current = null;
   }
   bindToMotionValue(key7, value,) {
@@ -3602,9 +2795,7 @@ var VisualElement = class {
     const removeOnChange = value.on('change', (latestValue) => {
       this.latestValues[key7] = latestValue;
       this.props.onUpdate && frame.update(this.notifyUpdate, false, true,);
-      if (valueIsTransform && this.projection) {
-        this.projection.isTransformDirty = true;
-      }
+      if (valueIsTransform && this.projection) this.projection.isTransformDirty = true;
     },);
     const removeOnRenderRequest = value.on('renderRequest', this.scheduleRender,);
     this.valueSubscriptions.set(key7, () => {
@@ -3613,20 +2804,10 @@ var VisualElement = class {
     },);
   }
   sortNodePosition(other,) {
-    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
-      return 0;
-    }
+    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) return 0;
     return this.sortInstanceNodePosition(this.current, other.current,);
   }
-  loadFeatures(
-    {
-      children,
-      ...renderedProps
-    },
-    isStrict,
-    preloadedFeatures2,
-    initialLayoutGroupConfig,
-  ) {
+  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig,) {
     let ProjectionNodeConstructor;
     let MeasureLayout2;
     if (false) {
@@ -3636,39 +2817,22 @@ var VisualElement = class {
     }
     for (let i = 0; i < numFeatures; i++) {
       const name = featureNames[i];
-      const {
-        isEnabled,
-        Feature: FeatureConstructor,
-        ProjectionNode,
-        MeasureLayout: MeasureLayoutComponent,
-      } = featureDefinitions[name];
+      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent, } = featureDefinitions[name];
       if (ProjectionNode) ProjectionNodeConstructor = ProjectionNode;
       if (isEnabled(renderedProps,)) {
-        if (!this.features[name] && FeatureConstructor) {
-          this.features[name] = new FeatureConstructor(this,);
-        }
-        if (MeasureLayoutComponent) {
-          MeasureLayout2 = MeasureLayoutComponent;
-        }
+        if (!this.features[name] && FeatureConstructor) this.features[name] = new FeatureConstructor(this,);
+        if (MeasureLayoutComponent) MeasureLayout2 = MeasureLayoutComponent;
       }
     }
     if ((this.type === 'html' || this.type === 'svg') && !this.projection && ProjectionNodeConstructor) {
       this.projection = new ProjectionNodeConstructor(this.latestValues, getClosestProjectingNode(this.parent,),);
-      const {
-        layoutId,
-        layout: layout2,
-        drag: drag2,
-        dragConstraints,
-        layoutScroll,
-        layoutRoot,
-      } = renderedProps;
+      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, } = renderedProps;
       this.projection.setOptions({
         layoutId,
         layout: layout2,
         alwaysMeasureLayout: Boolean(drag2,) || dragConstraints && isRefObject(dragConstraints,),
         visualElement: this,
-        scheduleRender: () => this.scheduleRender(),
-        /**
+        scheduleRender: () => this.scheduleRender(), /**
          * TODO: Update options in an effect. This could be tricky as it'll be too late
          * to update by the time layout animations run.
          * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
@@ -3685,9 +2849,8 @@ var VisualElement = class {
   updateFeatures() {
     for (const key7 in this.features) {
       const feature = this.features[key7];
-      if (feature.isMounted) {
-        feature.update();
-      } else {
+      if (feature.isMounted) feature.update();
+      else {
         feature.mount();
         feature.isMounted = true;
       }
@@ -3695,12 +2858,12 @@ var VisualElement = class {
   }
   triggerBuild() {
     this.build(this.renderState, this.latestValues, this.options, this.props,);
-  }
-  /**
+  } /**
    * Measure the current viewport box with or without transforms.
    * Only measures axis-aligned boxes, rotate and skew must be manually
    * removed with a re-render to work.
    */
+
   measureViewportBox() {
     return this.current ? this.measureInstanceViewportBox(this.current, this.props,) : createBox();
   }
@@ -3709,25 +2872,23 @@ var VisualElement = class {
   }
   setStaticValue(key7, value,) {
     this.latestValues[key7] = value;
-  }
-  /**
+  } /**
    * Make a target animatable by Popmotion. For instance, if we're
    * trying to animate width from 100px to 100vw we need to measure 100vw
    * in pixels to determine what we really need to animate to. This is also
    * pluggable to support Framer's custom value types like Color,
    * and CSS variables.
    */
+
   makeTargetAnimatable(target, canMutate = true,) {
     return this.makeTargetAnimatableFromInstance(target, canMutate,);
-  }
-  /**
+  } /**
    * Update the provided props. Ensure any newly-added motion values are
    * added to our map, old ones removed, and listeners updated.
    */
+
   update(props, presenceContext,) {
-    if (props.transformTemplate || this.props.transformTemplate) {
-      this.scheduleRender();
-    }
+    if (props.transformTemplate || this.props.transformTemplate) this.scheduleRender();
     this.prevProps = this.props;
     this.props = props;
     this.prevPresenceContext = this.presenceContext;
@@ -3739,31 +2900,27 @@ var VisualElement = class {
         delete this.propEventSubscriptions[key7];
       }
       const listener = props['on' + key7];
-      if (listener) {
-        this.propEventSubscriptions[key7] = this.on(key7, listener,);
-      }
+      if (listener) this.propEventSubscriptions[key7] = this.on(key7, listener,);
     }
     this.prevMotionValues = updateMotionValuesFromProps(
       this,
       this.scrapeMotionValuesFromProps(props, this.prevProps, this,),
       this.prevMotionValues,
     );
-    if (this.handleChildMotionValue) {
-      this.handleChildMotionValue();
-    }
+    if (this.handleChildMotionValue) this.handleChildMotionValue();
   }
   getProps() {
     return this.props;
-  }
-  /**
+  } /**
    * Returns the variant definition with a given name.
    */
+
   getVariant(name,) {
     return this.props.variants ? this.props.variants[name] : void 0;
-  }
-  /**
+  } /**
    * Returns the defined default transition on this component.
    */
+
   getDefaultTransition() {
     return this.props.transition;
   }
@@ -3774,39 +2931,33 @@ var VisualElement = class {
     return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
   }
   getVariantContext(startAtParent = false,) {
-    if (startAtParent) {
-      return this.parent ? this.parent.getVariantContext() : void 0;
-    }
+    if (startAtParent) return this.parent ? this.parent.getVariantContext() : void 0;
     if (!this.isControllingVariants) {
       const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
-      if (this.props.initial !== void 0) {
-        context2.initial = this.props.initial;
-      }
+      if (this.props.initial !== void 0) context2.initial = this.props.initial;
       return context2;
     }
     const context = {};
     for (let i = 0; i < numVariantProps; i++) {
       const name = variantProps[i];
       const prop = this.props[name];
-      if (isVariantLabel(prop,) || prop === false) {
-        context[name] = prop;
-      }
+      if (isVariantLabel(prop,) || prop === false) context[name] = prop;
     }
     return context;
-  }
-  /**
+  } /**
    * Add a child visual element to our set of children.
    */
+
   addVariantChild(child,) {
     const closestVariantNode = this.getClosestVariantNode();
     if (closestVariantNode) {
       closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child,);
       return () => closestVariantNode.variantChildren.delete(child,);
     }
-  }
-  /**
+  } /**
    * Add a motion value and bind it to this visual element.
    */
+
   addValue(key7, value,) {
     if (value !== this.values.get(key7,)) {
       this.removeValue(key7,);
@@ -3814,10 +2965,10 @@ var VisualElement = class {
     }
     this.values.set(key7, value,);
     this.latestValues[key7] = value.get();
-  }
-  /**
+  } /**
    * Remove a motion value and unbind any active subscriptions.
    */
+
   removeValue(key7,) {
     this.values.delete(key7,);
     const unsubscribe = this.valueSubscriptions.get(key7,);
@@ -3827,31 +2978,27 @@ var VisualElement = class {
     }
     delete this.latestValues[key7];
     this.removeValueFromRenderState(key7, this.renderState,);
-  }
-  /**
+  } /**
    * Check whether we have a motion value for this key
    */
+
   hasValue(key7,) {
     return this.values.has(key7,);
   }
   getValue(key7, defaultValue,) {
-    if (this.props.values && this.props.values[key7]) {
-      return this.props.values[key7];
-    }
+    if (this.props.values && this.props.values[key7]) return this.props.values[key7];
     let value = this.values.get(key7,);
     if (value === void 0 && defaultValue !== void 0) {
-      value = motionValue(defaultValue, {
-        owner: this,
-      },);
+      value = motionValue(defaultValue, { owner: this, },);
       this.addValue(key7, value,);
     }
     return value;
-  }
-  /**
+  } /**
    * If we're trying to animate to a previously unencountered value,
    * we need to check for it in our state and as a last resort read it
    * directly from the instance (which might have performance implications).
    */
+
   readValue(key7,) {
     var _a;
     return this.latestValues[key7] !== void 0 || !this.current
@@ -3859,63 +3006,50 @@ var VisualElement = class {
       : (_a = this.getBaseTargetFromProps(this.props, key7,)) !== null && _a !== void 0
       ? _a
       : this.readValueFromInstance(this.current, key7, this.options,);
-  }
-  /**
+  } /**
    * Set the base target to later animate back to. This is currently
    * only hydrated on creation and when we first read a value.
    */
+
   setBaseTarget(key7, value,) {
     this.baseTarget[key7] = value;
-  }
-  /**
+  } /**
    * Find the base target for a value thats been removed from all animation
    * props.
    */
+
   getBaseTarget(key7,) {
     var _a;
-    const {
-      initial,
-    } = this.props;
+    const { initial, } = this.props;
     const valueFromInitial = typeof initial === 'string' || typeof initial === 'object'
       ? (_a = resolveVariantFromProps(this.props, initial,)) === null || _a === void 0 ? void 0 : _a[key7]
       : void 0;
-    if (initial && valueFromInitial !== void 0) {
-      return valueFromInitial;
-    }
+    if (initial && valueFromInitial !== void 0) return valueFromInitial;
     const target = this.getBaseTargetFromProps(this.props, key7,);
     if (target !== void 0 && !isMotionValue(target,)) return target;
     return this.initialValues[key7] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key7];
   }
   on(eventName, callback,) {
-    if (!this.events[eventName]) {
-      this.events[eventName] = new SubscriptionManager();
-    }
+    if (!this.events[eventName]) this.events[eventName] = new SubscriptionManager();
     return this.events[eventName].add(callback,);
   }
   notify(eventName, ...args) {
-    if (this.events[eventName]) {
-      this.events[eventName].notify(...args,);
-    }
+    if (this.events[eventName]) this.events[eventName].notify(...args,);
   }
 };
 function createMotionProxy(createConfig,) {
   function custom(Component23, customMotionComponentConfig = {},) {
     return createMotionComponent(createConfig(Component23, customMotionComponentConfig,),);
   }
-  if (typeof Proxy === 'undefined') {
-    return custom;
-  }
+  if (typeof Proxy === 'undefined') return custom;
   const componentCache = /* @__PURE__ */ new Map();
   return new Proxy(custom, {
     /**
      * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
      * The prop name is passed through as `key` and we can use that to generate a `motion`
      * DOM component with that name.
-     */
-    get: (_target, key7,) => {
-      if (!componentCache.has(key7,)) {
-        componentCache.set(key7, custom(key7,),);
-      }
+     */ get: (_target, key7,) => {
+      if (!componentCache.has(key7,)) componentCache.set(key7, custom(key7,),);
       return componentCache.get(key7,);
     },
   },);
@@ -3952,32 +3086,22 @@ function isSVGComponent(Component23,) {
     /**
      * If it's not a string, it's a custom React component. Currently we only support
      * HTML custom React components.
-     */
-    typeof Component23 !== 'string' ||
-    /**
+     */ typeof Component23 !== 'string' || /**
      * If it contains a dash, the element is a custom HTML webcomponent.
      */
-    Component23.includes('-',)
-  ) {
-    return false;
-  } else if (
+      Component23.includes('-',)
+  ) return false;
+  else if (
     /**
      * If it's in our list of lowercase SVG tags, it's an SVG component
-     */
-    lowercaseSVGElements.indexOf(Component23,) > -1 ||
-    /**
+     */ lowercaseSVGElements.indexOf(Component23,) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
-    /[A-Z]/u.test(Component23,)
-  ) {
-    return true;
-  }
+      /[A-Z]/u.test(Component23,)
+  ) return true;
   return false;
 }
-function isForcedMotionValue(key7, {
-  layout: layout2,
-  layoutId,
-},) {
+function isForcedMotionValue(key7, { layout: layout2, layoutId, },) {
   return transformProps.has(key7,) || key7.startsWith('origin',) ||
     (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key7] || key7 === 'opacity');
 }
@@ -3985,12 +3109,7 @@ var getValueAsType = (value, type,) => {
   return type && typeof value === 'number' ? type.transform(value,) : value;
 };
 function buildHTMLStyles(state, latestValues, options, transformTemplate2,) {
-  const {
-    style,
-    vars,
-    transform: transform2,
-    transformOrigin,
-  } = state;
+  const { style, vars, transform: transform2, transformOrigin, } = state;
   let hasTransform2 = false;
   let hasTransformOrigin = false;
   let transformIsNone = true;
@@ -4010,9 +3129,7 @@ function buildHTMLStyles(state, latestValues, options, transformTemplate2,) {
     } else if (key7.startsWith('origin',)) {
       hasTransformOrigin = true;
       transformOrigin[key7] = valueAsType;
-    } else {
-      style[key7] = valueAsType;
-    }
+    } else style[key7] = valueAsType;
   }
   if (!latestValues.transform) {
     if (hasTransform2 || transformTemplate2) {
@@ -4022,39 +3139,18 @@ function buildHTMLStyles(state, latestValues, options, transformTemplate2,) {
     }
   }
   if (hasTransformOrigin) {
-    const {
-      originX = '50%',
-      originY = '50%',
-      originZ = 0,
-    } = transformOrigin;
+    const { originX = '50%', originY = '50%', originZ = 0, } = transformOrigin;
     style.transformOrigin = `${originX} ${originY} ${originZ}`;
   }
 }
-var createHtmlRenderState = () => ({
-  style: {},
-  transform: {},
-  transformOrigin: {},
-  vars: {},
-});
+var createHtmlRenderState = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {}, });
 function copyRawValuesOnly(target, source, props,) {
-  for (const key7 in source) {
-    if (!isMotionValue(source[key7],) && !isForcedMotionValue(key7, props,)) {
-      target[key7] = source[key7];
-    }
-  }
+  for (const key7 in source) if (!isMotionValue(source[key7],) && !isForcedMotionValue(key7, props,)) target[key7] = source[key7];
 }
-function useInitialMotionValues(
-  {
-    transformTemplate: transformTemplate2,
-  },
-  visualState,
-  isStatic,
-) {
+function useInitialMotionValues({ transformTemplate: transformTemplate2, }, visualState, isStatic,) {
   return useMemo(() => {
     const state = createHtmlRenderState();
-    buildHTMLStyles(state, visualState, {
-      enableHardwareAcceleration: !isStatic,
-    }, transformTemplate2,);
+    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic, }, transformTemplate2,);
     return Object.assign({}, state.vars, state.style,);
   }, [visualState,],);
 }
@@ -4073,9 +3169,7 @@ function useHTMLProps(props, visualState, isStatic,) {
     style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = 'none';
     style.touchAction = props.drag === true ? 'none' : `pan-${props.drag === 'x' ? 'y' : 'x'}`;
   }
-  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
-    htmlProps.tabIndex = 0;
-  }
+  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) htmlProps.tabIndex = 0;
   htmlProps.style = style;
   return htmlProps;
 }
@@ -4087,14 +3181,8 @@ function calcSVGTransformOrigin(dimensions, originX, originY,) {
   const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height,);
   return `${pxOriginX} ${pxOriginY}`;
 }
-var dashKeys = {
-  offset: 'stroke-dashoffset',
-  array: 'stroke-dasharray',
-};
-var camelKeys = {
-  offset: 'strokeDashoffset',
-  array: 'strokeDasharray',
-};
+var dashKeys = { offset: 'stroke-dashoffset', array: 'stroke-dasharray', };
+var camelKeys = { offset: 'strokeDashoffset', array: 'strokeDasharray', };
 function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true,) {
   attrs.pathLength = 1;
   const keys23 = useDashCase ? dashKeys : camelKeys;
@@ -4113,8 +3201,7 @@ function buildSVGAttrs(
     originY,
     pathLength,
     pathSpacing = 1,
-    pathOffset = 0,
-    // This is object creation, which we try to avoid per-frame.
+    pathOffset = 0, // This is object creation, which we try to avoid per-frame.
     ...latest
   },
   options,
@@ -4123,18 +3210,12 @@ function buildSVGAttrs(
 ) {
   buildHTMLStyles(state, latest, options, transformTemplate2,);
   if (isSVGTag2) {
-    if (state.style.viewBox) {
-      state.attrs.viewBox = state.style.viewBox;
-    }
+    if (state.style.viewBox) state.attrs.viewBox = state.style.viewBox;
     return;
   }
   state.attrs = state.style;
   state.style = {};
-  const {
-    attrs,
-    style,
-    dimensions,
-  } = state;
+  const { attrs, style, dimensions, } = state;
   if (attrs.transform) {
     if (dimensions) style.transform = attrs.transform;
     delete attrs.transform;
@@ -4145,82 +3226,38 @@ function buildSVGAttrs(
   if (attrX !== void 0) attrs.x = attrX;
   if (attrY !== void 0) attrs.y = attrY;
   if (attrScale !== void 0) attrs.scale = attrScale;
-  if (pathLength !== void 0) {
-    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false,);
-  }
+  if (pathLength !== void 0) buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false,);
 }
-var createSvgRenderState = () => ({
-  ...createHtmlRenderState(),
-  attrs: {},
-});
+var createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {}, });
 var isSVGTag = (tag) => typeof tag === 'string' && tag.toLowerCase() === 'svg';
 function useSVGProps(props, visualState, _isStatic, Component23,) {
   const visualProps = useMemo(() => {
     const state = createSvgRenderState();
-    buildSVGAttrs(
-      state,
-      visualState,
-      {
-        enableHardwareAcceleration: false,
-      },
-      isSVGTag(Component23,),
-      props.transformTemplate,
-    );
-    return {
-      ...state.attrs,
-      style: {
-        ...state.style,
-      },
-    };
+    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false, }, isSVGTag(Component23,), props.transformTemplate,);
+    return { ...state.attrs, style: { ...state.style, }, };
   }, [visualState,],);
   if (props.style) {
     const rawStyles = {};
     copyRawValuesOnly(rawStyles, props.style, props,);
-    visualProps.style = {
-      ...rawStyles,
-      ...visualProps.style,
-    };
+    visualProps.style = { ...rawStyles, ...visualProps.style, };
   }
   return visualProps;
 }
 function createUseRender(forwardMotionProps = false,) {
-  const useRender = (Component23, props, ref, {
-    latestValues,
-  }, isStatic,) => {
+  const useRender = (Component23, props, ref, { latestValues, }, isStatic,) => {
     const useVisualProps = isSVGComponent(Component23,) ? useSVGProps : useHTMLProps;
     const visualProps = useVisualProps(props, latestValues, isStatic, Component23,);
     const filteredProps2 = filterProps(props, typeof Component23 === 'string', forwardMotionProps,);
-    const elementProps = Component23 !== Fragment
-      ? {
-        ...filteredProps2,
-        ...visualProps,
-        ref,
-      }
-      : {};
-    const {
-      children,
-    } = props;
+    const elementProps = Component23 !== Fragment ? { ...filteredProps2, ...visualProps, ref, } : {};
+    const { children, } = props;
     const renderedChildren = useMemo(() => isMotionValue(children,) ? children.get() : children, [children,],);
-    return createElement2(Component23, {
-      ...elementProps,
-      children: renderedChildren,
-    },);
+    return createElement2(Component23, { ...elementProps, children: renderedChildren, },);
   };
   return useRender;
 }
-function renderHTML(
-  element,
-  {
-    style,
-    vars,
-  },
-  styleProp,
-  projection,
-) {
+function renderHTML(element, { style, vars, }, styleProp, projection,) {
   Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp,),);
-  for (const key7 in vars) {
-    element.style.setProperty(key7, vars[key7],);
-  }
+  for (const key7 in vars) element.style.setProperty(key7, vars[key7],);
 }
 var camelCaseAttributes = /* @__PURE__ */ new Set([
   'baseFrequency',
@@ -4255,9 +3292,7 @@ function renderSVG(element, renderState, _styleProp, projection,) {
 }
 function scrapeMotionValuesFromProps(props, prevProps, visualElement,) {
   var _a;
-  const {
-    style,
-  } = props;
+  const { style, } = props;
   const newValues = {};
   for (const key7 in style) {
     if (
@@ -4265,9 +3300,7 @@ function scrapeMotionValuesFromProps(props, prevProps, visualElement,) {
       ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key7,)) === null || _a === void 0
           ? void 0
           : _a.liveStyle) !== void 0
-    ) {
-      newValues[key7] = style[key7];
-    }
+    ) newValues[key7] = style[key7];
   }
   return newValues;
 }
@@ -4285,29 +3318,19 @@ var svgMotionConfig = {
   useVisualState: makeUseVisualState({
     scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
     createRenderState: createSvgRenderState,
-    onMount: (props, instance, {
-      renderState,
-      latestValues,
-    },) => {
+    onMount: (props, instance, { renderState, latestValues, },) => {
       frame.read(() => {
         try {
           renderState.dimensions = typeof instance.getBBox === 'function' ? instance.getBBox() : instance.getBoundingClientRect();
         } catch (e) {
-          renderState.dimensions = {
-            x: 0,
-            y: 0,
-            width: 0,
-            height: 0,
-          };
+          renderState.dimensions = { x: 0, y: 0, width: 0, height: 0, };
         }
       },);
       frame.render(() => {
         buildSVGAttrs(
           renderState,
           latestValues,
-          {
-            enableHardwareAcceleration: false,
-          },
+          { enableHardwareAcceleration: false, },
           isSVGTag(instance.tagName,),
           props.transformTemplate,
         );
@@ -4316,20 +3339,8 @@ var svgMotionConfig = {
     },
   },),
 };
-var htmlMotionConfig = {
-  useVisualState: makeUseVisualState({
-    scrapeMotionValuesFromProps,
-    createRenderState: createHtmlRenderState,
-  },),
-};
-function createDomMotionConfig(
-  Component23,
-  {
-    forwardMotionProps = false,
-  },
-  preloadedFeatures2,
-  createVisualElement2,
-) {
+var htmlMotionConfig = { useVisualState: makeUseVisualState({ scrapeMotionValuesFromProps, createRenderState: createHtmlRenderState, },), };
+function createDomMotionConfig(Component23, { forwardMotionProps = false, }, preloadedFeatures2, createVisualElement2,) {
   const baseConfig = isSVGComponent(Component23,) ? svgMotionConfig : htmlMotionConfig;
   return {
     ...baseConfig,
@@ -4345,16 +3356,10 @@ function addHoverEvent(node, isActive,) {
   const handleEvent = (event, info,) => {
     if (event.pointerType === 'touch' || isDragActive()) return;
     const props = node.getProps();
-    if (node.animationState && props.whileHover) {
-      node.animationState.setActive('whileHover', isActive,);
-    }
-    if (props[callbackName]) {
-      frame.update(() => props[callbackName](event, info,));
-    }
+    if (node.animationState && props.whileHover) node.animationState.setActive('whileHover', isActive,);
+    if (props[callbackName]) frame.update(() => props[callbackName](event, info,));
   };
-  return addPointerEvent(node.current, eventName, handleEvent, {
-    passive: !node.getProps()[callbackName],
-  },);
+  return addPointerEvent(node.current, eventName, handleEvent, { passive: !node.getProps()[callbackName], },);
 }
 var HoverGesture = class extends Feature {
   mount() {
@@ -4392,13 +3397,9 @@ var FocusGesture = class extends Feature {
   unmount() {}
 };
 var isNodeOrChild = (parent, child,) => {
-  if (!child) {
-    return false;
-  } else if (parent === child) {
-    return true;
-  } else {
-    return isNodeOrChild(parent, child.parentElement,);
-  }
+  if (!child) return false;
+  else if (parent === child) return true;
+  else return isNodeOrChild(parent, child.parentElement,);
 };
 function fireSyntheticPointerEvent(name, handler,) {
   if (!handler) return;
@@ -4417,11 +3418,7 @@ var PressGesture = class extends Feature {
       const props = this.node.getProps();
       const endPointerPress = (endEvent, endInfo,) => {
         if (!this.checkPressEnd()) return;
-        const {
-          onTap,
-          onTapCancel,
-          globalTapTarget,
-        } = this.node.getProps();
+        const { onTap, onTapCancel, globalTapTarget, } = this.node.getProps();
         frame.update(() => {
           !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target,)
             ? onTapCancel && onTapCancel(endEvent, endInfo,)
@@ -4435,9 +3432,7 @@ var PressGesture = class extends Feature {
         window,
         'pointercancel',
         (cancelEvent, cancelInfo,) => this.cancelPress(cancelEvent, cancelInfo,),
-        {
-          passive: !(props.onTapCancel || props['onPointerCancel']),
-        },
+        { passive: !(props.onTapCancel || props['onPointerCancel']), },
       );
       this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener,);
       this.startPress(startEvent, startInfo,);
@@ -4448,12 +3443,8 @@ var PressGesture = class extends Feature {
         const handleKeyup = (keyupEvent) => {
           if (keyupEvent.key !== 'Enter' || !this.checkPressEnd()) return;
           fireSyntheticPointerEvent('up', (event, info,) => {
-            const {
-              onTap,
-            } = this.node.getProps();
-            if (onTap) {
-              frame.update(() => onTap(event, info,));
-            }
+            const { onTap, } = this.node.getProps();
+            if (onTap) frame.update(() => onTap(event, info,));
           },);
         };
         this.removeEndListeners();
@@ -4473,34 +3464,21 @@ var PressGesture = class extends Feature {
   }
   startPress(event, info,) {
     this.isPressing = true;
-    const {
-      onTapStart,
-      whileTap,
-    } = this.node.getProps();
-    if (whileTap && this.node.animationState) {
-      this.node.animationState.setActive('whileTap', true,);
-    }
-    if (onTapStart) {
-      frame.update(() => onTapStart(event, info,));
-    }
+    const { onTapStart, whileTap, } = this.node.getProps();
+    if (whileTap && this.node.animationState) this.node.animationState.setActive('whileTap', true,);
+    if (onTapStart) frame.update(() => onTapStart(event, info,));
   }
   checkPressEnd() {
     this.removeEndListeners();
     this.isPressing = false;
     const props = this.node.getProps();
-    if (props.whileTap && this.node.animationState) {
-      this.node.animationState.setActive('whileTap', false,);
-    }
+    if (props.whileTap && this.node.animationState) this.node.animationState.setActive('whileTap', false,);
     return !isDragActive();
   }
   cancelPress(event, info,) {
     if (!this.checkPressEnd()) return;
-    const {
-      onTapCancel,
-    } = this.node.getProps();
-    if (onTapCancel) {
-      frame.update(() => onTapCancel(event, info,));
-    }
+    const { onTapCancel, } = this.node.getProps();
+    if (onTapCancel) frame.update(() => onTapCancel(event, info,));
   }
   mount() {
     const props = this.node.getProps();
@@ -4508,9 +3486,7 @@ var PressGesture = class extends Feature {
       props.globalTapTarget ? window : this.node.current,
       'pointerdown',
       this.startPointerPress,
-      {
-        passive: !(props.onTapStart || props['onPointerStart']),
-      },
+      { passive: !(props.onTapStart || props['onPointerStart']), },
     );
     const removeFocusListener = addDomEvent(this.node.current, 'focus', this.startAccessiblePress,);
     this.removeStartListeners = pipe(removePointerListener, removeFocusListener,);
@@ -4530,22 +3506,12 @@ var fireObserverCallback = (entry) => {
 var fireAllObserverCallbacks = (entries) => {
   entries.forEach(fireObserverCallback,);
 };
-function initIntersectionObserver({
-  root,
-  ...options
-},) {
+function initIntersectionObserver({ root, ...options },) {
   const lookupRoot = root || document;
-  if (!observers.has(lookupRoot,)) {
-    observers.set(lookupRoot, {},);
-  }
+  if (!observers.has(lookupRoot,)) observers.set(lookupRoot, {},);
   const rootObservers = observers.get(lookupRoot,);
   const key7 = JSON.stringify(options,);
-  if (!rootObservers[key7]) {
-    rootObservers[key7] = new IntersectionObserver(fireAllObserverCallbacks, {
-      root,
-      ...options,
-    },);
-  }
+  if (!rootObservers[key7]) rootObservers[key7] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options, },);
   return rootObservers[key7];
 }
 function observeIntersection(element, options, callback,) {
@@ -4557,10 +3523,7 @@ function observeIntersection(element, options, callback,) {
     rootInteresectionObserver.unobserve(element,);
   };
 }
-var thresholdNames = {
-  some: 0,
-  all: 1,
-};
+var thresholdNames = { some: 0, all: 1, };
 var InViewFeature = class extends Feature {
   constructor() {
     super(...arguments,);
@@ -4569,38 +3532,21 @@ var InViewFeature = class extends Feature {
   }
   startObserver() {
     this.unmount();
-    const {
-      viewport = {},
-    } = this.node.getProps();
-    const {
-      root,
-      margin: rootMargin,
-      amount = 'some',
-      once,
-    } = viewport;
+    const { viewport = {}, } = this.node.getProps();
+    const { root, margin: rootMargin, amount = 'some', once, } = viewport;
     const options = {
       root: root ? root.current : void 0,
       rootMargin,
       threshold: typeof amount === 'number' ? amount : thresholdNames[amount],
     };
     const onIntersectionUpdate = (entry) => {
-      const {
-        isIntersecting,
-      } = entry;
+      const { isIntersecting, } = entry;
       if (this.isInView === isIntersecting) return;
       this.isInView = isIntersecting;
-      if (once && !isIntersecting && this.hasEnteredView) {
-        return;
-      } else if (isIntersecting) {
-        this.hasEnteredView = true;
-      }
-      if (this.node.animationState) {
-        this.node.animationState.setActive('whileInView', isIntersecting,);
-      }
-      const {
-        onViewportEnter,
-        onViewportLeave,
-      } = this.node.getProps();
+      if (once && !isIntersecting && this.hasEnteredView) return;
+      else if (isIntersecting) this.hasEnteredView = true;
+      if (this.node.animationState) this.node.animationState.setActive('whileInView', isIntersecting,);
+      const { onViewportEnter, onViewportLeave, } = this.node.getProps();
       const callback = isIntersecting ? onViewportEnter : onViewportLeave;
       callback && callback(entry,);
     };
@@ -4611,44 +3557,23 @@ var InViewFeature = class extends Feature {
   }
   update() {
     if (typeof IntersectionObserver === 'undefined') return;
-    const {
-      props,
-      prevProps,
-    } = this.node;
+    const { props, prevProps, } = this.node;
     const hasOptionsChanged = ['amount', 'margin', 'root',].some(hasViewportOptionChanged(props, prevProps,),);
-    if (hasOptionsChanged) {
-      this.startObserver();
-    }
+    if (hasOptionsChanged) this.startObserver();
   }
   unmount() {}
 };
-function hasViewportOptionChanged({
-  viewport = {},
-}, {
-  viewport: prevViewport = {},
-} = {},) {
+function hasViewportOptionChanged({ viewport = {}, }, { viewport: prevViewport = {}, } = {},) {
   return (name) => viewport[name] !== prevViewport[name];
 }
 var gestureAnimations = {
-  inView: {
-    Feature: InViewFeature,
-  },
-  tap: {
-    Feature: PressGesture,
-  },
-  focus: {
-    Feature: FocusGesture,
-  },
-  hover: {
-    Feature: HoverGesture,
-  },
+  inView: { Feature: InViewFeature, },
+  tap: { Feature: PressGesture, },
+  focus: { Feature: FocusGesture, },
+  hover: { Feature: HoverGesture, },
 };
 var PanSession = class {
-  constructor(event, handlers, {
-    transformPagePoint,
-    contextWindow,
-    dragSnapToOrigin = false,
-  } = {},) {
+  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {},) {
     this.startEvent = null;
     this.lastMoveEvent = null;
     this.lastMoveEventInfo = null;
@@ -4658,25 +3583,12 @@ var PanSession = class {
       if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
       const info2 = getPanInfo(this.lastMoveEventInfo, this.history,);
       const isPanStarted = this.startEvent !== null;
-      const isDistancePastThreshold = distance2D(info2.offset, {
-        x: 0,
-        y: 0,
-      },) >= 3;
+      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0, },) >= 3;
       if (!isPanStarted && !isDistancePastThreshold) return;
-      const {
-        point: point3,
-      } = info2;
-      const {
-        timestamp: timestamp2,
-      } = frameData;
-      this.history.push({
-        ...point3,
-        timestamp: timestamp2,
-      },);
-      const {
-        onStart,
-        onMove,
-      } = this.handlers;
+      const { point: point3, } = info2;
+      const { timestamp: timestamp2, } = frameData;
+      this.history.push({ ...point3, timestamp: timestamp2, },);
+      const { onStart, onMove, } = this.handlers;
       if (!isPanStarted) {
         onStart && onStart(this.lastMoveEvent, info2,);
         this.startEvent = this.lastMoveEvent;
@@ -4690,20 +3602,14 @@ var PanSession = class {
     };
     this.handlePointerUp = (event2, info2,) => {
       this.end();
-      const {
-        onEnd,
-        onSessionEnd,
-        resumeAnimation,
-      } = this.handlers;
+      const { onEnd, onSessionEnd, resumeAnimation, } = this.handlers;
       if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();
       if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
       const panInfo = getPanInfo(
         event2.type === 'pointercancel' ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint,),
         this.history,
       );
-      if (this.startEvent && onEnd) {
-        onEnd(event2, panInfo,);
-      }
+      if (this.startEvent && onEnd) onEnd(event2, panInfo,);
       onSessionEnd && onSessionEnd(event2, panInfo,);
     };
     if (!isPrimaryPointer(event,)) return;
@@ -4713,19 +3619,10 @@ var PanSession = class {
     this.contextWindow = contextWindow || window;
     const info = extractEventInfo(event,);
     const initialInfo = transformPoint(info, this.transformPagePoint,);
-    const {
-      point: point2,
-    } = initialInfo;
-    const {
-      timestamp,
-    } = frameData;
-    this.history = [{
-      ...point2,
-      timestamp,
-    },];
-    const {
-      onSessionStart,
-    } = handlers;
+    const { point: point2, } = initialInfo;
+    const { timestamp, } = frameData;
+    this.history = [{ ...point2, timestamp, },];
+    const { onSessionStart, } = handlers;
     onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history,),);
     this.removeListeners = pipe(
       addPointerEvent(this.contextWindow, 'pointermove', this.handlePointerMove,),
@@ -4742,21 +3639,12 @@ var PanSession = class {
   }
 };
 function transformPoint(info, transformPagePoint,) {
-  return transformPagePoint
-    ? {
-      point: transformPagePoint(info.point,),
-    }
-    : info;
+  return transformPagePoint ? { point: transformPagePoint(info.point,), } : info;
 }
 function subtractPoint(a, b,) {
-  return {
-    x: a.x - b.x,
-    y: a.y - b.y,
-  };
+  return { x: a.x - b.x, y: a.y - b.y, };
 }
-function getPanInfo({
-  point: point2,
-}, history,) {
+function getPanInfo({ point: point2, }, history,) {
   return {
     point: point2,
     delta: subtractPoint(point2, lastDevicePoint(history,),),
@@ -4771,85 +3659,39 @@ function lastDevicePoint(history,) {
   return history[history.length - 1];
 }
 function getVelocity2(history, timeDelta2,) {
-  if (history.length < 2) {
-    return {
-      x: 0,
-      y: 0,
-    };
-  }
+  if (history.length < 2) return { x: 0, y: 0, };
   let i = history.length - 1;
   let timestampedPoint = null;
   const lastPoint = lastDevicePoint(history,);
   while (i >= 0) {
     timestampedPoint = history[i];
-    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta2,)) {
-      break;
-    }
+    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta2,)) break;
     i--;
   }
-  if (!timestampedPoint) {
-    return {
-      x: 0,
-      y: 0,
-    };
-  }
+  if (!timestampedPoint) return { x: 0, y: 0, };
   const time22 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp,);
-  if (time22 === 0) {
-    return {
-      x: 0,
-      y: 0,
-    };
-  }
-  const currentVelocity = {
-    x: (lastPoint.x - timestampedPoint.x) / time22,
-    y: (lastPoint.y - timestampedPoint.y) / time22,
-  };
-  if (currentVelocity.x === Infinity) {
-    currentVelocity.x = 0;
-  }
-  if (currentVelocity.y === Infinity) {
-    currentVelocity.y = 0;
-  }
+  if (time22 === 0) return { x: 0, y: 0, };
+  const currentVelocity = { x: (lastPoint.x - timestampedPoint.x) / time22, y: (lastPoint.y - timestampedPoint.y) / time22, };
+  if (currentVelocity.x === Infinity) currentVelocity.x = 0;
+  if (currentVelocity.y === Infinity) currentVelocity.y = 0;
   return currentVelocity;
 }
-function applyConstraints(point2, {
-  min,
-  max,
-}, elastic,) {
-  if (min !== void 0 && point2 < min) {
-    point2 = elastic ? mixNumber(min, point2, elastic.min,) : Math.max(point2, min,);
-  } else if (max !== void 0 && point2 > max) {
-    point2 = elastic ? mixNumber(max, point2, elastic.max,) : Math.min(point2, max,);
-  }
+function applyConstraints(point2, { min, max, }, elastic,) {
+  if (min !== void 0 && point2 < min) point2 = elastic ? mixNumber(min, point2, elastic.min,) : Math.max(point2, min,);
+  else if (max !== void 0 && point2 > max) point2 = elastic ? mixNumber(max, point2, elastic.max,) : Math.min(point2, max,);
   return point2;
 }
 function calcRelativeAxisConstraints(axis, min, max,) {
-  return {
-    min: min !== void 0 ? axis.min + min : void 0,
-    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0,
-  };
+  return { min: min !== void 0 ? axis.min + min : void 0, max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0, };
 }
-function calcRelativeConstraints(layoutBox, {
-  top,
-  left,
-  bottom,
-  right,
-},) {
-  return {
-    x: calcRelativeAxisConstraints(layoutBox.x, left, right,),
-    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom,),
-  };
+function calcRelativeConstraints(layoutBox, { top, left, bottom, right, },) {
+  return { x: calcRelativeAxisConstraints(layoutBox.x, left, right,), y: calcRelativeAxisConstraints(layoutBox.y, top, bottom,), };
 }
 function calcViewportAxisConstraints(layoutAxis, constraintsAxis,) {
   let min = constraintsAxis.min - layoutAxis.min;
   let max = constraintsAxis.max - layoutAxis.max;
-  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
-    [min, max,] = [max, min,];
-  }
-  return {
-    min,
-    max,
-  };
+  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) [min, max,] = [max, min,];
+  return { min, max, };
 }
 function calcViewportConstraints(layoutBox, constraintsBox,) {
   return {
@@ -4861,40 +3703,24 @@ function calcOrigin2(source, target,) {
   let origin = 0.5;
   const sourceLength = calcLength(source,);
   const targetLength = calcLength(target,);
-  if (targetLength > sourceLength) {
-    origin = progress(target.min, target.max - sourceLength, source.min,);
-  } else if (sourceLength > targetLength) {
-    origin = progress(source.min, source.max - targetLength, target.min,);
-  }
+  if (targetLength > sourceLength) origin = progress(target.min, target.max - sourceLength, source.min,);
+  else if (sourceLength > targetLength) origin = progress(source.min, source.max - targetLength, target.min,);
   return clamp(0, 1, origin,);
 }
 function rebaseAxisConstraints(layout2, constraints,) {
   const relativeConstraints = {};
-  if (constraints.min !== void 0) {
-    relativeConstraints.min = constraints.min - layout2.min;
-  }
-  if (constraints.max !== void 0) {
-    relativeConstraints.max = constraints.max - layout2.min;
-  }
+  if (constraints.min !== void 0) relativeConstraints.min = constraints.min - layout2.min;
+  if (constraints.max !== void 0) relativeConstraints.max = constraints.max - layout2.min;
   return relativeConstraints;
 }
 var defaultElastic = 0.35;
 function resolveDragElastic(dragElastic = defaultElastic,) {
-  if (dragElastic === false) {
-    dragElastic = 0;
-  } else if (dragElastic === true) {
-    dragElastic = defaultElastic;
-  }
-  return {
-    x: resolveAxisElastic(dragElastic, 'left', 'right',),
-    y: resolveAxisElastic(dragElastic, 'top', 'bottom',),
-  };
+  if (dragElastic === false) dragElastic = 0;
+  else if (dragElastic === true) dragElastic = defaultElastic;
+  return { x: resolveAxisElastic(dragElastic, 'left', 'right',), y: resolveAxisElastic(dragElastic, 'top', 'bottom',), };
 }
 function resolveAxisElastic(dragElastic, minLabel, maxLabel,) {
-  return {
-    min: resolvePointElastic(dragElastic, minLabel,),
-    max: resolvePointElastic(dragElastic, maxLabel,),
-  };
+  return { min: resolvePointElastic(dragElastic, minLabel,), max: resolvePointElastic(dragElastic, maxLabel,), };
 }
 function resolvePointElastic(dragElastic, label,) {
   return typeof dragElastic === 'number' ? dragElastic : dragElastic[label] || 0;
@@ -4902,59 +3728,22 @@ function resolvePointElastic(dragElastic, label,) {
 function eachAxis(callback,) {
   return [callback('x',), callback('y',),];
 }
-function convertBoundingBoxToBox({
-  top,
-  left,
-  right,
-  bottom,
-},) {
-  return {
-    x: {
-      min: left,
-      max: right,
-    },
-    y: {
-      min: top,
-      max: bottom,
-    },
-  };
+function convertBoundingBoxToBox({ top, left, right, bottom, },) {
+  return { x: { min: left, max: right, }, y: { min: top, max: bottom, }, };
 }
-function convertBoxToBoundingBox({
-  x,
-  y,
-},) {
-  return {
-    top: y.min,
-    right: x.max,
-    bottom: y.max,
-    left: x.min,
-  };
+function convertBoxToBoundingBox({ x, y, },) {
+  return { top: y.min, right: x.max, bottom: y.max, left: x.min, };
 }
 function transformBoxPoints(point2, transformPoint2,) {
   if (!transformPoint2) return point2;
-  const topLeft = transformPoint2({
-    x: point2.left,
-    y: point2.top,
-  },);
-  const bottomRight = transformPoint2({
-    x: point2.right,
-    y: point2.bottom,
-  },);
-  return {
-    top: topLeft.y,
-    left: topLeft.x,
-    bottom: bottomRight.y,
-    right: bottomRight.x,
-  };
+  const topLeft = transformPoint2({ x: point2.left, y: point2.top, },);
+  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom, },);
+  return { top: topLeft.y, left: topLeft.x, bottom: bottomRight.y, right: bottomRight.x, };
 }
 function isIdentityScale(scale2,) {
   return scale2 === void 0 || scale2 === 1;
 }
-function hasScale({
-  scale: scale2,
-  scaleX,
-  scaleY,
-},) {
+function hasScale({ scale: scale2, scaleX, scaleY, },) {
   return !isIdentityScale(scale2,) || !isIdentityScale(scaleX,) || !isIdentityScale(scaleY,);
 }
 function hasTransform(values,) {
@@ -4973,19 +3762,14 @@ function scalePoint(point2, scale2, originPoint,) {
   return originPoint + scaled;
 }
 function applyPointDelta(point2, translate, scale2, originPoint, boxScale,) {
-  if (boxScale !== void 0) {
-    point2 = scalePoint(point2, boxScale, originPoint,);
-  }
+  if (boxScale !== void 0) point2 = scalePoint(point2, boxScale, originPoint,);
   return scalePoint(point2, scale2, originPoint,) + translate;
 }
 function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale,) {
   axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale,);
   axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale,);
 }
-function applyBoxDelta(box, {
-  x,
-  y,
-},) {
+function applyBoxDelta(box, { x, y, },) {
   applyAxisDelta(box.x, x.translate, x.scale, x.originPoint,);
   applyAxisDelta(box.y, y.translate, y.scale, y.originPoint,);
 }
@@ -4999,23 +3783,16 @@ function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false,)
     node = treePath[i];
     delta = node.projectionDelta;
     const instance = node.instance;
-    if (instance && instance.style && instance.style.display === 'contents') {
-      continue;
-    }
+    if (instance && instance.style && instance.style.display === 'contents') continue;
     if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
-      transformBox(box, {
-        x: -node.scroll.offset.x,
-        y: -node.scroll.offset.y,
-      },);
+      transformBox(box, { x: -node.scroll.offset.x, y: -node.scroll.offset.y, },);
     }
     if (delta) {
       treeScale.x *= delta.x.scale;
       treeScale.y *= delta.y.scale;
       applyBoxDelta(box, delta,);
     }
-    if (isSharedTransition && hasTransform(node.latestValues,)) {
-      transformBox(box, node.latestValues,);
-    }
+    if (isSharedTransition && hasTransform(node.latestValues,)) transformBox(box, node.latestValues,);
   }
   treeScale.x = snapToDefault(treeScale.x,);
   treeScale.y = snapToDefault(treeScale.y,);
@@ -5044,18 +3821,14 @@ function measureViewportBox(instance, transformPoint2,) {
 }
 function measurePageBox(element, rootProjectionNode2, transformPagePoint,) {
   const viewportBox = measureViewportBox(element, transformPagePoint,);
-  const {
-    scroll: scroll2,
-  } = rootProjectionNode2;
+  const { scroll: scroll2, } = rootProjectionNode2;
   if (scroll2) {
     translateAxis(viewportBox.x, scroll2.offset.x,);
     translateAxis(viewportBox.y, scroll2.offset.y,);
   }
   return viewportBox;
 }
-var getContextWindow = ({
-  current,
-},) => {
+var getContextWindow = ({ current, },) => {
   return current ? current.ownerDocument.defaultView : null;
 };
 var elementDragControls = /* @__PURE__ */ new WeakMap();
@@ -5064,37 +3837,22 @@ var VisualElementDragControls = class {
     this.openGlobalLock = null;
     this.isDragging = false;
     this.currentDirection = null;
-    this.originPoint = {
-      x: 0,
-      y: 0,
-    };
+    this.originPoint = { x: 0, y: 0, };
     this.constraints = false;
     this.hasMutatedConstraints = false;
     this.elastic = createBox();
     this.visualElement = visualElement;
   }
-  start(originEvent, {
-    snapToCursor = false,
-  } = {},) {
-    const {
-      presenceContext,
-    } = this.visualElement;
+  start(originEvent, { snapToCursor = false, } = {},) {
+    const { presenceContext, } = this.visualElement;
     if (presenceContext && presenceContext.isPresent === false) return;
     const onSessionStart = (event) => {
-      const {
-        dragSnapToOrigin: dragSnapToOrigin2,
-      } = this.getProps();
+      const { dragSnapToOrigin: dragSnapToOrigin2, } = this.getProps();
       dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
-      if (snapToCursor) {
-        this.snapToCursor(extractEventInfo(event, 'page',).point,);
-      }
+      if (snapToCursor) this.snapToCursor(extractEventInfo(event, 'page',).point,);
     };
     const onStart = (event, info,) => {
-      const {
-        drag: drag2,
-        dragPropagation,
-        onDragStart,
-      } = this.getProps();
+      const { drag: drag2, dragPropagation, onDragStart, } = this.getProps();
       if (drag2 && !dragPropagation) {
         if (this.openGlobalLock) this.openGlobalLock();
         this.openGlobalLock = getGlobalLock(drag2,);
@@ -5110,9 +3868,7 @@ var VisualElementDragControls = class {
       eachAxis((axis) => {
         let current = this.getAxisMotionValue(axis,).get() || 0;
         if (percent.test(current,)) {
-          const {
-            projection,
-          } = this.visualElement;
+          const { projection, } = this.visualElement;
           if (projection && projection.layout) {
             const measuredAxis = projection.layout.layoutBox[axis];
             if (measuredAxis) {
@@ -5123,30 +3879,17 @@ var VisualElementDragControls = class {
         }
         this.originPoint[axis] = current;
       },);
-      if (onDragStart) {
-        frame.update(() => onDragStart(event, info,), false, true,);
-      }
-      const {
-        animationState,
-      } = this.visualElement;
+      if (onDragStart) frame.update(() => onDragStart(event, info,), false, true,);
+      const { animationState, } = this.visualElement;
       animationState && animationState.setActive('whileDrag', true,);
     };
     const onMove = (event, info,) => {
-      const {
-        dragPropagation,
-        dragDirectionLock,
-        onDirectionLock,
-        onDrag,
-      } = this.getProps();
+      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
       if (!dragPropagation && !this.openGlobalLock) return;
-      const {
-        offset,
-      } = info;
+      const { offset, } = info;
       if (dragDirectionLock && this.currentDirection === null) {
         this.currentDirection = getCurrentDirection(offset,);
-        if (this.currentDirection !== null) {
-          onDirectionLock && onDirectionLock(this.currentDirection,);
-        }
+        if (this.currentDirection !== null) onDirectionLock && onDirectionLock(this.currentDirection,);
         return;
       }
       this.updateAxis('x', info.point, offset,);
@@ -5161,16 +3904,8 @@ var VisualElementDragControls = class {
         return this.getAnimationState(axis,) === 'paused' &&
           ((_a = this.getAxisMotionValue(axis,).animation) === null || _a === void 0 ? void 0 : _a.play());
       },);
-    const {
-      dragSnapToOrigin,
-    } = this.getProps();
-    this.panSession = new PanSession(originEvent, {
-      onSessionStart,
-      onStart,
-      onMove,
-      onSessionEnd,
-      resumeAnimation,
-    }, {
+    const { dragSnapToOrigin, } = this.getProps();
+    this.panSession = new PanSession(originEvent, { onSessionStart, onStart, onMove, onSessionEnd, resumeAnimation, }, {
       transformPagePoint: this.visualElement.getTransformPagePoint(),
       dragSnapToOrigin,
       contextWindow: getContextWindow(this.visualElement,),
@@ -5180,31 +3915,18 @@ var VisualElementDragControls = class {
     const isDragging = this.isDragging;
     this.cancel();
     if (!isDragging) return;
-    const {
-      velocity,
-    } = info;
+    const { velocity, } = info;
     this.startAnimation(velocity,);
-    const {
-      onDragEnd,
-    } = this.getProps();
-    if (onDragEnd) {
-      frame.update(() => onDragEnd(event, info,));
-    }
+    const { onDragEnd, } = this.getProps();
+    if (onDragEnd) frame.update(() => onDragEnd(event, info,));
   }
   cancel() {
     this.isDragging = false;
-    const {
-      projection,
-      animationState,
-    } = this.visualElement;
-    if (projection) {
-      projection.isAnimationBlocked = false;
-    }
+    const { projection, animationState, } = this.visualElement;
+    if (projection) projection.isAnimationBlocked = false;
     this.panSession && this.panSession.end();
     this.panSession = void 0;
-    const {
-      dragPropagation,
-    } = this.getProps();
+    const { dragPropagation, } = this.getProps();
     if (!dragPropagation && this.openGlobalLock) {
       this.openGlobalLock();
       this.openGlobalLock = null;
@@ -5212,40 +3934,25 @@ var VisualElementDragControls = class {
     animationState && animationState.setActive('whileDrag', false,);
   }
   updateAxis(axis, _point, offset,) {
-    const {
-      drag: drag2,
-    } = this.getProps();
+    const { drag: drag2, } = this.getProps();
     if (!offset || !shouldDrag(axis, drag2, this.currentDirection,)) return;
     const axisValue = this.getAxisMotionValue(axis,);
     let next = this.originPoint[axis] + offset[axis];
-    if (this.constraints && this.constraints[axis]) {
-      next = applyConstraints(next, this.constraints[axis], this.elastic[axis],);
-    }
+    if (this.constraints && this.constraints[axis]) next = applyConstraints(next, this.constraints[axis], this.elastic[axis],);
     axisValue.set(next,);
   }
   resolveConstraints() {
     var _a;
-    const {
-      dragConstraints,
-      dragElastic,
-    } = this.getProps();
+    const { dragConstraints, dragElastic, } = this.getProps();
     const layout2 = this.visualElement.projection && !this.visualElement.projection.layout
       ? this.visualElement.projection.measure(false,)
       : (_a = this.visualElement.projection) === null || _a === void 0
       ? void 0
       : _a.layout;
     const prevConstraints = this.constraints;
-    if (dragConstraints && isRefObject(dragConstraints,)) {
-      if (!this.constraints) {
-        this.constraints = this.resolveRefConstraints();
-      }
-    } else {
-      if (dragConstraints && layout2) {
-        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints,);
-      } else {
-        this.constraints = false;
-      }
-    }
+    if (dragConstraints && isRefObject(dragConstraints,)) if (!this.constraints) this.constraints = this.resolveRefConstraints();
+    else {if (dragConstraints && layout2) this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints,);
+      else this.constraints = false;}
     this.elastic = resolveDragElastic(dragElastic,);
     if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
       eachAxis((axis) => {
@@ -5256,52 +3963,31 @@ var VisualElementDragControls = class {
     }
   }
   resolveRefConstraints() {
-    const {
-      dragConstraints: constraints,
-      onMeasureDragConstraints,
-    } = this.getProps();
+    const { dragConstraints: constraints, onMeasureDragConstraints, } = this.getProps();
     if (!constraints || !isRefObject(constraints,)) return false;
     const constraintsElement = constraints.current;
     invariant(
       constraintsElement !== null,
       'If `dragConstraints` is set as a React ref, that ref must be passed to another component\'s `ref` prop.',
     );
-    const {
-      projection,
-    } = this.visualElement;
+    const { projection, } = this.visualElement;
     if (!projection || !projection.layout) return false;
     const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint(),);
     let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox,);
     if (onMeasureDragConstraints) {
       const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints,),);
       this.hasMutatedConstraints = !!userConstraints;
-      if (userConstraints) {
-        measuredConstraints = convertBoundingBoxToBox(userConstraints,);
-      }
+      if (userConstraints) measuredConstraints = convertBoundingBoxToBox(userConstraints,);
     }
     return measuredConstraints;
   }
   startAnimation(velocity,) {
-    const {
-      drag: drag2,
-      dragMomentum,
-      dragElastic,
-      dragTransition,
-      dragSnapToOrigin,
-      onDragTransitionEnd,
-    } = this.getProps();
+    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();
     const constraints = this.constraints || {};
     const momentumAnimations = eachAxis((axis) => {
-      if (!shouldDrag(axis, drag2, this.currentDirection,)) {
-        return;
-      }
+      if (!shouldDrag(axis, drag2, this.currentDirection,)) return;
       let transition = constraints && constraints[axis] || {};
-      if (dragSnapToOrigin) {
-        transition = {
-          min: 0,
-          max: 0,
-        };
-      }
+      if (dragSnapToOrigin) transition = { min: 0, max: 0, };
       const bounceStiffness = dragElastic ? 200 : 1e6;
       const bounceDamping = dragElastic ? 40 : 1e7;
       const inertia2 = {
@@ -5335,13 +4021,13 @@ var VisualElementDragControls = class {
   getAnimationState(axis,) {
     var _a;
     return (_a = this.getAxisMotionValue(axis,).animation) === null || _a === void 0 ? void 0 : _a.state;
-  }
-  /**
+  } /**
    * Drag works differently depending on which props are provided.
    *
    * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
    * - Otherwise, we apply the delta to the x/y motion values.
    */
+
   getAxisMotionValue(axis,) {
     const dragKey = '_drag' + axis.toUpperCase();
     const props = this.visualElement.getProps();
@@ -5352,56 +4038,36 @@ var VisualElementDragControls = class {
   }
   snapToCursor(point2,) {
     eachAxis((axis) => {
-      const {
-        drag: drag2,
-      } = this.getProps();
+      const { drag: drag2, } = this.getProps();
       if (!shouldDrag(axis, drag2, this.currentDirection,)) return;
-      const {
-        projection,
-      } = this.visualElement;
+      const { projection, } = this.visualElement;
       const axisValue = this.getAxisMotionValue(axis,);
       if (projection && projection.layout) {
-        const {
-          min,
-          max,
-        } = projection.layout.layoutBox[axis];
+        const { min, max, } = projection.layout.layoutBox[axis];
         axisValue.set(point2[axis] - mixNumber(min, max, 0.5,),);
       }
     },);
-  }
-  /**
+  } /**
    * When the viewport resizes we want to check if the measured constraints
    * have changed and, if so, reposition the element within those new constraints
    * relative to where it was before the resize.
    */
+
   scalePositionWithinConstraints() {
     if (!this.visualElement.current) return;
-    const {
-      drag: drag2,
-      dragConstraints,
-    } = this.getProps();
-    const {
-      projection,
-    } = this.visualElement;
+    const { drag: drag2, dragConstraints, } = this.getProps();
+    const { projection, } = this.visualElement;
     if (!isRefObject(dragConstraints,) || !projection || !this.constraints) return;
     this.stopAnimation();
-    const boxProgress = {
-      x: 0,
-      y: 0,
-    };
+    const boxProgress = { x: 0, y: 0, };
     eachAxis((axis) => {
       const axisValue = this.getAxisMotionValue(axis,);
       if (axisValue) {
         const latest = axisValue.get();
-        boxProgress[axis] = calcOrigin2({
-          min: latest,
-          max: latest,
-        }, this.constraints[axis],);
+        boxProgress[axis] = calcOrigin2({ min: latest, max: latest, }, this.constraints[axis],);
       }
     },);
-    const {
-      transformTemplate: transformTemplate2,
-    } = this.visualElement.getProps();
+    const { transformTemplate: transformTemplate2, } = this.visualElement.getProps();
     this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, '',) : 'none';
     projection.root && projection.root.updateScroll();
     projection.updateLayout();
@@ -5409,10 +4075,7 @@ var VisualElementDragControls = class {
     eachAxis((axis) => {
       if (!shouldDrag(axis, drag2, null,)) return;
       const axisValue = this.getAxisMotionValue(axis,);
-      const {
-        min,
-        max,
-      } = this.constraints[axis];
+      const { min, max, } = this.constraints[axis];
       axisValue.set(mixNumber(min, max, boxProgress[axis],),);
     },);
   }
@@ -5421,23 +4084,14 @@ var VisualElementDragControls = class {
     elementDragControls.set(this.visualElement, this,);
     const element = this.visualElement.current;
     const stopPointerListener = addPointerEvent(element, 'pointerdown', (event) => {
-      const {
-        drag: drag2,
-        dragListener = true,
-      } = this.getProps();
+      const { drag: drag2, dragListener = true, } = this.getProps();
       drag2 && dragListener && this.start(event,);
     },);
     const measureDragConstraints = () => {
-      const {
-        dragConstraints,
-      } = this.getProps();
-      if (isRefObject(dragConstraints,)) {
-        this.constraints = this.resolveRefConstraints();
-      }
+      const { dragConstraints, } = this.getProps();
+      if (isRefObject(dragConstraints,)) this.constraints = this.resolveRefConstraints();
     };
-    const {
-      projection,
-    } = this.visualElement;
+    const { projection, } = this.visualElement;
     const stopMeasureLayoutListener = projection.addEventListener('measure', measureDragConstraints,);
     if (projection && !projection.layout) {
       projection.root && projection.root.updateScroll();
@@ -5445,10 +4099,7 @@ var VisualElementDragControls = class {
     }
     measureDragConstraints();
     const stopResizeListener = addDomEvent(window, 'resize', () => this.scalePositionWithinConstraints(),);
-    const stopLayoutUpdateListener = projection.addEventListener('didUpdate', ({
-      delta,
-      hasLayoutChanged,
-    },) => {
+    const stopLayoutUpdateListener = projection.addEventListener('didUpdate', ({ delta, hasLayoutChanged, },) => {
       if (this.isDragging && hasLayoutChanged) {
         eachAxis((axis) => {
           const motionValue2 = this.getAxisMotionValue(axis,);
@@ -5476,15 +4127,7 @@ var VisualElementDragControls = class {
       dragElastic = defaultElastic,
       dragMomentum = true,
     } = props;
-    return {
-      ...props,
-      drag: drag2,
-      dragDirectionLock,
-      dragPropagation,
-      dragConstraints,
-      dragElastic,
-      dragMomentum,
-    };
+    return { ...props, drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum, };
   }
 };
 function shouldDrag(direction, drag2, currentDirection,) {
@@ -5492,11 +4135,8 @@ function shouldDrag(direction, drag2, currentDirection,) {
 }
 function getCurrentDirection(offset, lockThreshold = 10,) {
   let direction = null;
-  if (Math.abs(offset.y,) > lockThreshold) {
-    direction = 'y';
-  } else if (Math.abs(offset.x,) > lockThreshold) {
-    direction = 'x';
-  }
+  if (Math.abs(offset.y,) > lockThreshold) direction = 'y';
+  else if (Math.abs(offset.x,) > lockThreshold) direction = 'x';
   return direction;
 }
 var DragGesture = class extends Feature {
@@ -5507,12 +4147,8 @@ var DragGesture = class extends Feature {
     this.controls = new VisualElementDragControls(node,);
   }
   mount() {
-    const {
-      dragControls,
-    } = this.node.getProps();
-    if (dragControls) {
-      this.removeGroupControls = dragControls.subscribe(this.controls,);
-    }
+    const { dragControls, } = this.node.getProps();
+    if (dragControls) this.removeGroupControls = dragControls.subscribe(this.controls,);
     this.removeListeners = this.controls.addListeners() || noop;
   }
   unmount() {
@@ -5521,9 +4157,7 @@ var DragGesture = class extends Feature {
   }
 };
 var asyncHandler = (handler) => (event, info,) => {
-  if (handler) {
-    frame.update(() => handler(event, info,));
-  }
+  if (handler) frame.update(() => handler(event, info,));
 };
 var PanGesture = class extends Feature {
   constructor() {
@@ -5537,21 +4171,14 @@ var PanGesture = class extends Feature {
     },);
   }
   createPanHandlers() {
-    const {
-      onPanSessionStart,
-      onPanStart,
-      onPan,
-      onPanEnd,
-    } = this.node.getProps();
+    const { onPanSessionStart, onPanStart, onPan, onPanEnd, } = this.node.getProps();
     return {
       onSessionStart: asyncHandler(onPanSessionStart,),
       onStart: asyncHandler(onPanStart,),
       onMove: onPan,
       onEnd: (event, info,) => {
         delete this.session;
-        if (onPanEnd) {
-          frame.update(() => onPanEnd(event, info,));
-        }
+        if (onPanEnd) frame.update(() => onPanEnd(event, info,));
       },
     };
   }
@@ -5570,9 +4197,7 @@ var globalProjectionState = {
   /**
    * Global flag as to whether the tree has animated since the last time
    * we resized the window
-   */
-  hasAnimatedSinceResize: true,
-  /**
+   */ hasAnimatedSinceResize: true, /**
    * We set this to true once, on the first update. Any nodes added to the tree beyond that
    * update will be given a `data-projection-id` attribute.
    */
@@ -5586,11 +4211,8 @@ var correctBorderRadius = {
   correct: (latest, node,) => {
     if (!node.target) return latest;
     if (typeof latest === 'string') {
-      if (px.test(latest,)) {
-        latest = parseFloat(latest,);
-      } else {
-        return latest;
-      }
+      if (px.test(latest,)) latest = parseFloat(latest,);
+      else return latest;
     }
     const x = pixelsToPercent(latest, node.target.x,);
     const y = pixelsToPercent(latest, node.target.y,);
@@ -5598,10 +4220,7 @@ var correctBorderRadius = {
   },
 };
 var correctBoxShadow = {
-  correct: (latest, {
-    treeScale,
-    projectionDelta,
-  },) => {
+  correct: (latest, { treeScale, projectionDelta, },) => {
     const original = latest;
     const shadow = complex.parse(latest,);
     if (shadow.length > 5) return original;
@@ -5622,85 +4241,51 @@ var MeasureLayoutWithContext = class extends React__default.Component {
    * This only mounts projection nodes for components that
    * need measuring, we might want to do it for all components
    * in order to incorporate transforms
-   */
-  componentDidMount() {
-    const {
-      visualElement,
-      layoutGroup,
-      switchLayoutGroup,
-      layoutId,
-    } = this.props;
-    const {
-      projection,
-    } = visualElement;
+   */ componentDidMount() {
+    const { visualElement, layoutGroup, switchLayoutGroup, layoutId, } = this.props;
+    const { projection, } = visualElement;
     addScaleCorrector(defaultScaleCorrectors,);
     if (projection) {
       if (layoutGroup.group) layoutGroup.group.add(projection,);
-      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
-        switchLayoutGroup.register(projection,);
-      }
+      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) switchLayoutGroup.register(projection,);
       projection.root.didUpdate();
       projection.addEventListener('animationComplete', () => {
         this.safeToRemove();
       },);
-      projection.setOptions({
-        ...projection.options,
-        onExitComplete: () => this.safeToRemove(),
-      },);
+      projection.setOptions({ ...projection.options, onExitComplete: () => this.safeToRemove(), },);
     }
     globalProjectionState.hasEverUpdated = true;
   }
   getSnapshotBeforeUpdate(prevProps,) {
-    const {
-      layoutDependency,
-      visualElement,
-      drag: drag2,
-      isPresent: isPresent2,
-    } = this.props;
+    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2, } = this.props;
     const projection = visualElement.projection;
     if (!projection) return null;
     projection.isPresent = isPresent2;
-    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
-      projection.willUpdate();
-    } else {
-      this.safeToRemove();
-    }
+    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) projection.willUpdate();
+    else this.safeToRemove();
     if (prevProps.isPresent !== isPresent2) {
-      if (isPresent2) {
-        projection.promote();
-      } else if (!projection.relegate()) {
+      if (isPresent2) projection.promote();
+      else if (!projection.relegate()) {
         frame.postRender(() => {
           const stack = projection.getStack();
-          if (!stack || !stack.members.length) {
-            this.safeToRemove();
-          }
+          if (!stack || !stack.members.length) this.safeToRemove();
         },);
       }
     }
     return null;
   }
   componentDidUpdate() {
-    const {
-      projection,
-    } = this.props.visualElement;
+    const { projection, } = this.props.visualElement;
     if (projection) {
       projection.root.didUpdate();
       microtask.postRender(() => {
-        if (!projection.currentAnimation && projection.isLead()) {
-          this.safeToRemove();
-        }
+        if (!projection.currentAnimation && projection.isLead()) this.safeToRemove();
       },);
     }
   }
   componentWillUnmount() {
-    const {
-      visualElement,
-      layoutGroup,
-      switchLayoutGroup: promoteContext,
-    } = this.props;
-    const {
-      projection,
-    } = visualElement;
+    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;
+    const { projection, } = visualElement;
     if (projection) {
       projection.scheduleCheckAfterUnmount();
       if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection,);
@@ -5708,9 +4293,7 @@ var MeasureLayoutWithContext = class extends React__default.Component {
     }
   }
   safeToRemove() {
-    const {
-      safeToRemove,
-    } = this.props;
+    const { safeToRemove, } = this.props;
     safeToRemove && safeToRemove();
   }
   render() {
@@ -5746,9 +4329,10 @@ var isPx = (value) => typeof value === 'number' || px.test(value,);
 function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember,) {
   if (shouldCrossfadeOpacity) {
     target.opacity = mixNumber(
-      0,
-      // TODO Reinstate this if only child
-      lead.opacity !== void 0 ? lead.opacity : 1,
+      0, // TODO Reinstate this if only child
+      lead.opacity !== void 0
+        ? lead.opacity
+        : 1,
       easeCrossfadeIn(progress2,),
     );
     target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2,),);
@@ -5765,16 +4349,10 @@ function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOn
     const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius,) === isPx(leadRadius,);
     if (canMix) {
       target[borderLabel] = Math.max(mixNumber(asNumber(followRadius,), asNumber(leadRadius,), progress2,), 0,);
-      if (percent.test(leadRadius,) || percent.test(followRadius,)) {
-        target[borderLabel] += '%';
-      }
-    } else {
-      target[borderLabel] = leadRadius;
-    }
-  }
-  if (follow.rotate || lead.rotate) {
-    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2,);
+      if (percent.test(leadRadius,) || percent.test(followRadius,)) target[borderLabel] += '%';
+    } else target[borderLabel] = leadRadius;
   }
+  if (follow.rotate || lead.rotate) target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2,);
 }
 function getRadius(values, radiusName,) {
   return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
@@ -5799,9 +4377,7 @@ function copyBoxInto(box, originBox,) {
 function removePointDelta(point2, translate, scale2, originPoint, boxScale,) {
   point2 -= translate;
   point2 = scalePoint(point2, 1 / scale2, originPoint,);
-  if (boxScale !== void 0) {
-    point2 = scalePoint(point2, 1 / boxScale, originPoint,);
-  }
+  if (boxScale !== void 0) point2 = scalePoint(point2, 1 / boxScale, originPoint,);
   return point2;
 }
 function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis,) {
@@ -5851,14 +4427,10 @@ var NodeStack = class {
   }
   remove(node,) {
     removeItem(this.members, node,);
-    if (node === this.prevLead) {
-      this.prevLead = void 0;
-    }
+    if (node === this.prevLead) this.prevLead = void 0;
     if (node === this.lead) {
       const prevLead = this.members[this.members.length - 1];
-      if (prevLead) {
-        this.promote(prevLead,);
-      }
+      if (prevLead) this.promote(prevLead,);
     }
   }
   relegate(node,) {
@@ -5875,9 +4447,7 @@ var NodeStack = class {
     if (prevLead) {
       this.promote(prevLead,);
       return true;
-    } else {
-      return false;
-    }
+    } else return false;
   }
   promote(node, preserveFollowOpacity,) {
     const prevLead = this.lead;
@@ -5889,49 +4459,34 @@ var NodeStack = class {
       prevLead.instance && prevLead.scheduleRender();
       node.scheduleRender();
       node.resumeFrom = prevLead;
-      if (preserveFollowOpacity) {
-        node.resumeFrom.preserveOpacity = true;
-      }
+      if (preserveFollowOpacity) node.resumeFrom.preserveOpacity = true;
       if (prevLead.snapshot) {
         node.snapshot = prevLead.snapshot;
         node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
       }
-      if (node.root && node.root.isUpdating) {
-        node.isLayoutDirty = true;
-      }
-      const {
-        crossfade,
-      } = node.options;
-      if (crossfade === false) {
-        prevLead.hide();
-      }
+      if (node.root && node.root.isUpdating) node.isLayoutDirty = true;
+      const { crossfade, } = node.options;
+      if (crossfade === false) prevLead.hide();
     }
   }
   exitAnimationComplete() {
     this.members.forEach((node) => {
-      const {
-        options,
-        resumingFrom,
-      } = node;
+      const { options, resumingFrom, } = node;
       options.onExitComplete && options.onExitComplete();
-      if (resumingFrom) {
-        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
-      }
+      if (resumingFrom) resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
     },);
   }
   scheduleRender() {
     this.members.forEach((node) => {
       node.instance && node.scheduleRender(false,);
     },);
-  }
-  /**
+  } /**
    * Clear any leads that have been removed this render to prevent them from being
    * used in future animations and to prevent memory leaks
    */
+
   removeLeadSnapshot() {
-    if (this.lead && this.lead.snapshot) {
-      this.lead.snapshot = void 0;
-    }
+    if (this.lead && this.lead.snapshot) this.lead.snapshot = void 0;
   }
 };
 function buildProjectionTransform(delta, treeScale, latestTransform,) {
@@ -5939,21 +4494,10 @@ function buildProjectionTransform(delta, treeScale, latestTransform,) {
   const xTranslate = delta.x.translate / treeScale.x;
   const yTranslate = delta.y.translate / treeScale.y;
   const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
-  if (xTranslate || yTranslate || zTranslate) {
-    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
-  }
-  if (treeScale.x !== 1 || treeScale.y !== 1) {
-    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
-  }
+  if (xTranslate || yTranslate || zTranslate) transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
+  if (treeScale.x !== 1 || treeScale.y !== 1) transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
   if (latestTransform) {
-    const {
-      transformPerspective,
-      rotate,
-      rotateX,
-      rotateY,
-      skewX,
-      skewY,
-    } = latestTransform;
+    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY, } = latestTransform;
     if (transformPerspective) transform2 = `perspective(${transformPerspective}px) ${transform2}`;
     if (rotate) transform2 += `rotate(${rotate}deg) `;
     if (rotateX) transform2 += `rotateX(${rotateX}deg) `;
@@ -5963,15 +4507,11 @@ function buildProjectionTransform(delta, treeScale, latestTransform,) {
   }
   const elementScaleX = delta.x.scale * treeScale.x;
   const elementScaleY = delta.y.scale * treeScale.y;
-  if (elementScaleX !== 1 || elementScaleY !== 1) {
-    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
-  }
+  if (elementScaleX !== 1 || elementScaleY !== 1) transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
   return transform2 || 'none';
 }
 function record(data2,) {
-  if (window.MotionDebug) {
-    window.MotionDebug.record(data2,);
-  }
+  if (window.MotionDebug) window.MotionDebug.record(data2,);
 }
 function isSVGElement(element,) {
   return element instanceof SVGElement && element.tagName !== 'svg';
@@ -5982,13 +4522,9 @@ function animateSingleValue(value, keyframes2, options,) {
   return motionValue$1.animation;
 }
 var transformAxes = ['', 'X', 'Y', 'Z',];
-var hiddenVisibility = {
-  visibility: 'hidden',
-};
+var hiddenVisibility = { visibility: 'hidden', };
 function resetDistortingTransform(key7, visualElement, values,) {
-  const {
-    latestValues,
-  } = visualElement;
+  const { latestValues, } = visualElement;
   if (latestValues[key7]) {
     values[key7] = latestValues[key7];
     visualElement.setStaticValue(key7, 0,);
@@ -5996,19 +4532,8 @@ function resetDistortingTransform(key7, visualElement, values,) {
 }
 var animationTarget = 1e3;
 var id2 = 0;
-var projectionFrameData = {
-  type: 'projectionFrame',
-  totalNodes: 0,
-  resolvedTargetDeltas: 0,
-  recalculatedProjection: 0,
-};
-function createProjectionNode({
-  attachResizeListener,
-  defaultParent,
-  measureScroll,
-  checkIsScrollRoot,
-  resetTransform,
-},) {
+var projectionFrameData = { type: 'projectionFrame', totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0, };
+function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, },) {
   return class ProjectionNode {
     constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent(),) {
       this.id = id2++;
@@ -6027,10 +4552,7 @@ function createProjectionNode({
       this.isSVG = false;
       this.needsReset = false;
       this.shouldResetTransform = false;
-      this.treeScale = {
-        x: 1,
-        y: 1,
-      };
+      this.treeScale = { x: 1, y: 1, };
       this.eventHandlers = /* @__PURE__ */ new Map();
       this.hasTreeAnimated = false;
       this.updateScheduled = false;
@@ -6059,15 +4581,11 @@ function createProjectionNode({
       this.path = parent ? [...parent.path, parent,] : [];
       this.parent = parent;
       this.depth = parent ? parent.depth + 1 : 0;
-      for (let i = 0; i < this.path.length; i++) {
-        this.path[i].shouldResetTransform = true;
-      }
+      for (let i = 0; i < this.path.length; i++) this.path[i].shouldResetTransform = true;
       if (this.root === this) this.nodes = new FlatTree();
     }
     addEventListener(name, handler,) {
-      if (!this.eventHandlers.has(name,)) {
-        this.eventHandlers.set(name, new SubscriptionManager(),);
-      }
+      if (!this.eventHandlers.has(name,)) this.eventHandlers.set(name, new SubscriptionManager(),);
       return this.eventHandlers.get(name,).add(handler,);
     }
     notifyListeners(name, ...args) {
@@ -6076,27 +4594,19 @@ function createProjectionNode({
     }
     hasListeners(name,) {
       return this.eventHandlers.has(name,);
-    }
-    /**
+    } /**
      * Lifecycles
      */
+
     mount(instance, isLayoutDirty = this.root.hasTreeAnimated,) {
       if (this.instance) return;
       this.isSVG = isSVGElement(instance,);
       this.instance = instance;
-      const {
-        layoutId,
-        layout: layout2,
-        visualElement,
-      } = this.options;
-      if (visualElement && !visualElement.current) {
-        visualElement.mount(instance,);
-      }
+      const { layoutId, layout: layout2, visualElement, } = this.options;
+      if (visualElement && !visualElement.current) visualElement.mount(instance,);
       this.root.nodes.add(this,);
       this.parent && this.parent.children.add(this,);
-      if (isLayoutDirty && (layout2 || layoutId)) {
-        this.isLayoutDirty = true;
-      }
+      if (isLayoutDirty && (layout2 || layoutId)) this.isLayoutDirty = true;
       if (attachResizeListener) {
         let cancelDelay;
         const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
@@ -6110,26 +4620,16 @@ function createProjectionNode({
           }
         },);
       }
-      if (layoutId) {
-        this.root.registerSharedNode(layoutId, this,);
-      }
+      if (layoutId) this.root.registerSharedNode(layoutId, this,);
       if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
-        this.addEventListener('didUpdate', ({
-          delta,
-          hasLayoutChanged,
-          hasRelativeTargetChanged,
-          layout: newLayout,
-        },) => {
+        this.addEventListener('didUpdate', ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, },) => {
           if (this.isTreeAnimationBlocked()) {
             this.target = void 0;
             this.relativeTarget = void 0;
             return;
           }
           const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
-          const {
-            onLayoutAnimationStart,
-            onLayoutAnimationComplete,
-          } = visualElement.getProps();
+          const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();
           const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout,) || hasRelativeTargetChanged;
           const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
           if (
@@ -6155,9 +4655,7 @@ function createProjectionNode({
             if (!hasLayoutChanged) {
               finishAnimation(this,);
             }
-            if (this.isLead() && this.options.onExitComplete) {
-              this.options.onExitComplete();
-            }
+            if (this.isLead() && this.options.onExitComplete) this.options.onExitComplete();
           }
           this.targetLayout = newLayout;
         },);
@@ -6171,8 +4669,7 @@ function createProjectionNode({
       this.parent && this.parent.children.delete(this,);
       this.instance = void 0;
       cancelFrame(this.updateProjection,);
-    }
-    // only on the root
+    } // only on the root
     blockUpdate() {
       this.updateManuallyBlocked = true;
     }
@@ -6184,8 +4681,7 @@ function createProjectionNode({
     }
     isTreeAnimationBlocked() {
       return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
-    }
-    // Note: currently only running on root node
+    } // Note: currently only running on root node
     startUpdate() {
       if (this.isUpdateBlocked()) return;
       this.isUpdating = true;
@@ -6193,9 +4689,7 @@ function createProjectionNode({
       this.animationId++;
     }
     getTransformTemplate() {
-      const {
-        visualElement,
-      } = this.options;
+      const { visualElement, } = this.options;
       return visualElement && visualElement.getProps().transformTemplate;
     }
     willUpdate(shouldNotifyListeners = true,) {
@@ -6211,14 +4705,9 @@ function createProjectionNode({
         const node = this.path[i];
         node.shouldResetTransform = true;
         node.updateScroll('snapshot',);
-        if (node.options.layoutRoot) {
-          node.willUpdate(false,);
-        }
+        if (node.options.layoutRoot) node.willUpdate(false,);
       }
-      const {
-        layoutId,
-        layout: layout2,
-      } = this.options;
+      const { layoutId, layout: layout2, } = this.options;
       if (layoutId === void 0 && !layout2) return;
       const transformTemplate2 = this.getTransformTemplate();
       this.prevTransformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, '',) : void 0;
@@ -6234,13 +4723,9 @@ function createProjectionNode({
         this.nodes.forEach(clearMeasurements,);
         return;
       }
-      if (!this.isUpdating) {
-        this.nodes.forEach(clearIsLayoutDirty,);
-      }
+      if (!this.isUpdating) this.nodes.forEach(clearIsLayoutDirty,);
       this.isUpdating = false;
-      if (window.HandoffCancelAllAnimations) {
-        window.HandoffCancelAllAnimations();
-      }
+      if (window.HandoffCancelAllAnimations) window.HandoffCancelAllAnimations();
       this.nodes.forEach(resetTransformStyle,);
       this.nodes.forEach(updateLayout,);
       this.nodes.forEach(notifyLayoutUpdate,);
@@ -6272,16 +4757,13 @@ function createProjectionNode({
     }
     scheduleCheckAfterUnmount() {
       frame.postRender(() => {
-        if (this.isLayoutDirty) {
-          this.root.didUpdate();
-        } else {
-          this.root.checkUpdateFailed();
-        }
+        if (this.isLayoutDirty) this.root.didUpdate();
+        else this.root.checkUpdateFailed();
       },);
-    }
-    /**
+    } /**
      * Update measurements
      */
+
     updateSnapshot() {
       if (this.snapshot || !this.instance) return;
       this.snapshot = this.measure();
@@ -6289,9 +4771,7 @@ function createProjectionNode({
     updateLayout() {
       if (!this.instance) return;
       this.updateScroll();
-      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
-        return;
-      }
+      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) return;
       if (this.resumeFrom && !this.resumeFrom.instance) {
         for (let i = 0; i < this.path.length; i++) {
           const node = this.path[i];
@@ -6304,16 +4784,12 @@ function createProjectionNode({
       this.isLayoutDirty = false;
       this.projectionDelta = void 0;
       this.notifyListeners('measure', this.layout.layoutBox,);
-      const {
-        visualElement,
-      } = this.options;
+      const { visualElement, } = this.options;
       visualElement && visualElement.notify('LayoutMeasure', this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0,);
     }
     updateScroll(phase = 'measure',) {
       let needsMeasurement = Boolean(this.options.layoutScroll && this.instance,);
-      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
-        needsMeasurement = false;
-      }
+      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) needsMeasurement = false;
       if (needsMeasurement) {
         this.scroll = {
           animationId: this.root.animationId,
@@ -6339,27 +4815,15 @@ function createProjectionNode({
     measure(removeTransform = true,) {
       const pageBox = this.measurePageBox();
       let layoutBox = this.removeElementScroll(pageBox,);
-      if (removeTransform) {
-        layoutBox = this.removeTransform(layoutBox,);
-      }
+      if (removeTransform) layoutBox = this.removeTransform(layoutBox,);
       roundBox(layoutBox,);
-      return {
-        animationId: this.root.animationId,
-        measuredBox: pageBox,
-        layoutBox,
-        latestValues: {},
-        source: this.id,
-      };
+      return { animationId: this.root.animationId, measuredBox: pageBox, layoutBox, latestValues: {}, source: this.id, };
     }
     measurePageBox() {
-      const {
-        visualElement,
-      } = this.options;
+      const { visualElement, } = this.options;
       if (!visualElement) return createBox();
       const box = visualElement.measureViewportBox();
-      const {
-        scroll: scroll2,
-      } = this.root;
+      const { scroll: scroll2, } = this.root;
       if (scroll2) {
         translateAxis(box.x, scroll2.offset.x,);
         translateAxis(box.y, scroll2.offset.y,);
@@ -6371,16 +4835,11 @@ function createProjectionNode({
       copyBoxInto(boxWithoutScroll, box,);
       for (let i = 0; i < this.path.length; i++) {
         const node = this.path[i];
-        const {
-          scroll: scroll2,
-          options,
-        } = node;
+        const { scroll: scroll2, options, } = node;
         if (node !== this.root && scroll2 && options.layoutScroll) {
           if (scroll2.isRoot) {
             copyBoxInto(boxWithoutScroll, box,);
-            const {
-              scroll: rootScroll,
-            } = this.root;
+            const { scroll: rootScroll, } = this.root;
             if (rootScroll) {
               translateAxis(boxWithoutScroll.x, -rootScroll.offset.x,);
               translateAxis(boxWithoutScroll.y, -rootScroll.offset.y,);
@@ -6398,17 +4857,12 @@ function createProjectionNode({
       for (let i = 0; i < this.path.length; i++) {
         const node = this.path[i];
         if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
-          transformBox(withTransforms, {
-            x: -node.scroll.offset.x,
-            y: -node.scroll.offset.y,
-          },);
+          transformBox(withTransforms, { x: -node.scroll.offset.x, y: -node.scroll.offset.y, },);
         }
         if (!hasTransform(node.latestValues,)) continue;
         transformBox(withTransforms, node.latestValues,);
       }
-      if (hasTransform(this.latestValues,)) {
-        transformBox(withTransforms, this.latestValues,);
-      }
+      if (hasTransform(this.latestValues,)) transformBox(withTransforms, this.latestValues,);
       return withTransforms;
     }
     removeTransform(box,) {
@@ -6424,9 +4878,7 @@ function createProjectionNode({
         copyBoxInto(sourceBox, nodeBox,);
         removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox,);
       }
-      if (hasTransform(this.latestValues,)) {
-        removeBoxTransforms(boxWithoutTransform, this.latestValues,);
-      }
+      if (hasTransform(this.latestValues,)) removeBoxTransforms(boxWithoutTransform, this.latestValues,);
       return boxWithoutTransform;
     }
     setTargetDelta(delta,) {
@@ -6435,11 +4887,7 @@ function createProjectionNode({
       this.isProjectionDirty = true;
     }
     setOptions(options,) {
-      this.options = {
-        ...this.options,
-        ...options,
-        crossfade: options.crossfade !== void 0 ? options.crossfade : true,
-      };
+      this.options = { ...this.options, ...options, crossfade: options.crossfade !== void 0 ? options.crossfade : true, };
     }
     clearMeasurements() {
       this.scroll = void 0;
@@ -6452,9 +4900,7 @@ function createProjectionNode({
     }
     forceRelativeParentToResolveTarget() {
       if (!this.relativeParent) return;
-      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
-        this.relativeParent.resolveTargetDelta(true,);
-      }
+      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) this.relativeParent.resolveTargetDelta(true,);
     }
     resolveTargetDelta(forceRecalculation = false,) {
       var _a;
@@ -6467,10 +4913,7 @@ function createProjectionNode({
         !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty ||
           ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
       if (canSkip) return;
-      const {
-        layout: layout2,
-        layoutId,
-      } = this.options;
+      const { layout: layout2, layoutId, } = this.options;
       if (!this.layout || !(layout2 || layoutId)) return;
       this.resolvedRelativeTargetAt = frameData.timestamp;
       if (!this.targetDelta && !this.relativeTarget) {
@@ -6482,9 +4925,7 @@ function createProjectionNode({
           this.relativeTargetOrigin = createBox();
           calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox,);
           copyBoxInto(this.relativeTarget, this.relativeTargetOrigin,);
-        } else {
-          this.relativeParent = this.relativeTarget = void 0;
-        }
+        } else this.relativeParent = this.relativeTarget = void 0;
       }
       if (!this.relativeTarget && !this.targetDelta) return;
       if (!this.target) {
@@ -6495,15 +4936,10 @@ function createProjectionNode({
         this.forceRelativeParentToResolveTarget();
         calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target,);
       } else if (this.targetDelta) {
-        if (Boolean(this.resumingFrom,)) {
-          this.target = this.applyTransform(this.layout.layoutBox,);
-        } else {
-          copyBoxInto(this.target, this.layout.layoutBox,);
-        }
+        if (Boolean(this.resumingFrom,)) this.target = this.applyTransform(this.layout.layoutBox,);
+        else copyBoxInto(this.target, this.layout.layoutBox,);
         applyBoxDelta(this.target, this.targetDelta,);
-      } else {
-        copyBoxInto(this.target, this.layout.layoutBox,);
-      }
+      } else copyBoxInto(this.target, this.layout.layoutBox,);
       if (this.attemptToResolveRelativeTarget) {
         this.attemptToResolveRelativeTarget = false;
         const relativeParent = this.getClosestProjectingParent();
@@ -6517,21 +4953,14 @@ function createProjectionNode({
           this.relativeTargetOrigin = createBox();
           calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target,);
           copyBoxInto(this.relativeTarget, this.relativeTargetOrigin,);
-        } else {
-          this.relativeParent = this.relativeTarget = void 0;
-        }
+        } else this.relativeParent = this.relativeTarget = void 0;
       }
       projectionFrameData.resolvedTargetDeltas++;
     }
     getClosestProjectingParent() {
-      if (!this.parent || hasScale(this.parent.latestValues,) || has2DTranslate(this.parent.latestValues,)) {
-        return void 0;
-      }
-      if (this.parent.isProjecting()) {
-        return this.parent;
-      } else {
-        return this.parent.getClosestProjectingParent();
-      }
+      if (!this.parent || hasScale(this.parent.latestValues,) || has2DTranslate(this.parent.latestValues,)) return void 0;
+      if (this.parent.isProjecting()) return this.parent;
+      else return this.parent.getClosestProjectingParent();
     }
     isProjecting() {
       return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout,);
@@ -6541,24 +4970,13 @@ function createProjectionNode({
       const lead = this.getLead();
       const isShared = Boolean(this.resumingFrom,) || this !== lead;
       let canSkip = true;
-      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
-        canSkip = false;
-      }
-      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
-        canSkip = false;
-      }
-      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
-        canSkip = false;
-      }
+      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) canSkip = false;
+      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) canSkip = false;
+      if (this.resolvedRelativeTargetAt === frameData.timestamp) canSkip = false;
       if (canSkip) return;
-      const {
-        layout: layout2,
-        layoutId,
-      } = this.options;
+      const { layout: layout2, layoutId, } = this.options;
       this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation,);
-      if (!this.isTreeAnimating) {
-        this.targetDelta = this.relativeTarget = void 0;
-      }
+      if (!this.isTreeAnimating) this.targetDelta = this.relativeTarget = void 0;
       if (!this.layout || !(layout2 || layoutId)) return;
       copyBoxInto(this.layoutCorrected, this.layout.layoutBox,);
       const prevTreeScaleX = this.treeScale.x;
@@ -6568,9 +4986,7 @@ function createProjectionNode({
         lead.target = lead.layout.layoutBox;
         lead.targetWithTransforms = createBox();
       }
-      const {
-        target,
-      } = lead;
+      const { target, } = lead;
       if (!target) {
         if (this.projectionTransform) {
           this.projectionDelta = createDelta();
@@ -6607,20 +5023,14 @@ function createProjectionNode({
         const stack = this.getStack();
         stack && stack.scheduleRender();
       }
-      if (this.resumingFrom && !this.resumingFrom.instance) {
-        this.resumingFrom = void 0;
-      }
+      if (this.resumingFrom && !this.resumingFrom.instance) this.resumingFrom = void 0;
     }
     setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false,) {
       const snapshot = this.snapshot;
       const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
-      const mixedValues = {
-        ...this.latestValues,
-      };
+      const mixedValues = { ...this.latestValues, };
       const targetDelta = createDelta();
-      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
-        this.relativeTarget = this.relativeTargetOrigin = void 0;
-      }
+      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) this.relativeTarget = this.relativeTargetOrigin = void 0;
       this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
       const relativeLayout = createBox();
       const snapshotSource = snapshot ? snapshot.source : void 0;
@@ -6641,9 +5051,7 @@ function createProjectionNode({
         if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
           calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox,);
           mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2,);
-          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget,)) {
-            this.isProjectionDirty = false;
-          }
+          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget,)) this.isProjectionDirty = false;
           if (!prevRelativeTarget) prevRelativeTarget = createBox();
           copyBoxInto(prevRelativeTarget, this.relativeTarget,);
         }
@@ -6660,9 +5068,7 @@ function createProjectionNode({
     startAnimation(options,) {
       this.notifyListeners('animationStart',);
       this.currentAnimation && this.currentAnimation.stop();
-      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
-        this.resumingFrom.currentAnimation.stop();
-      }
+      if (this.resumingFrom && this.resumingFrom.currentAnimation) this.resumingFrom.currentAnimation.stop();
       if (this.pendingAnimation) {
         cancelFrame(this.pendingAnimation,);
         this.pendingAnimation = void 0;
@@ -6680,9 +5086,7 @@ function createProjectionNode({
             this.completeAnimation();
           },
         },);
-        if (this.resumingFrom) {
-          this.resumingFrom.currentAnimation = this.currentAnimation;
-        }
+        if (this.resumingFrom) this.resumingFrom.currentAnimation = this.currentAnimation;
         this.pendingAnimation = void 0;
       },);
     }
@@ -6705,12 +5109,7 @@ function createProjectionNode({
     }
     applyTransformsToTarget() {
       const lead = this.getLead();
-      let {
-        targetWithTransforms,
-        target,
-        layout: layout2,
-        latestValues,
-      } = lead;
+      let { targetWithTransforms, target, layout: layout2, latestValues, } = lead;
       if (!targetWithTransforms || !target || !layout2) return;
       if (
         this !== lead && this.layout && layout2 &&
@@ -6729,9 +5128,7 @@ function createProjectionNode({
       calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues,);
     }
     registerSharedNode(layoutId, node,) {
-      if (!this.sharedNodes.has(layoutId,)) {
-        this.sharedNodes.set(layoutId, new NodeStack(),);
-      }
+      if (!this.sharedNodes.has(layoutId,)) this.sharedNodes.set(layoutId, new NodeStack(),);
       const stack = this.sharedNodes.get(layoutId,);
       stack.add(node,);
       const config = node.options.initialPromotionConfig;
@@ -6746,88 +5143,57 @@ function createProjectionNode({
     }
     getLead() {
       var _a;
-      const {
-        layoutId,
-      } = this.options;
+      const { layoutId, } = this.options;
       return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
     }
     getPrevLead() {
       var _a;
-      const {
-        layoutId,
-      } = this.options;
+      const { layoutId, } = this.options;
       return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
     }
     getStack() {
-      const {
-        layoutId,
-      } = this.options;
+      const { layoutId, } = this.options;
       if (layoutId) return this.root.sharedNodes.get(layoutId,);
     }
-    promote({
-      needsReset,
-      transition,
-      preserveFollowOpacity,
-    } = {},) {
+    promote({ needsReset, transition, preserveFollowOpacity, } = {},) {
       const stack = this.getStack();
       if (stack) stack.promote(this, preserveFollowOpacity,);
       if (needsReset) {
         this.projectionDelta = void 0;
         this.needsReset = true;
       }
-      if (transition) {
-        this.setOptions({
-          transition,
-        },);
-      }
+      if (transition) this.setOptions({ transition, },);
     }
     relegate() {
       const stack = this.getStack();
-      if (stack) {
-        return stack.relegate(this,);
-      } else {
-        return false;
-      }
+      if (stack) return stack.relegate(this,);
+      else return false;
     }
     resetRotation() {
-      const {
-        visualElement,
-      } = this.options;
+      const { visualElement, } = this.options;
       if (!visualElement) return;
       let hasRotate = false;
-      const {
-        latestValues,
-      } = visualElement;
+      const { latestValues, } = visualElement;
       if (
         latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ ||
         latestValues.skewX || latestValues.skewY
-      ) {
-        hasRotate = true;
-      }
+      ) hasRotate = true;
       if (!hasRotate) return;
       const resetValues = {};
-      if (latestValues.z) {
-        resetDistortingTransform('z', visualElement, resetValues,);
-      }
+      if (latestValues.z) resetDistortingTransform('z', visualElement, resetValues,);
       for (let i = 0; i < transformAxes.length; i++) {
         resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues,);
         resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues,);
       }
       visualElement.render();
-      for (const key7 in resetValues) {
-        visualElement.setStaticValue(key7, resetValues[key7],);
-      }
+      for (const key7 in resetValues) visualElement.setStaticValue(key7, resetValues[key7],);
       visualElement.scheduleRender();
     }
     getProjectionStyles(styleProp,) {
       var _a, _b;
       if (!this.instance || this.isSVG) return void 0;
-      if (!this.isVisible) {
-        return hiddenVisibility;
-      }
-      const styles = {
-        visibility: '',
-      };
+      if (!this.isVisible) return hiddenVisibility;
+      const styles = { visibility: '', };
       const transformTemplate2 = this.getTransformTemplate();
       if (this.needsReset) {
         this.needsReset = false;
@@ -6853,13 +5219,8 @@ function createProjectionNode({
       const valuesToRender = lead.animationValues || lead.latestValues;
       this.applyTransformsToTarget();
       styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender,);
-      if (transformTemplate2) {
-        styles.transform = transformTemplate2(valuesToRender, styles.transform,);
-      }
-      const {
-        x,
-        y,
-      } = this.projectionDelta;
+      if (transformTemplate2) styles.transform = transformTemplate2(valuesToRender, styles.transform,);
+      const { x, y, } = this.projectionDelta;
       styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
       if (lead.animationValues) {
         styles.opacity = lead === this
@@ -6869,28 +5230,19 @@ function createProjectionNode({
           : this.preserveOpacity
           ? this.latestValues.opacity
           : valuesToRender.opacityExit;
-      } else {
-        styles.opacity = lead === this
+      } else {styles.opacity = lead === this
           ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : ''
           : valuesToRender.opacityExit !== void 0
           ? valuesToRender.opacityExit
-          : 0;
-      }
+          : 0;}
       for (const key7 in scaleCorrectors) {
         if (valuesToRender[key7] === void 0) continue;
-        const {
-          correct,
-          applyTo,
-        } = scaleCorrectors[key7];
+        const { correct, applyTo, } = scaleCorrectors[key7];
         const corrected = styles.transform === 'none' ? valuesToRender[key7] : correct(valuesToRender[key7], lead,);
         if (applyTo) {
           const num = applyTo.length;
-          for (let i = 0; i < num; i++) {
-            styles[applyTo[i]] = corrected;
-          }
-        } else {
-          styles[key7] = corrected;
-        }
+          for (let i = 0; i < num; i++) styles[applyTo[i]] = corrected;
+        } else styles[key7] = corrected;
       }
       if (this.options.layoutId) {
         styles.pointerEvents = lead === this
@@ -6901,8 +5253,7 @@ function createProjectionNode({
     }
     clearSnapshot() {
       this.resumeFrom = this.snapshot = void 0;
-    }
-    // Only run on root
+    } // Only run on root
     resetTree() {
       this.root.nodes.forEach((node) => {
         var _a;
@@ -6920,13 +5271,8 @@ function notifyLayoutUpdate(node,) {
   var _a;
   const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
   if (node.isLead() && node.layout && snapshot && node.hasListeners('didUpdate',)) {
-    const {
-      layoutBox: layout2,
-      measuredBox: measuredLayout,
-    } = node.layout;
-    const {
-      animationType,
-    } = node.options;
+    const { layoutBox: layout2, measuredBox: measuredLayout, } = node.layout;
+    const { animationType, } = node.options;
     const isShared = snapshot.source !== node.layout.source;
     if (animationType === 'size') {
       eachAxis((axis) => {
@@ -6949,28 +5295,20 @@ function notifyLayoutUpdate(node,) {
     const layoutDelta = createDelta();
     calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox,);
     const visualDelta = createDelta();
-    if (isShared) {
-      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true,), snapshot.measuredBox,);
-    } else {
-      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox,);
-    }
+    if (isShared) calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true,), snapshot.measuredBox,);
+    else calcBoxDelta(visualDelta, layout2, snapshot.layoutBox,);
     const hasLayoutChanged = !isDeltaZero(layoutDelta,);
     let hasRelativeTargetChanged = false;
     if (!node.resumeFrom) {
       const relativeParent = node.getClosestProjectingParent();
       if (relativeParent && !relativeParent.resumeFrom) {
-        const {
-          snapshot: parentSnapshot,
-          layout: parentLayout,
-        } = relativeParent;
+        const { snapshot: parentSnapshot, layout: parentLayout, } = relativeParent;
         if (parentSnapshot && parentLayout) {
           const relativeSnapshot = createBox();
           calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox,);
           const relativeLayout = createBox();
           calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox,);
-          if (!boxEqualsRounded(relativeSnapshot, relativeLayout,)) {
-            hasRelativeTargetChanged = true;
-          }
+          if (!boxEqualsRounded(relativeSnapshot, relativeLayout,)) hasRelativeTargetChanged = true;
           if (relativeParent.options.layoutRoot) {
             node.relativeTarget = relativeLayout;
             node.relativeTargetOrigin = relativeSnapshot;
@@ -6988,9 +5326,7 @@ function notifyLayoutUpdate(node,) {
       hasRelativeTargetChanged,
     },);
   } else if (node.isLead()) {
-    const {
-      onExitComplete,
-    } = node.options;
+    const { onExitComplete, } = node.options;
     onExitComplete && onExitComplete();
   }
   node.options.transition = void 0;
@@ -6998,9 +5334,7 @@ function notifyLayoutUpdate(node,) {
 function propagateDirtyNodes(node,) {
   projectionFrameData.totalNodes++;
   if (!node.parent) return;
-  if (!node.isProjecting()) {
-    node.isProjectionDirty = node.parent.isProjectionDirty;
-  }
+  if (!node.isProjecting()) node.isProjectionDirty = node.parent.isProjectionDirty;
   node.isSharedProjectionDirty ||
     (node.isSharedProjectionDirty = Boolean(
       node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty,
@@ -7020,12 +5354,8 @@ function clearIsLayoutDirty(node,) {
   node.isLayoutDirty = false;
 }
 function resetTransformStyle(node,) {
-  const {
-    visualElement,
-  } = node.options;
-  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
-    visualElement.notify('BeforeLayoutMeasure',);
-  }
+  const { visualElement, } = node.options;
+  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) visualElement.notify('BeforeLayoutMeasure',);
   node.resetTransform();
 }
 function finishAnimation(node,) {
@@ -7062,10 +5392,7 @@ function mixBox(output, from, to, p,) {
 function hasOpacityCrossfade(node,) {
   return node.animationValues && node.animationValues.opacityExit !== void 0;
 }
-var defaultLayoutTransition = {
-  duration: 0.45,
-  ease: [0.4, 0, 0.1, 1,],
-};
+var defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1,], };
 var userAgentContains = (string) =>
   typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string,);
 var roundPoint = userAgentContains('applewebkit/',) && !userAgentContains('chrome/',) ? Math.round : noop;
@@ -7089,21 +5416,14 @@ var DocumentProjectionNode = createProjectionNode({
   }),
   checkIsScrollRoot: () => true,
 },);
-var rootProjectionNode = {
-  current: void 0,
-};
+var rootProjectionNode = { current: void 0, };
 var HTMLProjectionNode = createProjectionNode({
-  measureScroll: (instance) => ({
-    x: instance.scrollLeft,
-    y: instance.scrollTop,
-  }),
+  measureScroll: (instance) => ({ x: instance.scrollLeft, y: instance.scrollTop, }),
   defaultParent: () => {
     if (!rootProjectionNode.current) {
       const documentNode = new DocumentProjectionNode({},);
       documentNode.mount(window,);
-      documentNode.setOptions({
-        layoutScroll: true,
-      },);
+      documentNode.setOptions({ layoutScroll: true, },);
       rootProjectionNode.current = documentNode;
     }
     return rootProjectionNode.current;
@@ -7113,18 +5433,8 @@ var HTMLProjectionNode = createProjectionNode({
   },
   checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance,).position === 'fixed',),
 },);
-var drag = {
-  pan: {
-    Feature: PanGesture,
-  },
-  drag: {
-    Feature: DragGesture,
-    ProjectionNode: HTMLProjectionNode,
-    MeasureLayout,
-  },
-};
-var splitCSSVariableRegex =
-  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
+var drag = { pan: { Feature: PanGesture, }, drag: { Feature: DragGesture, ProjectionNode: HTMLProjectionNode, MeasureLayout, }, };
+var splitCSSVariableRegex = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
   /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
 function parseCSSVariable(current,) {
   const match = splitCSSVariableRegex.exec(current,);
@@ -7147,21 +5457,10 @@ function getVariableValue(current, element, depth = 1,) {
   }
   return isCSSVariableToken(fallback,) ? getVariableValue(fallback, element, depth + 1,) : fallback;
 }
-function resolveCSSVariables(visualElement, {
-  ...target
-}, transitionEnd,) {
+function resolveCSSVariables(visualElement, { ...target }, transitionEnd,) {
   const element = visualElement.current;
-  if (!(element instanceof Element)) {
-    return {
-      target,
-      transitionEnd,
-    };
-  }
-  if (transitionEnd) {
-    transitionEnd = {
-      ...transitionEnd,
-    };
-  }
+  if (!(element instanceof Element)) return { target, transitionEnd, };
+  if (transitionEnd) transitionEnd = { ...transitionEnd, };
   visualElement.values.forEach((value) => {
     const current = value.get();
     if (!isCSSVariableToken(current,)) return;
@@ -7175,14 +5474,9 @@ function resolveCSSVariables(visualElement, {
     if (!resolved) continue;
     target[key7] = resolved;
     if (!transitionEnd) transitionEnd = {};
-    if (transitionEnd[key7] === void 0) {
-      transitionEnd[key7] = current;
-    }
+    if (transitionEnd[key7] === void 0) transitionEnd[key7] = current;
   }
-  return {
-    target,
-    transitionEnd,
-  };
+  return { target, transitionEnd, };
 }
 var positionalKeys = /* @__PURE__ */ new Set(['width', 'height', 'top', 'left', 'right', 'bottom', 'x', 'y', 'translateX', 'translateY',],);
 var isPositionalKey = (key7) => positionalKeys.has(key7,);
@@ -7191,21 +5485,14 @@ var hasPositionalKey = (target) => {
 };
 var isNumOrPxType = (v) => v === number || v === px;
 var getPosFromMatrix = (matrix, pos,) => parseFloat(matrix.split(', ',)[pos],);
-var getTranslateFromMatrix = (pos2, pos3,) =>
-(_bbox, {
-  transform: transform2,
-},) => {
+var getTranslateFromMatrix = (pos2, pos3,) => (_bbox, { transform: transform2, },) => {
   if (transform2 === 'none' || !transform2) return 0;
   const matrix3d = transform2.match(/^matrix3d\((.+)\)$/u,);
-  if (matrix3d) {
-    return getPosFromMatrix(matrix3d[1], pos3,);
-  } else {
+  if (matrix3d) return getPosFromMatrix(matrix3d[1], pos3,);
+  else {
     const matrix = transform2.match(/^matrix\((.+)\)$/u,);
-    if (matrix) {
-      return getPosFromMatrix(matrix[1], pos2,);
-    } else {
-      return 0;
-    }
+    if (matrix) return getPosFromMatrix(matrix[1], pos2,);
+    else return 0;
   }
 };
 var transformKeys = /* @__PURE__ */ new Set(['x', 'y', 'z',],);
@@ -7222,37 +5509,13 @@ function removeNonTranslationalTransform(visualElement,) {
   if (removedTransforms.length) visualElement.render();
   return removedTransforms;
 }
-var positionalValues = {
-  // Dimensions
-  width: ({
-    x,
-  }, {
-    paddingLeft = '0',
-    paddingRight = '0',
-  },) => x.max - x.min - parseFloat(paddingLeft,) - parseFloat(paddingRight,),
-  height: ({
-    y,
-  }, {
-    paddingTop = '0',
-    paddingBottom = '0',
-  },) => y.max - y.min - parseFloat(paddingTop,) - parseFloat(paddingBottom,),
-  top: (_bbox, {
-    top,
-  },) => parseFloat(top,),
-  left: (_bbox, {
-    left,
-  },) => parseFloat(left,),
-  bottom: ({
-    y,
-  }, {
-    top,
-  },) => parseFloat(top,) + (y.max - y.min),
-  right: ({
-    x,
-  }, {
-    left,
-  },) => parseFloat(left,) + (x.max - x.min),
-  // Transform
+var positionalValues = { // Dimensions
+  width: ({ x, }, { paddingLeft = '0', paddingRight = '0', },) => x.max - x.min - parseFloat(paddingLeft,) - parseFloat(paddingRight,),
+  height: ({ y, }, { paddingTop = '0', paddingBottom = '0', },) => y.max - y.min - parseFloat(paddingTop,) - parseFloat(paddingBottom,),
+  top: (_bbox, { top, },) => parseFloat(top,),
+  left: (_bbox, { left, },) => parseFloat(left,),
+  bottom: ({ y, }, { top, },) => parseFloat(top,) + (y.max - y.min),
+  right: ({ x, }, { left, },) => parseFloat(left,) + (x.max - x.min), // Transform
   x: getTranslateFromMatrix(4, 13,),
   y: getTranslateFromMatrix(5, 14,),
 };
@@ -7262,13 +5525,9 @@ var convertChangedValueTypes = (target, visualElement, changedKeys,) => {
   const originBbox = visualElement.measureViewportBox();
   const element = visualElement.current;
   const elementComputedStyle = getComputedStyle(element,);
-  const {
-    display,
-  } = elementComputedStyle;
+  const { display, } = elementComputedStyle;
   const origin = {};
-  if (display === 'none') {
-    visualElement.setStaticValue('display', target.display || 'block',);
-  }
+  if (display === 'none') visualElement.setStaticValue('display', target.display || 'block',);
   changedKeys.forEach((key7) => {
     origin[key7] = positionalValues[key7](originBbox, elementComputedStyle,);
   },);
@@ -7282,12 +5541,8 @@ var convertChangedValueTypes = (target, visualElement, changedKeys,) => {
   return target;
 };
 var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {},) => {
-  target = {
-    ...target,
-  };
-  transitionEnd = {
-    ...transitionEnd,
-  };
+  target = { ...target, };
+  transitionEnd = { ...transitionEnd, };
   const targetPositionalKeys = Object.keys(target,).filter(isPositionalKey,);
   let removedTransformValues = [];
   let hasAttemptedToRemoveTransformValues = false;
@@ -7312,33 +5567,21 @@ var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, tran
             toType === fromType || isNumOrPxType(fromType,) && isNumOrPxType(toType,),
             'Keyframes must be of the same dimension as the current value',
           );
-        } else {
-          invariant(findDimensionValueType(to[i],) === toType, 'All keyframes must be of the same type',);
-        }
+        } else invariant(findDimensionValueType(to[i],) === toType, 'All keyframes must be of the same type',);
       }
-    } else {
-      toType = findDimensionValueType(to,);
-    }
+    } else toType = findDimensionValueType(to,);
     if (fromType !== toType) {
       if (isNumOrPxType(fromType,) && isNumOrPxType(toType,)) {
         const current = value.get();
-        if (typeof current === 'string') {
-          value.set(parseFloat(current,),);
-        }
-        if (typeof to === 'string') {
-          target[key7] = parseFloat(to,);
-        } else if (Array.isArray(to,) && toType === px) {
-          target[key7] = to.map(parseFloat,);
-        }
+        if (typeof current === 'string') value.set(parseFloat(current,),);
+        if (typeof to === 'string') target[key7] = parseFloat(to,);
+        else if (Array.isArray(to,) && toType === px) target[key7] = to.map(parseFloat,);
       } else if (
         (fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&
         (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)
       ) {
-        if (from === 0) {
-          value.set(toType.transform(from,),);
-        } else {
-          target[key7] = fromType.transform(to,);
-        }
+        if (from === 0) value.set(toType.transform(from,),);
+        else target[key7] = fromType.transform(to,);
       } else {
         if (!hasAttemptedToRemoveTransformValues) {
           removedTransformValues = removeNonTranslationalTransform(visualElement,);
@@ -7359,27 +5602,14 @@ var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, tran
       },);
     }
     visualElement.render();
-    if (isBrowser && scrollY !== null) {
-      window.scrollTo({
-        top: scrollY,
-      },);
-    }
-    return {
-      target: convertedTarget,
-      transitionEnd,
-    };
-  } else {
-    return {
-      target,
-      transitionEnd,
-    };
-  }
+    if (isBrowser && scrollY !== null) window.scrollTo({ top: scrollY, },);
+    return { target: convertedTarget, transitionEnd, };
+  } else return { target, transitionEnd, };
 };
 function unitConversion(visualElement, target, origin, transitionEnd,) {
-  return hasPositionalKey(target,) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd,) : {
-    target,
-    transitionEnd,
-  };
+  return hasPositionalKey(target,)
+    ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd,)
+    : { target, transitionEnd, };
 }
 var parseDomVariant = (visualElement, target, origin, transitionEnd,) => {
   const resolved = resolveCSSVariables(visualElement, target, transitionEnd,);
@@ -7394,18 +5624,11 @@ var DOMVisualElement = class extends VisualElement {
   getBaseTargetFromProps(props, key7,) {
     return props.style ? props.style[key7] : void 0;
   }
-  removeValueFromRenderState(key7, {
-    vars,
-    style,
-  },) {
+  removeValueFromRenderState(key7, { vars, style, },) {
     delete vars[key7];
     delete style[key7];
   }
-  makeTargetAnimatableFromInstance({
-    transition,
-    transitionEnd,
-    ...target
-  }, isMounted,) {
+  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, isMounted,) {
     const origin = getOrigin(target, transition || {}, this,);
     if (isMounted) {
       checkTargetForNewValues(this, target, origin,);
@@ -7413,11 +5636,7 @@ var DOMVisualElement = class extends VisualElement {
       transitionEnd = parsed.transitionEnd;
       target = parsed.target;
     }
-    return {
-      transition,
-      transitionEnd,
-      ...target,
-    };
+    return { transition, transitionEnd, ...target, };
   }
 };
 function getComputedStyle2(element,) {
@@ -7438,9 +5657,7 @@ var HTMLVisualElement = class extends DOMVisualElement {
       return typeof value === 'string' ? value.trim() : value;
     }
   }
-  measureInstanceViewportBox(instance, {
-    transformPagePoint,
-  },) {
+  measureInstanceViewportBox(instance, { transformPagePoint, },) {
     return measureViewportBox(instance, transformPagePoint,);
   }
   build(renderState, latestValues, options, props,) {
@@ -7454,9 +5671,7 @@ var HTMLVisualElement = class extends DOMVisualElement {
       this.childSubscription();
       delete this.childSubscription;
     }
-    const {
-      children,
-    } = this.props;
+    const { children, } = this.props;
     if (isMotionValue(children,)) {
       this.childSubscription = children.on('change', (latest) => {
         if (this.current) this.current.textContent = `${latest}`;
@@ -7503,38 +5718,16 @@ var SVGVisualElement = class extends DOMVisualElement {
 };
 var createDomVisualElement = (Component23, options,) => {
   return isSVGComponent(Component23,)
-    ? new SVGVisualElement(options, {
-      enableHardwareAcceleration: false,
-    },)
-    : new HTMLVisualElement(options, {
-      enableHardwareAcceleration: true,
-      allowProjection: Component23 !== React__default.Fragment,
-    },);
-};
-var layout = {
-  layout: {
-    ProjectionNode: HTMLProjectionNode,
-    MeasureLayout,
-  },
-};
-var preloadedFeatures = {
-  ...animations,
-  ...gestureAnimations,
-  ...drag,
-  ...layout,
+    ? new SVGVisualElement(options, { enableHardwareAcceleration: false, },)
+    : new HTMLVisualElement(options, { enableHardwareAcceleration: true, allowProjection: Component23 !== React__default.Fragment, },);
 };
+var layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout, }, };
+var preloadedFeatures = { ...animations, ...gestureAnimations, ...drag, ...layout, };
 var motion = /* @__PURE__ */ createMotionProxy((Component23, config,) =>
   createDomMotionConfig(Component23, config, preloadedFeatures, createDomVisualElement,)
 );
 function createDomMotionComponent(key7,) {
-  return createMotionComponent(createDomMotionConfig(
-    key7,
-    {
-      forwardMotionProps: false,
-    },
-    preloadedFeatures,
-    createDomVisualElement,
-  ),);
+  return createMotionComponent(createDomMotionConfig(key7, { forwardMotionProps: false, }, preloadedFeatures, createDomVisualElement,),);
 }
 var m = createMotionProxy(createDomMotionConfig,);
 function useIsMounted() {
@@ -7570,37 +5763,22 @@ var PopChildMeasure = class extends React.Component {
       size2.left = element.offsetLeft;
     }
     return null;
-  }
-  /**
+  } /**
    * Required with getSnapshotBeforeUpdate to stop React complaining.
    */
+
   componentDidUpdate() {}
   render() {
     return this.props.children;
   }
 };
-function PopChild({
-  children,
-  isPresent: isPresent2,
-},) {
+function PopChild({ children, isPresent: isPresent2, },) {
   const id4 = useId();
   const ref = useRef(null,);
-  const size2 = useRef({
-    width: 0,
-    height: 0,
-    top: 0,
-    left: 0,
-  },);
-  const {
-    nonce,
-  } = useContext3(MotionConfigContext,);
+  const size2 = useRef({ width: 0, height: 0, top: 0, left: 0, },);
+  const { nonce, } = useContext3(MotionConfigContext,);
   useInsertionEffect(() => {
-    const {
-      width,
-      height,
-      top,
-      left,
-    } = size2.current;
+    const { width, height, top, left, } = size2.current;
     if (isPresent2 || !ref.current || !width || !height) return;
     ref.current.dataset.motionPopId = id4;
     const style = document.createElement('style',);
@@ -7623,66 +5801,40 @@ function PopChild({
   }, [isPresent2,],);
   return React.createElement(
     PopChildMeasure,
-    {
-      isPresent: isPresent2,
-      childRef: ref,
-      sizeRef: size2,
-    },
-    React.cloneElement(children, {
-      ref,
-    },),
+    { isPresent: isPresent2, childRef: ref, sizeRef: size2, },
+    React.cloneElement(children, { ref, },),
   );
 }
-var PresenceChild = ({
-  children,
-  initial,
-  isPresent: isPresent2,
-  onExitComplete,
-  custom,
-  presenceAffectsLayout,
-  mode,
-},) => {
+var PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode, },) => {
   const presenceChildren = useConstant(newChildrenMap,);
   const id4 = useId();
-  const context = useMemo(
-    () => ({
-      id: id4,
-      initial,
-      isPresent: isPresent2,
-      custom,
-      onExitComplete: (childId) => {
-        presenceChildren.set(childId, true,);
-        for (const isComplete of presenceChildren.values()) {
-          if (!isComplete) return;
-        }
-        onExitComplete && onExitComplete();
-      },
-      register: (childId) => {
-        presenceChildren.set(childId, false,);
-        return () => presenceChildren.delete(childId,);
-      },
-    }),
-    /**
-     * If the presence of a child affects the layout of the components around it,
-     * we want to make a new context value to ensure they get re-rendered
-     * so they can detect that layout change.
-     */
-    presenceAffectsLayout ? void 0 : [isPresent2,],
-  );
+  const context = useMemo(() => ({
+    id: id4,
+    initial,
+    isPresent: isPresent2,
+    custom,
+    onExitComplete: (childId) => {
+      presenceChildren.set(childId, true,);
+      for (const isComplete of presenceChildren.values()) if (!isComplete) return;
+      onExitComplete && onExitComplete();
+    },
+    register: (childId) => {
+      presenceChildren.set(childId, false,);
+      return () => presenceChildren.delete(childId,);
+    },
+  }), /**
+   * If the presence of a child affects the layout of the components around it,
+   * we want to make a new context value to ensure they get re-rendered
+   * so they can detect that layout change.
+   */ presenceAffectsLayout ? void 0 : [isPresent2,],);
   useMemo(() => {
     presenceChildren.forEach((_, key7,) => presenceChildren.set(key7, false,));
   }, [isPresent2,],);
   React.useEffect(() => {
     !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
   }, [isPresent2,],);
-  if (mode === 'popLayout') {
-    children = React.createElement(PopChild, {
-      isPresent: isPresent2,
-    }, children,);
-  }
-  return React.createElement(PresenceContext.Provider, {
-    value: context,
-  }, children,);
+  if (mode === 'popLayout') children = React.createElement(PopChild, { isPresent: isPresent2, }, children,);
+  return React.createElement(PresenceContext.Provider, { value: context, }, children,);
 };
 function newChildrenMap() {
   return /* @__PURE__ */ new Map();
@@ -7701,15 +5853,9 @@ function onlyElements(children,) {
   },);
   return filtered;
 }
-var AnimatePresence = ({
-  children,
-  custom,
-  initial = true,
-  onExitComplete,
-  exitBeforeEnter,
-  presenceAffectsLayout = true,
-  mode = 'sync',
-},) => {
+var AnimatePresence = (
+  { children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = 'sync', },
+) => {
   invariant(!exitBeforeEnter, 'Replace exitBeforeEnter with mode=\'wait\'',);
   const forceRender = useContext3(LayoutGroupContext,).forceRender || useForceUpdate()[0];
   const isMounted = useIsMounted();
@@ -7750,13 +5896,9 @@ var AnimatePresence = ({
   const numPresent = presentKeys.length;
   for (let i = 0; i < numPresent; i++) {
     const key7 = presentKeys[i];
-    if (targetKeys.indexOf(key7,) === -1 && !exitingChildren.has(key7,)) {
-      exitingChildren.set(key7, void 0,);
-    }
-  }
-  if (mode === 'wait' && exitingChildren.size) {
-    childrenToRender = [];
+    if (targetKeys.indexOf(key7,) === -1 && !exitingChildren.has(key7,)) exitingChildren.set(key7, void 0,);
   }
+  if (mode === 'wait' && exitingChildren.size) childrenToRender = [];
   exitingChildren.forEach((component, key7,) => {
     if (targetKeys.indexOf(key7,) !== -1) return;
     const child = allChildren.get(key7,);
@@ -7770,10 +5912,8 @@ var AnimatePresence = ({
         leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey,));
         presentChildren.current = filteredChildren.filter((presentChild) => {
           const presentChildKey = getChildKey(presentChild,);
-          return (
-            // filter out the node exiting
-            presentChildKey === key7 ||
-            // filter out the leftover children
+          return ( // filter out the node exiting
+            presentChildKey === key7 || // filter out the leftover children
             leftOverKeys.includes(presentChildKey,)
           );
         },);
@@ -7797,12 +5937,9 @@ var AnimatePresence = ({
   },);
   childrenToRender = childrenToRender.map((child) => {
     const key7 = child.key;
-    return exitingChildren.has(key7,) ? child : React.createElement(PresenceChild, {
-      key: getChildKey(child,),
-      isPresent: true,
-      presenceAffectsLayout,
-      mode,
-    }, child,);
+    return exitingChildren.has(key7,)
+      ? child
+      : React.createElement(PresenceChild, { key: getChildKey(child,), isPresent: true, presenceAffectsLayout, mode, }, child,);
   },);
   if (false) {
     console.warn(
@@ -7815,55 +5952,31 @@ var AnimatePresence = ({
     exitingChildren.size ? childrenToRender : childrenToRender.map((child) => cloneElement2(child,)),
   );
 };
-function MotionConfig({
-  children,
-  isValidProp,
-  ...config
-},) {
+function MotionConfig({ children, isValidProp, ...config },) {
   isValidProp && loadExternalIsValidProp(isValidProp,);
-  config = {
-    ...useContext3(MotionConfigContext,),
-    ...config,
-  };
+  config = { ...useContext3(MotionConfigContext,), ...config, };
   config.isStatic = useConstant(() => config.isStatic);
   const context = useMemo(() => config, [JSON.stringify(config.transition,), config.transformPagePoint, config.reducedMotion,],);
-  return React.createElement(MotionConfigContext.Provider, {
-    value: context,
-  }, children,);
+  return React.createElement(MotionConfigContext.Provider, { value: context, }, children,);
 }
-function LazyMotion({
-  children,
-  features,
-  strict = false,
-},) {
+function LazyMotion({ children, features, strict = false, },) {
   const [, setIsLoaded,] = useState(!isLazyBundle(features,),);
   const loadedRenderer = useRef(void 0,);
   if (!isLazyBundle(features,)) {
-    const {
-      renderer,
-      ...loadedFeatures
-    } = features;
+    const { renderer, ...loadedFeatures } = features;
     loadedRenderer.current = renderer;
     loadFeatures(loadedFeatures,);
   }
   useEffect(() => {
     if (isLazyBundle(features,)) {
-      features().then(({
-        renderer,
-        ...loadedFeatures
-      },) => {
+      features().then(({ renderer, ...loadedFeatures },) => {
         loadFeatures(loadedFeatures,);
         loadedRenderer.current = renderer;
         setIsLoaded(true,);
       },);
     }
   }, [],);
-  return React.createElement(LazyContext.Provider, {
-    value: {
-      renderer: loadedRenderer.current,
-      strict,
-    },
-  }, children,);
+  return React.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict, }, }, children,);
 }
 function isLazyBundle(features,) {
   return typeof features === 'function';
@@ -7893,38 +6006,22 @@ function nodeGroup() {
 }
 var shouldInheritGroup = (inherit) => inherit === true;
 var shouldInheritId = (inherit) => shouldInheritGroup(inherit === true,) || inherit === 'id';
-var LayoutGroup = ({
-  children,
-  id: id4,
-  inherit = true,
-},) => {
+var LayoutGroup = ({ children, id: id4, inherit = true, },) => {
   const layoutGroupContext = useContext3(LayoutGroupContext,);
   const deprecatedLayoutGroupContext = useContext3(DeprecatedLayoutGroupContext,);
   const [forceRender, key7,] = useForceUpdate();
   const context = useRef(null,);
   const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
   if (context.current === null) {
-    if (shouldInheritId(inherit,) && upstreamId) {
-      id4 = id4 ? upstreamId + '-' + id4 : upstreamId;
-    }
-    context.current = {
-      id: id4,
-      group: shouldInheritGroup(inherit,) ? layoutGroupContext.group || nodeGroup() : nodeGroup(),
-    };
+    if (shouldInheritId(inherit,) && upstreamId) id4 = id4 ? upstreamId + '-' + id4 : upstreamId;
+    context.current = { id: id4, group: shouldInheritGroup(inherit,) ? layoutGroupContext.group || nodeGroup() : nodeGroup(), };
   }
-  const memoizedContext = useMemo(() => ({
-    ...context.current,
-    forceRender,
-  }), [key7,],);
-  return React.createElement(LayoutGroupContext.Provider, {
-    value: memoizedContext,
-  }, children,);
+  const memoizedContext = useMemo(() => ({ ...context.current, forceRender, }), [key7,],);
+  return React.createElement(LayoutGroupContext.Provider, { value: memoizedContext, }, children,);
 };
 function useMotionValue(initial,) {
   const value = useConstant(() => motionValue(initial,));
-  const {
-    isStatic,
-  } = useContext3(MotionConfigContext,);
+  const { isStatic, } = useContext3(MotionConfigContext,);
   if (isStatic) {
     const [, setLatest,] = useState(initial,);
     useEffect(() => value.on('change', setLatest,), [],);
@@ -7942,10 +6039,7 @@ function transform(...args) {
   const inputRange = args[1 + argOffset];
   const outputRange = args[2 + argOffset];
   const options = args[3 + argOffset];
-  const interpolator = interpolate(inputRange, outputRange, {
-    mixer: getMixer2(outputRange[0],),
-    ...options,
-  },);
+  const interpolator = interpolate(inputRange, outputRange, { mixer: getMixer2(outputRange[0],), ...options, },);
   return useImmediate ? interpolator(inputValue,) : interpolator;
 }
 function useCombineMotionValues(values, combineValues,) {
@@ -7970,9 +6064,7 @@ function useComputed(compute,) {
   return value;
 }
 function useTransform(input, inputRangeOrTransformer, outputRange, options,) {
-  if (typeof input === 'function') {
-    return useComputed(input,);
-  }
+  if (typeof input === 'function') return useComputed(input,);
   const transformer = typeof inputRangeOrTransformer === 'function'
     ? inputRangeOrTransformer
     : transform(inputRangeOrTransformer, outputRange, options,);
@@ -7983,9 +6075,7 @@ function useListTransform(values, transformer,) {
   return useCombineMotionValues(values, () => {
     latest.length = 0;
     const numValues = values.length;
-    for (let i = 0; i < numValues; i++) {
-      latest[i] = values[i].get();
-    }
+    for (let i = 0; i < numValues; i++) latest[i] = values[i].get();
     return transformer(latest,);
   },);
 }
@@ -8005,14 +6095,7 @@ function checkReorder(order, value, offset, velocity,) {
   }
   return order;
 }
-function ReorderGroup({
-  children,
-  as = 'ul',
-  axis = 'y',
-  onReorder,
-  values,
-  ...props
-}, externalRef,) {
+function ReorderGroup({ children, as = 'ul', axis = 'y', onReorder, values, ...props }, externalRef,) {
   const Component23 = useConstant(() => motion(as,));
   const order = [];
   const isReordering = useRef(false,);
@@ -8021,14 +6104,8 @@ function ReorderGroup({
     axis,
     registerItem: (value, layout2,) => {
       const idx = order.findIndex((entry) => value === entry.value);
-      if (idx !== -1) {
-        order[idx].layout = layout2[axis];
-      } else {
-        order.push({
-          value,
-          layout: layout2[axis],
-        },);
-      }
+      if (idx !== -1) order[idx].layout = layout2[axis];
+      else order.push({ value, layout: layout2[axis], },);
       order.sort(compareMin,);
     },
     updateOrder: (item, offset, velocity,) => {
@@ -8045,14 +6122,8 @@ function ReorderGroup({
   },);
   return React.createElement(
     Component23,
-    {
-      ...props,
-      ref: externalRef,
-      ignoreStrict: true,
-    },
-    React.createElement(ReorderContext.Provider, {
-      value: context,
-    }, children,),
+    { ...props, ref: externalRef, ignoreStrict: true, },
+    React.createElement(ReorderContext.Provider, { value: context, }, children,),
   );
 }
 var Group = forwardRef(ReorderGroup,);
@@ -8065,43 +6136,21 @@ function compareMin(a, b,) {
 function useDefaultMotionValue(value, defaultValue = 0,) {
   return isMotionValue(value,) ? value : useMotionValue(defaultValue,);
 }
-function ReorderItem({
-  children,
-  style = {},
-  value,
-  as = 'li',
-  onDrag,
-  layout: layout2 = true,
-  ...props
-}, externalRef,) {
+function ReorderItem({ children, style = {}, value, as = 'li', onDrag, layout: layout2 = true, ...props }, externalRef,) {
   const Component23 = useConstant(() => motion(as,));
   const context = useContext3(ReorderContext,);
-  const point2 = {
-    x: useDefaultMotionValue(style.x,),
-    y: useDefaultMotionValue(style.y,),
-  };
+  const point2 = { x: useDefaultMotionValue(style.x,), y: useDefaultMotionValue(style.y,), };
   const zIndex = useTransform([point2.x, point2.y,], ([latestX, latestY,],) => latestX || latestY ? 1 : 'unset',);
   invariant(Boolean(context,), 'Reorder.Item must be a child of Reorder.Group',);
-  const {
-    axis,
-    registerItem,
-    updateOrder,
-  } = context;
+  const { axis, registerItem, updateOrder, } = context;
   return React.createElement(Component23, {
     drag: axis,
     ...props,
     dragSnapToOrigin: true,
-    style: {
-      ...style,
-      x: point2.x,
-      y: point2.y,
-      zIndex,
-    },
+    style: { ...style, x: point2.x, y: point2.y, zIndex, },
     layout: layout2,
     onDrag: (event, gesturePoint,) => {
-      const {
-        velocity,
-      } = gesturePoint;
+      const { velocity, } = gesturePoint;
       velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis],);
       onDrag && onDrag(event, gesturePoint,);
     },
@@ -8111,20 +6160,9 @@ function ReorderItem({
   }, children,);
 }
 var Item = forwardRef(ReorderItem,);
-var Reorder = {
-  Group,
-  Item,
-};
-var domAnimation = {
-  renderer: createDomVisualElement,
-  ...animations,
-  ...gestureAnimations,
-};
-var domMax = {
-  ...domAnimation,
-  ...drag,
-  ...layout,
-};
+var Reorder = { Group, Item, };
+var domAnimation = { renderer: createDomVisualElement, ...animations, ...gestureAnimations, };
+var domMax = { ...domAnimation, ...drag, ...layout, };
 function useMotionTemplate(fragments, ...values) {
   const numFragments = fragments.length;
   function buildValue() {
@@ -8132,32 +6170,24 @@ function useMotionTemplate(fragments, ...values) {
     for (let i = 0; i < numFragments; i++) {
       output += fragments[i];
       const value = values[i];
-      if (value) {
-        output += isMotionValue(value,) ? value.get() : value;
-      }
+      if (value) output += isMotionValue(value,) ? value.get() : value;
     }
     return output;
   }
   return useCombineMotionValues(values.filter(isMotionValue,), buildValue,);
 }
 function useSpring(source, config = {},) {
-  const {
-    isStatic,
-  } = useContext3(MotionConfigContext,);
+  const { isStatic, } = useContext3(MotionConfigContext,);
   const activeSpringAnimation = useRef(null,);
   const value = useMotionValue(isMotionValue(source,) ? source.get() : source,);
   const stopAnimation2 = () => {
-    if (activeSpringAnimation.current) {
-      activeSpringAnimation.current.stop();
-    }
+    if (activeSpringAnimation.current) activeSpringAnimation.current.stop();
   };
   useInsertionEffect(() => {
     return value.attach((v, set,) => {
       if (isStatic) return set(v,);
       const animation = activeSpringAnimation.current;
-      if (animation && animation.time === 0) {
-        animation.sample(frameData.delta,);
-      }
+      if (animation && animation.time === 0) animation.sample(frameData.delta,);
       stopAnimation2();
       activeSpringAnimation.current = animateValue({
         keyframes: [value.get(), v,],
@@ -8172,9 +6202,7 @@ function useSpring(source, config = {},) {
     }, stopAnimation2,);
   }, [JSON.stringify(config,),],);
   useIsomorphicLayoutEffect(() => {
-    if (isMotionValue(source,)) {
-      return source.on('change', (v) => value.set(parseFloat(v,),),);
-    }
+    if (isMotionValue(source,)) return source.on('change', (v) => value.set(parseFloat(v,),),);
   }, [value,],);
   return value;
 }
@@ -8204,40 +6232,20 @@ function resolveElements(elements, scope, selectorCache,) {
     if (selectorCache) {
       (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements,);
       elements = selectorCache[elements];
-    } else {
-      elements = root.querySelectorAll(elements,);
-    }
-  } else if (elements instanceof Element) {
-    elements = [elements,];
-  }
+    } else elements = root.querySelectorAll(elements,);
+  } else if (elements instanceof Element) elements = [elements,];
   return Array.from(elements || [],);
 }
 var resizeHandlers = /* @__PURE__ */ new WeakMap();
 var observer;
 function getElementSize(target, borderBoxSize,) {
   if (borderBoxSize) {
-    const {
-      inlineSize,
-      blockSize,
-    } = borderBoxSize[0];
-    return {
-      width: inlineSize,
-      height: blockSize,
-    };
-  } else if (target instanceof SVGElement && 'getBBox' in target) {
-    return target.getBBox();
-  } else {
-    return {
-      width: target.offsetWidth,
-      height: target.offsetHeight,
-    };
-  }
+    const { inlineSize, blockSize, } = borderBoxSize[0];
+    return { width: inlineSize, height: blockSize, };
+  } else if (target instanceof SVGElement && 'getBBox' in target) return target.getBBox();
+  else return { width: target.offsetWidth, height: target.offsetHeight, };
 }
-function notifyTarget({
-  target,
-  contentRect,
-  borderBoxSize,
-},) {
+function notifyTarget({ target, contentRect, borderBoxSize, },) {
   var _a;
   (_a = resizeHandlers.get(target,)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {
     handler({
@@ -8282,15 +6290,8 @@ var windowCallbacks = /* @__PURE__ */ new Set();
 var windowResizeHandler;
 function createWindowResizeHandler() {
   windowResizeHandler = () => {
-    const size2 = {
-      width: window.innerWidth,
-      height: window.innerHeight,
-    };
-    const info = {
-      target: window,
-      size: size2,
-      contentSize: size2,
-    };
+    const size2 = { width: window.innerWidth, height: window.innerHeight, };
+    const info = { target: window, size: size2, contentSize: size2, };
     windowCallbacks.forEach((callback) => callback(info,));
   };
   window.addEventListener('resize', windowResizeHandler,);
@@ -8300,9 +6301,7 @@ function resizeWindow(callback,) {
   if (!windowResizeHandler) createWindowResizeHandler();
   return () => {
     windowCallbacks.delete(callback,);
-    if (!windowCallbacks.size && windowResizeHandler) {
-      windowResizeHandler = void 0;
-    }
+    if (!windowCallbacks.size && windowResizeHandler) windowResizeHandler = void 0;
   };
 }
 function resize(a, b,) {
@@ -8319,27 +6318,11 @@ var createAxisInfo = () => ({
   containerLength: 0,
   velocity: 0,
 });
-var createScrollInfo = () => ({
-  time: 0,
-  x: createAxisInfo(),
-  y: createAxisInfo(),
-});
-var keys = {
-  x: {
-    length: 'Width',
-    position: 'Left',
-  },
-  y: {
-    length: 'Height',
-    position: 'Top',
-  },
-};
+var createScrollInfo = () => ({ time: 0, x: createAxisInfo(), y: createAxisInfo(), });
+var keys = { x: { length: 'Width', position: 'Left', }, y: { length: 'Height', position: 'Top', }, };
 function updateAxisInfo(element, axisName, info, time22,) {
   const axis = info[axisName];
-  const {
-    length,
-    position,
-  } = keys[axisName];
+  const { length, position, } = keys[axisName];
   const prev = axis.current;
   const prevTime = info.time;
   axis.current = element['scroll' + position];
@@ -8357,10 +6340,7 @@ function updateScrollInfo(element, info, time22,) {
   info.time = time22;
 }
 function calcInset(element, container,) {
-  const inset2 = {
-    x: 0,
-    y: 0,
-  };
+  const inset2 = { x: 0, y: 0, };
   let current = element;
   while (current && current !== container) {
     if (current instanceof HTMLElement) {
@@ -8374,60 +6354,34 @@ function calcInset(element, container,) {
       inset2.x += svgBoundingBox.left - parentBoundingBox.left;
       inset2.y += svgBoundingBox.top - parentBoundingBox.top;
     } else if (current instanceof SVGGraphicsElement) {
-      const {
-        x,
-        y,
-      } = current.getBBox();
+      const { x, y, } = current.getBBox();
       inset2.x += x;
       inset2.y += y;
       let svg = null;
       let parent = current.parentNode;
       while (!svg) {
-        if (parent.tagName === 'svg') {
-          svg = parent;
-        }
+        if (parent.tagName === 'svg') svg = parent;
         parent = current.parentNode;
       }
       current = svg;
-    } else {
-      break;
-    }
+    } else break;
   }
   return inset2;
 }
-var ScrollOffset = {
-  Enter: [[0, 1,], [1, 1,],],
-  Exit: [[0, 0,], [1, 0,],],
-  Any: [[1, 0,], [0, 1,],],
-  All: [[0, 0,], [1, 1,],],
-};
-var namedEdges = {
-  start: 0,
-  center: 0.5,
-  end: 1,
-};
+var ScrollOffset = { Enter: [[0, 1,], [1, 1,],], Exit: [[0, 0,], [1, 0,],], Any: [[1, 0,], [0, 1,],], All: [[0, 0,], [1, 1,],], };
+var namedEdges = { start: 0, center: 0.5, end: 1, };
 function resolveEdge(edge, length, inset2 = 0,) {
   let delta = 0;
-  if (namedEdges[edge] !== void 0) {
-    edge = namedEdges[edge];
-  }
+  if (namedEdges[edge] !== void 0) edge = namedEdges[edge];
   if (typeof edge === 'string') {
     const asNumber2 = parseFloat(edge,);
-    if (edge.endsWith('px',)) {
-      delta = asNumber2;
-    } else if (edge.endsWith('%',)) {
-      edge = asNumber2 / 100;
-    } else if (edge.endsWith('vw',)) {
-      delta = asNumber2 / 100 * document.documentElement.clientWidth;
-    } else if (edge.endsWith('vh',)) {
-      delta = asNumber2 / 100 * document.documentElement.clientHeight;
-    } else {
-      edge = asNumber2;
-    }
-  }
-  if (typeof edge === 'number') {
-    delta = length * edge;
+    if (edge.endsWith('px',)) delta = asNumber2;
+    else if (edge.endsWith('%',)) edge = asNumber2 / 100;
+    else if (edge.endsWith('vw',)) delta = asNumber2 / 100 * document.documentElement.clientWidth;
+    else if (edge.endsWith('vh',)) delta = asNumber2 / 100 * document.documentElement.clientHeight;
+    else edge = asNumber2;
   }
+  if (typeof edge === 'number') delta = length * edge;
   return inset2 + delta;
 }
 var defaultOffset2 = [0, 0,];
@@ -8435,58 +6389,33 @@ function resolveOffset(offset, containerLength, targetLength, targetInset,) {
   let offsetDefinition = Array.isArray(offset,) ? offset : defaultOffset2;
   let targetPoint = 0;
   let containerPoint = 0;
-  if (typeof offset === 'number') {
-    offsetDefinition = [offset, offset,];
-  } else if (typeof offset === 'string') {
+  if (typeof offset === 'number') offsetDefinition = [offset, offset,];
+  else if (typeof offset === 'string') {
     offset = offset.trim();
-    if (offset.includes(' ',)) {
-      offsetDefinition = offset.split(' ',);
-    } else {
-      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`,];
-    }
+    if (offset.includes(' ',)) offsetDefinition = offset.split(' ',);
+    else offsetDefinition = [offset, namedEdges[offset] ? offset : `0`,];
   }
   targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset,);
   containerPoint = resolveEdge(offsetDefinition[1], containerLength,);
   return targetPoint - containerPoint;
 }
-var point = {
-  x: 0,
-  y: 0,
-};
+var point = { x: 0, y: 0, };
 function getTargetSize(target,) {
-  return 'getBBox' in target && target.tagName !== 'svg' ? target.getBBox() : {
-    width: target.clientWidth,
-    height: target.clientHeight,
-  };
+  return 'getBBox' in target && target.tagName !== 'svg' ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight, };
 }
 function resolveOffsets(container, info, options,) {
-  const {
-    offset: offsetDefinition = ScrollOffset.All,
-  } = options;
-  const {
-    target = container,
-    axis = 'y',
-  } = options;
+  const { offset: offsetDefinition = ScrollOffset.All, } = options;
+  const { target = container, axis = 'y', } = options;
   const lengthLabel = axis === 'y' ? 'height' : 'width';
   const inset2 = target !== container ? calcInset(target, container,) : point;
-  const targetSize = target === container
-    ? {
-      width: container.scrollWidth,
-      height: container.scrollHeight,
-    }
-    : getTargetSize(target,);
-  const containerSize = {
-    width: container.clientWidth,
-    height: container.clientHeight,
-  };
+  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight, } : getTargetSize(target,);
+  const containerSize = { width: container.clientWidth, height: container.clientHeight, };
   info[axis].offset.length = 0;
   let hasChanged = !info[axis].interpolate;
   const numOffsets = offsetDefinition.length;
   for (let i = 0; i < numOffsets; i++) {
     const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset2[axis],);
-    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
-      hasChanged = true;
-    }
+    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) hasChanged = true;
     info[axis].offset[i] = offset;
   }
   if (hasChanged) {
@@ -8524,9 +6453,7 @@ function createOnScrollHandler(element, onScroll, info, options = {},) {
     measure: () => measure(element, options.target, info,),
     update: (time22) => {
       updateScrollInfo(element, info, time22,);
-      if (options.offset || options.target) {
-        resolveOffsets(element, info, options,);
-      }
+      if (options.offset || options.target) resolveOffsets(element, info, options,);
     },
     notify: () => onScroll(info,),
   };
@@ -8535,10 +6462,7 @@ var scrollListeners = /* @__PURE__ */ new WeakMap();
 var resizeListeners = /* @__PURE__ */ new WeakMap();
 var onScrollHandlers = /* @__PURE__ */ new WeakMap();
 var getEventTarget = (element) => element === document.documentElement ? window : element;
-function scrollInfo(onScroll, {
-  container = document.documentElement,
-  ...options
-} = {},) {
+function scrollInfo(onScroll, { container = document.documentElement, ...options } = {},) {
   let containerHandlers = onScrollHandlers.get(container,);
   if (!containerHandlers) {
     containerHandlers = /* @__PURE__ */ new Set();
@@ -8552,9 +6476,7 @@ function scrollInfo(onScroll, {
       for (const handler of containerHandlers) handler.measure();
     };
     const updateAll = () => {
-      for (const handler of containerHandlers) {
-        handler.update(frameData.timestamp,);
-      }
+      for (const handler of containerHandlers) handler.update(frameData.timestamp,);
     };
     const notifyAll2 = () => {
       for (const handler of containerHandlers) handler.notify();
@@ -8566,15 +6488,9 @@ function scrollInfo(onScroll, {
     };
     scrollListeners.set(container, listener2,);
     const target = getEventTarget(container,);
-    window.addEventListener('resize', listener2, {
-      passive: true,
-    },);
-    if (container !== document.documentElement) {
-      resizeListeners.set(container, resize(container, listener2,),);
-    }
-    target.addEventListener('scroll', listener2, {
-      passive: true,
-    },);
+    window.addEventListener('resize', listener2, { passive: true, },);
+    if (container !== document.documentElement) resizeListeners.set(container, resize(container, listener2,),);
+    target.addEventListener('scroll', listener2, { passive: true, },);
   }
   const listener = scrollListeners.get(container,);
   frame.read(listener, false, true,);
@@ -8606,21 +6522,13 @@ var createScrollMotionValues = () => ({
   scrollXProgress: motionValue(0,),
   scrollYProgress: motionValue(0,),
 });
-function useScroll({
-  container,
-  target,
-  layoutEffect = true,
-  ...options
-} = {},) {
+function useScroll({ container, target, layoutEffect = true, ...options } = {},) {
   const values = useConstant(createScrollMotionValues,);
   const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : useEffect;
   useLifecycleEffect(() => {
     refWarning('target', target,);
     refWarning('container', container,);
-    return scrollInfo(({
-      x,
-      y,
-    },) => {
+    return scrollInfo(({ x, y, },) => {
       values.scrollX.set(x.current,);
       values.scrollXProgress.set(x.progress,);
       values.scrollY.set(y.current,);
@@ -8634,30 +6542,19 @@ function useScroll({
   return values;
 }
 function useElementScroll(ref,) {
-  if (false) {
-    warnOnce(false, 'useElementScroll is deprecated. Convert to useScroll({ container: ref }).',);
-  }
-  return useScroll({
-    container: ref,
-  },);
+  if (false) warnOnce(false, 'useElementScroll is deprecated. Convert to useScroll({ container: ref }).',);
+  return useScroll({ container: ref, },);
 }
 function useViewportScroll() {
-  if (false) {
-    warnOnce(false, 'useViewportScroll is deprecated. Convert to useScroll().',);
-  }
+  if (false) warnOnce(false, 'useViewportScroll is deprecated. Convert to useScroll().',);
   return useScroll();
 }
 function useAnimationFrame(callback,) {
   const initialTimestamp = useRef(0,);
-  const {
-    isStatic,
-  } = useContext3(MotionConfigContext,);
+  const { isStatic, } = useContext3(MotionConfigContext,);
   useEffect(() => {
     if (isStatic) return;
-    const provideTimeSinceStart = ({
-      timestamp,
-      delta,
-    },) => {
+    const provideTimeSinceStart = ({ timestamp, delta, },) => {
       if (!initialTimestamp.current) initialTimestamp.current = timestamp;
       callback(timestamp - initialTimestamp.current, delta,);
     };
@@ -8681,9 +6578,7 @@ var WillChangeMotionValue = class extends MotionValue {
     if (transformProps.has(name,)) {
       this.transforms.add(name,);
       memberName = 'transform';
-    } else if (!name.startsWith('origin',) && !isCSSVariableName(name,) && name !== 'willChange') {
-      memberName = camelToDash(name,);
-    }
+    } else if (!name.startsWith('origin',) && !isCSSVariableName(name,) && name !== 'willChange') memberName = camelToDash(name,);
     if (memberName) {
       addUniqueItem(this.members, memberName,);
       this.update();
@@ -8692,12 +6587,8 @@ var WillChangeMotionValue = class extends MotionValue {
   remove(name,) {
     if (transformProps.has(name,)) {
       this.transforms.delete(name,);
-      if (!this.transforms.size) {
-        removeItem(this.members, 'transform',);
-      }
-    } else {
-      removeItem(this.members, camelToDash(name,),);
-    }
+      if (!this.transforms.size) removeItem(this.members, 'transform',);
+    } else removeItem(this.members, camelToDash(name,),);
     this.update();
   }
   update() {
@@ -8717,16 +6608,10 @@ function useReducedMotion() {
 }
 function useReducedMotionConfig() {
   const reducedMotionPreference = useReducedMotion();
-  const {
-    reducedMotion,
-  } = useContext3(MotionConfigContext,);
-  if (reducedMotion === 'never') {
-    return false;
-  } else if (reducedMotion === 'always') {
-    return true;
-  } else {
-    return reducedMotionPreference;
-  }
+  const { reducedMotion, } = useContext3(MotionConfigContext,);
+  if (reducedMotion === 'never') return false;
+  else if (reducedMotion === 'always') return true;
+  else return reducedMotionPreference;
 }
 function stopAnimation(visualElement,) {
   visualElement.values.forEach((value) => value.stop());
@@ -8746,9 +6631,7 @@ function animationControls() {
       );
       const animations2 = [];
       subscribers.forEach((visualElement) => {
-        animations2.push(animateVisualElement(visualElement, definition, {
-          transitionOverride,
-        },),);
+        animations2.push(animateVisualElement(visualElement, definition, { transitionOverride, },),);
       },);
       return Promise.all(animations2,);
     },
@@ -8783,14 +6666,10 @@ var wrap = (min, max, v,) => {
 function observeTimeline(update, timeline,) {
   let prevProgress;
   const onFrame = () => {
-    const {
-      currentTime,
-    } = timeline;
+    const { currentTime, } = timeline;
     const percentage = currentTime === null ? 0 : currentTime.value;
     const progress2 = percentage / 100;
-    if (prevProgress !== progress2) {
-      update(progress2,);
-    }
+    if (prevProgress !== progress2) update(progress2,);
     prevProgress = progress2;
   };
   frame.update(onFrame, true,);
@@ -8803,23 +6682,20 @@ var GroupPlaybackControls = class {
   }
   then(onResolve, onReject,) {
     return Promise.all(this.animations,).then(onResolve,).catch(onReject,);
-  }
-  /**
+  } /**
    * TODO: Filter out cancelled or stopped animations before returning
    */
+
   getAll(propName,) {
     return this.animations[0][propName];
   }
   setAll(propName, newValue,) {
-    for (let i = 0; i < this.animations.length; i++) {
-      this.animations[i][propName] = newValue;
-    }
+    for (let i = 0; i < this.animations.length; i++) this.animations[i][propName] = newValue;
   }
   attachTimeline(timeline,) {
     const cancelAll = this.animations.map((animation) => {
-      if (supportsScrollTimeline() && animation.attachTimeline) {
-        animation.attachTimeline(timeline,);
-      } else {
+      if (supportsScrollTimeline() && animation.attachTimeline) animation.attachTimeline(timeline,);
+      else {
         animation.pause();
         return observeTimeline((progress2) => {
           animation.time = animation.duration * progress2;
@@ -8847,9 +6723,7 @@ var GroupPlaybackControls = class {
   }
   get duration() {
     let max = 0;
-    for (let i = 0; i < this.animations.length; i++) {
-      max = Math.max(max, this.animations[i].duration,);
-    }
+    for (let i = 0; i < this.animations.length; i++) max = Math.max(max, this.animations[i].duration,);
     return max;
   }
   runAll(methodName,) {
@@ -8878,32 +6752,16 @@ function createVisualElement(element,) {
   const options = {
     presenceContext: null,
     props: {},
-    visualState: {
-      renderState: {
-        transform: {},
-        transformOrigin: {},
-        style: {},
-        vars: {},
-        attrs: {},
-      },
-      latestValues: {},
-    },
+    visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {}, }, latestValues: {}, },
   };
   const node = isSVGElement(element,)
-    ? new SVGVisualElement(options, {
-      enableHardwareAcceleration: false,
-    },)
-    : new HTMLVisualElement(options, {
-      enableHardwareAcceleration: true,
-    },);
+    ? new SVGVisualElement(options, { enableHardwareAcceleration: false, },)
+    : new HTMLVisualElement(options, { enableHardwareAcceleration: true, },);
   node.mount(element,);
   visualElementStore.set(element, node,);
 }
 function createGeneratorEasing(options, scale2 = 100,) {
-  const generator = spring({
-    keyframes: [0, scale2,],
-    ...options,
-  },);
+  const generator = spring({ keyframes: [0, scale2,], ...options, },);
   const duration = Math.min(calcGeneratorDuration(generator,), maxGeneratorDuration,);
   return {
     type: 'keyframes',
@@ -8913,15 +6771,10 @@ function createGeneratorEasing(options, scale2 = 100,) {
 }
 function calcNextTime(current, next, prev, labels,) {
   var _a;
-  if (typeof next === 'number') {
-    return next;
-  } else if (next.startsWith('-',) || next.startsWith('+',)) {
-    return Math.max(0, current + parseFloat(next,),);
-  } else if (next === '<') {
-    return prev;
-  } else {
-    return (_a = labels.get(next,)) !== null && _a !== void 0 ? _a : current;
-  }
+  if (typeof next === 'number') return next;
+  else if (next.startsWith('-',) || next.startsWith('+',)) return Math.max(0, current + parseFloat(next,),);
+  else if (next === '<') return prev;
+  else return (_a = labels.get(next,)) !== null && _a !== void 0 ? _a : current;
 }
 function getEasingForSegment(easing, i,) {
   return isEasingArray(easing,) ? easing[wrap(0, easing.length, i,)] : easing;
@@ -8938,11 +6791,7 @@ function eraseKeyframes(sequence2, startTime, endTime,) {
 function addKeyframes(sequence2, keyframes2, easing, offset, startTime, endTime,) {
   eraseKeyframes(sequence2, startTime, endTime,);
   for (let i = 0; i < keyframes2.length; i++) {
-    sequence2.push({
-      value: keyframes2[i],
-      at: mixNumber(startTime, endTime, offset[i],),
-      easing: getEasingForSegment(easing, i,),
-    },);
+    sequence2.push({ value: keyframes2[i], at: mixNumber(startTime, endTime, offset[i],), easing: getEasingForSegment(easing, i,), },);
   }
 }
 function compareByTime(a, b,) {
@@ -8950,15 +6799,10 @@ function compareByTime(a, b,) {
     if (a.value === null) return 1;
     if (b.value === null) return -1;
     return 0;
-  } else {
-    return a.at - b.at;
-  }
+  } else return a.at - b.at;
 }
 var defaultSegmentEasing = 'easeInOut';
-function createAnimationsFromSequence(sequence2, {
-  defaultTransition = {},
-  ...sequenceTransition
-} = {}, scope,) {
+function createAnimationsFromSequence(sequence2, { defaultTransition = {}, ...sequenceTransition } = {}, scope,) {
   const defaultDuration = defaultTransition.duration || 0.3;
   const animationDefinitions = /* @__PURE__ */ new Map();
   const sequences = /* @__PURE__ */ new Map();
@@ -8977,22 +6821,13 @@ function createAnimationsFromSequence(sequence2, {
       continue;
     }
     let [subject, keyframes2, transition = {},] = segment;
-    if (transition.at !== void 0) {
-      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels,);
-    }
+    if (transition.at !== void 0) currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels,);
     let maxDuration32 = 0;
     const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0,) => {
       const valueKeyframesAsList = keyframesAsList(valueKeyframes,);
-      const {
-        delay: delay2 = 0,
-        times = defaultOffset(valueKeyframesAsList,),
-        type = 'keyframes',
-        ...remainingTransition
-      } = valueTransition;
-      let {
-        ease: ease2 = defaultTransition.ease || 'easeOut',
-        duration,
-      } = valueTransition;
+      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList,), type = 'keyframes', ...remainingTransition } =
+        valueTransition;
+      let { ease: ease2 = defaultTransition.ease || 'easeOut', duration, } = valueTransition;
       const calculatedDelay = typeof delay2 === 'function' ? delay2(elementIndex, numElements,) : delay2;
       const numKeyframes = valueKeyframesAsList.length;
       if (numKeyframes <= 2 && type === 'spring') {
@@ -9001,12 +6836,8 @@ function createAnimationsFromSequence(sequence2, {
           const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
           absoluteDelta = Math.abs(delta,);
         }
-        const springTransition = {
-          ...remainingTransition,
-        };
-        if (duration !== void 0) {
-          springTransition.duration = secondsToMilliseconds(duration,);
-        }
+        const springTransition = { ...remainingTransition, };
+        if (duration !== void 0) springTransition.duration = secondsToMilliseconds(duration,);
         const springEasing = createGeneratorEasing(springTransition, absoluteDelta,);
         ease2 = springEasing.ease;
         duration = springEasing.duration;
@@ -9014,9 +6845,7 @@ function createAnimationsFromSequence(sequence2, {
       duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
       const startTime = currentTime + calculatedDelay;
       const targetTime = startTime + duration;
-      if (times.length === 1 && times[0] === 0) {
-        times[1] = 1;
-      }
+      if (times.length === 1 && times[0] === 0) times[1] = 1;
       const remainder = times.length - valueKeyframesAsList.length;
       remainder > 0 && fillOffset(times, remainder,);
       valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null,);
@@ -9057,11 +6886,7 @@ function createAnimationsFromSequence(sequence2, {
       const valueOffset = [];
       const valueEasing = [];
       for (let i = 0; i < valueSequence.length; i++) {
-        const {
-          at,
-          value,
-          easing,
-        } = valueSequence[i];
+        const { at, value, easing, } = valueSequence[i];
         keyframes2.push(value,);
         valueOffset.push(progress(0, totalDuration, at,),);
         valueEasing.push(easing || 'easeOut',);
@@ -9075,12 +6900,7 @@ function createAnimationsFromSequence(sequence2, {
         valueOffset.push(1,);
         keyframes2.push(null,);
       }
-      if (!animationDefinitions.has(element,)) {
-        animationDefinitions.set(element, {
-          keyframes: {},
-          transition: {},
-        },);
-      }
+      if (!animationDefinitions.has(element,)) animationDefinitions.set(element, { keyframes: {}, transition: {}, },);
       const definition = animationDefinitions.get(element,);
       definition.keyframes[key7] = keyframes2;
       definition.transition[key7] = {
@@ -9106,14 +6926,7 @@ function keyframesAsList(keyframes2,) {
   return Array.isArray(keyframes2,) ? keyframes2 : [keyframes2,];
 }
 function getValueTransition2(transition, key7,) {
-  return transition[key7]
-    ? {
-      ...transition,
-      ...transition[key7],
-    }
-    : {
-      ...transition,
-    };
+  return transition[key7] ? { ...transition, ...transition[key7], } : { ...transition, };
 }
 var isNumber = (keyframe) => typeof keyframe === 'number';
 var isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber,);
@@ -9124,20 +6937,11 @@ function animateElements(elementOrSelector, keyframes2, options, scope,) {
   const animations2 = [];
   for (let i = 0; i < numElements; i++) {
     const element = elements[i];
-    if (!visualElementStore.has(element,)) {
-      createVisualElement(element,);
-    }
+    if (!visualElementStore.has(element,)) createVisualElement(element,);
     const visualElement = visualElementStore.get(element,);
-    const transition = {
-      ...options,
-    };
-    if (typeof transition.delay === 'function') {
-      transition.delay = transition.delay(i, numElements,);
-    }
-    animations2.push(...animateTarget(visualElement, {
-      ...keyframes2,
-      transition,
-    }, {},),);
+    const transition = { ...options, };
+    if (typeof transition.delay === 'function') transition.delay = transition.delay(i, numElements,);
+    animations2.push(...animateTarget(visualElement, { ...keyframes2, transition, }, {},),);
   }
   return new GroupPlaybackControls(animations2,);
 }
@@ -9145,16 +6949,10 @@ var isSequence = (value) => Array.isArray(value,) && Array.isArray(value[0],);
 function animateSequence(sequence2, options, scope,) {
   const animations2 = [];
   const animationDefinitions = createAnimationsFromSequence(sequence2, options, scope,);
-  animationDefinitions.forEach(({
-    keyframes: keyframes2,
-    transition,
-  }, subject,) => {
+  animationDefinitions.forEach(({ keyframes: keyframes2, transition, }, subject,) => {
     let animation;
-    if (isMotionValue(subject,)) {
-      animation = animateSingleValue(subject, keyframes2.default, transition.default,);
-    } else {
-      animation = animateElements(subject, keyframes2, transition,);
-    }
+    if (isMotionValue(subject,)) animation = animateSingleValue(subject, keyframes2.default, transition.default,);
+    else animation = animateElements(subject, keyframes2, transition,);
     animations2.push(animation,);
   },);
   return new GroupPlaybackControls(animations2,);
@@ -9162,26 +6960,17 @@ function animateSequence(sequence2, options, scope,) {
 var createScopedAnimate = (scope) => {
   function scopedAnimate(valueOrElementOrSequence, keyframes2, options,) {
     let animation;
-    if (isSequence(valueOrElementOrSequence,)) {
-      animation = animateSequence(valueOrElementOrSequence, keyframes2, scope,);
-    } else if (isDOMKeyframes(keyframes2,)) {
-      animation = animateElements(valueOrElementOrSequence, keyframes2, options, scope,);
-    } else {
-      animation = animateSingleValue(valueOrElementOrSequence, keyframes2, options,);
-    }
-    if (scope) {
-      scope.animations.push(animation,);
-    }
+    if (isSequence(valueOrElementOrSequence,)) animation = animateSequence(valueOrElementOrSequence, keyframes2, scope,);
+    else if (isDOMKeyframes(keyframes2,)) animation = animateElements(valueOrElementOrSequence, keyframes2, options, scope,);
+    else animation = animateSingleValue(valueOrElementOrSequence, keyframes2, options,);
+    if (scope) scope.animations.push(animation,);
     return animation;
   }
   return scopedAnimate;
 };
 var animate = createScopedAnimate();
 function useAnimate() {
-  const scope = useConstant(() => ({
-    current: null,
-    animations: [],
-  }));
+  const scope = useConstant(() => ({ current: null, animations: [], }));
   const animate22 = useConstant(() => createScopedAnimate(scope,));
   useUnmountEffect(() => {
     scope.animations.forEach((animation) => animation.stop());
@@ -9197,24 +6986,19 @@ var useAnimation = useAnimationControls;
 function useCycle(...items) {
   const index = useRef(0,);
   const [item, setItem,] = useState(items[index.current],);
-  const runCycle = useCallback((next) => {
-    index.current = typeof next !== 'number' ? wrap(0, items.length, index.current + 1,) : next;
-    setItem(items[index.current],);
-  }, // The array will change on each call, but by putting items.length at
-  // the front of this array, we guarantee the dependency comparison will match up
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  [items.length, ...items,],);
+  const runCycle = useCallback(
+    (next) => {
+      index.current = typeof next !== 'number' ? wrap(0, items.length, index.current + 1,) : next;
+      setItem(items[index.current],);
+    }, // The array will change on each call, but by putting items.length at
+    // the front of this array, we guarantee the dependency comparison will match up
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [items.length, ...items,],
+  );
   return [item, runCycle,];
 }
-var thresholds = {
-  some: 0,
-  all: 1,
-};
-function inView(elementOrSelector, onStart, {
-  root,
-  margin: rootMargin,
-  amount = 'some',
-} = {},) {
+var thresholds = { some: 0, all: 1, };
+function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = 'some', } = {},) {
   const elements = resolveElements(elementOrSelector,);
   const activeIntersections = /* @__PURE__ */ new WeakMap();
   const onIntersectionChange = (entries) => {
@@ -9223,11 +7007,8 @@ function inView(elementOrSelector, onStart, {
       if (entry.isIntersecting === Boolean(onEnd,)) return;
       if (entry.isIntersecting) {
         const newOnEnd = onStart(entry,);
-        if (typeof newOnEnd === 'function') {
-          activeIntersections.set(entry.target, newOnEnd,);
-        } else {
-          observer2.unobserve(entry.target,);
-        }
+        if (typeof newOnEnd === 'function') activeIntersections.set(entry.target, newOnEnd,);
+        else observer2.unobserve(entry.target,);
       } else if (onEnd) {
         onEnd(entry,);
         activeIntersections.delete(entry.target,);
@@ -9242,12 +7023,7 @@ function inView(elementOrSelector, onStart, {
   elements.forEach((element) => observer2.observe(element,));
   return () => observer2.disconnect();
 }
-function useInView(ref, {
-  root,
-  margin,
-  amount,
-  once = false,
-} = {},) {
+function useInView(ref, { root, margin, amount, once = false, } = {},) {
   const [isInView, setInView,] = useState(false,);
   useEffect(() => {
     if (!ref.current || once && isInView) return;
@@ -9255,11 +7031,7 @@ function useInView(ref, {
       setInView(true,);
       return once ? void 0 : () => setInView(false,);
     };
-    const options = {
-      root: root && root.current || void 0,
-      margin,
-      amount,
-    };
+    const options = { root: root && root.current || void 0, margin, amount, };
     return inView(ref.current, onEnter, options,);
   }, [root, ref, margin, once, amount,],);
   return isInView;
@@ -9267,17 +7039,16 @@ function useInView(ref, {
 var DragControls = class {
   constructor() {
     this.componentControls = /* @__PURE__ */ new Set();
-  }
-  /**
+  } /**
    * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
    *
    * @internal
    */
+
   subscribe(controls,) {
     this.componentControls.add(controls,);
     return () => this.componentControls.delete(controls,);
-  }
-  /**
+  } /**
    * Start a drag gesture on every `motion` component that has this set of drag controls
    * passed into it via the `dragControls` prop.
    *
@@ -9292,6 +7063,7 @@ var DragControls = class {
    *
    * @public
    */
+
   start(event, options,) {
     this.componentControls.forEach((controls) => {
       controls.start(event.nativeEvent || event, options,);
@@ -9305,18 +7077,14 @@ function useDragControls() {
 function useDomEvent(ref, eventName, handler, options,) {
   useEffect(() => {
     const element = ref.current;
-    if (handler && element) {
-      return addDomEvent(element, eventName, handler, options,);
-    }
+    if (handler && element) return addDomEvent(element, eventName, handler, options,);
   }, [ref, eventName, handler, options,],);
 }
 function isMotionComponent(component,) {
   return component !== null && typeof component === 'object' && motionComponentSymbol in component;
 }
 function unwrapMotionComponent(component,) {
-  if (isMotionComponent(component,)) {
-    return component[motionComponentSymbol];
-  }
+  if (isMotionComponent(component,)) return component[motionComponentSymbol];
   return void 0;
 }
 function useInstantLayoutTransition() {
@@ -9367,13 +7135,8 @@ function handoffOptimizedAppearAnimation(elementId, valueName, _value, _frame,)
   const optimisedValueName = transformProps.has(valueName,) ? 'transform' : valueName;
   const storeId = appearStoreId(elementId, optimisedValueName,);
   const optimisedAnimation = appearAnimationStore.get(storeId,);
-  if (!optimisedAnimation) {
-    return null;
-  }
-  const {
-    animation,
-    startTime,
-  } = optimisedAnimation;
+  if (!optimisedAnimation) return null;
+  const { animation, startTime, } = optimisedAnimation;
   const cancelAnimation = () => {
     appearAnimationStore.delete(storeId,);
     try {
@@ -9384,9 +7147,7 @@ function handoffOptimizedAppearAnimation(elementId, valueName, _value, _frame,)
     cancelAnimation();
     return null;
   } else {
-    if (handoffFrameTime === void 0) {
-      handoffFrameTime = performance.now();
-    }
+    if (handoffFrameTime === void 0) handoffFrameTime = performance.now();
     return handoffFrameTime - startTime || 0;
   }
 }
@@ -9405,20 +7166,11 @@ function startOptimizedAppearAnimation(element, name, keyframes2, options, onRea
     readyAnimation = animateStyle(element, name, [keyframes2[0], keyframes2[0],], /**
      * 10 secs is basically just a super-safe duration to give Chrome
      * long enough to get the animation ready.
-     */
-    {
-      duration: 1e4,
-      ease: 'linear',
-    },);
-    appearAnimationStore.set(storeId, {
-      animation: readyAnimation,
-      startTime: null,
-    },);
+     */ { duration: 1e4, ease: 'linear', },);
+    appearAnimationStore.set(storeId, { animation: readyAnimation, startTime: null, },);
     if (!window.HandoffCancelAllAnimations) {
       window.HandoffCancelAllAnimations = () => {
-        appearAnimationStore.forEach(({
-          animation,
-        },) => {
+        appearAnimationStore.forEach(({ animation, },) => {
           animation.cancel();
         },);
         appearAnimationStore.clear();
@@ -9429,21 +7181,13 @@ function startOptimizedAppearAnimation(element, name, keyframes2, options, onRea
   const startAnimation2 = () => {
     readyAnimation.cancel();
     const appearAnimation = animateStyle(element, name, keyframes2, options,);
-    if (startFrameTime === void 0) {
-      startFrameTime = performance.now();
-    }
+    if (startFrameTime === void 0) startFrameTime = performance.now();
     appearAnimation.startTime = startFrameTime;
-    appearAnimationStore.set(storeId, {
-      animation: appearAnimation,
-      startTime: startFrameTime,
-    },);
+    appearAnimationStore.set(storeId, { animation: appearAnimation, startTime: startFrameTime, },);
     if (onReady) onReady(appearAnimation,);
   };
-  if (readyAnimation.ready) {
-    readyAnimation.ready.then(startAnimation2,).catch(noop,);
-  } else {
-    startAnimation2();
-  }
+  if (readyAnimation.ready) readyAnimation.ready.then(startAnimation2,).catch(noop,);
+  else startAnimation2();
 }
 var createObject = () => ({});
 var StateVisualElement = class extends VisualElement {
@@ -9467,35 +7211,18 @@ var StateVisualElement = class extends VisualElement {
   sortInstanceNodePosition() {
     return 0;
   }
-  makeTargetAnimatableFromInstance({
-    transition,
-    transitionEnd,
-    ...target
-  },) {
+  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target },) {
     const origin = getOrigin(target, transition || {}, this,);
     checkTargetForNewValues(this, target, origin,);
-    return {
-      transition,
-      transitionEnd,
-      ...target,
-    };
+    return { transition, transitionEnd, ...target, };
   }
 };
-var useVisualState = makeUseVisualState({
-  scrapeMotionValuesFromProps: createObject,
-  createRenderState: createObject,
-},);
+var useVisualState = makeUseVisualState({ scrapeMotionValuesFromProps: createObject, createRenderState: createObject, },);
 function useAnimatedState(initialState2,) {
   const [animationState, setAnimationState,] = useState(initialState2,);
   const visualState = useVisualState({}, false,);
   const element = useConstant(() => {
-    return new StateVisualElement({
-      props: {},
-      visualState,
-      presenceContext: null,
-    }, {
-      initialState: initialState2,
-    },);
+    return new StateVisualElement({ props: {}, visualState, presenceContext: null, }, { initialState: initialState2, },);
   },);
   useEffect(() => {
     element.mount({},);
@@ -9504,9 +7231,7 @@ function useAnimatedState(initialState2,) {
   useEffect(() => {
     element.update({
       onUpdate: (v) => {
-        setAnimationState({
-          ...v,
-        },);
+        setAnimationState({ ...v, },);
       },
     }, null,);
   }, [setAnimationState, element,],);
@@ -9521,9 +7246,7 @@ var hasWarned = false;
 function useInvertedScale(scale2,) {
   let parentScaleX = useMotionValue(1,);
   let parentScaleY = useMotionValue(1,);
-  const {
-    visualElement,
-  } = useContext3(MotionContext,);
+  const { visualElement, } = useContext3(MotionContext,);
   invariant(
     !!(scale2 || visualElement),
     'If no scale values are provided, useInvertedScale must be used within a child of another motion component.',
@@ -9539,72 +7262,39 @@ function useInvertedScale(scale2,) {
   }
   const scaleX = useTransform(parentScaleX, invertScale,);
   const scaleY = useTransform(parentScaleY, invertScale,);
-  return {
-    scaleX,
-    scaleY,
-  };
+  return { scaleX, scaleY, };
 }
-function scrollTimelineFallback({
-  source,
-  axis = 'y',
-},) {
-  const currentTime = {
-    value: 0,
-  };
+function scrollTimelineFallback({ source, axis = 'y', },) {
+  const currentTime = { value: 0, };
   const cancel = scrollInfo((info) => {
     currentTime.value = info[axis].progress * 100;
-  }, {
-    container: source,
-    axis,
-  },);
-  return {
-    currentTime,
-    cancel,
-  };
+  }, { container: source, axis, },);
+  return { currentTime, cancel, };
 }
 var timelineCache = /* @__PURE__ */ new Map();
-function getTimeline({
-  source = document.documentElement,
-  axis = 'y',
-} = {},) {
-  if (!timelineCache.has(source,)) {
-    timelineCache.set(source, {},);
-  }
+function getTimeline({ source = document.documentElement, axis = 'y', } = {},) {
+  if (!timelineCache.has(source,)) timelineCache.set(source, {},);
   const elementCache = timelineCache.get(source,);
   if (!elementCache[axis]) {
     elementCache[axis] = supportsScrollTimeline()
-      ? new ScrollTimeline({
-        source,
-        axis,
-      },)
-      : scrollTimelineFallback({
-        source,
-        axis,
-      },);
+      ? new ScrollTimeline({ source, axis, },)
+      : scrollTimelineFallback({ source, axis, },);
   }
   return elementCache[axis];
 }
 function scroll(onScroll, options,) {
   const timeline = getTimeline(options,);
-  if (typeof onScroll === 'function') {
-    return observeTimeline(onScroll, timeline,);
-  } else {
-    return onScroll.attachTimeline(timeline,);
-  }
+  if (typeof onScroll === 'function') return observeTimeline(onScroll, timeline,);
+  else return onScroll.attachTimeline(timeline,);
 }
 function getOriginIndex(from, total,) {
-  if (from === 'first') {
-    return 0;
-  } else {
+  if (from === 'first') return 0;
+  else {
     const lastIndex = total - 1;
     return from === 'last' ? lastIndex : lastIndex / 2;
   }
 }
-function stagger(duration = 0.1, {
-  startDelay = 0,
-  from = 0,
-  ease: ease2,
-} = {},) {
+function stagger(duration = 0.1, { startDelay = 0, from = 0, ease: ease2, } = {},) {
   return (i, total,) => {
     const fromIndex = typeof from === 'number' ? from : getOriginIndex(from, total,);
     const distance2 = Math.abs(fromIndex - i,);
@@ -9621,9 +7311,7 @@ var sync = frame;
 var cancelSync = stepsOrder.reduce((acc, key7,) => {
   acc[key7] = (process2) => cancelFrame(process2,);
   return acc;
-}, {},);
-
-// https :https://app.framerstatic.com/framer.2CYBC7FS.js
+}, {},); // https :https://app.framerstatic.com/framer.2CYBC7FS.js
 import { Component as Component2, } from 'react';
 import { jsx as _jsx5, jsxs as _jsxs, } from 'react/jsx-runtime';
 import { startTransition as startTransition2, } from 'react';
@@ -9633,7 +7321,6 @@ import { createRef, } from 'react';
 var require_eventemitter3 = __commonJS({
   '../../../node_modules/eventemitter3/index.js'(exports, module,) {
     'use strict';
-
     var has = Object.prototype.hasOwnProperty;
     var prefix2 = '~';
     function Events() {}
@@ -9647,11 +7334,8 @@ var require_eventemitter3 = __commonJS({
       this.once = once || false;
     }
     function addListener(emitter, event, fn, context, once,) {
-      if (typeof fn !== 'function') {
-        throw new TypeError('The listener must be a function',);
-      }
-      var listener = new EE(fn, context || emitter, once,),
-        evt = prefix2 ? prefix2 + event : event;
+      if (typeof fn !== 'function') throw new TypeError('The listener must be a function',);
+      var listener = new EE(fn, context || emitter, once,), evt = prefix2 ? prefix2 + event : event;
       if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
       else if (!emitter._events[evt].fn) emitter._events[evt].push(listener,);
       else emitter._events[evt] = [emitter._events[evt], listener,];
@@ -9666,31 +7350,21 @@ var require_eventemitter3 = __commonJS({
       this._eventsCount = 0;
     }
     EventEmitter2.prototype.eventNames = function eventNames() {
-      var names = [],
-        events2,
-        name;
+      var names = [], events2, name;
       if (this._eventsCount === 0) return names;
-      for (name in events2 = this._events) {
-        if (has.call(events2, name,)) names.push(prefix2 ? name.slice(1,) : name,);
-      }
-      if (Object.getOwnPropertySymbols) {
-        return names.concat(Object.getOwnPropertySymbols(events2,),);
-      }
+      for (name in events2 = this._events) if (has.call(events2, name,)) names.push(prefix2 ? name.slice(1,) : name,);
+      if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events2,),);
       return names;
     };
     EventEmitter2.prototype.listeners = function listeners(event,) {
-      var evt = prefix2 ? prefix2 + event : event,
-        handlers = this._events[evt];
+      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
       if (!handlers) return [];
       if (handlers.fn) return [handlers.fn,];
-      for (var i = 0, l = handlers.length, ee = new Array(l,); i < l; i++) {
-        ee[i] = handlers[i].fn;
-      }
+      for (var i = 0, l = handlers.length, ee = new Array(l,); i < l; i++) ee[i] = handlers[i].fn;
       return ee;
     };
     EventEmitter2.prototype.listenerCount = function listenerCount(event,) {
-      var evt = prefix2 ? prefix2 + event : event,
-        listeners = this._events[evt];
+      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
       if (!listeners) return 0;
       if (listeners.fn) return 1;
       return listeners.length;
@@ -9698,10 +7372,7 @@ var require_eventemitter3 = __commonJS({
     EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5,) {
       var evt = prefix2 ? prefix2 + event : event;
       if (!this._events[evt]) return false;
-      var listeners = this._events[evt],
-        len = arguments.length,
-        args,
-        i;
+      var listeners = this._events[evt], len = arguments.length, args, i;
       if (listeners.fn) {
         if (listeners.once) this.removeListener(event, listeners.fn, void 0, true,);
         switch (len) {
@@ -9718,13 +7389,10 @@ var require_eventemitter3 = __commonJS({
           case 6:
             return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5,), true;
         }
-        for (i = 1, args = new Array(len - 1,); i < len; i++) {
-          args[i - 1] = arguments[i];
-        }
+        for (i = 1, args = new Array(len - 1,); i < len; i++) args[i - 1] = arguments[i];
         listeners.fn.apply(listeners.context, args,);
       } else {
-        var length = listeners.length,
-          j;
+        var length = listeners.length, j;
         for (i = 0; i < length; i++) {
           if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true,);
           switch (len) {
@@ -9741,11 +7409,7 @@ var require_eventemitter3 = __commonJS({
               listeners[i].fn.call(listeners[i].context, a1, a2, a3,);
               break;
             default:
-              if (!args) {
-                for (j = 1, args = new Array(len - 1,); j < len; j++) {
-                  args[j - 1] = arguments[j];
-                }
-              }
+              if (!args) for (j = 1, args = new Array(len - 1,); j < len; j++) args[j - 1] = arguments[j];
               listeners[i].fn.apply(listeners[i].context, args,);
           }
         }
@@ -9767,9 +7431,7 @@ var require_eventemitter3 = __commonJS({
       }
       var listeners = this._events[evt];
       if (listeners.fn) {
-        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
-          clearEvent(this, evt,);
-        }
+        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt,);
       } else {
         for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
           if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
@@ -9796,9 +7458,7 @@ var require_eventemitter3 = __commonJS({
     EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
     EventEmitter2.prefixed = prefix2;
     EventEmitter2.EventEmitter = EventEmitter2;
-    if ('undefined' !== typeof module) {
-      module.exports = EventEmitter2;
-    }
+    if ('undefined' !== typeof module) module.exports = EventEmitter2;
   },
 },);
 var require_browser = __commonJS({
@@ -9814,28 +7474,20 @@ var require_browser = __commonJS({
     }
     (function () {
       try {
-        if (typeof setTimeout === 'function') {
-          cachedSetTimeout = setTimeout;
-        } else {
-          cachedSetTimeout = defaultSetTimout;
-        }
+        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
+        else cachedSetTimeout = defaultSetTimout;
       } catch (e) {
         cachedSetTimeout = defaultSetTimout;
       }
       try {
-        if (typeof clearTimeout === 'function') {
-          cachedClearTimeout = clearTimeout;
-        } else {
-          cachedClearTimeout = defaultClearTimeout;
-        }
+        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
+        else cachedClearTimeout = defaultClearTimeout;
       } catch (e) {
         cachedClearTimeout = defaultClearTimeout;
       }
     })();
     function runTimeout(fun,) {
-      if (cachedSetTimeout === setTimeout) {
-        return setTimeout(fun, 0,);
-      }
+      if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0,);
       if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
         cachedSetTimeout = setTimeout;
         return setTimeout(fun, 0,);
@@ -9851,9 +7503,7 @@ var require_browser = __commonJS({
       }
     }
     function runClearTimeout(marker,) {
-      if (cachedClearTimeout === clearTimeout) {
-        return clearTimeout(marker,);
-      }
+      if (cachedClearTimeout === clearTimeout) return clearTimeout(marker,);
       if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
         cachedClearTimeout = clearTimeout;
         return clearTimeout(marker,);
@@ -9873,34 +7523,21 @@ var require_browser = __commonJS({
     var currentQueue;
     var queueIndex = -1;
     function cleanUpNextTick() {
-      if (!draining || !currentQueue) {
-        return;
-      }
+      if (!draining || !currentQueue) return;
       draining = false;
-      if (currentQueue.length) {
-        queue = currentQueue.concat(queue,);
-      } else {
-        queueIndex = -1;
-      }
-      if (queue.length) {
-        drainQueue();
-      }
+      if (currentQueue.length) queue = currentQueue.concat(queue,);
+      else queueIndex = -1;
+      if (queue.length) drainQueue();
     }
     function drainQueue() {
-      if (draining) {
-        return;
-      }
+      if (draining) return;
       var timeout = runTimeout(cleanUpNextTick,);
       draining = true;
       var len = queue.length;
       while (len) {
         currentQueue = queue;
         queue = [];
-        while (++queueIndex < len) {
-          if (currentQueue) {
-            currentQueue[queueIndex].run();
-          }
-        }
+        while (++queueIndex < len) if (currentQueue) currentQueue[queueIndex].run();
         queueIndex = -1;
         len = queue.length;
       }
@@ -9910,15 +7547,9 @@ var require_browser = __commonJS({
     }
     process6.nextTick = function (fun,) {
       var args = new Array(arguments.length - 1,);
-      if (arguments.length > 1) {
-        for (var i = 1; i < arguments.length; i++) {
-          args[i - 1] = arguments[i];
-        }
-      }
+      if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
       queue.push(new Item2(fun, args,),);
-      if (queue.length === 1 && !draining) {
-        runTimeout(drainQueue,);
-      }
+      if (queue.length === 1 && !draining) runTimeout(drainQueue,);
     };
     function Item2(fun, array,) {
       this.fun = fun;
@@ -9963,7 +7594,6 @@ var require_browser = __commonJS({
 var require_react_is_production_min = __commonJS({
   '../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js'(exports,) {
     'use strict';
-
     var b = 'function' === typeof Symbol && Symbol.for;
     var c = b ? Symbol.for('react.element',) : 60103;
     var d = b ? Symbol.for('react.portal',) : 60106;
@@ -10078,18 +7708,13 @@ var require_react_is_production_min = __commonJS({
 var require_react_is = __commonJS({
   '../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js'(exports, module,) {
     'use strict';
-
-    if (true) {
-      module.exports = require_react_is_production_min();
-    } else {
-      module.exports = null;
-    }
+    if (true) module.exports = require_react_is_production_min();
+    else module.exports = null;
   },
 },);
 var require_hoist_non_react_statics_cjs = __commonJS({
   '../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js'(exports, module,) {
     'use strict';
-
     var reactIs = require_react_is();
     var REACT_STATICS = {
       childContextTypes: true,
@@ -10104,37 +7729,14 @@ var require_hoist_non_react_statics_cjs = __commonJS({
       propTypes: true,
       type: true,
     };
-    var KNOWN_STATICS = {
-      name: true,
-      length: true,
-      prototype: true,
-      caller: true,
-      callee: true,
-      arguments: true,
-      arity: true,
-    };
-    var FORWARD_REF_STATICS = {
-      '$$typeof': true,
-      render: true,
-      defaultProps: true,
-      displayName: true,
-      propTypes: true,
-    };
-    var MEMO_STATICS = {
-      '$$typeof': true,
-      compare: true,
-      defaultProps: true,
-      displayName: true,
-      propTypes: true,
-      type: true,
-    };
+    var KNOWN_STATICS = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true, };
+    var FORWARD_REF_STATICS = { '$$typeof': true, render: true, defaultProps: true, displayName: true, propTypes: true, };
+    var MEMO_STATICS = { '$$typeof': true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true, };
     var TYPE_STATICS = {};
     TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
     TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
     function getStatics(component,) {
-      if (reactIs.isMemo(component,)) {
-        return MEMO_STATICS;
-      }
+      if (reactIs.isMemo(component,)) return MEMO_STATICS;
       return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
     }
     var defineProperty = Object.defineProperty;
@@ -10152,9 +7754,7 @@ var require_hoist_non_react_statics_cjs = __commonJS({
           }
         }
         var keys3 = getOwnPropertyNames(sourceComponent,);
-        if (getOwnPropertySymbols) {
-          keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent,),);
-        }
+        if (getOwnPropertySymbols) keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent,),);
         var targetStatics = getStatics(targetComponent,);
         var sourceStatics = getStatics(sourceComponent,);
         for (var i = 0; i < keys3.length; ++i) {
@@ -10181,20 +7781,10 @@ var require_archy = __commonJS({
       if (prefix2 === void 0) prefix2 = '';
       if (!opts) opts = {};
       var chr = function (s,) {
-        var chars = {
-          '\u2502': '|',
-          '\u2514': '`',
-          '\u251C': '+',
-          '\u2500': '-',
-          '\u252C': '-',
-        };
+        var chars = { '\u2502': '|', '\u2514': '`', '\u251C': '+', '\u2500': '-', '\u252C': '-', };
         return opts.unicode === false ? chars[s] : s;
       };
-      if (typeof obj === 'string') {
-        obj = {
-          label: obj,
-        };
-      }
+      if (typeof obj === 'string') obj = { label: obj, };
       var nodes = obj.nodes || [];
       var lines = (obj.label || '').split('\n',);
       var splitter = '\n' + prefix2 + (nodes.length ? chr('\u2502',) : ' ') + ' ';
@@ -10226,7 +7816,6 @@ var require_fontfaceobserver_standalone = __commonJS({
             }
           },);
       }
-
       function t(a,) {
         this.a = document.createElement('div',);
         this.a.setAttribute('aria-hidden', 'true',);
@@ -10254,8 +7843,7 @@ var require_fontfaceobserver_standalone = __commonJS({
           b + ';';
       }
       function z(a,) {
-        var b = a.a.offsetWidth,
-          c = b + 100;
+        var b = a.a.offsetWidth, c = b + 100;
         a.f.style.width = c + 'px';
         a.c.scrollLeft = c;
         a.b.scrollLeft = a.b.scrollWidth + 100;
@@ -10271,7 +7859,6 @@ var require_fontfaceobserver_standalone = __commonJS({
         l(a.c, c,);
         z(a,);
       }
-
       function B(a, b,) {
         var c = b || {};
         this.family = a;
@@ -10279,10 +7866,7 @@ var require_fontfaceobserver_standalone = __commonJS({
         this.weight = c.weight || 'normal';
         this.stretch = c.stretch || 'normal';
       }
-      var C = null,
-        D = null,
-        E = null,
-        F = null;
+      var C = null, D = null, E = null, F = null;
       function G() {
         if (null === D) {
           if (J() && /Apple/.test(window.navigator.vendor,)) {
@@ -10310,11 +7894,7 @@ var require_fontfaceobserver_standalone = __commonJS({
         return [a.style, a.weight, K() ? a.stretch : '', '100px', b,].join(' ',);
       }
       B.prototype.load = function (a, b,) {
-        var c = this,
-          k = a || 'BESbswy',
-          r = 0,
-          n = b || 3e3,
-          H = (/* @__PURE__ */ new Date()).getTime();
+        var c = this, k = a || 'BESbswy', r = 0, n = b || 3e3, H = (/* @__PURE__ */ new Date()).getTime();
         return new Promise(function (a2, b2,) {
           if (J() && !G()) {
             var M = new Promise(function (a3, b3,) {
@@ -10404,9 +7984,7 @@ var require_fontfaceobserver_standalone = __commonJS({
   },
 },);
 function renderPage(Page4, defaultPageStyle,) {
-  const style = {
-    style: defaultPageStyle,
-  };
+  const style = { style: defaultPageStyle, };
   return React__default.isValidElement(Page4,) ? React__default.cloneElement(Page4, style,) : React__default.createElement(Page4, style,);
 }
 var NotFoundError = class extends Error {};
@@ -10414,45 +7992,28 @@ var ErrorBoundaryCaughtError = class extends Error {};
 var ErrorBoundary = class extends Component2 {
   constructor(props,) {
     super(props,);
-    this.state = {
-      error: void 0,
-      forceUpdateKey: props.forceUpdateKey,
-    };
+    this.state = { error: void 0, forceUpdateKey: props.forceUpdateKey, };
   }
   static getDerivedStateFromError(error,) {
-    return {
-      error,
-    };
-  }
-  /** Resets the error when forceUpdateKey gets bumped. */
+    return { error, };
+  } /** Resets the error when forceUpdateKey gets bumped. */
   static getDerivedStateFromProps(nextProps, prevState,) {
     if (nextProps.forceUpdateKey !== prevState.forceUpdateKey) {
-      const newState = {
-        forceUpdateKey: nextProps.forceUpdateKey,
-      };
-      if (prevState.error) {
-        newState.error = void 0;
-      }
+      const newState = { forceUpdateKey: nextProps.forceUpdateKey, };
+      if (prevState.error) newState.error = void 0;
       return newState;
     }
     return null;
   }
   render() {
-    if (this.state.error === void 0) {
-      return this.props.children;
-    }
+    if (this.state.error === void 0) return this.props.children;
     if (!(this.state.error instanceof NotFoundError)) {
       const error = new ErrorBoundaryCaughtError();
       error.cause = this.state.error;
       throw error;
     }
-    const {
-      notFoundPage,
-      defaultPageStyle,
-    } = this.props;
-    if (!notFoundPage) {
-      throw this.state.error;
-    }
+    const { notFoundPage, defaultPageStyle, } = this.props;
+    if (!notFoundPage) throw this.state.error;
     return renderPage(notFoundPage, defaultPageStyle,);
   }
 };
@@ -10466,16 +8027,12 @@ function fillPathVariables(path, variables,) {
   },);
 }
 function computeRelativePath(from, to,) {
-  if (!from.startsWith('/',) || !to.startsWith('/',)) {
-    throw new Error('from/to paths are expected to be absolute',);
-  }
+  if (!from.startsWith('/',) || !to.startsWith('/',)) throw new Error('from/to paths are expected to be absolute',);
   const [fromDir,] = getDirAndFile(from,);
   const [toDir, toFile,] = getDirAndFile(to,);
   let relativePath = relative(fromDir, toDir,);
   if (relativePath === '') relativePath = '.';
-  if (!relativePath.startsWith('.',) && !relativePath.startsWith('/',)) {
-    relativePath = './' + relativePath;
-  }
+  if (!relativePath.startsWith('.',) && !relativePath.startsWith('/',)) relativePath = './' + relativePath;
   return relativePath + '/' + toFile;
 }
 function getDirAndFile(path,) {
@@ -10507,25 +8064,16 @@ function relative(from, to,) {
   }
   if (i === length) {
     if (toLen > length) {
-      if (StringPrototypeCharCodeAt(to, toStart + i,) === CHAR_FORWARD_SLASH) {
-        return StringPrototypeSlice(to, toStart + i + 1,);
-      }
-      if (i === 0) {
-        return StringPrototypeSlice(to, toStart + i,);
-      }
+      if (StringPrototypeCharCodeAt(to, toStart + i,) === CHAR_FORWARD_SLASH) return StringPrototypeSlice(to, toStart + i + 1,);
+      if (i === 0) return StringPrototypeSlice(to, toStart + i,);
     } else if (fromLen > length) {
-      if (StringPrototypeCharCodeAt(from, fromStart + i,) === CHAR_FORWARD_SLASH) {
-        lastCommonSep = i;
-      } else if (i === 0) {
-        lastCommonSep = 0;
-      }
+      if (StringPrototypeCharCodeAt(from, fromStart + i,) === CHAR_FORWARD_SLASH) lastCommonSep = i;
+      else if (i === 0) lastCommonSep = 0;
     }
   }
   let out = '';
   for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
-    if (i === fromEnd || StringPrototypeCharCodeAt(from, i,) === CHAR_FORWARD_SLASH) {
-      out += out.length === 0 ? '..' : '/..';
-    }
+    if (i === fromEnd || StringPrototypeCharCodeAt(from, i,) === CHAR_FORWARD_SLASH) out += out.length === 0 ? '..' : '/..';
   }
   return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep,)}`;
 }
@@ -10580,19 +8128,14 @@ function normalizeString(path,) {
       }
       lastSlash = i;
       dots = 0;
-    } else if (code === CHAR_DOT && dots !== -1) {
-      ++dots;
-    } else {
-      dots = -1;
-    }
+    } else if (code === CHAR_DOT && dots !== -1) ++dots;
+    else dots = -1;
   }
   return res;
 }
 function forwardCurrentQueryParams(href,) {
   const queryParamsString = typeof window !== 'undefined' ? window.location.search : '';
-  if (!queryParamsString) {
-    return href;
-  }
+  if (!queryParamsString) return href;
   return forwardQueryParams(queryParamsString, href,);
 }
 function forwardQueryParams(queryParamsString, href,) {
@@ -10600,17 +8143,11 @@ function forwardQueryParams(queryParamsString, href,) {
   const hrefWithoutHash = startOfHash === -1 ? href : href.substring(0, startOfHash,);
   const hash2 = startOfHash === -1 ? '' : href.substring(startOfHash,);
   const startOfSearch = hrefWithoutHash.indexOf('?',);
-  if (startOfSearch === -1) {
-    return hrefWithoutHash + queryParamsString + hash2;
-  }
+  if (startOfSearch === -1) return hrefWithoutHash + queryParamsString + hash2;
   const currentSearchParams = new URLSearchParams(queryParamsString,);
   const newSearchString = hrefWithoutHash.substring(startOfSearch + 1,);
   const newSearchParams = new URLSearchParams(newSearchString,);
-  for (const [key7, value,] of currentSearchParams) {
-    if (!newSearchParams.has(key7,)) {
-      newSearchParams.append(key7, value,);
-    }
-  }
+  for (const [key7, value,] of currentSearchParams) if (!newSearchParams.has(key7,)) newSearchParams.append(key7, value,);
   return hrefWithoutHash.substring(0, startOfSearch + 1,) + newSearchParams.toString() + hash2;
 }
 function isObject(value,) {
@@ -10631,14 +8168,7 @@ function lazy(factory,) {
   const Component14 = React__default.forwardRef(function LazyWithPreload(props, ref,) {
     return React__default.createElement(
       LoadedComponent !== null && LoadedComponent !== void 0 ? LoadedComponent : LazyComponent,
-      Object.assign(
-        ref
-          ? {
-            ref,
-          }
-          : {},
-        props,
-      ),
+      Object.assign(ref ? { ref, } : {}, props,),
     );
   },);
   Component14.preload = () => {
@@ -10654,11 +8184,8 @@ function lazy(factory,) {
 }
 function getRouteElementId(route, hash2,) {
   if (hash2 && route) {
-    if (route.elements && hash2 in route.elements) {
-      return route.elements[hash2];
-    } else {
-      return hash2;
-    }
+    if (route.elements && hash2 in route.elements) return route.elements[hash2];
+    else return hash2;
   }
   return void 0;
 }
@@ -10669,9 +8196,7 @@ async function replacePathVariables(path, currentLocale, nextLocale, defaultLoca
   var _a, _b, _c;
   let resultPath = path;
   let isMissingInLocale = false;
-  const resultPathVariables = {
-    ...pathVariables,
-  };
+  const resultPathVariables = { ...pathVariables, };
   const matches = Array.from(resultPath.matchAll(pathVariablesRegExp,),);
   const replacements = await Promise.all(matches.map(async (match) => {
     var _a2;
@@ -10681,26 +8206,20 @@ async function replacePathVariables(path, currentLocale, nextLocale, defaultLoca
       throw new Error('Failed to replace path variables: unexpected regex match group',);
     }
     const currentSlug = pathVariables[pathVariableValue];
-    if (!currentSlug || !isString2(currentSlug,)) {
-      throw new Error(`No slug found for path variable ${pathVariableValue}`,);
-    }
+    if (!currentSlug || !isString2(currentSlug,)) throw new Error(`No slug found for path variable ${pathVariableValue}`,);
     const utils =
       await ((_a2 = collectionUtils === null || collectionUtils === void 0 ? void 0 : collectionUtils[collectionId]) === null ||
           _a2 === void 0
         ? void 0
         : _a2.call(collectionUtils,));
-    if (!utils || !currentLocale) {
-      return currentSlug;
-    }
+    if (!utils || !currentLocale) return currentSlug;
     const recordId = await utils.getRecordIdBySlug(currentSlug, currentLocale,);
     if (!recordId) return currentSlug;
     const nextSlug = await utils.getSlugByRecordId(recordId, nextLocale,);
     if (!nextSlug) {
       isMissingInLocale = true;
       const defaultLocaleSlug = await utils.getSlugByRecordId(recordId, defaultLocale,);
-      if (defaultLocaleSlug) {
-        resultPathVariables[pathVariableValue] = defaultLocaleSlug;
-      }
+      if (defaultLocaleSlug) resultPathVariables[pathVariableValue] = defaultLocaleSlug;
       return defaultLocaleSlug !== null && defaultLocaleSlug !== void 0 ? defaultLocaleSlug : currentSlug;
     }
     resultPathVariables[pathVariableValue] = nextSlug;
@@ -10719,32 +8238,14 @@ async function replacePathVariables(path, currentLocale, nextLocale, defaultLoca
     replacedPath += replacements[i];
     hasMatch = true;
   }
-  if (hasMatch) {
-    resultPath = replacedPath;
-  }
-  return {
-    path: resultPath,
-    pathVariables: resultPathVariables,
-    isMissingInLocale,
-  };
+  if (hasMatch) resultPath = replacedPath;
+  return { path: resultPath, pathVariables: resultPathVariables, isMissingInLocale, };
 }
-async function getLocalizedNavigationPath({
-  currentLocale,
-  nextLocale,
-  defaultLocale,
-  route,
-  pathVariables,
-  collectionUtils,
-  preserveQueryParams,
-},) {
-  const {
-    path,
-  } = route;
-  let result = {
-    path,
-    pathVariables,
-    isMissingInLocale: false,
-  };
+async function getLocalizedNavigationPath(
+  { currentLocale, nextLocale, defaultLocale, route, pathVariables, collectionUtils, preserveQueryParams, },
+) {
+  const { path, } = route;
+  let result = { path, pathVariables, isMissingInLocale: false, };
   if (!path) return result;
   if (pathVariables && route.collectionId) {
     try {
@@ -10760,34 +8261,18 @@ async function getLocalizedNavigationPath({
       result = pathReplacement;
     } catch {}
   }
-  if (nextLocale.slug) {
-    result.path = '/' + nextLocale.slug + result.path;
-  }
-  if (preserveQueryParams && result.path) {
-    result.path = forwardCurrentQueryParams(result.path,);
-  }
+  if (nextLocale.slug) result.path = '/' + nextLocale.slug + result.path;
+  if (preserveQueryParams && result.path) result.path = forwardCurrentQueryParams(result.path,);
   return result;
 }
-function getPageEffectForRoute(currentRouteId, nextRouteId, {
-  global: global2,
-  routes,
-},) {
+function getPageEffectForRoute(currentRouteId, nextRouteId, { global: global2, routes, },) {
   var _a;
   return ((_a = routes[currentRouteId]) === null || _a === void 0 ? void 0 : _a[nextRouteId]) || global2;
 }
-var defaultSitePageEffects = {
-  global: void 0,
-  routes: {},
-};
+var defaultSitePageEffects = { global: void 0, routes: {}, };
 var PageEffectsContext = React__default.createContext(defaultSitePageEffects,);
-function PageEffectsProvider({
-  children,
-  value,
-},) {
-  return _jsx5(PageEffectsContext.Provider, {
-    value,
-    children,
-  },);
+function PageEffectsProvider({ children, value, },) {
+  return _jsx5(PageEffectsContext.Provider, { value, children, },);
 }
 function usePageEffects() {
   return React__default.useContext(PageEffectsContext,);
@@ -10804,26 +8289,17 @@ function createLinearEasing(generator,) {
     time22 += step;
   }
   if (keyframes2.length === 1) keyframes2.push(state.value,);
-  return {
-    easing: `linear(${keyframes2.join(',',)})`,
-    duration: time22 - step,
-  };
+  return { easing: `linear(${keyframes2.join(',',)})`, duration: time22 - step, };
 }
 var cssVariable = (name) => `--view-transition-${name}`;
 function parseUnit(value,) {
   return [parseFloat(value,), value.endsWith('px',) ? 'px' : '%',];
 }
 function calcMaskPosition(mask,) {
-  const {
-    innerWidth,
-    innerHeight,
-  } = window;
+  const { innerWidth, innerHeight, } = window;
   const [x, xUnit,] = parseUnit(mask.x,);
   const [y, yUnit,] = parseUnit(mask.y,);
-  return {
-    x: xUnit === 'px' ? x : innerWidth * (x / 100),
-    y: yUnit === 'px' ? y : innerHeight * (y / 100),
-  };
+  return { x: xUnit === 'px' ? x : innerWidth * (x / 100), y: yUnit === 'px' ? y : innerHeight * (y / 100), };
 }
 var conic = {
   makeKeyframe: (mask, progress2, page,) => {
@@ -10833,9 +8309,7 @@ var conic = {
       page === 'exit' && mask.angularDirection === 'counter-clockwise' && progress2 === 'end' ||
       page === 'enter' && mask.angularDirection === 'counter-clockwise' && progress2 === 'start' ||
       page === 'enter' && mask.angularDirection === 'clockwise' && progress2 === 'end'
-    ) {
-      percentage = mask.sweepAngle / 360 * 100;
-    }
+    ) percentage = mask.sweepAngle / 360 * 100;
     return `${cssVariable('conic-offset',)}: ${percentage}%;`;
   },
   makeStyles: (mask, page,) => {
@@ -10860,13 +8334,9 @@ var conic = {
 };
 var circle = {
   makeKeyframe: (mask, progress2,) => {
-    const {
-      x,
-      y,
-    } = calcMaskPosition(mask,);
-    if (progress2 === 'start') {
-      return `clip-path: circle(0 at ${x}px ${y}px);`;
-    } else {
+    const { x, y, } = calcMaskPosition(mask,);
+    if (progress2 === 'start') return `clip-path: circle(0 at ${x}px ${y}px);`;
+    else {
       const endRadius = Math.hypot(Math.max(x, window.innerWidth - x,), Math.max(y, window.innerHeight - y,),);
       return `clip-path: circle(${endRadius}px at ${x}px ${y}px);`;
     }
@@ -10874,10 +8344,7 @@ var circle = {
 };
 var inset = {
   makeKeyframe: (mask, progress2,) => {
-    const {
-      x,
-      y,
-    } = calcMaskPosition(mask,);
+    const { x, y, } = calcMaskPosition(mask,);
     const bottom = window.innerHeight - y;
     const right = window.innerWidth - x;
     return progress2 === 'start'
@@ -10889,9 +8356,7 @@ var blinds = {
   makeKeyframe: (mask, progress2, page,) => {
     const [, unit,] = parseUnit(mask.width,);
     let width = `0${unit}`;
-    if (progress2 === 'start' && page === 'exit' || progress2 === 'end' && page === 'enter') {
-      width = mask.width;
-    }
+    if (progress2 === 'start' && page === 'exit' || progress2 === 'end' && page === 'enter') width = mask.width;
     return `${cssVariable('blinds-width',)}: ${width};`;
   },
   makeStyles: (mask, page,) => {
@@ -10939,23 +8404,8 @@ var wipe = {
         `;
   },
 };
-var maskGenerators = {
-  circle,
-  conic,
-  inset,
-  blinds,
-  wipe,
-};
-var restState = {
-  opacity: 1,
-  x: '0px',
-  y: '0px',
-  scale: 1,
-  rotate: 0,
-  rotateX: 0,
-  rotateY: 0,
-  mask: void 0,
-};
+var maskGenerators = { circle, conic, inset, blinds, wipe, };
+var restState = { opacity: 1, x: '0px', y: '0px', scale: 1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0, };
 function valuesToCSSKeyframes(values, progress2, page, maskGenerator,) {
   var _a;
   let keyframes2 = `
@@ -10972,31 +8422,24 @@ function valuesToCSSKeyframes(values, progress2, page, maskGenerator,) {
 function getMaskGenerator(type,) {
   return type ? maskGenerators[type] : void 0;
 }
-function createPageTransitionRules(page, {
-  transition,
-  ...values
-},) {
+function createPageTransitionRules(page, { transition, ...values },) {
   var _a;
   const name = 'view-transition-' + page;
-  const settings = {
-    duration: '0s',
-    easing: 'linear',
-  };
+  const settings = { duration: '0s', easing: 'linear', };
   if (transition.type === 'tween') {
     settings.duration = transition.duration + 's';
     settings.easing = `cubic-bezier(${transition.ease.join(',',)})`;
   } else if (transition.type === 'spring') {
-    const {
-      easing,
-      duration,
-    } = createLinearEasing(spring({
-      keyframes: [0, 1,],
-      stiffness: transition.stiffness,
-      damping: transition.damping,
-      mass: transition.mass,
-      restDelta: 1e-3,
-      restSpeed: 1e-4,
-    },),);
+    const { easing, duration, } = createLinearEasing(
+      spring({
+        keyframes: [0, 1,],
+        stiffness: transition.stiffness,
+        damping: transition.damping,
+        mass: transition.mass,
+        restDelta: 1e-3,
+        restSpeed: 1e-4,
+      },),
+    );
     settings.duration = duration + 'ms';
     settings.easing = easing;
   }
@@ -11004,15 +8447,7 @@ function createPageTransitionRules(page, {
     (_a = values === null || values === void 0 ? void 0 : values.mask) === null || _a === void 0 ? void 0 : _a.type,
   );
   let startKeyframes = valuesToCSSKeyframes(values, 'start', page, maskGenerator,);
-  let endKeyframes = valuesToCSSKeyframes(
-    {
-      ...restState,
-      mask: values.mask,
-    },
-    'end',
-    page,
-    maskGenerator,
-  );
+  let endKeyframes = valuesToCSSKeyframes({ ...restState, mask: values.mask, }, 'end', page, maskGenerator,);
   if (page === 'exit') {
     [startKeyframes, endKeyframes,] = [endKeyframes, startKeyframes,];
   }
@@ -11058,20 +8493,9 @@ var defaultPageTransition = {
   rotateX: 0,
   rotateY: 0,
   mask: void 0,
-  transition: {
-    type: 'tween',
-    delay: 0,
-    duration: 0.2,
-    ease: [0.27, 0, 0.51, 1,],
-    stiffness: 400,
-    damping: 30,
-    mass: 1,
-  },
+  transition: { type: 'tween', delay: 0, duration: 0.2, ease: [0.27, 0, 0.51, 1,], stiffness: 400, damping: 30, mass: 1, },
 };
-function createViewTransitionStylesheet({
-  exit = defaultPageTransition,
-  enter,
-},) {
+function createViewTransitionStylesheet({ exit = defaultPageTransition, enter, },) {
   const styleElement = document.createElement('style',);
   styleElement.id = VIEW_TRANSITION_STYLES_ID;
   let styleContent = `
@@ -11106,18 +8530,14 @@ function createViewTransitionStylesheet({
 function removeViewTransitionStylesheet() {
   frame.render(() => {
     const element = document.getElementById(VIEW_TRANSITION_STYLES_ID,);
-    if (element) {
-      document.head.removeChild(element,);
-    }
+    if (element) document.head.removeChild(element,);
   },);
 }
 function supportsViewTransitions() {
   return Boolean(document.startViewTransition,);
 }
 function startViewTransition(updateView, effect,) {
-  if (!supportsViewTransitions()) {
-    return void updateView();
-  }
+  if (!supportsViewTransitions()) return void updateView();
   createViewTransitionStylesheet(effect,);
   const transition = document.startViewTransition(updateView,);
   Promise.all([transition.ready, transition.finished,],).then(removeViewTransitionStylesheet,).catch(() => {},);
@@ -11143,37 +8563,19 @@ function useViewTransition() {
         await hasPainted;
       };
       return startViewTransition(asyncUpdate, pageEffect,);
-    } else {
-      return update();
-    }
+    } else return update();
   }, [sitePageEffects,],);
 }
-function pushRouteState(routeId, route, {
-  currentRoutePath,
-  currentPathVariables,
-  hash: hash2,
-  pathVariables,
-  localeId,
-  preserveQueryParams,
-},) {
-  const {
-    path,
-  } = route;
+function pushRouteState(
+  routeId,
+  route,
+  { currentRoutePath, currentPathVariables, hash: hash2, pathVariables, localeId, preserveQueryParams, },
+) {
+  const { path, } = route;
   if (!path) return;
   try {
-    const newPath = getPathForRoute(route, {
-      currentRoutePath,
-      currentPathVariables,
-      hash: hash2,
-      pathVariables,
-      preserveQueryParams,
-    },);
-    pushHistoryState({
-      routeId,
-      hash: hash2,
-      pathVariables,
-      localeId,
-    }, newPath,);
+    const newPath = getPathForRoute(route, { currentRoutePath, currentPathVariables, hash: hash2, pathVariables, preserveQueryParams, },);
+    pushHistoryState({ routeId, hash: hash2, pathVariables, localeId, }, newPath,);
   } catch {}
 }
 function isHistoryState(data2,) {
@@ -11182,8 +8584,7 @@ function isHistoryState(data2,) {
 }
 function replaceHistoryState(data2, url,) {
   window.history.replaceState(
-    data2,
-    // Second arg is unused and exists for historical purposes only
+    data2, // Second arg is unused and exists for historical purposes only
     // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState#unused
     '',
     url,
@@ -11191,42 +8592,25 @@ function replaceHistoryState(data2, url,) {
 }
 function pushHistoryState(data2, url,) {
   window.history.pushState(
-    data2,
-    // Second arg is unused and exists for historical purposes only
+    data2, // Second arg is unused and exists for historical purposes only
     // https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#unused
     '',
     url,
   );
 }
-function useReplaceInitialState({
-  disabled,
-  routeId,
-  initialPathVariables,
-  initialLocaleId,
-},) {
+function useReplaceInitialState({ disabled, routeId, initialPathVariables, initialLocaleId, },) {
   React__default.useLayoutEffect(() => {
     if (disabled) return;
-    replaceHistoryState({
-      routeId,
-      pathVariables: initialPathVariables,
-      localeId: initialLocaleId,
-    },);
+    replaceHistoryState({ routeId, pathVariables: initialPathVariables, localeId: initialLocaleId, },);
   }, [],);
 }
 function usePopStateHandler(currentRouteId, setCurrentRouteId,) {
   const startViewTransition2 = useViewTransition();
   const viewTransitionReady = React__default.useRef(void 0,);
-  const popStateHandler = React__default.useCallback(({
-    state,
-  },) => {
+  const popStateHandler = React__default.useCallback(({ state, },) => {
     var _a, _b, _c;
     if (!isObject(state,)) return;
-    const {
-      routeId,
-      hash: hash2,
-      pathVariables,
-      localeId,
-    } = state;
+    const { routeId, hash: hash2, pathVariables, localeId, } = state;
     if (!isString2(routeId,)) return;
     const changeRoute = () => {
       setCurrentRouteId(
@@ -11243,19 +8627,14 @@ function usePopStateHandler(currentRouteId, setCurrentRouteId,) {
       void transition.updateCallbackDone.then((_a = viewTransitionReady.current) === null || _a === void 0 ? void 0 : _a.resolve,).catch(
         (_b = viewTransitionReady.current) === null || _b === void 0 ? void 0 : _b.reject,
       );
-    } else {
-      (_c = viewTransitionReady.current) === null || _c === void 0 ? void 0 : _c.resolve();
-    }
+    } else (_c = viewTransitionReady.current) === null || _c === void 0 ? void 0 : _c.resolve();
   }, [currentRouteId, setCurrentRouteId, startViewTransition2,],);
   const traversalHandler = useCallback((event) => {
     if (event.navigationType !== 'traverse') return;
     event.intercept({
       async handler() {
         await new Promise((resolve, reject,) => {
-          viewTransitionReady.current = {
-            resolve,
-            reject,
-          };
+          viewTransitionReady.current = { resolve, reject, };
         },);
       },
       scroll: 'after-transition',
@@ -11281,36 +8660,21 @@ function getHashForRoute(hash2, route, hashVariables,) {
     return String((_a = variables[p1]) !== null && _a !== void 0 ? _a : m2,);
   },);
 }
-function getPathForRoute(route, {
-  currentRoutePath,
-  currentPathVariables,
-  hash: hash2,
-  pathVariables,
-  hashVariables,
-  relative: relative2 = true,
-  preserveQueryParams,
-},) {
+function getPathForRoute(
+  route,
+  { currentRoutePath, currentPathVariables, hash: hash2, pathVariables, hashVariables, relative: relative2 = true, preserveQueryParams, },
+) {
   var _a;
   let currentPath = currentRoutePath !== null && currentRoutePath !== void 0 ? currentRoutePath : '/';
-  if (currentPathVariables) {
-    currentPath = currentPath.replace(pathVariablesRegExp, (m2, p1,) => String(currentPathVariables[p1] || m2,),);
-  }
+  if (currentPathVariables) currentPath = currentPath.replace(pathVariablesRegExp, (m2, p1,) => String(currentPathVariables[p1] || m2,),);
   const targetPath = (_a = route === null || route === void 0 ? void 0 : route.path) !== null && _a !== void 0 ? _a : '/';
   let path = targetPath;
-  if (pathVariables) {
-    path = path.replace(pathVariablesRegExp, (m2, p1,) => String(pathVariables[p1] || m2,),);
-  }
+  if (pathVariables) path = path.replace(pathVariablesRegExp, (m2, p1,) => String(pathVariables[p1] || m2,),);
   const resolvedHash = getHashForRoute(hash2, route, hashVariables,);
   const isSamePageHashNavigation = currentPath === path && resolvedHash;
-  if (relative2) {
-    path = computeRelativePath(currentPath, path,);
-  }
-  if (preserveQueryParams || isSamePageHashNavigation) {
-    path = forwardCurrentQueryParams(path,);
-  }
-  if (resolvedHash) {
-    path = `${path}#${resolvedHash}`;
-  }
+  if (relative2) path = computeRelativePath(currentPath, path,);
+  if (preserveQueryParams || isSamePageHashNavigation) path = forwardCurrentQueryParams(path,);
+  if (resolvedHash) path = `${path}#${resolvedHash}`;
   return path;
 }
 async function handleRedirectForMissingSlugs(route, pathVariables, nextLocale,) {
@@ -11318,10 +8682,7 @@ async function handleRedirectForMissingSlugs(route, pathVariables, nextLocale,)
   if (!pathVariables) return false;
   const prefix2 = nextLocale.slug ? `/${nextLocale.slug}` : '';
   const nextLocaleWithDefaultSlugPath = `${prefix2}${fillPathVariables(route.path, pathVariables,)}`;
-  const response = await fetch(nextLocaleWithDefaultSlugPath, {
-    method: 'HEAD',
-    redirect: 'manual',
-  },);
+  const response = await fetch(nextLocaleWithDefaultSlugPath, { method: 'HEAD', redirect: 'manual', },);
   const isRedirect = response.type === 'opaqueredirect';
   if (isRedirect) {
     window.location.href = window.location.origin + nextLocaleWithDefaultSlugPath;
@@ -11336,9 +8697,7 @@ async function switchLocale(options,) {
     localStorage.setItem('preferredLocale', options.nextLocale.code,);
   } catch (error) {}
   try {
-    if (typeof result.path !== 'string') {
-      throw new Error('Expected result.path to be a string',);
-    }
+    if (typeof result.path !== 'string') throw new Error('Expected result.path to be a string',);
     if (result.isMissingInLocale) {
       const hasRedirect = await handleRedirectForMissingSlugs(options.route, result.pathVariables, options.nextLocale,);
       if (hasRedirect) return;
@@ -11356,10 +8715,7 @@ function pushLoadMoreHistory(paginationInfo,) {
   try {
     const currentHistoryState = window.history.state;
     if (!isHistoryState(currentHistoryState,)) return;
-    replaceHistoryState({
-      ...currentHistoryState,
-      paginationInfo,
-    },);
+    replaceHistoryState({ ...currentHistoryState, paginationInfo, },);
   } catch {}
 }
 function isSamePage(a, b,) {
@@ -11390,8 +8746,7 @@ var eventsToStop = [
   'keypress',
   'keyup',
   'input',
-  'textInput',
-  // Intentionally camelCase
+  'textInput', // Intentionally camelCase
   'copy',
   'cut',
   'paste',
@@ -11411,26 +8766,19 @@ var stopFn = (event) => {
 if (typeof window !== 'undefined') {
   window.__FRAMER_TURN_OFF_REACT_EVENT_HANDLING__ = function () {
     if (!eventsToStop) return;
-    const options = {
-      capture: true,
-    };
+    const options = { capture: true, };
     eventsToStop.forEach((event) => document.body.addEventListener(event, stopFn, options,));
     window.__FRAMER_TURN_OFF_REACT_EVENT_HANDLING__ = void 0;
   };
 }
 function turnOnReactEventHandling() {
   if (!eventsToStop) return;
-  const options = {
-    capture: true,
-  };
+  const options = { capture: true, };
   eventsToStop.forEach((event) => document.body.removeEventListener(event, stopFn, options,));
   eventsToStop = void 0;
 }
 var hydrated = false;
-function OnHydrationEnd({
-  addHydrationEndMarker,
-  turnOffEventHandlerHack,
-},) {
+function OnHydrationEnd({ addHydrationEndMarker, turnOffEventHandlerHack, },) {
   useLayoutEffect(() => {
     if (hydrated) return;
     hydrated = true;
@@ -11446,59 +8794,39 @@ function useGetRouteCallback(routes,) {
   return React__default.useCallback((routeId) => routes[routeId], [routes,],);
 }
 var RouterContext = React__default.createContext({},);
-function RouterAPIProvider({
-  api,
-  children,
-},) {
-  return _jsx5(RouterContext.Provider, {
-    value: api,
-    children,
-  },);
+function RouterAPIProvider({ api, children, },) {
+  return _jsx5(RouterContext.Provider, { value: api, children, },);
 }
 function useRouter() {
   return React__default.useContext(RouterContext,);
 }
-function RoutesProvider({
-  routes,
-  children,
-},) {
+function RoutesProvider({ routes, children, },) {
   const getRoute = useGetRouteCallback(routes,);
-  return _jsx5(RouterContext.Provider, {
-    value: {
-      getRoute,
-    },
-    children,
-  },);
+  return _jsx5(RouterContext.Provider, { value: { getRoute, }, children, },);
 }
 var SuspenseErrorBoundary = class extends Component2 {
   constructor() {
     super(...arguments,);
-    this.state = {
-      error: void 0,
-    };
+    this.state = { error: void 0, };
   }
   static getDerivedStateFromError(error,) {
     console.error('Derived error in SuspenseErrorBoundary', error,);
-    return {
-      error,
-    };
+    return { error, };
   }
   componentDidCatch(error, errorInfo,) {
     var _a;
     console.error('Caught error in SuspenseErrorBoundary', error, errorInfo,);
-    (_a = window.__framer_events) === null || _a === void 0 ? void 0 : _a.push(['published_site_load_recoverable_error', {
-      message: String(error,),
-      componentStack: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack,
-    },],);
+    (_a = window.__framer_events) === null || _a === void 0
+      ? void 0
+      : _a.push(['published_site_load_recoverable_error', {
+        message: String(error,),
+        componentStack: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack,
+      },],);
   }
   render() {
     if (this.state.error === void 0) return this.props.children;
-    if (this.state.error instanceof ErrorBoundaryCaughtError) {
-      throw this.state.error.cause;
-    }
-    return _jsx5(Suspense2, {
-      children: this.props.fallbackChildren,
-    },);
+    if (this.state.error instanceof ErrorBoundaryCaughtError) throw this.state.error.cause;
+    return _jsx5(Suspense2, { children: this.props.fallbackChildren, },);
   }
 };
 var suspendPromise = typeof window !== 'undefined' ? new Promise(() => {},) : null;
@@ -11506,24 +8834,15 @@ function Suspend() {
   if (typeof window === 'undefined') return null;
   throw suspendPromise;
 }
-function SuspenseThatPreservesDom({
-  children,
-},) {
+function SuspenseThatPreservesDom({ children, },) {
   return _jsx5(SuspenseErrorBoundary, {
     fallbackChildren: children,
-    children: _jsx5(Suspense2, {
-      fallback: _jsx5(Suspend, {},),
-      children,
-    },),
+    children: _jsx5(Suspense2, { fallback: _jsx5(Suspend, {},), children, },),
   },);
 }
 var defaultLocaleId = 'default';
 var noopAsync = async () => {};
-var defaultCollectionListPaginationInfo = {
-  paginationInfo: void 0,
-  setPaginationInfo: noopAsync,
-  loadMore: noopAsync,
-};
+var defaultCollectionListPaginationInfo = { paginationInfo: void 0, setPaginationInfo: noopAsync, loadMore: noopAsync, };
 var CollectionListPaginationInfoContext = /* @__PURE__ */ React__default.createContext(defaultCollectionListPaginationInfo,);
 function useCollectionListPaginationInfo() {
   return React__default.useContext(CollectionListPaginationInfoContext,);
@@ -11533,26 +8852,14 @@ function useForceUpdate2() {
   return [_, React__default.useCallback(() => setForcedRenderCount((v) => v + 1), [],),];
 }
 var noopAsync2 = async () => {};
-var defaultLocaleInfo = {
-  activeLocale: null,
-  locales: [],
-  setLocale: noopAsync2,
-};
+var defaultLocaleInfo = { activeLocale: null, locales: [], setLocale: noopAsync2, };
 var LocaleInfoContext = /* @__PURE__ */ React__default.createContext(defaultLocaleInfo,);
 function useLocaleInfo() {
   return React__default.useContext(LocaleInfoContext,);
 }
 function useLocalizationInfo() {
-  const {
-    activeLocale,
-    locales,
-    setLocale,
-  } = useLocaleInfo();
-  return {
-    activeLocalization: activeLocale,
-    localizations: locales,
-    setLocalization: setLocale,
-  };
+  const { activeLocale, locales, setLocale, } = useLocaleInfo();
+  return { activeLocalization: activeLocale, localizations: locales, setLocalization: setLocale, };
 }
 function useLocaleCode() {
   var _a, _b;
@@ -11603,27 +8910,24 @@ function useScheduleRenderSideEffects(dep,) {
     actions.current.push(cb,);
   }, [],);
 }
-function Router({
-  defaultPageStyle,
-  disableHistory,
-  initialPathVariables,
-  initialRoute,
-  notFoundPage,
-  collectionUtils,
-  routes,
-  initialLocaleId,
-  locales = [],
-  preserveQueryParams = false,
-  enableImproveInpDuringHydration = false,
-  shouldMarkHydrationEnd = false,
-},) {
-  var _a, _b;
-  useReplaceInitialState({
-    disabled: disableHistory,
-    routeId: initialRoute,
+function Router(
+  {
+    defaultPageStyle,
+    disableHistory,
     initialPathVariables,
+    initialRoute,
+    notFoundPage,
+    collectionUtils,
+    routes,
     initialLocaleId,
-  },);
+    locales = [],
+    preserveQueryParams = false,
+    enableImproveInpDuringHydration = false,
+    shouldMarkHydrationEnd = false,
+  },
+) {
+  var _a, _b;
+  useReplaceInitialState({ disabled: disableHistory, routeId: initialRoute, initialPathVariables, initialLocaleId, },);
   const startViewTransition2 = useViewTransition();
   const monitorNextRender = useMonitorNextRender('route-change',);
   const currentRouteRef = React__default.useRef(initialRoute,);
@@ -11632,9 +8936,7 @@ function Router({
   const currentLocaleId = currentLocaleIdRef.current;
   const activeLocale = React__default.useMemo(() => {
     var _a2;
-    return (_a2 = locales.find(({
-            id: id3,
-          },) => {
+    return (_a2 = locales.find(({ id: id3, },) => {
             if (!currentLocaleId) return id3 === defaultLocaleId;
             return id3 === currentLocaleId;
           },)) !== null && _a2 !== void 0
@@ -11660,10 +8962,7 @@ function Router({
       },
       loadMore: async () => {
         if ((paginationInfo === null || paginationInfo === void 0 ? void 0 : paginationInfo.type) !== 'loadMore') return;
-        const newPaginationInfo = {
-          ...paginationInfo,
-          currentPage: paginationInfo.currentPage + 1,
-        };
+        const newPaginationInfo = { ...paginationInfo, currentPage: paginationInfo.currentPage + 1, };
         pushLoadMoreHistory(newPaginationInfo,);
         startTransition2(() => {
           setPaginationInfo(newPaginationInfo,);
@@ -11677,17 +8976,10 @@ function Router({
       locales,
       setLocale: async (localeOrLocaleId) => {
         let localeId;
-        if (isString2(localeOrLocaleId,)) {
-          localeId = localeOrLocaleId;
-        } else if (isObject(localeOrLocaleId,)) {
-          localeId = localeOrLocaleId.id;
-        }
-        const defaultLocale = locales.find(({
-          id: id3,
-        },) => id3 === defaultLocaleId);
-        const nextLocale = locales.find(({
-          id: id3,
-        },) => id3 === localeId);
+        if (isString2(localeOrLocaleId,)) localeId = localeOrLocaleId;
+        else if (isObject(localeOrLocaleId,)) localeId = localeOrLocaleId.id;
+        const defaultLocale = locales.find(({ id: id3, },) => id3 === defaultLocaleId);
+        const nextLocale = locales.find(({ id: id3, },) => id3 === localeId);
         if (!nextLocale) return;
         const currentRouteId2 = currentRouteRef.current;
         const currentRoute = routes[currentRouteId2];
@@ -11746,23 +9038,13 @@ function Router({
       const path = (_a2 = newRoute === null || newRoute === void 0 ? void 0 : newRoute.path) !== null && _a2 !== void 0 ? _a2 : '/';
       for (const match of path.matchAll(pathVariablesRegExp,)) {
         const usedVariable = match[1];
-        if (usedVariable === void 0) {
-          throw new Error('A matching path variable should not be undefined',);
-        }
+        if (usedVariable === void 0) throw new Error('A matching path variable should not be undefined',);
         inUse.add(usedVariable,);
       }
       pathVariables = Object.fromEntries(Object.entries(pathVariables,).filter(([key7,],) => inUse.has(key7,)),);
     }
     const routeElementId = getRouteElementId(newRoute, hash2,);
-    if (
-      isSamePage({
-        routeId: currentRouteRef.current,
-        pathVariables: currentPathVariablesRef.current,
-      }, {
-        routeId,
-        pathVariables,
-      },)
-    ) {
+    if (isSamePage({ routeId: currentRouteRef.current, pathVariables: currentPathVariablesRef.current, }, { routeId, pathVariables, },)) {
       if (((_b2 = window.history.state) === null || _b2 === void 0 ? void 0 : _b2.hash) !== hash2) {
         if (!disableHistory) {
           const route = routes[routeId];
@@ -11799,19 +9081,12 @@ function Router({
   const getRoute = useGetRouteCallback(routes,);
   const currentRouteId = currentRouteRef.current;
   const currentPathVariables = currentPathVariablesRef.current;
-  const api = React__default.useMemo(() => ({
-    navigate,
-    getRoute,
-    currentRouteId,
-    currentPathVariables,
-    routes,
-    collectionUtils,
-    preserveQueryParams,
-  }), [navigate, getRoute, currentRouteId, currentPathVariables, routes, collectionUtils, preserveQueryParams,],);
+  const api = React__default.useMemo(
+    () => ({ navigate, getRoute, currentRouteId, currentPathVariables, routes, collectionUtils, preserveQueryParams, }),
+    [navigate, getRoute, currentRouteId, currentPathVariables, routes, collectionUtils, preserveQueryParams,],
+  );
   const current = routes[currentRouteRef.current];
-  if (!current) {
-    throw new Error(`Router cannot find route for ${currentRouteRef.current}`,);
-  }
+  if (!current) throw new Error(`Router cannot find route for ${currentRouteRef.current}`,);
   const pageExistsInCurrentLocale = !activeLocale || !current.includedLocales || current.includedLocales.includes(activeLocale.id,);
   const pathWithFilledVariables = current.path && currentPathVariables
     ? fillPathVariables(current.path, currentPathVariables,)
@@ -11846,13 +9121,7 @@ function Router({
   },);
 }
 function scrollElementIntoView(element, smoothScroll,) {
-  const scrollIntoViewOptions = smoothScroll
-    ? {
-      behavior: 'smooth',
-      block: 'start',
-      inline: 'nearest',
-    }
-    : void 0;
+  const scrollIntoViewOptions = smoothScroll ? { behavior: 'smooth', block: 'start', inline: 'nearest', } : void 0;
   element.scrollIntoView(scrollIntoViewOptions,);
 }
 var memoPathRoutes;
@@ -11861,25 +9130,11 @@ var lastRoutes;
 function getRouteInfoMemo(routes,) {
   if (lastRoutes !== routes) {
     memoPathRoutes = {};
-    for (
-      const [routeId, {
-        path,
-      },] of Object.entries(routes,)
-    ) {
-      if (path) {
-        memoPathRoutes[path] = {
-          path,
-          depth: pathDepth(path,),
-          routeId,
-        };
-      }
+    for (const [routeId, { path, },] of Object.entries(routes,)) {
+      if (path) memoPathRoutes[path] = { path, depth: pathDepth(path,), routeId, };
     }
     memoPaths = Object.values(memoPathRoutes,);
-    memoPaths.sort(({
-      depth: depth1,
-    }, {
-      depth: depth2,
-    },) => depth2 - depth1);
+    memoPaths.sort(({ depth: depth1, }, { depth: depth2, },) => depth2 - depth1);
     lastRoutes = routes;
   }
   return [memoPathRoutes, memoPaths,];
@@ -11892,63 +9147,32 @@ function inferInitialRouteFromPath(routes, decodedLocationPath, fallback = true,
   if (locales.length > 0) {
     const firstPathSegment = locationPath.split('/',).find(Boolean,);
     if (firstPathSegment) {
-      activeLocale = locales.find(({
-        slug,
-      },) => slug === firstPathSegment);
+      activeLocale = locales.find(({ slug, },) => slug === firstPathSegment);
       if (activeLocale) {
         localeId = activeLocale.id;
         locationPath = locationPath.substring(activeLocale.slug.length + 1,);
       }
     }
     if (!localeId) {
-      const defaultLocale = locales.find(({
-        slug,
-      },) => slug === '');
-      if (defaultLocale) {
-        localeId = defaultLocale.id;
-      }
+      const defaultLocale = locales.find(({ slug, },) => slug === '');
+      if (defaultLocale) localeId = defaultLocale.id;
     }
   }
   const exactMatch = pathRoutes[locationPath];
   if (exactMatch) {
     const match = matchPath(locationPath, exactMatch.path,);
-    if (match.isMatch) {
-      return {
-        routeId: exactMatch.routeId,
-        localeId,
-        pathVariables: match.pathVariables,
-      };
-    }
+    if (match.isMatch) return { routeId: exactMatch.routeId, localeId, pathVariables: match.pathVariables, };
   }
-  for (
-    const {
-      path,
-      routeId,
-    } of paths
-  ) {
+  for (const { path, routeId, } of paths) {
     const match = matchPath(locationPath, path,);
-    if (match.isMatch) {
-      return {
-        routeId,
-        localeId,
-        pathVariables: match.pathVariables,
-      };
-    }
+    if (match.isMatch) return { routeId, localeId, pathVariables: match.pathVariables, };
   }
   if (!fallback) throw new Error('No exact match found for path',);
   const rootPath = pathRoutes['/'];
-  if (rootPath) {
-    return {
-      routeId: rootPath.routeId,
-      localeId,
-    };
-  }
+  if (rootPath) return { routeId: rootPath.routeId, localeId, };
   const firstRoute = Object.keys(routes,)[0];
   if (!firstRoute) throw new Error('Router should not have undefined routes',);
-  return {
-    routeId: firstRoute,
-    localeId,
-  };
+  return { routeId: firstRoute, localeId, };
 }
 function pathDepth(path,) {
   const pathWithTrimmedSlashes = path.replace(/^\/|\/$/gu, '',);
@@ -11964,16 +9188,8 @@ function matchPath(path, routePath,) {
   },);
   const routePathRegExp = new RegExp(routePathRegExpString + '$',);
   const matches = path.match(routePathRegExp,);
-  if (!matches) {
-    return {
-      isMatch: false,
-    };
-  }
-  if (matches.length === 1) {
-    return {
-      isMatch: true,
-    };
-  }
+  if (!matches) return { isMatch: false, };
+  if (matches.length === 1) return { isMatch: true, };
   const pathVariables = {};
   const pathVariablesValues = matches.slice(1,);
   for (let i = 0; i < pathVariablesKeys.length; ++i) {
@@ -11982,23 +9198,13 @@ function matchPath(path, routePath,) {
     const value = pathVariablesValues[i];
     const existingValue = pathVariables[key7];
     if (existingValue) {
-      if (existingValue !== value) {
-        return {
-          isMatch: false,
-        };
-      } else {
-        continue;
-      }
-    }
-    if (value === void 0) {
-      throw new Error('Path variable values cannot be undefined',);
+      if (existingValue !== value) return { isMatch: false, };
+      else continue;
     }
+    if (value === void 0) throw new Error('Path variable values cannot be undefined',);
     pathVariables[key7] = value;
   }
-  return {
-    isMatch: true,
-    pathVariables,
-  };
+  return { isMatch: true, pathVariables, };
 }
 function escapeStringRegExp(string,) {
   return string.replace(/[|\\{}()[\]^$+*?.]/gu, '\\$&',).replace(/-/gu, '\\x2d',);
@@ -12016,11 +9222,7 @@ function useCurrentRoute() {
   if (!id3) return void 0;
   const route = (_a = router.getRoute) === null || _a === void 0 ? void 0 : _a.call(router, id3,);
   if (!route) return void 0;
-  return {
-    ...route,
-    id: id3,
-    pathVariables: override ? void 0 : router.currentPathVariables,
-  };
+  return { ...route, id: id3, pathVariables: override ? void 0 : router.currentPathVariables, };
 }
 function useCurrentRouteId() {
   var _a;
@@ -12038,9 +9240,7 @@ function useRoute(routeId,) {
 }
 var shouldPreloadBasedOnUA = typeof window !== 'undefined' && !isBot(navigator.userAgent,);
 function useRoutePreloader(routeIds, enabled = true,) {
-  const {
-    getRoute,
-  } = useRouter();
+  const { getRoute, } = useRouter();
   React__default.useEffect(() => {
     if (!getRoute || !enabled || !shouldPreloadBasedOnUA) return;
     for (const routeId of routeIds) {
@@ -12051,31 +9251,25 @@ function useRoutePreloader(routeIds, enabled = true,) {
 }
 function preloadComponent(component,) {
   if (!shouldPreloadBasedOnUA) return;
-  if (isLazyComponentType(component,)) {
-    void component.preload();
-  }
+  if (isLazyComponentType(component,)) void component.preload();
 }
-function useRouteAnchor(routeId, {
-  elementId,
-  hash: linkHash,
-} = {},) {
-  const {
-    navigate,
-    currentPathVariables,
-    preserveQueryParams,
-  } = useRouter();
+function useRouteAnchor(routeId, { elementId, hash: linkHash, } = {},) {
+  const { navigate, currentPathVariables, preserveQueryParams, } = useRouter();
   const route = useRoute(routeId,);
   const currentRouteId = useCurrentRouteId();
   const currentRoute = useRoute(currentRouteId !== null && currentRouteId !== void 0 ? currentRouteId : '',);
   useRoutePreloader([routeId,], true,);
   const hash2 = linkHash !== null && linkHash !== void 0 ? linkHash : elementId;
-  const href = React__default.useMemo(() =>
-    getPathForRoute(route, {
-      currentRoutePath: currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.path,
-      currentPathVariables,
-      hash: hash2,
-      preserveQueryParams,
-    },), [currentRoute, currentPathVariables, hash2, preserveQueryParams, route,],);
+  const href = React__default.useMemo(
+    () =>
+      getPathForRoute(route, {
+        currentRoutePath: currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.path,
+        currentPathVariables,
+        hash: hash2,
+        preserveQueryParams,
+      },),
+    [currentRoute, currentPathVariables, hash2, preserveQueryParams, route,],
+  );
   const navigateToRoute = React__default.useCallback(() => navigate === null || navigate === void 0 ? void 0 : navigate(routeId, hash2,), [
     hash2,
     navigate,
@@ -12085,10 +9279,7 @@ function useRouteAnchor(routeId, {
     event.preventDefault();
     navigateToRoute();
   }, [navigateToRoute,],);
-  return {
-    onClick,
-    href,
-  };
+  return { onClick, href, };
 }
 function useRouteElementId(id3, targetRouteId,) {
   var _a;
@@ -12100,9 +9291,7 @@ function useRouteElementId(id3, targetRouteId,) {
   }, [id3, route,],);
 }
 function useRouteHandler(routeId, preload = false, elementId,) {
-  const {
-    navigate,
-  } = useRouter();
+  const { navigate, } = useRouter();
   useRoutePreloader([routeId,], preload,);
   const handler = React__default.useCallback(() => navigate === null || navigate === void 0 ? void 0 : navigate(routeId, elementId,), [
     navigate,
@@ -12131,9 +9320,7 @@ var Observers = class {
     this.observers.add(observer2,);
     let isCalled = false;
     return () => {
-      if (isCalled) {
-        return;
-      }
+      if (isCalled) return;
       isCalled = true;
       this.remove(observer2,);
     };
@@ -12146,9 +9333,7 @@ var Observers = class {
       const accumulatedChange = this.transactions[transaction] || change;
       accumulatedChange.value = change.value;
       this.transactions[transaction] = accumulatedChange;
-    } else {
-      this.callObservers(change,);
-    }
+    } else this.callObservers(change,);
   }
   finishTransaction(transaction,) {
     const accumulatedChange = this.transactions[transaction];
@@ -12158,9 +9343,8 @@ var Observers = class {
   callObservers(change, transaction,) {
     const finishObservers = [];
     new Set(this.observers,).forEach((observer2) => {
-      if (typeof observer2 === 'function') {
-        observer2(change, transaction,);
-      } else {
+      if (typeof observer2 === 'function') observer2(change, transaction,);
+      else {
         observer2.update(change, transaction,);
         finishObservers.push(observer2.finish,);
       }
@@ -12193,26 +9377,17 @@ var Animatable = /* @__PURE__ */ (() => {
     return Animatable2.get(value, defaultValue,);
   };
   Animatable2.get = (value, defaultValue,) => {
-    if (value === void 0 || value === null) {
-      return defaultValue;
-    }
-    if (isAnimatable2(value,)) {
-      return value.get();
-    }
+    if (value === void 0 || value === null) return defaultValue;
+    if (isAnimatable2(value,)) return value.get();
     return value;
   };
   Animatable2.objectToValues = (object) => {
-    if (!object) {
-      return object;
-    }
+    if (!object) return object;
     const result = {};
     for (const key7 in object) {
       const value = object[key7];
-      if (isAnimatable2(value,)) {
-        result[key7] = value.get();
-      } else {
-        result[key7] = value;
-      }
+      if (isAnimatable2(value,)) result[key7] = value.get();
+      else result[key7] = value;
     }
     return result;
   };
@@ -12248,23 +9423,16 @@ var AnimatableValue = class {
     __publicField(this, 'observers', new Observers(),);
   }
   static interpolationFor(value, currentInterpolation,) {
-    if (isAnimatable2(value,)) {
-      return animatableInterpolation(value, currentInterpolation,);
-    }
+    if (isAnimatable2(value,)) return animatableInterpolation(value, currentInterpolation,);
   }
   get() {
     return this.value;
   }
   set(value, transaction,) {
     const oldValue = this.value;
-    if (isAnimatable2(value,)) {
-      value = value.get();
-    }
+    if (isAnimatable2(value,)) value = value.get();
     this.value = value;
-    const change = {
-      value,
-      oldValue,
-    };
+    const change = { value, oldValue, };
     this.observers.notify(change, transaction,);
   }
   finishTransaction(transaction,) {
@@ -12284,71 +9452,37 @@ function roundedNumberString(value, decimals,) {
   return decimals === 0 ? result : `${+result}`;
 }
 function roundWithOffset(value, offset,) {
-  if (offset === 0) {
-    return Math.round(value,);
-  }
+  if (offset === 0) return Math.round(value,);
   offset -= offset | 0;
-  if (offset < 0) {
-    offset = 1 - offset;
-  }
+  if (offset < 0) offset = 1 - offset;
   return Math.round(value - offset,) + offset;
 }
 function Point(x, y,) {
-  return {
-    x,
-    y,
-  };
+  return { x, y, };
 }
 ((Point2) => {
   Point2.add = (...args) => {
     return args.reduce((previousValue, currentValue,) => {
-      return {
-        x: previousValue.x + currentValue.x,
-        y: previousValue.y + currentValue.y,
-      };
-    }, {
-      x: 0,
-      y: 0,
-    },);
+      return { x: previousValue.x + currentValue.x, y: previousValue.y + currentValue.y, };
+    }, { x: 0, y: 0, },);
   };
   Point2.subtract = (a, b,) => {
-    return {
-      x: a.x - b.x,
-      y: a.y - b.y,
-    };
+    return { x: a.x - b.x, y: a.y - b.y, };
   };
   Point2.multiply = (a, b,) => {
-    return {
-      x: a.x * b,
-      y: a.y * b,
-    };
+    return { x: a.x * b, y: a.y * b, };
   };
   Point2.divide = (a, b,) => {
-    return {
-      x: a.x / b,
-      y: a.y / b,
-    };
+    return { x: a.x / b, y: a.y / b, };
   };
   Point2.absolute = (point2) => {
-    return {
-      x: Math.abs(point2.x,),
-      y: Math.abs(point2.y,),
-    };
+    return { x: Math.abs(point2.x,), y: Math.abs(point2.y,), };
   };
   Point2.reverse = (point2) => {
-    return {
-      x: point2.x * -1,
-      y: point2.y * -1,
-    };
+    return { x: point2.x * -1, y: point2.y * -1, };
   };
-  Point2.pixelAligned = (point2, offset = {
-    x: 0,
-    y: 0,
-  },) => {
-    return {
-      x: roundWithOffset(point2.x, offset.x,),
-      y: roundWithOffset(point2.y, offset.y,),
-    };
+  Point2.pixelAligned = (point2, offset = { x: 0, y: 0, },) => {
+    return { x: roundWithOffset(point2.x, offset.x,), y: roundWithOffset(point2.y, offset.y,), };
   };
   Point2.distance = (a, b,) => {
     const deltaX = Math.abs(a.x - b.x,);
@@ -12367,27 +9501,18 @@ function Point(x, y,) {
   Point2.rotationNormalizer = () => {
     let lastValue;
     return (value) => {
-      if (typeof lastValue !== 'number') {
-        lastValue = value;
-      }
+      if (typeof lastValue !== 'number') lastValue = value;
       const diff = lastValue - value;
       const maxDiff = Math.abs(diff,) + 180;
       const nTimes = Math.floor(maxDiff / 360,);
-      if (diff < 180) {
-        value -= nTimes * 360;
-      }
-      if (diff > 180) {
-        value += nTimes * 360;
-      }
+      if (diff < 180) value -= nTimes * 360;
+      if (diff > 180) value += nTimes * 360;
       lastValue = value;
       return value;
     };
   };
   function center(a, b,) {
-    return {
-      x: (a.x + b.x) / 2,
-      y: (a.y + b.y) / 2,
-    };
+    return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, };
   }
   Point2.center = center;
   function centroid(points,) {
@@ -12399,10 +9524,7 @@ function Point(x, y,) {
     },);
     const centroidX = sumX / points.length;
     const centroidY = sumY / points.length;
-    return {
-      x: centroidX,
-      y: centroidY,
-    };
+    return { x: centroidX, y: centroidY, };
   }
   Point2.centroid = centroid;
   function sortClockwise(points,) {
@@ -12416,10 +9538,7 @@ function Point(x, y,) {
   }
   Point2.sortClockwise = sortClockwise;
 })(Point || (Point = {}),);
-var BezierDefaults = {
-  curve: 'ease',
-  duration: 1,
-};
+var BezierDefaults = { curve: 'ease', duration: 1, };
 function controlPointsForCurve(curve,) {
   switch (curve) {
     case 'linear':
@@ -12444,24 +9563,16 @@ var BezierAnimator = class {
     __publicField(this, 'interpolator',);
     __publicField(this, 'progress', 0,);
     __publicField(this, 'next', (delta) => {
-      const {
-        duration,
-      } = this.options;
+      const { duration, } = this.options;
       this.progress += delta / duration;
       const value = this.unitBezier.solve(this.progress, this.solveEpsilon(duration,),);
       this.current = this.interpolator(value,);
       return this.current;
     },);
-    this.options = {
-      ...BezierDefaults,
-      ...options,
-    };
+    this.options = { ...BezierDefaults, ...options, };
     let controlPoints;
-    if (typeof this.options.curve === 'string') {
-      controlPoints = controlPointsForCurve(this.options.curve,);
-    } else {
-      controlPoints = this.options.curve;
-    }
+    if (typeof this.options.curve === 'string') controlPoints = controlPointsForCurve(this.options.curve,);
+    else controlPoints = this.options.curve;
     const [p1x, p1y, p2x, p2y,] = controlPoints;
     this.unitBezier = new UnitBezier(Point(p1x, p1y,), Point(p2x, p2y,),);
   }
@@ -12477,9 +9588,7 @@ var BezierAnimator = class {
     return this.interpolator !== void 0;
   }
   updateInterpolator() {
-    if (this.current === void 0 || this.destination === void 0) {
-      return;
-    }
+    if (this.current === void 0 || this.destination === void 0) return;
     this.interpolator = this.interpolation.interpolate(this.current, this.destination,);
   }
   isFinished() {
@@ -12553,20 +9662,11 @@ var Integrator = class {
   }
   evaluateState(initialState2,) {
     const dv = this.accelerationForState(initialState2,);
-    return {
-      dx: initialState2.v,
-      dv,
-    };
+    return { dx: initialState2.v, dv, };
   }
   evaluateStateWithDerivative(initialState2, dt, derivative,) {
-    const state = {
-      x: initialState2.x + derivative.dx * dt,
-      v: initialState2.v + derivative.dv * dt,
-    };
-    const output = {
-      dx: state.v,
-      dv: this.accelerationForState(state,),
-    };
+    const state = { x: initialState2.x + derivative.dx * dt, v: initialState2.v + derivative.dv * dt, };
+    const output = { dx: state.v, dv: this.accelerationForState(state,), };
     return output;
   }
 };
@@ -12575,16 +9675,9 @@ var FrictionAnimator = class {
     __publicField(this, 'options',);
     __publicField(this, 'state',);
     __publicField(this, 'integrator',);
-    this.options = {
-      velocity: 0,
-      friction: 2,
-      tolerance: 1 / 10,
-    };
+    this.options = { velocity: 0, friction: 2, tolerance: 1 / 10, };
     Object.assign(this.options, options,);
-    this.state = {
-      x: 0,
-      v: this.options.velocity,
-    };
+    this.state = { x: 0, v: this.options.velocity, };
     this.integrator = new Integrator((state) => -(this.options.friction * state.v));
   }
   setFrom(value,) {
@@ -12616,14 +9709,9 @@ var Interpolation = {
    * @param from -
    * @param to -
    * @internal
-   */
-  handleUndefined: (from, to,) => {
-    if (from === void 0) {
-      from = to;
-    }
-    if (to === void 0) {
-      to = from;
-    }
+   */ handleUndefined: (from, to,) => {
+    if (from === void 0) from = to;
+    if (to === void 0) to = from;
     return [from, to,];
   },
 };
@@ -12659,8 +9747,7 @@ function angularFrequency(undampedFrequency, dampingRatio,) {
 var SpringCurveValueConverter = {
   computeDampingRatio: (tension, friction, mass = 1,) => {
     return friction / (2 * Math.sqrt(mass * tension,));
-  },
-  // Tries to compute the duration of a spring,
+  }, // Tries to compute the duration of a spring,
   // but can't for certain velocities and if dampingRatio >= 1
   // In those cases it will return null
   computeDuration: (tension, friction, velocity = 0, mass = 1,) => {
@@ -12672,13 +9759,9 @@ var SpringCurveValueConverter = {
       const b = velocity / (a * undampedFrequency);
       const c = dampingRatio / a;
       const d = -((b - c) / epsilon);
-      if (d <= 0) {
-        return null;
-      }
+      if (d <= 0) return null;
       duration = Math.log(d,) / (dampingRatio * undampedFrequency);
-    } else {
-      return null;
-    }
+    } else return null;
     return duration;
   },
   computeDerivedCurveOptions: (dampingRatio, duration, velocity = 0, mass = 1,) => {
@@ -12716,11 +9799,7 @@ var SpringCurveValueConverter = {
         return a * b;
       };
     }
-    const result = {
-      tension: 100,
-      friction: 10,
-      velocity,
-    };
+    const result = { tension: 100, friction: 10, velocity, };
     const initialGuess = 5 / duration;
     const undampedFrequency = approximateRoot2(envelope, derivative, initialGuess,);
     if (!isNaN(undampedFrequency,)) {
@@ -12730,22 +9809,10 @@ var SpringCurveValueConverter = {
     return result;
   },
 };
-var SpringTensionFrictionDefaults = {
-  tension: 500,
-  friction: 10,
-  tolerance: 1 / 1e4,
-  velocity: 0,
-};
-var SpringDampingDurationDefaults = {
-  dampingRatio: 1,
-  duration: 1,
-  velocity: 0,
-  mass: 1,
-};
+var SpringTensionFrictionDefaults = { tension: 500, friction: 10, tolerance: 1 / 1e4, velocity: 0, };
+var SpringDampingDurationDefaults = { dampingRatio: 1, duration: 1, velocity: 0, mass: 1, };
 function isDampingDurationSpringOptions(options,) {
-  if (!options) {
-    return false;
-  }
+  if (!options) return false;
   return typeof options.dampingRatio === 'number' || typeof options.duration === 'number' || typeof options.mass === 'number';
 }
 var SpringAnimator = class {
@@ -12760,22 +9827,11 @@ var SpringAnimator = class {
     __publicField(this, 'interpolator',);
     let _opt;
     if (isDampingDurationSpringOptions(options,)) {
-      const toPass = {
-        ...SpringDampingDurationDefaults,
-        ...options,
-      };
+      const toPass = { ...SpringDampingDurationDefaults, ...options, };
       _opt = SpringCurveValueConverter.computeDerivedCurveOptions(toPass.dampingRatio, toPass.duration, toPass.velocity, toPass.mass,);
-    } else {
-      _opt = options;
-    }
-    this.options = {
-      ...SpringTensionFrictionDefaults,
-      ..._opt,
-    };
-    this.state = {
-      x: 0,
-      v: this.options.velocity,
-    };
+    } else _opt = options;
+    this.options = { ...SpringTensionFrictionDefaults, ..._opt, };
+    this.state = { x: 0, v: this.options.velocity, };
     this.integrator = new Integrator((state) => -this.options.tension * state.x - this.options.friction * state.v);
   }
   isReady() {
@@ -12800,8 +9856,7 @@ var SpringAnimator = class {
   }
   progress() {
     return 1 - this.state.x / this.difference;
-  }
-  // The spring always settles to 0, so we create an interpolation to the destination
+  } // The spring always settles to 0, so we create an interpolation to the destination
   // And calculate the progress based on the current state and the span of the interpolation
   // This lets us integrate over state.x, even though Value is generic
   setTo(value,) {
@@ -12809,15 +9864,12 @@ var SpringAnimator = class {
     this.difference = this.interpolation.difference(this.destination, this.current,);
     this.state.x = this.difference;
     this.updateInterpolator();
-  }
-  /** @internal */
+  } /** @internal */
   getState() {
     return this.state;
   }
   updateInterpolator() {
-    if (this.current === void 0 || this.destination === void 0) {
-      return;
-    }
+    if (this.current === void 0 || this.destination === void 0) return;
     this.interpolator = this.interpolation.interpolate(this.current, this.destination,);
   }
 };
@@ -12825,15 +9877,8 @@ var Defaults = {
   velocity: 0,
   min: 0,
   max: 0,
-  momentum: {
-    friction: 2,
-    tolerance: 10,
-  },
-  bounce: {
-    tension: 500,
-    friction: 10,
-    tolerance: 1,
-  },
+  momentum: { friction: 2, tolerance: 10, },
+  bounce: { tension: 500, friction: 10, tolerance: 1, },
 };
 var InertialScrollAnimator = class {
   constructor(options,) {
@@ -12842,9 +9887,7 @@ var InertialScrollAnimator = class {
     __publicField(this, 'frictionAnimator',);
     __publicField(this, 'springAnimator',);
     __publicField(this, 'useSpring',);
-    this.options = Object.assign({
-      ...Defaults,
-    }, options,);
+    this.options = Object.assign({ ...Defaults, }, options,);
     this.frictionAnimator = new FrictionAnimator({
       friction: this.options.momentum.friction,
       tolerance: this.options.momentum.tolerance,
@@ -12863,15 +9906,11 @@ var InertialScrollAnimator = class {
   }
   next(delta,) {
     this.current = this.currentAnimator.next(delta,);
-    if (!this.useSpring) {
-      this.tryTransitionToSpring();
-    }
+    if (!this.useSpring) this.tryTransitionToSpring();
     return this.current;
   }
   get currentAnimator() {
-    if (this.useSpring) {
-      return this.springAnimator;
-    }
+    if (this.useSpring) return this.springAnimator;
     return this.frictionAnimator;
   }
   isFinished() {
@@ -12881,24 +9920,16 @@ var InertialScrollAnimator = class {
     return this.currentAnimator.getState();
   }
   setFrom(value,) {
-    this.setState({
-      x: value,
-      v: this.state.v,
-    },);
+    this.setState({ x: value, v: this.state.v, },);
   }
   setState(state,) {
     this.frictionAnimator.setFrom(state.x,);
     this.frictionAnimator.setVelocity(state.v,);
-    if (this.isValidState()) {
-      return this.tryTransitionToSpring();
-    } else {
+    if (this.isValidState()) return this.tryTransitionToSpring();
+    else {
       let bound = 0;
-      if (this.state.x <= this.options.min) {
-        bound = this.options.min;
-      }
-      if (this.state.x >= this.options.max) {
-        bound = this.options.max;
-      }
+      if (this.state.x <= this.options.min) bound = this.options.min;
+      if (this.state.x >= this.options.max) bound = this.options.max;
       return this.transitionToSpring(bound,);
     }
   }
@@ -12909,31 +9940,24 @@ var InertialScrollAnimator = class {
   setLimits(min, max,) {
     this.options.min = min;
     this.options.max = max;
-  }
-  // If the position is outside the min and max bounds, and traveling
+  } // If the position is outside the min and max bounds, and traveling
   // further away, then transition from friction to spring animation
   tryTransitionToSpring() {
     const belowMinWithVelocity = this.state.x < this.options.min && this.state.v <= 0;
     const aboveMaxWithVelocity = this.state.x > this.options.max && this.state.v >= 0;
     if (belowMinWithVelocity || aboveMaxWithVelocity) {
       let bound;
-      if (belowMinWithVelocity) {
-        bound = this.options.min;
-      } else {
-        bound = this.options.max;
-      }
+      if (belowMinWithVelocity) bound = this.options.min;
+      else bound = this.options.max;
       this.transitionToSpring(bound,);
-    } else {
-      this.useSpring = false;
-    }
+    } else this.useSpring = false;
   }
   transitionToSpring(bound,) {
     this.springAnimator.setFrom(this.state.x,);
     this.springAnimator.setVelocity(this.state.v,);
     this.springAnimator.setTo(bound,);
     this.useSpring = true;
-  }
-  // If the position is outside the min and max bounds, but traveling
+  } // If the position is outside the min and max bounds, but traveling
   // back towards the bounds, check if the velocity is sufficient to
   // carry the position back within bounds. If it is, let friction do the
   // work. If not, the state is invalid, so use the spring.
@@ -12942,18 +9966,14 @@ var InertialScrollAnimator = class {
     const aboveMaxTravelingBack = this.state.x > this.options.max && this.state.v < 0;
     if (belowMinTravelingBack || aboveMaxTravelingBack) {
       let bound;
-      if (belowMinTravelingBack) {
-        bound = this.options.min;
-      } else {
-        bound = this.options.max;
-      }
+      if (belowMinTravelingBack) bound = this.options.min;
+      else bound = this.options.max;
       const friction = this.frictionAnimator.options.friction;
       const solution = 1 - friction * (bound - this.state.x) / this.state.v;
       return solution > 0;
     }
     return true;
-  }
-  // The math behind _isValidState:
+  } // The math behind _isValidState:
   //
   // 1. Integrate the friction animator's acceleration to find velocity
   //
@@ -13035,32 +10055,20 @@ var Hsluv = class {
     this.b1i = 0;
   }
   static fromLinear(c,) {
-    if (c <= 31308e-7) {
-      return 12.92 * c;
-    } else {
-      return 1.055 * Math.pow(c, 1 / 2.4,) - 0.055;
-    }
+    if (c <= 31308e-7) return 12.92 * c;
+    else return 1.055 * Math.pow(c, 1 / 2.4,) - 0.055;
   }
   static toLinear(c,) {
-    if (c > 0.04045) {
-      return Math.pow((c + 0.055) / 1.055, 2.4,);
-    } else {
-      return c / 12.92;
-    }
+    if (c > 0.04045) return Math.pow((c + 0.055) / 1.055, 2.4,);
+    else return c / 12.92;
   }
   static yToL(Y,) {
-    if (Y <= Hsluv.epsilon) {
-      return Y / Hsluv.refY * Hsluv.kappa;
-    } else {
-      return 116 * Math.pow(Y / Hsluv.refY, 1 / 3,) - 16;
-    }
+    if (Y <= Hsluv.epsilon) return Y / Hsluv.refY * Hsluv.kappa;
+    else return 116 * Math.pow(Y / Hsluv.refY, 1 / 3,) - 16;
   }
   static lToY(L,) {
-    if (L <= 8) {
-      return Hsluv.refY * L / Hsluv.kappa;
-    } else {
-      return Hsluv.refY * Math.pow((L + 16) / 116, 3,);
-    }
+    if (L <= 8) return Hsluv.refY * L / Hsluv.kappa;
+    else return Hsluv.refY * Math.pow((L + 16) / 116, 3,);
   }
   static rgbChannelToHex(chan,) {
     const c = Math.round(chan * 255,);
@@ -13076,11 +10084,8 @@ var Hsluv = class {
   }
   static distanceFromOriginAngle(slope, intercept, angle,) {
     const d = intercept / (Math.sin(angle,) - slope * Math.cos(angle,));
-    if (d < 0) {
-      return Infinity;
-    } else {
-      return d;
-    }
+    if (d < 0) return Infinity;
+    else return d;
   }
   static distanceFromOrigin(slope, intercept,) {
     return Math.abs(intercept,) / Math.sqrt(Math.pow(slope, 2,) + 1,);
@@ -13149,14 +10154,11 @@ var Hsluv = class {
   luvToLch() {
     this.lch_l = this.luv_l;
     this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v,);
-    if (this.lch_c < 1e-8) {
-      this.lch_h = 0;
-    } else {
+    if (this.lch_c < 1e-8) this.lch_h = 0;
+    else {
       const hrad = Math.atan2(this.luv_v, this.luv_u,);
       this.lch_h = hrad * 180 / Math.PI;
-      if (this.lch_h < 0) {
-        this.lch_h = 360 + this.lch_h;
-      }
+      if (this.lch_h < 0) this.lch_h = 360 + this.lch_h;
     }
   }
   lchToLuv() {
@@ -13504,19 +10506,11 @@ function modulate(value, rangeA, rangeB, limit = false,) {
   const result = toLow + (value - fromLow) / fromDelta * toDelta;
   if (limit === true) {
     if (toLow < toHigh) {
-      if (result < toLow) {
-        return toLow;
-      }
-      if (result > toHigh) {
-        return toHigh;
-      }
+      if (result < toLow) return toLow;
+      if (result > toHigh) return toHigh;
     } else {
-      if (result > toLow) {
-        return toLow;
-      }
-      if (result < toHigh) {
-        return toHigh;
-      }
+      if (result > toLow) return toLow;
+      if (result < toHigh) return toHigh;
     }
   }
   return result;
@@ -13527,9 +10521,7 @@ function isNumeric(value,) {
 function percentToFraction(val,) {
   const digits = numberFromString(val,);
   if (digits !== void 0) {
-    if (val.includes('%',)) {
-      return digits / 100;
-    }
+    if (val.includes('%',)) return digits / 100;
     return digits;
   }
   return 0;
@@ -13544,23 +10536,14 @@ function rgbToHsluv(r, g, b,) {
   hsluvConverter.rgb_g = g / 255;
   hsluvConverter.rgb_b = b / 255;
   hsluvConverter.rgbToHsluv();
-  return {
-    h: hsluvConverter.hsluv_h,
-    s: hsluvConverter.hsluv_s,
-    l: hsluvConverter.hsluv_l,
-  };
+  return { h: hsluvConverter.hsluv_h, s: hsluvConverter.hsluv_s, l: hsluvConverter.hsluv_l, };
 }
 function rgbaFromHusl(h, s, l, a = 1,) {
   hsluvConverter.hsluv_h = h;
   hsluvConverter.hsluv_s = s;
   hsluvConverter.hsluv_l = l;
   hsluvConverter.hsluvToRgb();
-  return {
-    r: hsluvConverter.rgb_r * 255,
-    g: hsluvConverter.rgb_g * 255,
-    b: hsluvConverter.rgb_b * 255,
-    a,
-  };
+  return { r: hsluvConverter.rgb_r * 255, g: hsluvConverter.rgb_g * 255, b: hsluvConverter.rgb_b * 255, a, };
 }
 function hsvToStr(h, s, v, a,) {
   const _h = Math.round(h,);
@@ -13580,9 +10563,7 @@ function rgbToHex(r, g, b, allow3Char,) {
   if (
     allow3Char && hex2[0].charAt(0,) === hex2[0].charAt(1,) && hex2[1].charAt(0,) === hex2[1].charAt(1,) &&
     hex2[2].charAt(0,) === hex2[2].charAt(1,)
-  ) {
-    return hex2[0].charAt(0,) + hex2[1].charAt(0,) + hex2[2].charAt(0,);
-  }
+  ) return hex2[0].charAt(0,) + hex2[1].charAt(0,) + hex2[2].charAt(0,);
   return hex2.join('',);
 }
 function rgbToHsl(r, g, b,) {
@@ -13594,9 +10575,8 @@ function rgbToHsl(r, g, b,) {
   const max = Math.max(_r, _g, _b,);
   const min = Math.min(_r, _g, _b,);
   let h = s = l = (max + min) / 2;
-  if (max === min) {
-    h = s = 0;
-  } else {
+  if (max === min) h = s = 0;
+  else {
     const d = max - min;
     s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
     switch (max) {
@@ -13612,28 +10592,14 @@ function rgbToHsl(r, g, b,) {
     }
     h /= 6;
   }
-  return {
-    h: h * 360,
-    s,
-    l,
-  };
+  return { h: h * 360, s, l, };
 }
 function hue2rgb(p, q, t,) {
-  if (t < 0) {
-    t += 1;
-  }
-  if (t > 1) {
-    t -= 1;
-  }
-  if (t < 1 / 6) {
-    return p + (q - p) * 6 * t;
-  }
-  if (t < 1 / 2) {
-    return q;
-  }
-  if (t < 2 / 3) {
-    return p + (q - p) * (2 / 3 - t) * 6;
-  }
+  if (t < 0) t += 1;
+  if (t > 1) t -= 1;
+  if (t < 1 / 6) return p + (q - p) * 6 * t;
+  if (t < 1 / 2) return q;
+  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
   return p;
 }
 function hslToRgb(h, s, l,) {
@@ -13643,20 +10609,15 @@ function hslToRgb(h, s, l,) {
   h = bound01(h, 360,);
   s = bound01(s * 100, 100,);
   l = bound01(l * 100, 100,);
-  if (s === 0) {
-    r = g = b = l;
-  } else {
+  if (s === 0) r = g = b = l;
+  else {
     const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
     const p = 2 * l - q;
     r = hue2rgb(p, q, h + 1 / 3,);
     g = hue2rgb(p, q, h,);
     b = hue2rgb(p, q, h - 1 / 3,);
   }
-  return {
-    r: r * 255,
-    g: g * 255,
-    b: b * 255,
-  };
+  return { r: r * 255, g: g * 255, b: b * 255, };
 }
 function rgbToHsv(r, g, b,) {
   r = bound01(r, 255,);
@@ -13668,9 +10629,8 @@ function rgbToHsv(r, g, b,) {
   let h;
   const s = max === 0 ? 0 : d / max;
   const v = max;
-  if (max === min) {
-    h = 0;
-  } else {
+  if (max === min) h = 0;
+  else {
     switch (max) {
       case r:
         h = (g - b) / d + (g < b ? 6 : 0);
@@ -13684,11 +10644,7 @@ function rgbToHsv(r, g, b,) {
     }
     h /= 6;
   }
-  return {
-    h,
-    s,
-    v,
-  };
+  return { h, s, v, };
 }
 function hsvToRgb(h, s, v,) {
   h = bound01(h, 360,) * 6;
@@ -13703,11 +10659,7 @@ function hsvToRgb(h, s, v,) {
   const r = [v, q, p, p, t, v,][mod];
   const g = [t, v, v, q, p, p,][mod];
   const b = [p, p, t, v, v, q,][mod];
-  return {
-    r: r * 255,
-    g: g * 255,
-    b: b * 255,
-  };
+  return { r: r * 255, g: g * 255, b: b * 255, };
 }
 function bound01(n, max,) {
   let _max;
@@ -13715,20 +10667,12 @@ function bound01(n, max,) {
   if (typeof max === 'string') _max = parseFloat(max,);
   else _max = max;
   if (typeof n === 'string') {
-    if (isOnePointZero(n,)) {
-      n = '100%';
-    }
+    if (isOnePointZero(n,)) n = '100%';
     const processPercent = isPercentage(n,);
     _n = Math.min(_max, Math.max(0, parseFloat(n,),),);
-    if (processPercent) {
-      _n = Math.floor(_n * _max,) / 100;
-    }
-  } else {
-    _n = n;
-  }
-  if (Math.abs(_n - _max,) < 1e-6) {
-    return 1;
-  }
+    if (processPercent) _n = Math.floor(_n * _max,) / 100;
+  } else _n = n;
+  if (Math.abs(_n - _max,) < 1e-6) return 1;
   return _n % _max / _max;
 }
 function isOnePointZero(n,) {
@@ -13738,11 +10682,8 @@ function isPercentage(n,) {
   return typeof n === 'string' && n.includes('%',);
 }
 function pad2(char,) {
-  if (char.length === 1) {
-    return '0' + char;
-  } else {
-    return '' + char;
-  }
+  if (char.length === 1) return '0' + char;
+  else return '' + char;
 }
 var matchers = (() => {
   const cssInteger = '[-\\+]?\\d+%?';
@@ -13769,29 +10710,11 @@ function stringToObject(inputColor,) {
   const trimLeft = /^[\s,#]+/u;
   let color2 = inputColor.replace(trimLeft, '',).trimEnd().toLowerCase();
   const namedColor = cssNames[color2];
-  if (namedColor) {
-    color2 = namedColor;
-  }
-  if (color2 === 'transparent') {
-    return {
-      r: 0,
-      g: 0,
-      b: 0,
-      a: 0,
-      format: 'name',
-      /* NAME */
-    };
-  }
+  if (namedColor) color2 = namedColor;
+  if (color2 === 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name', /* NAME */ };
   let match;
   if (match = matchers.rgb.exec(color2,)) {
-    return {
-      r: parseInt(match[1] ?? '',),
-      g: parseInt(match[2] ?? '',),
-      b: parseInt(match[3] ?? '',),
-      a: 1,
-      format: 'rgb',
-      /* RGB */
-    };
+    return { r: parseInt(match[1] ?? '',), g: parseInt(match[2] ?? '',), b: parseInt(match[3] ?? '',), a: 1, format: 'rgb', /* RGB */ };
   }
   if (match = matchers.rgba.exec(color2,)) {
     return {
@@ -13799,8 +10722,7 @@ function stringToObject(inputColor,) {
       g: parseInt(match[2] ?? '',),
       b: parseInt(match[3] ?? '',),
       a: parseFloat(match[4] ?? '',),
-      format: 'rgb',
-      /* RGB */
+      format: 'rgb', /* RGB */
     };
   }
   if (match = matchers.hsl.exec(color2,)) {
@@ -13809,8 +10731,7 @@ function stringToObject(inputColor,) {
       s: percentToFraction(match[2] ?? '',),
       l: percentToFraction(match[3] ?? '',),
       a: 1,
-      format: 'hsl',
-      /* HSL */
+      format: 'hsl', /* HSL */
     };
   }
   if (match = matchers.hsla.exec(color2,)) {
@@ -13819,8 +10740,7 @@ function stringToObject(inputColor,) {
       s: percentToFraction(match[2] ?? '',),
       l: percentToFraction(match[3] ?? '',),
       a: parseFloat(match[4] ?? '',),
-      format: 'hsl',
-      /* HSL */
+      format: 'hsl', /* HSL */
     };
   }
   if (match = matchers.hsv.exec(color2,)) {
@@ -13829,8 +10749,7 @@ function stringToObject(inputColor,) {
       s: percentToFraction(match[2] ?? '',),
       v: percentToFraction(match[3] ?? '',),
       a: 1,
-      format: 'hsv',
-      /* HSV */
+      format: 'hsv', /* HSV */
     };
   }
   if (match = matchers.hsva.exec(color2,)) {
@@ -13839,8 +10758,7 @@ function stringToObject(inputColor,) {
       s: percentToFraction(match[2] ?? '',),
       v: percentToFraction(match[3] ?? '',),
       a: parseFloat(match[4] ?? '',),
-      format: 'hsv',
-      /* HSV */
+      format: 'hsv', /* HSV */
     };
   }
   if (match = matchers.hex8.exec(color2,)) {
@@ -13849,8 +10767,7 @@ function stringToObject(inputColor,) {
       g: parseIntFromHex(match[2] ?? '',),
       b: parseIntFromHex(match[3] ?? '',),
       a: convertHexToDecimal(match[4] ?? '',),
-      format: namedColor ? 'name' : 'hex',
-      /* HEX */
+      format: namedColor ? 'name' : 'hex', /* HEX */
     };
   }
   if (match = matchers.hex6.exec(color2,)) {
@@ -13859,8 +10776,7 @@ function stringToObject(inputColor,) {
       g: parseIntFromHex(match[2] ?? '',),
       b: parseIntFromHex(match[3] ?? '',),
       a: 1,
-      format: namedColor ? 'name' : 'hex',
-      /* HEX */
+      format: namedColor ? 'name' : 'hex', /* HEX */
     };
   }
   if (match = matchers.hex4.exec(color2,)) {
@@ -13869,8 +10785,7 @@ function stringToObject(inputColor,) {
       g: parseIntFromHex(`${match[2]}${match[2]}`,),
       b: parseIntFromHex(`${match[3]}${match[3]}`,),
       a: convertHexToDecimal(match[4] + '' + match[4],),
-      format: namedColor ? 'name' : 'hex',
-      /* HEX */
+      format: namedColor ? 'name' : 'hex', /* HEX */
     };
   }
   if (match = matchers.hex3.exec(color2,)) {
@@ -13879,12 +10794,9 @@ function stringToObject(inputColor,) {
       g: parseIntFromHex(`${match[2]}${match[2]}`,),
       b: parseIntFromHex(`${match[3]}${match[3]}`,),
       a: 1,
-      format: namedColor ? 'name' : 'hex',
-      /* HEX */
+      format: namedColor ? 'name' : 'hex', /* HEX */
     };
-  } else {
-    return false;
-  }
+  } else return false;
 }
 function parseIntFromHex(hex2,) {
   return parseInt(hex2, 16,);
@@ -13899,20 +10811,12 @@ var Color = /* @__PURE__ */ (() => {
       let c = cache.get(color2,);
       if (c) return c;
       c = createColor(color2,);
-      if (c === void 0) {
-        return {
-          ...Color2('black',),
-          isValid: false,
-        };
-      }
+      if (c === void 0) return { ...Color2('black',), isValid: false, };
       cache.set(color2, c,);
       return c;
     }
     const created = createColor(color2, r, g, b,);
-    return created !== void 0 ? created : {
-      ...Color2('black',),
-      isValid: false,
-    };
+    return created !== void 0 ? created : { ...Color2('black',), isValid: false, };
   }
   function createColor(color2, r, g, b,) {
     if (color2 === '') return void 0;
@@ -13933,9 +10837,7 @@ var Color = /* @__PURE__ */ (() => {
         toValue: () => Color2.toRgbString(newColor,),
       };
       return newColor;
-    } else {
-      return void 0;
-    }
+    } else return void 0;
   }
   const ColorMixModel = {
     isRGB(colorModel,) {
@@ -13946,25 +10848,16 @@ var Color = /* @__PURE__ */ (() => {
     },
   };
   Color2.inspect = (color2, initialValue,) => {
-    if (color2.format === 'hsl') {
-      return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;
-    } else if (color2.format === 'hex' || color2.format === 'name') {
-      return `<${color2.constructor.name} "${initialValue}">`;
-    } else {
-      return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;
-    }
+    if (color2.format === 'hsl') return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;
+    else if (color2.format === 'hex' || color2.format === 'name') return `<${color2.constructor.name} "${initialValue}">`;
+    else return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;
   };
   Color2.isColor = (color2) => {
-    if (typeof color2 === 'string') {
-      return Color2.isColorString(color2,);
-    } else {
-      return Color2.isColorObject(color2,);
-    }
+    if (typeof color2 === 'string') return Color2.isColorString(color2,);
+    else return Color2.isColorObject(color2,);
   };
   Color2.isColorString = (colorString) => {
-    if (typeof colorString === 'string') {
-      return stringToObject(colorString,) !== false;
-    }
+    if (typeof colorString === 'string') return stringToObject(colorString,) !== false;
     return false;
   };
   Color2.isColorObject = (color2) => {
@@ -13987,10 +10880,7 @@ var Color = /* @__PURE__ */ (() => {
       : 'rgba(' + Math.round(color2.r,) + ', ' + Math.round(color2.g,) + ', ' + Math.round(color2.b,) + ', ' + color2.roundA + ')';
   };
   Color2.toHusl = (color2) => {
-    return {
-      ...rgbToHsluv(color2.r, color2.g, color2.b,),
-      a: color2.roundA,
-    };
+    return { ...rgbToHsluv(color2.r, color2.g, color2.b,), a: color2.roundA, };
   };
   Color2.toHslString = (color2) => {
     const hsl = Color2.toHsl(color2,);
@@ -14001,12 +10891,7 @@ var Color = /* @__PURE__ */ (() => {
   };
   Color2.toHsv = (color2) => {
     const hsv = rgbToHsv(color2.r, color2.g, color2.b,);
-    return {
-      h: hsv.h * 360,
-      s: hsv.s,
-      v: hsv.v,
-      a: color2.a,
-    };
+    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: color2.a, };
   };
   Color2.toHsvString = (color2) => {
     const hsv = rgbToHsv(color2.r, color2.g, color2.b,);
@@ -14016,36 +10901,20 @@ var Color = /* @__PURE__ */ (() => {
     return color2.a === 1 ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)' : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + color2.roundA + ')';
   };
   Color2.toName = (color2) => {
-    if (color2.a === 0) {
-      return 'transparent';
-    }
-    if (color2.a < 1) {
-      return false;
-    }
+    if (color2.a === 0) return 'transparent';
+    if (color2.a < 1) return false;
     const hex2 = rgbToHex(color2.r, color2.g, color2.b, true,);
     for (const key7 of Object.keys(cssNames,)) {
       const value = cssNames[key7];
-      if (value === hex2) {
-        return key7;
-      }
+      if (value === hex2) return key7;
     }
     return false;
   };
   Color2.toHsl = (color2) => {
-    return {
-      h: Math.round(color2.h,),
-      s: color2.s,
-      l: color2.l,
-      a: color2.a,
-    };
+    return { h: Math.round(color2.h,), s: color2.s, l: color2.l, a: color2.a, };
   };
   Color2.toRgb = (color2) => {
-    return {
-      r: Math.round(color2.r,),
-      g: Math.round(color2.g,),
-      b: Math.round(color2.b,),
-      a: color2.a,
-    };
+    return { r: Math.round(color2.r,), g: Math.round(color2.g,), b: Math.round(color2.b,), a: color2.a, };
   };
   Color2.brighten = (color2, amount = 10,) => {
     const rgb = Color2.toRgb(color2,);
@@ -14088,23 +10957,13 @@ var Color = /* @__PURE__ */ (() => {
     return Color2(hsl,);
   };
   Color2.alpha = (color2, a = 1,) => {
-    return Color2({
-      r: color2.r,
-      g: color2.g,
-      b: color2.b,
-      a,
-    },);
+    return Color2({ r: color2.r, g: color2.g, b: color2.b, a, },);
   };
   Color2.transparent = (color2) => {
     return Color2.alpha(color2, 0,);
   };
   Color2.multiplyAlpha = (color2, alphaValue = 1,) => {
-    return Color2({
-      r: color2.r,
-      g: color2.g,
-      b: color2.b,
-      a: color2.a * alphaValue,
-    },);
+    return Color2({ r: color2.r, g: color2.g, b: color2.b, a: color2.a * alphaValue, },);
   };
   Color2.interpolate = (colorA, colorB, model = 'rgb',) => {
     if (!Color2.isColorObject(colorA,) || !Color2.isColorObject(colorB,)) {
@@ -14115,10 +10974,7 @@ var Color = /* @__PURE__ */ (() => {
       return color2;
     };
   };
-  Color2.mix = (from, toColor, {
-    model = 'rgb',
-    /* RGB */
-  } = {},) => {
+  Color2.mix = (from, toColor, { model = 'rgb', /* RGB */ } = {},) => {
     const fromColor = typeof from === 'string' ? Color2(from,) : from;
     const mixer = Color2.interpolate(fromColor, toColor, model,);
     return (p) => Color2.toRgbString(mixer(p,),);
@@ -14141,30 +10997,21 @@ var Color = /* @__PURE__ */ (() => {
         hslA = Color2.toHusl(colorA,);
         hslB = Color2.toHusl(colorB,);
       }
-      if (hslA.s === 0) {
-        hslA.h = hslB.h;
-      } else if (hslB.s === 0) {
-        hslB.h = hslA.h;
-      }
+      if (hslA.s === 0) hslA.h = hslB.h;
+      else if (hslB.s === 0) hslB.h = hslA.h;
       const fromH = hslA.h;
       const toH = hslB.h;
       let deltaH = toH - fromH;
-      if (deltaH > 180) {
-        deltaH = toH - 360 - fromH;
-      } else if (deltaH < -180) {
-        deltaH = toH + 360 - fromH;
-      }
+      if (deltaH > 180) deltaH = toH - 360 - fromH;
+      else if (deltaH < -180) deltaH = toH + 360 - fromH;
       const tween = {
         h: modulate(fraction2, [0, 1,], [fromH, fromH + deltaH,], limit,),
         s: modulate(fraction2, [0, 1,], [hslA.s, hslB.s,], limit,),
         l: modulate(fraction2, [0, 1,], [hslA.l, hslB.l,], limit,),
         a: modulate(fraction2, [0, 1,], [colorA.a, colorB.a,], limit,),
       };
-      if (ColorMixModel.isHSL(model,)) {
-        result = Color2(tween,);
-      } else {
-        result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a,),);
-      }
+      if (ColorMixModel.isHSL(model,)) result = Color2(tween,);
+      else result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a,),);
     }
     return result;
   };
@@ -14184,9 +11031,7 @@ var Color = /* @__PURE__ */ (() => {
   };
   Color2.isValidColorProperty = (name, value,) => {
     const isColorKey = name.toLowerCase().slice(-5,) === 'color' || name === 'fill' || name === 'stroke';
-    if (isColorKey && typeof value === 'string' && Color2.isColorString(value,)) {
-      return true;
-    }
+    if (isColorKey && typeof value === 'string' && Color2.isColorString(value,)) return true;
     return false;
   };
   Color2.difference = (colorA, colorB,) => {
@@ -14200,18 +11045,10 @@ var Color = /* @__PURE__ */ (() => {
     return Math.sqrt(2 * deltaR2 + 4 * deltaG2 + 3 * deltaB2 + _r * (deltaR2 - deltaB2) / 256,);
   };
   Color2.equal = (colorA, colorB, tolerance = 0.1,) => {
-    if (Math.abs(colorA.r - colorB.r,) >= tolerance) {
-      return false;
-    }
-    if (Math.abs(colorA.g - colorB.g,) >= tolerance) {
-      return false;
-    }
-    if (Math.abs(colorA.b - colorB.b,) >= tolerance) {
-      return false;
-    }
-    if (Math.abs(colorA.a - colorB.a,) * 256 >= tolerance) {
-      return false;
-    }
+    if (Math.abs(colorA.r - colorB.r,) >= tolerance) return false;
+    if (Math.abs(colorA.g - colorB.g,) >= tolerance) return false;
+    if (Math.abs(colorA.b - colorB.b,) >= tolerance) return false;
+    if (Math.abs(colorA.a - colorB.a,) * 256 >= tolerance) return false;
     return true;
   };
   const channelToDecimal = interpolate([0, 255,], [0, 1,],);
@@ -14222,11 +11059,7 @@ var Color = /* @__PURE__ */ (() => {
     return (Math.sign(channel,) || 1) * Math.pow((abs + 0.055) / 1.055, 2.4,);
   }
   Color2.luminance = (color2) => {
-    const {
-      r,
-      g,
-      b,
-    } = Color2.toRgb(color2,);
+    const { r, g, b, } = Color2.toRgb(color2,);
     return 0.2126 * convertChannelToLinearRgb(r,) + 0.7152 * convertChannelToLinearRgb(g,) + 0.0722 * convertChannelToLinearRgb(b,);
   };
   Color2.contrast = (a, b,) => {
@@ -14246,101 +11079,53 @@ function getCompleteColorStrategy(colorOrR, g, b, a = 1,) {
     const _g = g;
     const _b = b;
     const _a = a;
-    completeColor = getCompleteColorFromRGB({
-      r: _r,
-      g: _g,
-      b: _b,
-      a: _a,
-    },);
-  } else if (typeof colorOrR === 'string') {
-    completeColor = getCompleteColorFromString(colorOrR,);
-  } else if (typeof colorOrR === 'object') {
+    completeColor = getCompleteColorFromRGB({ r: _r, g: _g, b: _b, a: _a, },);
+  } else if (typeof colorOrR === 'string') completeColor = getCompleteColorFromString(colorOrR,);
+  else if (typeof colorOrR === 'object') {
     if (colorOrR.hasOwnProperty('r',) && colorOrR.hasOwnProperty('g',) && colorOrR.hasOwnProperty('b',)) {
       completeColor = getCompleteColorFromRGB(colorOrR,);
-    } else {
-      completeColor = getCompleteColorFromHSL(colorOrR,);
-    }
+    } else completeColor = getCompleteColorFromHSL(colorOrR,);
   }
   return completeColor;
 }
 function getCompleteColorFromString(color2,) {
   const result = stringToObject(color2,);
   if (result) {
-    if (result.format === 'hsl') {
-      return getCompleteColorFromHSL(result,);
-    } else if (result.format === 'hsv') {
-      return getCompleteColorFromHSV(result,);
-    } else {
-      return getCompleteColorFromRGB(result,);
-    }
+    if (result.format === 'hsl') return getCompleteColorFromHSL(result,);
+    else if (result.format === 'hsv') return getCompleteColorFromHSV(result,);
+    else return getCompleteColorFromRGB(result,);
   }
 }
 function getCompleteColorFromHSV(color2,) {
   const rgb = hsvToRgb(color2.h, color2.s, color2.v,);
   const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b,);
-  return {
-    ...hsl,
-    ...rgb,
-    format: 'rgb',
-    a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1,
-  };
+  return { ...hsl, ...rgb, format: 'rgb', a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1, };
 }
 function getCompleteColorFromRGB(color2,) {
   const rgb = rgbToRgb(color2.r, color2.g, color2.b,);
   const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b,);
-  return {
-    ...hsl,
-    ...rgb,
-    format: 'rgb',
-    a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1,
-  };
+  return { ...hsl, ...rgb, format: 'rgb', a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1, };
 }
 function getCompleteColorFromHSL(color2,) {
   let h;
   let s;
   let l;
-  let rgb = {
-    r: 0,
-    g: 0,
-    b: 0,
-  };
-  let hsl = {
-    h: 0,
-    s: 0,
-    l: 0,
-  };
+  let rgb = { r: 0, g: 0, b: 0, };
+  let hsl = { h: 0, s: 0, l: 0, };
   h = isNumeric(color2.h,) ? color2.h : 0;
   h = (h + 360) % 360;
   s = isNumeric(color2.s,) ? color2.s : 1;
-  if (typeof color2.s === 'string') {
-    s = numberFromString(color2.s,);
-  }
+  if (typeof color2.s === 'string') s = numberFromString(color2.s,);
   l = isNumeric(color2.l,) ? color2.l : 0.5;
-  if (typeof color2.l === 'string') {
-    l = numberFromString(color2.l,);
-  }
+  if (typeof color2.l === 'string') l = numberFromString(color2.l,);
   rgb = hslToRgb(h, s, l,);
-  hsl = {
-    h,
-    s,
-    l,
-  };
-  return {
-    ...rgb,
-    ...hsl,
-    a: color2.a === void 0 ? 1 : color2.a,
-    format: 'hsl',
-    /* HSL */
-  };
+  hsl = { h, s, l, };
+  return { ...rgb, ...hsl, a: color2.a === void 0 ? 1 : color2.a, format: 'hsl', /* HSL */ };
 }
 function correctAlpha(alphaValue,) {
   alphaValue = parseFloat(alphaValue,);
-  if (alphaValue < 0) {
-    alphaValue = 0;
-  }
-  if (isNaN(alphaValue,) || alphaValue > 1) {
-    alphaValue = 1;
-  }
+  if (alphaValue < 0) alphaValue = 0;
+  if (isNaN(alphaValue,) || alphaValue > 1) alphaValue = 1;
   return alphaValue;
 }
 var ColorInterpolation = (type = 'husl',) => {
@@ -14383,9 +11168,7 @@ var ObjectInterpolation = (valueInterpolation) => {
         }
       }
       return (progress2) => {
-        for (const key7 in interpolations) {
-          result[key7] = interpolations[key7](progress2,);
-        }
+        for (const key7 in interpolations) result[key7] = interpolations[key7](progress2,);
         return result;
       };
     },
@@ -14399,15 +11182,11 @@ var ObjectInterpolation = (valueInterpolation) => {
     },
   };
 };
-var DefaultInterpolationOptions = {
-  colorModel: 'husl',
-  /* HUSL */
-};
+var DefaultInterpolationOptions = { colorModel: 'husl', /* HUSL */ };
 var ValueInterpolation = class {
   /**
    * @internal
-   */
-  constructor(options = DefaultInterpolationOptions,) {
+   */ constructor(options = DefaultInterpolationOptions,) {
     __publicField(this, 'options',);
     __publicField(this, 'interpolate', (from, to,) => {
       [from, to,] = Interpolation.handleUndefined(from, to,);
@@ -14417,32 +11196,22 @@ var ValueInterpolation = class {
       const interpolation = this.interPolationForValue(from,);
       return interpolation.difference(from, to,);
     },);
-    this.options = {
-      ...DefaultInterpolationOptions,
-      ...options,
-    };
-  }
-  /**
+    this.options = { ...DefaultInterpolationOptions, ...options, };
+  } /**
    * @internal
    */
+
   interPolationForValue(value,) {
     const type = typeof value;
-    if (type === 'number') {
-      return NumberInterpolation;
-    } else if (type === 'boolean' || type === 'function') {
-      return NoInterpolation;
-    } else if (Color.isColor(value,)) {
-      return ColorInterpolation(this.options.colorModel,);
-    } else if (type === 'object') {
-      if (value === null) {
-        return NoInterpolation;
-      }
+    if (type === 'number') return NumberInterpolation;
+    else if (type === 'boolean' || type === 'function') return NoInterpolation;
+    else if (Color.isColor(value,)) return ColorInterpolation(this.options.colorModel,);
+    else if (type === 'object') {
+      if (value === null) return NoInterpolation;
       const constructor = value.constructor;
       if (constructor && isInterpolatable(constructor,)) {
         const interpolation = constructor.interpolationFor(value, this,);
-        if (interpolation && interpolation !== this && interpolation.constructor !== ValueInterpolation) {
-          return interpolation;
-        }
+        if (interpolation && interpolation !== this && interpolation.constructor !== ValueInterpolation) return interpolation;
       }
       return ObjectInterpolation(this,);
     }
@@ -14452,10 +11221,7 @@ var ValueInterpolation = class {
 };
 var AnyInterpolation = /* @__PURE__ */ new ValueInterpolation();
 var isMotionValue2 = (v) => v instanceof MotionValue;
-var Defaults2 = {
-  delta: 1 / 60,
-  maxValues: 1e4,
-};
+var Defaults2 = { delta: 1 / 60, maxValues: 1e4, };
 var PrecalculatedAnimator = class {
   constructor(options,) {
     __publicField(this, 'animator',);
@@ -14463,27 +11229,18 @@ var PrecalculatedAnimator = class {
     __publicField(this, 'currentTime', 0,);
     __publicField(this, 'totalTime',);
     __publicField(this, 'options',);
-    this.options = {
-      ...Defaults2,
-      ...options,
-    };
+    this.options = { ...Defaults2, ...options, };
     this.animator = options.animator;
   }
   preCalculate() {
-    if (!this.animator.isReady()) {
-      return;
-    }
-    const {
-      delta,
-    } = this.options;
+    if (!this.animator.isReady()) return;
+    const { delta, } = this.options;
     this.values = [];
     while (!this.animator.isFinished() && this.values.length < this.options.maxValues) {
       let value = this.animator.next(this.options.delta,);
       if (typeof value === 'object' && value) {
         const object = value;
-        const copy = {
-          ...object,
-        };
+        const copy = { ...object, };
         value = copy;
       }
       this.values.push(value,);
@@ -14523,9 +11280,7 @@ var PrecalculatedAnimator = class {
   }
 };
 var import_eventemitter3 = __toESM(require_eventemitter3(), 1,);
-var {
-  EventEmitter: EventEmitter3,
-} = import_eventemitter3.default;
+var { EventEmitter: EventEmitter3, } = import_eventemitter3.default;
 var EventEmitter = class {
   constructor() {
     __publicField(this, '_emitter', new EventEmitter3(),);
@@ -14535,9 +11290,7 @@ var EventEmitter = class {
   }
   eventListeners() {
     const listeners = {};
-    for (const eventName of this._emitter.eventNames()) {
-      listeners[eventName] = this._emitter.listeners(eventName,);
-    }
+    for (const eventName of this._emitter.eventNames()) listeners[eventName] = this._emitter.listeners(eventName,);
     return listeners;
   }
   on(eventName, fn,) {
@@ -14553,37 +11306,22 @@ var EventEmitter = class {
     this.addEventListener(eventName, fn, false, true, this,);
   }
   addEventListener(eventName, fn, once, unique, context,) {
-    if (unique) {
-      for (const name of this._emitter.eventNames()) {
-        if (fn === this._emitter.listeners(name,)) {
-          return;
-        }
-      }
-    }
-    if (once === true) {
-      this._emitter.once(eventName, fn, context,);
-    } else {
-      this._emitter.addListener(eventName, fn, context,);
-    }
+    if (unique) for (const name of this._emitter.eventNames()) if (fn === this._emitter.listeners(name,)) return;
+    if (once === true) this._emitter.once(eventName, fn, context,);
+    else this._emitter.addListener(eventName, fn, context,);
   }
   removeEventListeners(eventName, fn,) {
-    if (eventName) {
-      this._emitter.removeListener(eventName, fn,);
-    } else {
-      this.removeAllEventListeners();
-    }
+    if (eventName) this._emitter.removeListener(eventName, fn,);
+    else this.removeAllEventListeners();
   }
   removeAllEventListeners() {
     this._emitter.removeAllListeners();
   }
   countEventListeners(eventName, handler,) {
-    if (eventName) {
-      return this._emitter.listeners(eventName,).length;
-    } else {
+    if (eventName) return this._emitter.listeners(eventName,).length;
+    else {
       let count = 0;
-      for (const name of this._emitter.eventNames()) {
-        count += this._emitter.listeners(name,).length;
-      }
+      for (const name of this._emitter.eventNames()) count += this._emitter.listeners(name,).length;
       return count;
     }
   }
@@ -14608,9 +11346,7 @@ var mockWindow = {
   devicePixelRatio: 1,
   scrollX: 0,
   scrollY: 0,
-  location: {
-    href: '',
-  },
+  location: { href: '', },
   setTimeout: () => 0,
   clearTimeout: () => {},
   setInterval: () => 0,
@@ -14644,8 +11380,7 @@ var LoopTimeStep = 1 / 60;
 var Loop = class extends EventEmitter {
   /**
    * @internal
-   */
-  constructor(start = false,) {
+   */ constructor(start = false,) {
     super();
     __publicField(this, '_started', false,);
     __publicField(this, '_frame', 0,);
@@ -14658,15 +11393,13 @@ var Loop = class extends EventEmitter {
       this._processFrameTasks();
       this._frame++;
     },);
-    if (start) {
-      this.start();
-    }
-  }
-  /**
+    if (start) this.start();
+  } /**
    * To add a task to be done at the end of a frame.
    * Tasks added from a task will be ignored. These will run after loop events have been processed.
    * @internal
    */
+
   addFrameTask(task,) {
     this._frameTasks.push(task,);
   }
@@ -14675,50 +11408,48 @@ var Loop = class extends EventEmitter {
     const postEventTasks = this._frameTasks;
     const length = postEventTasks.length;
     if (length === 0) return;
-    for (let i = 0; i < length; i++) {
-      (_a = postEventTasks[i]) == null ? void 0 : _a.call(postEventTasks,);
-    }
+    for (let i = 0; i < length; i++) (_a = postEventTasks[i]) == null ? void 0 : _a.call(postEventTasks,);
     postEventTasks.length = 0;
-  }
-  /**
+  } /**
    * @internal
    */
+
   static set TimeStep(value,) {
     LoopTimeStep = value;
-  }
-  /**
+  } /**
    * @internal
    */
+
   static get TimeStep() {
     return LoopTimeStep;
-  }
-  /**
+  } /**
    * @internal
    */
+
   start() {
     if (this._started) return this;
     this._frame = 0;
     this._started = true;
     raf(this.tick,);
     return this;
-  }
-  /**
+  } /**
    * @internal
    * @deprecated Don’t use `stop` as you could be stopping the MainLoop for others.
    */
+
   stop() {
     this._started = false;
     return this;
-  }
-  /**
+  } /**
    * @internal
    */
+
   get frame() {
     return this._frame;
-  }
-  /**
+  } /**
    * @internal
    */
+
   get time() {
     return this._frame * LoopTimeStep;
   }
@@ -14731,10 +11462,7 @@ var RenderTarget = /* @__PURE__ */ ((RenderTarget2) => {
   RenderTarget2['preview'] = 'PREVIEW';
   return RenderTarget2;
 })(RenderTarget || {},);
-var RenderEnvironment = {
-  target: 'PREVIEW',
-  zoom: 1,
-};
+var RenderEnvironment = { target: 'PREVIEW', zoom: 1, };
 function executeInRenderEnvironment(customEnvironment, task,) {
   const previousEnvironment = Object.assign({}, RenderEnvironment,);
   Object.assign(RenderEnvironment, customEnvironment,);
@@ -14751,12 +11479,8 @@ function useRenderEnvironment(target, zoom,) {
     RenderEnvironment.target = target;
     willChangeElements = true;
   }
-  if (RenderEnvironment.zoom !== zoom) {
-    RenderEnvironment.zoom = zoom;
-  }
-  return {
-    willChangeElements,
-  };
+  if (RenderEnvironment.zoom !== zoom) RenderEnvironment.zoom = zoom;
+  return { willChangeElements, };
 }
 ((RenderTarget2) => {
   function current() {
@@ -14777,21 +11501,16 @@ var AnimationDriver = class {
     this.updateCallback = updateCallback;
     this.finishedCallback = finishedCallback;
     __publicField(this, 'update', (frame2, elapsed,) => {
-      if (this.animator.isFinished()) {
-        this.finish();
-      } else {
+      if (this.animator.isFinished()) this.finish();
+      else {
         const value = this.animator.next(elapsed,);
         this.updateCallback(value,);
       }
     },);
-    if (!this.animator.isReady()) {
-      console.warn('AnimationDriver initialized with animator that isn\'t ready',);
-    }
+    if (!this.animator.isReady()) console.warn('AnimationDriver initialized with animator that isn\'t ready',);
   }
   finish() {
-    if (this.finishedCallback) {
-      this.finishedCallback(this.animator.isFinished(),);
-    }
+    if (this.finishedCallback) this.finishedCallback(this.animator.isFinished(),);
   }
   isFinished() {
     return this.animator.isFinished();
@@ -14813,16 +11532,11 @@ var MainLoopAnimationDriver = class extends AnimationDriver {
     super.finish();
   }
 };
-var DefaultDeprecatedAnimationOptions = {
-  precalculate: false,
-  colorModel: 'husl',
-  /* HUSL */
-};
+var DefaultDeprecatedAnimationOptions = { precalculate: false, colorModel: 'husl', /* HUSL */ };
 var FramerAnimation = class {
   /**
    * @internal
-   */
-  constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver,) {
+   */ constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver,) {
     __publicField(this, 'driver',);
     __publicField(this, 'playStateSource', 'idle',);
     __publicField(this, 'onfinish',);
@@ -14833,31 +11547,19 @@ var FramerAnimation = class {
     __publicField(this, 'finishedResolve',);
     __publicField(this, 'finishedReject',);
     this.resetFinishedPromise();
-    const deprecatedAnimationOptions = {
-      ...DefaultDeprecatedAnimationOptions,
-    };
+    const deprecatedAnimationOptions = { ...DefaultDeprecatedAnimationOptions, };
     const animatorOptions = {};
     if (options) {
       Object.assign(deprecatedAnimationOptions, options,);
       Object.assign(animatorOptions, options,);
     }
     let interpolation;
-    if (deprecatedAnimationOptions.customInterpolation) {
-      interpolation = deprecatedAnimationOptions.customInterpolation;
-    } else {
-      interpolation = new ValueInterpolation(options,);
-    }
+    if (deprecatedAnimationOptions.customInterpolation) interpolation = deprecatedAnimationOptions.customInterpolation;
+    else interpolation = new ValueInterpolation(options,);
     let animator;
-    if (!animatorClass) {
-      animator = new BezierAnimator({}, interpolation,);
-    } else {
-      animator = new animatorClass(animatorOptions, interpolation,);
-    }
-    if (deprecatedAnimationOptions.precalculate) {
-      animator = new PrecalculatedAnimator({
-        animator,
-      },);
-    }
+    if (!animatorClass) animator = new BezierAnimator({}, interpolation,);
+    else animator = new animatorClass(animatorOptions, interpolation,);
+    if (deprecatedAnimationOptions.precalculate) animator = new PrecalculatedAnimator({ animator, },);
     animator.setFrom(from,);
     animator.setTo(to,);
     const updateCallback = (value) => {
@@ -14866,51 +11568,43 @@ var FramerAnimation = class {
     const finishedCallback = (isFinished) => {
       if (isFinished) {
         FramerAnimation.driverCallbackHandler(target, to,);
-        if (this.playStateSource === 'running') {
-          this.playStateValue = 'finished';
-        }
+        if (this.playStateSource === 'running') this.playStateValue = 'finished';
       }
     };
     this.driver = new driverClass(animator, updateCallback, finishedCallback,);
-  }
-  /**
+  } /**
    * @internal
    */
+
   static driverCallbackHandler(target, value,) {
-    if (isAnimatable2(target,) || isMotionValue2(target,)) {
-      target.set(value,);
-    } else {
+    if (isAnimatable2(target,) || isMotionValue2(target,)) target.set(value,);
+    else {
       const targetObject = target;
       Animatable.transaction((update) => {
         for (const key7 in targetObject) {
           const targetValue = targetObject[key7];
-          if (isAnimatable2(targetValue,)) {
-            update(targetValue, value[key7],);
-          } else {
-            targetObject[key7] = value[key7];
-          }
+          if (isAnimatable2(targetValue,)) update(targetValue, value[key7],);
+          else targetObject[key7] = value[key7];
         }
       },);
     }
-  }
-  /**
+  } /**
    * @internal
    */
+
   get playStateValue() {
     return this.playStateSource;
-  }
-  /**
+  } /**
    * @internal
    */
+
   set playStateValue(value,) {
     if (value !== this.playStateSource) {
       const oldValue = value;
       this.playStateSource = value;
       switch (value) {
         case 'idle':
-          if (oldValue === 'running') {
-            this.oncancel && this.oncancel();
-          }
+          if (oldValue === 'running') this.oncancel && this.oncancel();
           this.readyResolve && this.readyResolve();
           this.resetReadyPromise();
           break;
@@ -14926,30 +11620,25 @@ var FramerAnimation = class {
           this.resetReadyPromise();
           break;
       }
-      if (oldValue === 'finished') {
-        this.resetFinishedPromise();
-      }
-      if (value === 'finished') {
-        this.playStateValue = 'idle';
-      }
+      if (oldValue === 'finished') this.resetFinishedPromise();
+      if (value === 'finished') this.playStateValue = 'idle';
     }
-  }
-  /**
+  } /**
    * @internal
    */
+
   get playState() {
     return this.playStateValue;
-  }
-  /**
+  } /**
    * @internal
    */
+
   resetReadyPromise() {
     this.readyResolve = null;
     this.readyPromise = new Promise((resolve, reject,) => {
       this.readyResolve = resolve;
     },);
-  }
-  /**
+  } /**
        * Wait for the animation to be ready to play.
        * @remarks
        * ```jsx
@@ -14966,12 +11655,13 @@ var FramerAnimation = class {
        * @returns Promise that is resolved when the animation is ready to play
        * @public
        */
+
   get ready() {
     return this.readyPromise;
-  }
-  /**
+  } /**
    * @internal
    */
+
   resetFinishedPromise() {
     this.finishedResolve = null;
     this.finishedReject = null;
@@ -14980,8 +11670,7 @@ var FramerAnimation = class {
       this.finishedReject = reject;
     },);
     this.finishedPromise.catch((reason) => {},);
-  }
-  /**
+  } /**
    * Wait for the animation to be finished.
    * @remarks
    * ```jsx
@@ -14998,17 +11687,17 @@ var FramerAnimation = class {
    * @returns Promise that is resolved when the animation is ready to play
    * @public
    */
+
   get finished() {
     return this.finishedPromise;
-  }
-  /**
+  } /**
    * @internal
    */
+
   play() {
     this.playStateValue = 'running';
     this.driver.play();
-  }
-  /**
+  } /**
    * Cancels the animation if it is still running.
    * @remarks
    * ```jsx
@@ -15017,38 +11706,34 @@ var FramerAnimation = class {
    * ```
    * @public
    */
+
   cancel() {
-    if (this.playStateValue !== 'running') {
-      return;
-    }
+    if (this.playStateValue !== 'running') return;
     this.driver.cancel();
     if (this.playState !== 'idle') {
       const reason = 'AbortError';
       this.finishedReject && this.finishedReject(reason,);
     }
     this.playStateValue = 'idle';
-  }
-  /**
+  } /**
    * @internal
    */
+
   finish() {
     if (this.playStateSource === 'running') {
       this.playStateValue = 'finished';
       this.driver.finish();
     }
-  }
-  /**
+  } /**
    * @internal
    */
+
   isFinished() {
     return this.playStateValue === 'finished';
   }
 };
 var correctBorderScale = (axis) => ({
-  correct: (latest, {
-    delta,
-    treeScale,
-  },) => {
+  correct: (latest, { delta, treeScale, },) => {
     if (typeof latest === 'string') latest = parseFloat(latest,);
     if (latest === 0) return '0px';
     let corrected = latest;
@@ -15065,31 +11750,21 @@ addScaleCorrector({
   borderRightWidth: correctBorderScale('x',),
   borderBottomWidth: correctBorderScale('y',),
 },);
-function MotionSetup({
-  children,
-},) {
-  return /* @__PURE__ */ _jsx5(Fragment, {
-    children,
-  },);
+function MotionSetup({ children, },) {
+  return /* @__PURE__ */ _jsx5(Fragment, { children, },);
 }
 function startAnimation(_key, value, target, transition = {},) {
   warnOnce2(`"startAnimation" is unsupported. Use "animate" instead: https://www.framer.com/api/motion/utilities/#animate`,);
   return new Promise((resolve) => {
-    animate(value, target, {
-      ...transition,
-      onComplete: () => resolve(),
-    },);
+    animate(value, target, { ...transition, onComplete: () => resolve(), },);
   },);
 }
 function deprecatedAnimate(from, to, animator, options,) {
   deprecationWarning('animate()', '2.0.0', 'the new animation API (https://www.framer.com/api/animation/)',);
   const target = from;
   let fromValue;
-  if (isAnimatable2(from,) || isMotionValue2(from,)) {
-    fromValue = from.get();
-  } else {
-    fromValue = Animatable.objectToValues(from,);
-  }
+  if (isAnimatable2(from,) || isMotionValue2(from,)) fromValue = from.get();
+  else fromValue = Animatable.objectToValues(from,);
   const animation = new FramerAnimation(target, fromValue, to, animator, options,);
   animation.play();
   return animation;
@@ -15105,39 +11780,19 @@ var animate2 = /* @__PURE__ */ (() => {
     return animate3(from, to, BezierAnimator, options,);
   };
   animate3.linear = (from, to, options,) => {
-    return animate3.bezier(from, to, {
-      ...options,
-      curve: 'linear',
-      /* Linear */
-    },);
+    return animate3.bezier(from, to, { ...options, curve: 'linear', /* Linear */ },);
   };
   animate3.ease = (from, to, options,) => {
-    return animate3.bezier(from, to, {
-      ...options,
-      curve: 'ease',
-      /* Ease */
-    },);
+    return animate3.bezier(from, to, { ...options, curve: 'ease', /* Ease */ },);
   };
   animate3.easeIn = (from, to, options,) => {
-    return animate3.bezier(from, to, {
-      ...options,
-      curve: 'ease-in',
-      /* EaseIn */
-    },);
+    return animate3.bezier(from, to, { ...options, curve: 'ease-in', /* EaseIn */ },);
   };
   animate3.easeOut = (from, to, options,) => {
-    return animate3.bezier(from, to, {
-      ...options,
-      curve: 'ease-out',
-      /* EaseOut */
-    },);
+    return animate3.bezier(from, to, { ...options, curve: 'ease-out', /* EaseOut */ },);
   };
   animate3.easeInOut = (from, to, options,) => {
-    return animate3.bezier(from, to, {
-      ...options,
-      curve: 'ease-in-out',
-      /* EaseInOut */
-    },);
+    return animate3.bezier(from, to, { ...options, curve: 'ease-in-out', /* EaseInOut */ },);
   };
   return animate3;
 })();
@@ -15168,55 +11823,32 @@ var LayoutIdContext = React__default.createContext({
   top: false,
   enabled: true,
 },);
-function LayoutIdProvider({
-  children,
-},) {
+function LayoutIdProvider({ children, },) {
   const context = useContext3(LayoutIdContext,);
-  if (context.top) {
-    return /* @__PURE__ */ _jsx5(Fragment, {
-      children,
-    },);
-  }
-  const cache3 = useRef({
-    // When we provide a layoutId for a node based on it's first
+  if (context.top) return /* @__PURE__ */ _jsx5(Fragment, { children, },);
+  const cache3 = useRef({ // When we provide a layoutId for a node based on it's first
     // duplicatedFrom id, we save it's layoutId mapped to it's actual id.
     // Future screen's nodes will check this cache first, to see if they've
     // previously been assigned a layoutId, or if any of there other
     // duplicatedFrom ids matched a node that was previously assigned a
     // layoutId.
     byId: {},
-    byName: {},
-    // When we navigate from screens that were duplicated from a future
+    byName: {}, // When we navigate from screens that were duplicated from a future
     // screen, to that future screen, we want to do a reverse lookup on the
     // last duplicatedFrom id, rather than the id. We need to keep them
     // separate so they don't overlap.
     byLastId: {},
     byPossibleId: {},
     byLastName: {},
-    byLayoutId: {},
-    // When we don't have a cached layoutId for all duplicatedFrom ids, we
+    byLayoutId: {}, // When we don't have a cached layoutId for all duplicatedFrom ids, we
     // need to increment and save it so that we don't create clashing
     // layoutIds. We also need to reset name counts between screens, so we
     // record those separately.
-    count: {
-      byId: {},
-      byName: {},
-    },
-  },);
-  const screen = useRef({
-    byId: {},
-    byName: {},
-    byLastId: {},
-    byPossibleId: {},
-    byLastName: {},
-    byLayoutId: {},
+    count: { byId: {}, byName: {}, },
   },);
+  const screen = useRef({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, },);
   const usedIds = useRef(/* @__PURE__ */ new Set(),).current;
-  const getLayoutId = useCallback(({
-    id: id3,
-    name,
-    duplicatedFrom,
-  },) => {
+  const getLayoutId = useCallback(({ id: id3, name, duplicatedFrom, },) => {
     if (!id3) return null;
     const cacheKey = name ? 'byName' : 'byId';
     const previousId = cache3.current[cacheKey][id3];
@@ -15280,25 +11912,18 @@ function LayoutIdProvider({
     const rootDuplicatedId = duplicatedFrom == null ? void 0 : duplicatedFrom[0];
     const identifier = name || rootDuplicatedId || id3;
     const value = (cache3.current.count[cacheKey][identifier] ?? -1) + 1;
-    const {
-      layoutId,
-      value: nextValue,
-    } = nextLayoutId(identifier, value, usedIds,);
+    const { layoutId, value: nextValue, } = nextLayoutId(identifier, value, usedIds,);
     cache3.current.count[cacheKey][identifier] = nextValue;
     screen.current[cacheKey][id3] = layoutId;
     if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {
       if (!name) {
         const lastId = duplicatedFrom[duplicatedFrom.length - 1];
-        if (lastId) {
-          screen.current.byLastId[lastId] = layoutId;
-        }
+        if (lastId) screen.current.byLastId[lastId] = layoutId;
         if (duplicatedFrom.length > 1) {
           for (let index = 0; index < duplicatedFrom.length - 1; index++) {
             const possibleId = duplicatedFrom[index];
             if (possibleId === void 0) continue;
-            if (!screen.current.byPossibleId[possibleId]) {
-              screen.current.byPossibleId[possibleId] = layoutId;
-            }
+            if (!screen.current.byPossibleId[possibleId]) screen.current.byPossibleId[possibleId] = layoutId;
           }
         }
       }
@@ -15309,31 +11934,12 @@ function LayoutIdProvider({
   }, [],);
   const persistLayoutIdCache = useCallback(() => {
     cache3.current = {
-      byId: {
-        ...cache3.current.byId,
-        ...screen.current.byId,
-      },
-      byLastId: {
-        ...cache3.current.byLastId,
-        ...screen.current.byLastId,
-      },
-      byPossibleId: {
-        ...cache3.current.byPossibleId,
-        ...screen.current.byPossibleId,
-      },
-      byName: {
-        ...cache3.current.byName,
-        ...screen.current.byName,
-      },
-      byLastName: {
-        ...cache3.current.byLastName,
-        ...screen.current.byLastName,
-      },
-      byLayoutId: {
-        ...cache3.current.byLayoutId,
-        ...screen.current.byLayoutId,
-      },
-      // Unlike the count.byId, we need to reset the count.byName because
+      byId: { ...cache3.current.byId, ...screen.current.byId, },
+      byLastId: { ...cache3.current.byLastId, ...screen.current.byLastId, },
+      byPossibleId: { ...cache3.current.byPossibleId, ...screen.current.byPossibleId, },
+      byName: { ...cache3.current.byName, ...screen.current.byName, },
+      byLastName: { ...cache3.current.byLastName, ...screen.current.byLastName, },
+      byLayoutId: { ...cache3.current.byLayoutId, ...screen.current.byLayoutId, }, // Unlike the count.byId, we need to reset the count.byName because
       // named layers might not have duplicatedFrom ids (e.g. imported
       // from Figma). When we can use duplicatedFrom ids to check if an id
       // was assigned on a previous screen, we don't increment the count,
@@ -15342,31 +11948,13 @@ function LayoutIdProvider({
       // layers need to always match in some way between screens, we reset
       // the count so that the second named layer on a second screen is
       // always name-1 if it doesn't have any duplicatedFrom ids.
-      count: {
-        ...cache3.current.count,
-        byName: {},
-      },
-    };
-    screen.current = {
-      byId: {},
-      byName: {},
-      byLastId: {},
-      byPossibleId: {},
-      byLastName: {},
-      byLayoutId: {},
+      count: { ...cache3.current.count, byName: {}, },
     };
+    screen.current = { byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, };
     usedIds.clear();
   }, [],);
-  const contextValue = useRef({
-    getLayoutId,
-    persistLayoutIdCache,
-    top: true,
-    enabled: true,
-  },).current;
-  return /* @__PURE__ */ _jsx5(LayoutIdContext.Provider, {
-    value: contextValue,
-    children,
-  },);
+  const contextValue = useRef({ getLayoutId, persistLayoutIdCache, top: true, enabled: true, },).current;
+  return /* @__PURE__ */ _jsx5(LayoutIdContext.Provider, { value: contextValue, children, },);
 }
 function nextLayoutId(identifier, initialValue, usedIds,) {
   let value = initialValue;
@@ -15375,32 +11963,18 @@ function nextLayoutId(identifier, initialValue, usedIds,) {
     value++;
     layoutId = `${identifier}-${value}`;
   }
-  return {
-    layoutId,
-    value,
-  };
+  return { layoutId, value, };
 }
-function AutomaticLayoutIds({
-  enabled = true,
-  ...props
-},) {
+function AutomaticLayoutIds({ enabled = true, ...props },) {
   const context = useContext3(LayoutIdContext,);
   const contextValue = useMemo(() => {
-    return {
-      ...context,
-      enabled,
-    };
+    return { ...context, enabled, };
   }, [enabled,],);
-  return /* @__PURE__ */ _jsx5(LayoutIdContext.Provider, {
-    ...props,
-    value: contextValue,
-  },);
+  return /* @__PURE__ */ _jsx5(LayoutIdContext.Provider, { ...props, value: contextValue, },);
 }
 function useConstant2(init,) {
   const ref = useRef(null,);
-  if (ref.current === null) {
-    ref.current = init();
-  }
+  if (ref.current === null) ref.current = init();
   return ref.current;
 }
 var baseStyle = {
@@ -15424,17 +11998,9 @@ var errorStyle = {
   backgroundColor: 'rgba(149, 149, 149, 0.1)',
   color: '#a5a5a5',
 };
-var textStyle = {
-  overflow: 'hidden',
-  whiteSpace: 'nowrap',
-  textOverflow: 'ellipsis',
-  maxWidth: '100%',
-  flexShrink: 0,
-  padding: `0 10px`,
-};
+var textStyle = { overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis', maxWidth: '100%', flexShrink: 0, padding: `0 10px`, };
 var titleStyle = {
-  ...textStyle,
-  // TODO: Use Fresco tokens for this.
+  ...textStyle, // TODO: Use Fresco tokens for this.
   fontWeight: 500,
 };
 var messageStyle = {
@@ -15444,39 +12010,23 @@ var messageStyle = {
   WebkitMaskImage: 'linear-gradient(to bottom, black 80%, transparent 100%)',
 };
 function ErrorPlaceholder(props,) {
-  const {
-    error,
-    file,
-  } = props;
+  const { error, file, } = props;
   const title = file ? `Error in ${stripSlash(file,)}` : 'Error';
   const message = error instanceof Error ? error.message : '' + error;
   return /* @__PURE__ */ _jsxs('div', {
     style: errorStyle,
     children: [
-      /* @__PURE__ */ _jsx5('div', {
-        className: 'text',
-        style: titleStyle,
-        children: title,
-      },),
-      message && /* @__PURE__ */ _jsx5('div', {
-        className: 'text',
-        style: messageStyle,
-        children: message,
-      },),
+      /* @__PURE__ */ _jsx5('div', { className: 'text', style: titleStyle, children: title, },),
+      message && /* @__PURE__ */ _jsx5('div', { className: 'text', style: messageStyle, children: message, },),
     ],
   },);
 }
 function stripSlash(title,) {
-  if (title.startsWith('./',)) {
-    return title.replace('./', '',);
-  }
+  if (title.startsWith('./',)) return title.replace('./', '',);
   return title;
 }
 function getScaleData(deviceOptions, containerSize,) {
-  const {
-    componentWidth,
-    componentHeight,
-  } = getComponentSize(deviceOptions,);
+  const { componentWidth, componentHeight, } = getComponentSize(deviceOptions,);
   const scaleX = containerSize.width / componentWidth;
   const scaleY = containerSize.height / componentHeight;
   const scale2 = Math.min(scaleX, scaleY, 1,);
@@ -15522,44 +12072,25 @@ var ErrorBoundary2 = class extends Component2 {
     let currentIndex = 0;
     if (stack) {
       for (const line of stack) {
-        if (line.startsWith(`    in ${this.constructor.name}`,)) {
-          break;
-        }
+        if (line.startsWith(`    in ${this.constructor.name}`,)) break;
         currentIndex++;
       }
       stack = stack.slice(0, currentIndex,);
     }
-    this.setState({
-      lastError: {
-        error,
-        componentStack: stack,
-      },
-    },);
+    this.setState({ lastError: { error, componentStack: stack, }, },);
   }
   componentDidUpdate(_, prevState,) {
     if (this.state.lastError === void 0) return;
-    if (prevState.lastError === this.state.lastError) {
-      this.setState({
-        lastError: void 0,
-      },);
-    }
+    if (prevState.lastError === this.state.lastError) this.setState({ lastError: void 0, },);
   }
   render() {
     if (this.state.lastError) {
-      return /* @__PURE__ */ _jsx5(ErrorPlaceholder, {
-        error: this.state.lastError.error.message,
-        file: 'Prototype',
-      },);
+      return /* @__PURE__ */ _jsx5(ErrorPlaceholder, { error: this.state.lastError.error.message, file: 'Prototype', },);
     }
     return this.props.children;
   }
 };
-function Device({
-  canResize = false,
-  children,
-  ResizeObserver: ResizeObserver22 = safeWindow.ResizeObserver,
-  ...options
-},) {
+function Device({ canResize = false, children, ResizeObserver: ResizeObserver22 = safeWindow.ResizeObserver, ...options },) {
   var _a, _b;
   const optionsRef = React__default.useRef(void 0,);
   if (optionsRef.current === void 0) optionsRef.current = options;
@@ -15568,10 +12099,7 @@ function Device({
   const containerRef = React__default.useRef(null,);
   const deviceRef = React__default.useRef(null,);
   const screenRef = React__default.useRef(null,);
-  const updateImperativeScale = ({
-    scale: scale2,
-    screenScalePixelFix,
-  },) => {
+  const updateImperativeScale = ({ scale: scale2, screenScalePixelFix, },) => {
     if (!scaleDataRef.current || !deviceRef.current || !screenRef.current) return;
     deviceRef.current.style.transform = `scale(${scale2})`;
     screenRef.current.style.transform = `scale(${screenScalePixelFix})`;
@@ -15582,20 +12110,11 @@ function Device({
   }
   const invertScale2 = React__default.useCallback((point2) => {
     if (!scaleDataRef.current) return point2;
-    const {
-      scale: scale2 = 1,
-    } = scaleDataRef.current;
-    return {
-      x: point2.x / scale2,
-      y: point2.y / scale2,
-    };
+    const { scale: scale2 = 1, } = scaleDataRef.current;
+    return { x: point2.x / scale2, y: point2.y / scale2, };
   }, [scaleDataRef,],);
   const updateScale = React__default.useCallback(() => {
-    const {
-      deviceOptions,
-      scaleTo,
-      onScaleChange,
-    } = optionsRef.current ?? {};
+    const { deviceOptions, scaleTo, onScaleChange, } = optionsRef.current ?? {};
     if (!deviceOptions || !scaleTo || scaleTo !== 'dynamic' || !containerRef.current) return;
     if (containerRef.current.offsetWidth === 0 || containerRef.current.offsetHeight === 0) return;
     const scaleData = scaleDataRef.current = getScaleData(deviceOptions, {
@@ -15606,9 +12125,7 @@ function Device({
     updateImperativeScale(scaleData,);
   }, [],);
   const observer2 = useConstant2(() => {
-    if (!ResizeObserver22) {
-      return;
-    }
+    if (!ResizeObserver22) return;
     return new ResizeObserver22(() => updateScale());
   },);
   React__default.useLayoutEffect(() => {
@@ -15627,57 +12144,27 @@ function Device({
     observer2.observe(containerRef.current,);
     return () => observer2.disconnect();
   }, [observer2,],);
-  const {
-    containerStyle,
-    handStyle,
-    deviceStyle,
-    deviceImageStyle,
-    screenStyle,
-  } = getDeviceStyle(options,);
-  const resizeStyles = canResize
-    ? {
-      display: 'flex',
-      justifyContent: 'center',
-      alignItems: 'center',
-      height: '100%',
-    }
-    : {};
+  const { containerStyle, handStyle, deviceStyle, deviceImageStyle, screenStyle, } = getDeviceStyle(options,);
+  const resizeStyles = canResize ? { display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%', } : {};
   const screenBackground = ((_b = options.deviceOptions) == null ? void 0 : _b.transparentBackground) ? 'transparent' : 'white';
   return /* @__PURE__ */ _jsx5('div', {
-    style: {
-      ...containerStyle,
-      ...resizeStyles,
-    },
+    style: { ...containerStyle, ...resizeStyles, },
     ref: containerRef,
     children: /* @__PURE__ */ _jsxs('div', {
-      style: {
-        ...deviceStyle,
-      },
+      style: { ...deviceStyle, },
       ref: deviceRef,
       children: [
-        handStyle && /* @__PURE__ */ _jsx5('div', {
-          style: handStyle,
-        },),
-        deviceAppearance === 'external-clay' && deviceImageStyle && /* @__PURE__ */ _jsx5('div', {
-          style: deviceImageStyle,
-        },),
+        handStyle && /* @__PURE__ */ _jsx5('div', { style: handStyle, },),
+        deviceAppearance === 'external-clay' && deviceImageStyle && /* @__PURE__ */ _jsx5('div', { style: deviceImageStyle, },),
         /* @__PURE__ */ _jsx5('div', {
-          style: {
-            ...screenStyle,
-            pointerEvents: void 0,
-            backgroundColor: children ? screenBackground : screenStyle.backgroundColor,
-          },
+          style: { ...screenStyle, pointerEvents: void 0, backgroundColor: children ? screenBackground : screenStyle.backgroundColor, },
           ref: screenRef,
           children: /* @__PURE__ */ _jsx5(MotionConfig, {
             transformPagePoint: invertScale2,
-            children: /* @__PURE__ */ _jsx5(ErrorBoundary2, {
-              children,
-            },),
+            children: /* @__PURE__ */ _jsx5(ErrorBoundary2, { children, },),
           },),
         },),
-        deviceAppearance === 'realistic' && deviceImageStyle && /* @__PURE__ */ _jsx5('div', {
-          style: deviceImageStyle,
-        },),
+        deviceAppearance === 'realistic' && deviceImageStyle && /* @__PURE__ */ _jsx5('div', { style: deviceImageStyle, },),
       ],
     },),
   },);
@@ -15688,38 +12175,17 @@ var HAND_IMG_HEIGHT = 3740;
 var HAND_IMG_GAP_WIDTH = 859;
 var HAND_IMG_GAP_LEFT = 772;
 var HAND_IMG_GAP_BOTTOM = 992 - 5;
-var noDeviceSize = {
-  componentWidth: 500,
-  componentHeight: 500,
-};
+var noDeviceSize = { componentWidth: 500, componentHeight: 500, };
 function getComponentSize(options,) {
   if (!options) return noDeviceSize;
-  const {
-    deviceWidth,
-    deviceHeight,
-    noPadding,
-  } = options;
+  const { deviceWidth, deviceHeight, noPadding, } = options;
   const padding = noPadding ? 0 : DEVICE_PADDING * 2;
-  return {
-    componentWidth: deviceWidth + padding,
-    componentHeight: deviceHeight + padding,
-  };
+  return { componentWidth: deviceWidth + padding, componentHeight: deviceHeight + padding, };
 }
-function getDeviceStyle({
-  scaleTo,
-  deviceOptions,
-  overrideTheme,
-} = {},) {
-  const noDeviceStyle = {
-    containerStyle: {},
-    deviceStyle: {},
-    screenStyle: {},
-  };
+function getDeviceStyle({ scaleTo, deviceOptions, overrideTheme, } = {},) {
+  const noDeviceStyle = { containerStyle: {}, deviceStyle: {}, screenStyle: {}, };
   if (!deviceOptions) return noDeviceStyle;
-  const {
-    componentWidth,
-    componentHeight,
-  } = getComponentSize(deviceOptions,);
+  const { componentWidth, componentHeight, } = getComponentSize(deviceOptions,);
   const overriddenColors = getColorsFromTheme(overrideTheme, deviceOptions.appearance.type,);
   const {
     deviceWidth,
@@ -15739,15 +12205,10 @@ function getDeviceStyle({
     hand,
   } = deviceOptions;
   const boxShadows = [];
-  if (appearance.type === 'clay' && shadow) {
-    boxShadows.push(shadow,);
-  }
+  if (appearance.type === 'clay' && shadow) boxShadows.push(shadow,);
   let bezelStyle = void 0;
   if (appearance.type === 'clay') {
-    bezelStyle = {
-      borderRadius: appearance.bezelRadius,
-      backgroundColor: overriddenColors.bezelColor || appearance.bezelColor,
-    };
+    bezelStyle = { borderRadius: appearance.bezelRadius, backgroundColor: overriddenColors.bezelColor || appearance.bezelColor, };
     if (overriddenColors.bezelShadeColor || appearance.bezelShadeColor) {
       boxShadows.push(`inset 0 0 15px ${overriddenColors.bezelShadeColor || appearance.bezelShadeColor}`,);
     }
@@ -15796,8 +12257,7 @@ function getDeviceStyle({
         backgroundImage: `url("${appearance.imageUrl}")`,
         backgroundPosition: 'top left',
         backgroundRepeat: 'no-repeat',
-        backgroundSize: `${appearance.imageWidth}px ${appearance.imageHeight}px`,
-        // Rotate 90 degrees counter-clockwise around (0,0), then move the
+        backgroundSize: `${appearance.imageWidth}px ${appearance.imageHeight}px`, // Rotate 90 degrees counter-clockwise around (0,0), then move the
         // result down into the viewport (rightmost transform is applied first).
         transformOrigin: 'top left',
         transform: appearance.rotateImage ? `translateY(${appearance.imageWidth}px) rotate(-90deg)` : void 0,
@@ -15816,12 +12276,8 @@ function getDeviceStyle({
       overflow: 'hidden',
       borderRadius: screenRadius,
       backgroundColor: overriddenColors.screenColor || screenColor,
-      ...(screenMaskImage && {
-        maskImage: screenMaskImage,
-        WebkitMaskImage: screenMaskImage,
-        maskSize: 'contain',
-        WebkitMaskSize: 'contain',
-      }),
+      ...(screenMaskImage &&
+        { maskImage: screenMaskImage, WebkitMaskImage: screenMaskImage, maskSize: 'contain', WebkitMaskSize: 'contain', }),
     },
   };
 }
@@ -15845,23 +12301,14 @@ function degreesToRadians(degrees2,) {
 }
 var Line = /* @__PURE__ */ (() => {
   function Line2(a, b,) {
-    return {
-      a,
-      b,
-    };
+    return { a, b, };
   }
   Line2.offset = (line, offset,) => {
     const angle = Point.angleFromX(line.a, line.b,);
     const rad = degreesToRadians(angle,);
     const x = offset * Math.sin(rad,);
     const y = offset * Math.cos(rad,);
-    return Line2({
-      x: line.a.x + x,
-      y: line.a.y - y,
-    }, {
-      x: line.b.x + x,
-      y: line.b.y - y,
-    },);
+    return Line2({ x: line.a.x + x, y: line.a.y - y, }, { x: line.b.x + x, y: line.b.y - y, },);
   };
   Line2.intersection = (lineA, lineB, segments,) => {
     const x1 = lineA.a.x;
@@ -15880,10 +12327,7 @@ var Line = /* @__PURE__ */ (() => {
     const alpha2 = a1 / b1;
     const beta = c1 / b1;
     if (segments && (alpha2 < 0 || alpha2 > 1 || beta < 0 || beta > 1)) return null;
-    return {
-      x: x1 + alpha2 * (x2 - x1),
-      y: y1 + alpha2 * (y2 - y1),
-    };
+    return { x: x1 + alpha2 * (x2 - x1), y: y1 + alpha2 * (y2 - y1), };
   };
   Line2.intersectionAngle = (lineA, lineB,) => {
     const deltaAX = lineA.b.x - lineA.a.x;
@@ -15909,10 +12353,7 @@ var Line = /* @__PURE__ */ (() => {
   Line2.pointAtPercentDistance = (line, distance2,) => {
     const hypotenuse = Line2.distance(line,);
     const r = distance2 * hypotenuse / hypotenuse;
-    return {
-      x: r * line.b.x + (1 - r) * line.a.x,
-      y: r * line.b.y + (1 - r) * line.a.y,
-    };
+    return { x: r * line.b.x + (1 - r) * line.a.x, y: r * line.b.y + (1 - r) * line.a.y, };
   };
   Line2.distance = (line) => {
     return Point.distance(line.a, line.b,);
@@ -15928,35 +12369,16 @@ var Rect;
   }
   Rect2.equals = equals;
   Rect2.atOrigin = (size2) => {
-    return {
-      ...size2,
-      x: 0,
-      y: 0,
-    };
+    return { ...size2, x: 0, y: 0, };
   };
   Rect2.fromTwoPoints = (a, b,) => {
-    return {
-      x: Math.min(a.x, b.x,),
-      y: Math.min(a.y, b.y,),
-      width: Math.abs(a.x - b.x,),
-      height: Math.abs(a.y - b.y,),
-    };
+    return { x: Math.min(a.x, b.x,), y: Math.min(a.y, b.y,), width: Math.abs(a.x - b.x,), height: Math.abs(a.y - b.y,), };
   };
   Rect2.fromRect = (rect) => {
-    return {
-      x: rect.left,
-      y: rect.top,
-      width: rect.right - rect.left,
-      height: rect.bottom - rect.top,
-    };
+    return { x: rect.left, y: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top, };
   };
   Rect2.multiply = (rect, n,) => {
-    return {
-      x: rect.x * n,
-      y: rect.y * n,
-      width: rect.width * n,
-      height: rect.height * n,
-    };
+    return { x: rect.x * n, y: rect.y * n, width: rect.width * n, height: rect.height * n, };
   };
   Rect2.divide = (rect, n,) => {
     return (0, Rect2.multiply)(rect, 1 / n,);
@@ -15964,21 +12386,12 @@ var Rect;
   Rect2.offset = (rect, delta2,) => {
     const xOffset = typeof delta2.x === 'number' ? delta2.x : 0;
     const yOffset = typeof delta2.y === 'number' ? delta2.y : 0;
-    return {
-      ...rect,
-      x: rect.x + xOffset,
-      y: rect.y + yOffset,
-    };
+    return { ...rect, x: rect.x + xOffset, y: rect.y + yOffset, };
   };
   function inflate(rect, value,) {
     if (value === 0) return rect;
     const doubleValue = 2 * value;
-    return {
-      x: rect.x - value,
-      y: rect.y - value,
-      width: rect.width + doubleValue,
-      height: rect.height + doubleValue,
-    };
+    return { x: rect.x - value, y: rect.y - value, width: rect.width + doubleValue, height: rect.height + doubleValue, };
   }
   Rect2.inflate = inflate;
   Rect2.pixelAligned = (rect) => {
@@ -15988,12 +12401,7 @@ var Rect;
     const rectMaxY = Math.round(rect.y + rect.height,);
     const width = Math.max(rectMaxX - x, 0,);
     const height = Math.max(rectMaxY - y, 0,);
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.halfPixelAligned = (rect) => {
     const x = Math.round(rect.x * 2,) / 2;
@@ -16002,24 +12410,14 @@ var Rect;
     const rectMaxY = Math.round((rect.y + rect.height) * 2,) / 2;
     const width = Math.max(rectMaxX - x, 1,);
     const height = Math.max(rectMaxY - y, 1,);
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.round = (rect, decimals = 0,) => {
     const x = roundedNumber(rect.x, decimals,);
     const y = roundedNumber(rect.y, decimals,);
     const width = roundedNumber(rect.width, decimals,);
     const height = roundedNumber(rect.height, decimals,);
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.roundToOutside = (rect) => {
     const x = Math.floor(rect.x,);
@@ -16028,12 +12426,7 @@ var Rect;
     const rectMaxY = Math.ceil(rect.y + rect.height,);
     const width = Math.max(rectMaxX - x, 0,);
     const height = Math.max(rectMaxY - y, 0,);
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.minX = (rect) => {
     return rect.x;
@@ -16058,10 +12451,7 @@ var Rect;
     };
   };
   Rect2.center = (rect) => {
-    return {
-      x: rect.x + rect.width / 2,
-      y: rect.y + rect.height / 2,
-    };
+    return { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2, };
   };
   Rect2.boundingRectFromPoints = (ps) => {
     let minX2 = Infinity;
@@ -16075,37 +12465,18 @@ var Rect;
       minY2 = Math.min(minY2, point2.y,);
       maxY2 = Math.max(maxY2, point2.y,);
     }
-    return {
-      x: minX2,
-      y: minY2,
-      width: maxX2 - minX2,
-      height: maxY2 - minY2,
-    };
+    return { x: minX2, y: minY2, width: maxX2 - minX2, height: maxY2 - minY2, };
   };
   Rect2.fromPoints = (ps) => {
     const [tl, tr, _, bl,] = ps;
-    const {
-      x,
-      y,
-    } = tl;
+    const { x, y, } = tl;
     const width = Point.distance(tl, tr,);
     const height = Point.distance(tl, bl,);
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.merge = (...rect) => {
-    const min = {
-      x: Math.min(...rect.map(Rect2.minX,),),
-      y: Math.min(...rect.map(Rect2.minY,),),
-    };
-    const max = {
-      x: Math.max(...rect.map(Rect2.maxX,),),
-      y: Math.max(...rect.map(Rect2.maxY,),),
-    };
+    const min = { x: Math.min(...rect.map(Rect2.minX,),), y: Math.min(...rect.map(Rect2.minY,),), };
+    const max = { x: Math.max(...rect.map(Rect2.maxX,),), y: Math.max(...rect.map(Rect2.maxY,),), };
     return (0, Rect2.fromTwoPoints)(min, max,);
   };
   Rect2.intersection = (rect1, rect2,) => {
@@ -16113,127 +12484,46 @@ var Rect;
     const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width,);
     const y = Math.max(rect1.y, rect2.y,);
     const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height,);
-    return {
-      x,
-      y,
-      width: x2 - x,
-      height: y2 - y,
-    };
+    return { x, y, width: x2 - x, height: y2 - y, };
   };
   Rect2.points = (rect) => {
-    return [{
-      x: (0, Rect2.minX)(rect,),
-      y: (0, Rect2.minY)(rect,),
-    }, {
-      x: (0, Rect2.minX)(rect,),
-      y: (0, Rect2.maxY)(rect,),
-    }, {
+    return [{ x: (0, Rect2.minX)(rect,), y: (0, Rect2.minY)(rect,), }, { x: (0, Rect2.minX)(rect,), y: (0, Rect2.maxY)(rect,), }, {
       x: (0, Rect2.maxX)(rect,),
       y: (0, Rect2.minY)(rect,),
-    }, {
-      x: (0, Rect2.maxX)(rect,),
-      y: (0, Rect2.maxY)(rect,),
-    },];
+    }, { x: (0, Rect2.maxX)(rect,), y: (0, Rect2.maxY)(rect,), },];
   };
   Rect2.pointsAtOrigin = (rect) => {
-    return [{
-      x: 0,
-      y: 0,
-    }, {
-      x: rect.width,
-      y: 0,
-    }, {
-      x: rect.width,
-      y: rect.height,
-    }, {
-      x: 0,
-      y: rect.height,
-    },];
+    return [{ x: 0, y: 0, }, { x: rect.width, y: 0, }, { x: rect.width, y: rect.height, }, { x: 0, y: rect.height, },];
   };
   Rect2.transform = (rect, matrix,) => {
-    const {
-      x: x1,
-      y: y1,
-    } = matrix.transformPoint({
-      x: rect.x,
-      y: rect.y,
-    },);
-    const {
-      x: x2,
-      y: y2,
-    } = matrix.transformPoint({
-      x: rect.x + rect.width,
-      y: rect.y,
-    },);
-    const {
-      x: x3,
-      y: y3,
-    } = matrix.transformPoint({
-      x: rect.x + rect.width,
-      y: rect.y + rect.height,
-    },);
-    const {
-      x: x4,
-      y: y4,
-    } = matrix.transformPoint({
-      x: rect.x,
-      y: rect.y + rect.height,
-    },);
+    const { x: x1, y: y1, } = matrix.transformPoint({ x: rect.x, y: rect.y, },);
+    const { x: x2, y: y2, } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y, },);
+    const { x: x3, y: y3, } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y + rect.height, },);
+    const { x: x4, y: y4, } = matrix.transformPoint({ x: rect.x, y: rect.y + rect.height, },);
     const x = Math.min(x1, x2, x3, x4,);
     const width = Math.max(x1, x2, x3, x4,) - x;
     const y = Math.min(y1, y2, y3, y4,);
     const height = Math.max(y1, y2, y3, y4,) - y;
-    return {
-      x,
-      y,
-      width,
-      height,
-    };
+    return { x, y, width, height, };
   };
   Rect2.containsPoint = (rect, point2,) => {
-    if (point2.x < (0, Rect2.minX)(rect,)) {
-      return false;
-    }
-    if (point2.x > (0, Rect2.maxX)(rect,)) {
-      return false;
-    }
-    if (point2.y < (0, Rect2.minY)(rect,)) {
-      return false;
-    }
-    if (point2.y > (0, Rect2.maxY)(rect,)) {
-      return false;
-    }
-    if (isNaN(rect.x,)) {
-      return false;
-    }
-    if (isNaN(rect.y,)) {
-      return false;
-    }
+    if (point2.x < (0, Rect2.minX)(rect,)) return false;
+    if (point2.x > (0, Rect2.maxX)(rect,)) return false;
+    if (point2.y < (0, Rect2.minY)(rect,)) return false;
+    if (point2.y > (0, Rect2.maxY)(rect,)) return false;
+    if (isNaN(rect.x,)) return false;
+    if (isNaN(rect.y,)) return false;
     return true;
   };
   Rect2.containsRect = (rectA, rectB,) => {
-    for (const point2 of (0, Rect2.points)(rectB,)) {
-      if (!(0, Rect2.containsPoint)(rectA, point2,)) {
-        return false;
-      }
-    }
+    for (const point2 of (0, Rect2.points)(rectB,)) if (!(0, Rect2.containsPoint)(rectA, point2,)) return false;
     return true;
   };
   Rect2.toCSS = (rect) => {
-    return {
-      display: 'block',
-      transform: `translate(${rect.x}px, ${rect.y}px)`,
-      width: `${rect.width}px`,
-      height: `${rect.height}px`,
-    };
+    return { display: 'block', transform: `translate(${rect.x}px, ${rect.y}px)`, width: `${rect.width}px`, height: `${rect.height}px`, };
   };
   Rect2.inset = (rect, n,) => {
-    return {
-      x: rect.x + n,
-      y: rect.y + n,
-      width: Math.max(0, rect.width - 2 * n,),
-      height: Math.max(0, rect.height - 2 * n,),
-    };
+    return { x: rect.x + n, y: rect.y + n, width: Math.max(0, rect.width - 2 * n,), height: Math.max(0, rect.height - 2 * n,), };
   };
   Rect2.intersects = (rectA, rectB,) => {
     return !(rectB.x >= (0, Rect2.maxX)(rectA,) || (0, Rect2.maxX)(rectB,) <= rectA.x || rectB.y >= (0, Rect2.maxY)(rectA,) ||
@@ -16262,22 +12552,10 @@ var Rect;
     const rectMaxX = rect.x + rect.width;
     const rectMinY = rect.y;
     const rectMaxY = rect.y + rect.height;
-    const corner1 = {
-      x: rectMinX,
-      y: rectMinY,
-    };
-    const corner2 = {
-      x: rectMaxX,
-      y: rectMinY,
-    };
-    const corner3 = {
-      x: rectMaxX,
-      y: rectMaxY,
-    };
-    const corner4 = {
-      x: rectMinX,
-      y: rectMaxY,
-    };
+    const corner1 = { x: rectMinX, y: rectMinY, };
+    const corner2 = { x: rectMaxX, y: rectMinY, };
+    const corner3 = { x: rectMaxX, y: rectMaxY, };
+    const corner4 = { x: rectMinX, y: rectMaxY, };
     return [corner1, corner2, corner3, corner4,];
   };
   Rect2.midPoints = (rect) => {
@@ -16287,51 +12565,22 @@ var Rect;
     const rectMinY = rect.y;
     const rectMidY = rect.y + rect.height / 2;
     const rectMaxY = rect.y + rect.height;
-    const top = {
-      x: rectMidX,
-      y: rectMinY,
-    };
-    const right = {
-      x: rectMaxX,
-      y: rectMidY,
-    };
-    const bottom = {
-      x: rectMidX,
-      y: rectMaxY,
-    };
-    const left = {
-      x: rectMinX,
-      y: rectMidY,
-    };
+    const top = { x: rectMidX, y: rectMinY, };
+    const right = { x: rectMaxX, y: rectMidY, };
+    const bottom = { x: rectMidX, y: rectMaxY, };
+    const left = { x: rectMinX, y: rectMidY, };
     return [top, right, bottom, left,];
   };
   Rect2.pointDistance = (rect, point2,) => {
     let x = 0;
     let y = 0;
-    if (point2.x < rect.x) {
-      x = rect.x - point2.x;
-    } else if (point2.x > Rect2.maxX(rect,)) {
-      x = point2.x - Rect2.maxX(rect,);
-    }
-    if (point2.y < rect.y) {
-      y = rect.y - point2.y;
-    } else if (point2.y > Rect2.maxY(rect,)) {
-      y = point2.y - Rect2.maxY(rect,);
-    }
-    return Point.distance({
-      x,
-      y,
-    }, {
-      x: 0,
-      y: 0,
-    },);
-  };
-  const fromAnyDefaults = {
-    x: 0,
-    y: 0,
-    width: 0,
-    height: 0,
+    if (point2.x < rect.x) x = rect.x - point2.x;
+    else if (point2.x > Rect2.maxX(rect,)) x = point2.x - Rect2.maxX(rect,);
+    if (point2.y < rect.y) y = rect.y - point2.y;
+    else if (point2.y > Rect2.maxY(rect,)) y = point2.y - Rect2.maxY(rect,);
+    return Point.distance({ x, y, }, { x: 0, y: 0, },);
   };
+  const fromAnyDefaults = { x: 0, y: 0, width: 0, height: 0, };
   Rect2.fromAny = (rect, defaults = fromAnyDefaults,) => {
     return {
       x: rect.x || defaults.x,
@@ -16341,24 +12590,12 @@ var Rect;
     };
   };
   Rect2.delta = (a, b,) => {
-    const pointA = {
-      x: (0, Rect2.minX)(a,),
-      y: (0, Rect2.minY)(a,),
-    };
-    const pointB = {
-      x: (0, Rect2.minX)(b,),
-      y: (0, Rect2.minY)(b,),
-    };
-    return {
-      x: pointA.x - pointB.x,
-      y: pointA.y - pointB.y,
-    };
+    const pointA = { x: (0, Rect2.minX)(a,), y: (0, Rect2.minY)(a,), };
+    const pointB = { x: (0, Rect2.minX)(b,), y: (0, Rect2.minY)(b,), };
+    return { x: pointA.x - pointB.x, y: pointA.y - pointB.y, };
   };
   Rect2.withMinSize = (rect, minSize,) => {
-    const {
-      width: minWidth,
-      height: minHeight,
-    } = minSize;
+    const { width: minWidth, height: minHeight, } = minSize;
     const diffX = rect.width - minWidth;
     const diffY = rect.height - minHeight;
     return {
@@ -16374,12 +12611,8 @@ var Rect;
     const rectMaxX = (0, Rect2.maxX)(rect,);
     const rectMaxY = (0, Rect2.maxY)(rect,);
     for (const point2 of ps) {
-      if (point2.x < rectMinX || point2.x > rectMaxX) {
-        return true;
-      }
-      if (point2.y < rectMinY || point2.y > rectMaxY) {
-        return true;
-      }
+      if (point2.x < rectMinX || point2.x > rectMaxX) return true;
+      if (point2.y < rectMinY || point2.y > rectMaxY) return true;
     }
     return false;
   };
@@ -16388,9 +12621,7 @@ var Rect;
     return [Line(tl, tr,), Line(tr, br,), Line(br, bl,), Line(bl, tl,),];
   };
   Rect2.rebaseRectOnto = (rect, anchorRect, direction, alignment,) => {
-    const rebasedRect = {
-      ...rect,
-    };
+    const rebasedRect = { ...rect, };
     switch (direction) {
       case 'bottom':
       case 'top':
@@ -16467,41 +12698,25 @@ var DimensionType = /* @__PURE__ */ ((DimensionType2) => {
   return DimensionType2;
 })(DimensionType || {},);
 function isConstraintSupportingChild(child,) {
-  if (!isReactChild(child,) || !isReactElement(child,)) {
-    return false;
-  }
+  if (!isReactChild(child,) || !isReactElement(child,)) return false;
   return true;
 }
 var ConstraintMask;
 ((ConstraintMask2) => {
   ConstraintMask2.quickfix = (constraints) => {
-    if (constraints.widthType === 2 || constraints.heightType === 2) {
-      constraints.aspectRatio = null;
-    }
+    if (constraints.widthType === 2 || constraints.heightType === 2) constraints.aspectRatio = null;
     if (isFiniteNumber(constraints.aspectRatio,)) {
-      if (constraints.left && constraints.right) {
-        constraints.widthType = 0;
-      }
-      if (constraints.top && constraints.bottom) {
-        constraints.heightType = 0;
-      }
-      if (constraints.left && constraints.right && constraints.top && constraints.bottom) {
-        constraints.bottom = false;
-      }
-      if (constraints.widthType !== 0 && constraints.heightType !== 0) {
-        constraints.heightType = 0;
-      }
+      if (constraints.left && constraints.right) constraints.widthType = 0;
+      if (constraints.top && constraints.bottom) constraints.heightType = 0;
+      if (constraints.left && constraints.right && constraints.top && constraints.bottom) constraints.bottom = false;
+      if (constraints.widthType !== 0 && constraints.heightType !== 0) constraints.heightType = 0;
     }
     if (constraints.left && constraints.right) {
-      if (constraints.fixedSize || constraints.widthType === 2 || isFiniteNumber(constraints.maxWidth,)) {
-        constraints.right = false;
-      }
+      if (constraints.fixedSize || constraints.widthType === 2 || isFiniteNumber(constraints.maxWidth,)) constraints.right = false;
       constraints.widthType = 0;
     }
     if (constraints.top && constraints.bottom) {
-      if (constraints.fixedSize || constraints.heightType === 2 || isFiniteNumber(constraints.maxHeight,)) {
-        constraints.bottom = false;
-      }
+      if (constraints.fixedSize || constraints.heightType === 2 || isFiniteNumber(constraints.maxHeight,)) constraints.bottom = false;
       constraints.heightType = 0;
     }
     return constraints;
@@ -16520,18 +12735,7 @@ function valueToDimensionType(value,) {
 var ConstraintValues;
 ((ConstraintValues2) => {
   ConstraintValues2.fromProperties = (props) => {
-    const {
-      left,
-      right,
-      top,
-      bottom,
-      width,
-      height,
-      centerX,
-      centerY,
-      aspectRatio: aspectRatio2,
-      autoSize,
-    } = props;
+    const { left, right, top, bottom, width, height, centerX, centerY, aspectRatio: aspectRatio2, autoSize, } = props;
     const constraints = ConstraintMask.quickfix({
       left: isFiniteNumber(left,) || isAnimatable2(left,),
       right: isFiniteNumber(right,) || isAnimatable2(right,),
@@ -16551,37 +12755,27 @@ var ConstraintValues;
       if (width.endsWith('fr',)) {
         widthType = 3;
         widthValue = parsedWidth;
-      } else if (width === 'auto') {
-        widthType = 2;
-      } else {
+      } else if (width === 'auto') widthType = 2;
+      else {
         widthType = 1;
         widthValue = parsedWidth / 100;
       }
-    } else if (width !== void 0 && typeof width !== 'string') {
-      widthValue = Animatable.getNumber(width,);
-    }
+    } else if (width !== void 0 && typeof width !== 'string') widthValue = Animatable.getNumber(width,);
     if (constraints.heightType !== 0 && typeof height === 'string') {
       const parsedHeight = parseFloat(height,);
       if (height.endsWith('fr',)) {
         heightType = 3;
         heightValue = parsedHeight;
-      } else if (height === 'auto') {
-        heightType = 2;
-      } else {
+      } else if (height === 'auto') heightType = 2;
+      else {
         heightType = 1;
         heightValue = parseFloat(height,) / 100;
       }
-    } else if (height !== void 0 && typeof height !== 'string') {
-      heightValue = Animatable.getNumber(height,);
-    }
+    } else if (height !== void 0 && typeof height !== 'string') heightValue = Animatable.getNumber(height,);
     let centerAnchorX = 0.5;
     let centerAnchorY = 0.5;
-    if (centerX) {
-      centerAnchorX = parseFloat(centerX,) / 100;
-    }
-    if (centerY) {
-      centerAnchorY = parseFloat(centerY,) / 100;
-    }
+    if (centerX) centerAnchorX = parseFloat(centerX,) / 100;
+    if (centerY) centerAnchorY = parseFloat(centerY,) / 100;
     return {
       left: constraints.left ? Animatable.getNumber(left,) : null,
       right: constraints.right ? Animatable.getNumber(right,) : null,
@@ -16606,11 +12800,9 @@ var ConstraintValues;
       ? Animatable.getNumber(parentSizeInfo == null ? void 0 : parentSizeInfo.sizing.height,)
       : null;
     const hOpposingPinsOffset = pinnedOffset(values.left, values.right,);
-    if (parentWidth && isFiniteNumber(hOpposingPinsOffset,)) {
-      width = parentWidth - hOpposingPinsOffset;
-    } else if (autoSize && values.widthType === 2) {
-      width = autoSize.width;
-    } else if (isFiniteNumber(values.width,)) {
+    if (parentWidth && isFiniteNumber(hOpposingPinsOffset,)) width = parentWidth - hOpposingPinsOffset;
+    else if (autoSize && values.widthType === 2) width = autoSize.width;
+    else if (isFiniteNumber(values.width,)) {
       switch (values.widthType) {
         case 0:
           width = values.width;
@@ -16620,9 +12812,7 @@ var ConstraintValues;
           break;
         case 1:
         case 4:
-          if (parentWidth) {
-            width = parentWidth * values.width;
-          }
+          if (parentWidth) width = parentWidth * values.width;
           break;
         case 2:
           break;
@@ -16631,11 +12821,9 @@ var ConstraintValues;
       }
     }
     const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom,);
-    if (parentHeight && isFiniteNumber(vOpposingPinsOffset,)) {
-      height = parentHeight - vOpposingPinsOffset;
-    } else if (autoSize && values.heightType === 2) {
-      height = autoSize.height;
-    } else if (isFiniteNumber(values.height,)) {
+    if (parentHeight && isFiniteNumber(vOpposingPinsOffset,)) height = parentHeight - vOpposingPinsOffset;
+    else if (autoSize && values.heightType === 2) height = autoSize.height;
+    else if (isFiniteNumber(values.height,)) {
       switch (values.heightType) {
         case 0:
           height = values.height;
@@ -16645,9 +12833,7 @@ var ConstraintValues;
           break;
         case 1:
         case 4:
-          if (parentHeight) {
-            height = parentHeight * values.height;
-          }
+          if (parentHeight) height = parentHeight * values.height;
           break;
         case 2:
           break;
@@ -16655,44 +12841,29 @@ var ConstraintValues;
           assertNever(values.heightType,);
       }
     }
-    return sizeAfterApplyingConstraintsAndAspectRatio(width, height, values, {
-      height: parentHeight ?? 0,
-      width: parentWidth ?? 0,
-    }, parentSizeInfo == null ? void 0 : parentSizeInfo.viewport,);
+    return sizeAfterApplyingConstraintsAndAspectRatio(
+      width,
+      height,
+      values,
+      { height: parentHeight ?? 0, width: parentWidth ?? 0, },
+      parentSizeInfo == null ? void 0 : parentSizeInfo.viewport,
+    );
   };
   ConstraintValues2.toRect = (values, parentSizeInfo = null, autoSize = null, pixelAlign = false, freeSpace = null,) => {
     let x = values.left || 0;
     let y = values.top || 0;
-    const {
-      width,
-      height,
-    } = ConstraintValues2.toSize(values, parentSizeInfo, autoSize, freeSpace,);
+    const { width, height, } = ConstraintValues2.toSize(values, parentSizeInfo, autoSize, freeSpace,);
     const parentSizeForPositioning = (parentSizeInfo == null ? void 0 : parentSizeInfo.positioning) ?? null;
     const positioningParentWidth = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.width,) : null;
     const positioningParentHeight = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.height,) : null;
-    if (values.left !== null) {
-      x = values.left;
-    } else if (positioningParentWidth && values.right !== null) {
-      x = positioningParentWidth - values.right - width;
-    } else if (positioningParentWidth) {
-      x = values.centerAnchorX * positioningParentWidth - width / 2;
-    }
-    if (values.top !== null) {
-      y = values.top;
-    } else if (positioningParentHeight && values.bottom !== null) {
-      y = positioningParentHeight - values.bottom - height;
-    } else if (positioningParentHeight) {
-      y = values.centerAnchorY * positioningParentHeight - height / 2;
-    }
-    const f = {
-      x,
-      y,
-      width,
-      height,
-    };
-    if (pixelAlign) {
-      return Rect.pixelAligned(f,);
-    }
+    if (values.left !== null) x = values.left;
+    else if (positioningParentWidth && values.right !== null) x = positioningParentWidth - values.right - width;
+    else if (positioningParentWidth) x = values.centerAnchorX * positioningParentWidth - width / 2;
+    if (values.top !== null) y = values.top;
+    else if (positioningParentHeight && values.bottom !== null) y = positioningParentHeight - values.bottom - height;
+    else if (positioningParentHeight) y = values.centerAnchorY * positioningParentHeight - height / 2;
+    const f = { x, y, width, height, };
+    if (pixelAlign) return Rect.pixelAligned(f,);
     return f;
   };
 })(ConstraintValues || (ConstraintValues = {}),);
@@ -16729,41 +12900,25 @@ function getConstraintValue(constraint, value, parentSize, viewport,) {
   return value;
 }
 function constrainHeight(height, values, parentSize, viewport,) {
-  if (values.minHeight) {
-    height = Math.max(getConstraintValue('minHeight', values.minHeight, parentSize, viewport,), height,);
-  }
-  if (values.maxHeight) {
-    height = Math.min(getConstraintValue('maxHeight', values.maxHeight, parentSize, viewport,), height,);
-  }
+  if (values.minHeight) height = Math.max(getConstraintValue('minHeight', values.minHeight, parentSize, viewport,), height,);
+  if (values.maxHeight) height = Math.min(getConstraintValue('maxHeight', values.maxHeight, parentSize, viewport,), height,);
   return height;
 }
 function constrainWidth(width, values, parentSize, viewport,) {
-  if (values.minWidth) {
-    width = Math.max(getConstraintValue('minWidth', values.minWidth, parentSize, viewport,), width,);
-  }
-  if (values.maxWidth) {
-    width = Math.min(getConstraintValue('maxWidth', values.maxWidth, parentSize, viewport,), width,);
-  }
+  if (values.minWidth) width = Math.max(getConstraintValue('minWidth', values.minWidth, parentSize, viewport,), width,);
+  if (values.maxWidth) width = Math.min(getConstraintValue('maxWidth', values.maxWidth, parentSize, viewport,), width,);
   return width;
 }
 function sizeAfterApplyingConstraintsAndAspectRatio(width, height, values, parentSize, viewport,) {
   let w = constrainWidth(isFiniteNumber(width,) ? width : defaultWidth, values, parentSize, viewport,);
   let h = constrainHeight(isFiniteNumber(height,) ? height : defaultHeight, values, parentSize, viewport,);
   if (isFiniteNumber(values.aspectRatio,) && values.aspectRatio > 0) {
-    if (isFiniteNumber(values.left,) && isFiniteNumber(values.right,)) {
-      h = w / values.aspectRatio;
-    } else if (isFiniteNumber(values.top,) && isFiniteNumber(values.bottom,)) {
-      w = h * values.aspectRatio;
-    } else if (values.widthType !== 0) {
-      h = w / values.aspectRatio;
-    } else {
-      w = h * values.aspectRatio;
-    }
+    if (isFiniteNumber(values.left,) && isFiniteNumber(values.right,)) h = w / values.aspectRatio;
+    else if (isFiniteNumber(values.top,) && isFiniteNumber(values.bottom,)) w = h * values.aspectRatio;
+    else if (values.widthType !== 0) h = w / values.aspectRatio;
+    else w = h * values.aspectRatio;
   }
-  return {
-    width: w,
-    height: h,
-  };
+  return { width: w, height: h, };
 }
 function pinnedOffset(start, end,) {
   if (!isFiniteNumber(start,) || !isFiniteNumber(end,)) return null;
@@ -16771,25 +12926,15 @@ function pinnedOffset(start, end,) {
 }
 function getMergedConstraintsProps(props, constraints,) {
   const result = {};
-  if (props.constraints) {
-    result.constraints = {
-      ...props.constraints,
-      ...constraints,
-    };
-  } else {
-    Object.assign(result, constraints,);
-  }
+  if (props.constraints) result.constraints = { ...props.constraints, ...constraints, };
+  else Object.assign(result, constraints,);
   return result;
 }
 function containsInvalidStringValues(props,) {
   if (typeof props.right === 'string') return true;
   if (typeof props.bottom === 'string') return true;
-  if (typeof props.left === 'string' && (!props.center || props.center === 'y')) {
-    return true;
-  }
-  if (typeof props.top === 'string' && (!props.center || props.center === 'x')) {
-    return true;
-  }
+  if (typeof props.left === 'string' && (!props.center || props.center === 'y')) return true;
+  if (typeof props.top === 'string' && (!props.center || props.center === 'x')) return true;
   return false;
 }
 function constraintsEnabled(props,) {
@@ -16798,88 +12943,37 @@ function constraintsEnabled(props,) {
   return props._constraints.enabled;
 }
 function sizeFromFiniteNumberProps(props,) {
-  const {
-    size: size2,
-  } = props;
-  let {
-    width,
-    height,
-  } = props;
+  const { size: size2, } = props;
+  let { width, height, } = props;
   if (isFiniteNumber(size2,)) {
-    if (width === void 0) {
-      width = size2;
-    }
-    if (height === void 0) {
-      height = size2;
-    }
-  }
-  if (isFiniteNumber(width,) && isFiniteNumber(height,)) {
-    return {
-      width,
-      height,
-    };
+    if (width === void 0) width = size2;
+    if (height === void 0) height = size2;
   }
+  if (isFiniteNumber(width,) && isFiniteNumber(height,)) return { width, height, };
   return null;
 }
 function rectFromFiniteNumberProps(props,) {
   const size2 = sizeFromFiniteNumberProps(props,);
-  if (size2 === null) {
-    return null;
-  }
-  const {
-    left,
-    top,
-  } = props;
-  if (isFiniteNumber(left,) && isFiniteNumber(top,)) {
-    return {
-      x: left,
-      y: top,
-      ...size2,
-    };
-  }
+  if (size2 === null) return null;
+  const { left, top, } = props;
+  if (isFiniteNumber(left,) && isFiniteNumber(top,)) return { x: left, y: top, ...size2, };
   return null;
 }
 function calculateRect(props, parentSize, pixelAlign = true,) {
   if (props.positionFixed || props.positionAbsolute) return null;
   const parentSizeDisabled = parentSize === 1 || parentSize === 2;
-  if (!constraintsEnabled(props,) || parentSizeDisabled) {
-    return rectFromFiniteNumberProps(props,);
-  }
+  if (!constraintsEnabled(props,) || parentSizeDisabled) return rectFromFiniteNumberProps(props,);
   const constraintValues = getConstraintValues(props,);
   const enabledParentSize = deprecatedParentSize(parentSize,);
-  const parentSizeInfo = enabledParentSize
-    ? {
-      sizing: enabledParentSize,
-      positioning: enabledParentSize,
-      viewport: null,
-    }
-    : null;
+  const parentSizeInfo = enabledParentSize ? { sizing: enabledParentSize, positioning: enabledParentSize, viewport: null, } : null;
   return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, pixelAlign, null,);
 }
 function getConstraintValues(props,) {
-  const {
-    left,
-    right,
-    top,
-    bottom,
-    center,
-    _constraints,
-    size: size2,
-  } = props;
-  let {
-    width,
-    height,
-  } = props;
-  if (width === void 0) {
-    width = size2;
-  }
-  if (height === void 0) {
-    height = size2;
-  }
-  const {
-    aspectRatio: aspectRatio2,
-    autoSize,
-  } = _constraints;
+  const { left, right, top, bottom, center, _constraints, size: size2, } = props;
+  let { width, height, } = props;
+  if (width === void 0) width = size2;
+  if (height === void 0) height = size2;
+  const { aspectRatio: aspectRatio2, autoSize, } = _constraints;
   const constraintMask = ConstraintMask.quickfix({
     left: isFiniteNumber(left,),
     right: isFiniteNumber(right,),
@@ -16899,45 +12993,34 @@ function getConstraintValues(props,) {
     if (width.endsWith('fr',)) {
       widthType = 3;
       widthValue = parsedWidth;
-    } else if (width === 'auto') {
-      widthType = 2;
-    } else {
+    } else if (width === 'auto') widthType = 2;
+    else {
       widthType = 1;
       widthValue = parsedWidth / 100;
     }
-  } else if (width !== void 0 && typeof width !== 'string') {
-    widthValue = width;
-  }
+  } else if (width !== void 0 && typeof width !== 'string') widthValue = width;
   if (constraintMask.heightType !== 0 && typeof height === 'string') {
     const parsedHeight = parseFloat(height,);
     if (height.endsWith('fr',)) {
       heightType = 3;
       heightValue = parsedHeight;
-    } else if (height === 'auto') {
-      heightType = 2;
-    } else {
+    } else if (height === 'auto') heightType = 2;
+    else {
       heightType = 1;
       heightValue = parseFloat(height,) / 100;
     }
-  } else if (height !== void 0 && typeof height !== 'string') {
-    heightValue = height;
-  }
+  } else if (height !== void 0 && typeof height !== 'string') heightValue = height;
   let centerAnchorX = 0.5;
   let centerAnchorY = 0.5;
   if (center === true || center === 'x') {
     constraintMask.left = false;
-    if (typeof left === 'string') {
-      centerAnchorX = parseFloat(left,) / 100;
-    }
+    if (typeof left === 'string') centerAnchorX = parseFloat(left,) / 100;
   }
   if (center === true || center === 'y') {
     constraintMask.top = false;
-    if (typeof top === 'string') {
-      centerAnchorY = parseFloat(top,) / 100;
-    }
+    if (typeof top === 'string') centerAnchorY = parseFloat(top,) / 100;
   }
-  return {
-    // Because we check isFiniteNumber when creating the masks,
+  return { // Because we check isFiniteNumber when creating the masks,
     // We know that left, right, top and bottom are numbers if the mask is true for the corresponding value
     // We need to cast this because typescript does not understand that
     left: constraintMask.left ? left : null,
@@ -16963,14 +13046,9 @@ var ParentSizeState = /* @__PURE__ */ ((ParentSizeState2) => {
   ParentSizeState2[ParentSizeState2['DisabledForCurrentLevel'] = 2] = 'DisabledForCurrentLevel';
   return ParentSizeState2;
 })(ParentSizeState || {},);
-var ConstraintsContext = React__default.createContext({
-  parentSize: 0,
-  /* Unknown */
-},);
+var ConstraintsContext = React__default.createContext({ parentSize: 0, /* Unknown */ },);
 function deprecatedParentSize(parentSize,) {
-  if (parentSize === 0 || parentSize === 1 || parentSize === 2) {
-    return null;
-  }
+  if (parentSize === 0 || parentSize === 1 || parentSize === 2) return null;
   return parentSize;
 }
 function useParentSize() {
@@ -16981,27 +13059,15 @@ function isSize(o,) {
 }
 var ProvideParentSize = (props) => {
   const currentParentSize = useParentSize();
-  const {
-    parentSize,
-    children,
-  } = props;
-  const value = React__default.useMemo(() => ({
-    parentSize,
-  }), // We are generating the memoKeys in runtime and react doesn't like it,
-  // but it should be safe to ignore.
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  [getParentWidth(parentSize,), getParentHeight(parentSize,),],);
-  if (currentParentSize === 1) {
-    return children
-      ? /* @__PURE__ */ _jsx5(Fragment, {
-        children,
-      },)
-      : null;
-  }
-  return /* @__PURE__ */ _jsx5(ConstraintsContext.Provider, {
-    value,
-    children,
-  },);
+  const { parentSize, children, } = props;
+  const value = React__default.useMemo(
+    () => ({ parentSize, }), // We are generating the memoKeys in runtime and react doesn't like it,
+    // but it should be safe to ignore.
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [getParentWidth(parentSize,), getParentHeight(parentSize,),],
+  );
+  if (currentParentSize === 1) return children ? /* @__PURE__ */ _jsx5(Fragment, { children, },) : null;
+  return /* @__PURE__ */ _jsx5(ConstraintsContext.Provider, { value, children, },);
 };
 function getParentWidth(parentSize,) {
   return isSize(parentSize,) ? parentSize.width : parentSize;
@@ -17011,10 +13077,7 @@ function getParentHeight(parentSize,) {
 }
 var ConsumeParentSize = ConstraintsContext.Consumer;
 function useProvideParentSize(node, parentSize,) {
-  return /* @__PURE__ */ _jsx5(ProvideParentSize, {
-    parentSize,
-    children: node,
-  },);
+  return /* @__PURE__ */ _jsx5(ProvideParentSize, { parentSize, children: node, },);
 }
 function useConstraints(props,) {
   const parentSize = useParentSize();
@@ -17053,13 +13116,10 @@ var ControlType = /* @__PURE__ */ ((ControlType2) => {
 })(ControlType || {},);
 var isFlexboxGapSupportedCached;
 function isFlexboxGapSupported() {
-  if (isFlexboxGapSupportedCached !== void 0) {
-    return isFlexboxGapSupportedCached;
-  }
+  if (isFlexboxGapSupportedCached !== void 0) return isFlexboxGapSupportedCached;
   const flex = document.createElement('div',);
   Object.assign(flex.style, {
-    position: 'absolute',
-    // avoid layout shift
+    position: 'absolute', // avoid layout shift
     display: 'flex',
     flexDirection: 'column',
     rowGap: '1px',
@@ -17068,9 +13128,7 @@ function isFlexboxGapSupported() {
   flex.appendChild(document.createElement('div',),);
   document.body.appendChild(flex,);
   const isSupported = flex.scrollHeight === 1;
-  if (flex.parentNode) {
-    flex.parentNode.removeChild(flex,);
-  }
+  if (flex.parentNode) flex.parentNode.removeChild(flex,);
   isFlexboxGapSupportedCached = isSupported;
   return isSupported;
 }
@@ -17277,8 +13335,7 @@ var deprecatedRichTextCSSRules = [
   richTextStylesBulletedListMarker,
 ];
 var richTextCSSRules = [
-  /* css */
-  `
+  /* css */ `
         p.framer-text,
         div.framer-text,
         h1.framer-text,
@@ -17292,8 +13349,8 @@ var richTextCSSRules = [
             margin: 0;
             padding: 0;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         p.framer-text,
         div.framer-text,
         h1.framer-text,
@@ -17317,35 +13374,35 @@ var richTextCSSRules = [
             line-height: var(--framer-line-height, 1.2em);
             text-align: var(--framer-text-alignment, start);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         .framer-fit-text .framer-text {
             white-space: nowrap;
             white-space-collapse: preserve;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         strong.framer-text {
             font-family: var(--framer-font-family-bold);
             font-style: var(--framer-font-style-bold);
             font-weight: var(--framer-font-weight-bold, bolder);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         em.framer-text {
             font-family: var(--framer-font-family-italic);
             font-style: var(--framer-font-style-italic, italic);
             font-weight: var(--framer-font-weight-italic);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         em.framer-text > strong.framer-text {
             font-family: var(--framer-font-family-bold-italic);
             font-style: var(--framer-font-style-bold-italic, italic);
             font-weight: var(--framer-font-weight-bold-italic, bolder);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         p.framer-text:not(:first-child),
         div.framer-text:not(:first-child),
         h1.framer-text:not(:first-child),
@@ -17359,17 +13416,14 @@ var richTextCSSRules = [
         .framer-image.framer-text:not(:first-child) {
             margin-top: var(--framer-paragraph-spacing, 0);
         }
-    `,
-  // The first child of a list item is a paragraph. If the second child is a
+    `, // The first child of a list item is a paragraph. If the second child is a
   // nested list we don't want it to have paragraph spacing.
-  /* css */
-  `
+  /* css */ `
         li.framer-text > ul.framer-text:nth-child(2),
         li.framer-text > ol.framer-text:nth-child(2) {
             margin-top: 0;
         }
-    `,
-  // background-clip: text clips to the physical dimensions of text as appose
+    `, // background-clip: text clips to the physical dimensions of text as appose
   // to the rendered dimensions. normal text will bleed out side these
   // constraints but since this is just a clipping mask over the area the text
   // takes up we have cases where the text will get clipped. That is why we
@@ -17378,8 +13432,7 @@ var richTextCSSRules = [
   // perfectly to the edges of the text. but this is a acceptable trade off at
   // this point. For now we increase the area of the clipping mask on the
   // bottom (for descenders) and the right for italic or wide fonts.
-  /* css */
-  `
+  /* css */ `
         .framer-text[data-text-fill] {
             display: inline-block;
             background-clip: text;
@@ -17389,8 +13442,8 @@ var richTextCSSRules = [
             padding: max(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / 2));
             margin: min(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / -2));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         code.framer-text,
         code.framer-text span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17401,8 +13454,8 @@ var richTextCSSRules = [
             letter-spacing: var(--framer-letter-spacing, 0);
             line-height: var(--framer-line-height, 1.2em);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         a.framer-text,
         a.framer-text span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17415,8 +13468,8 @@ var richTextCSSRules = [
             /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
             cursor: var(--framer-custom-cursors, pointer);
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         code.framer-text a.framer-text,
         code.framer-text a.framer-text span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17425,8 +13478,8 @@ var richTextCSSRules = [
             color: var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
             font-size: calc(var(--framer-link-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         a.framer-text:hover,
         a.framer-text:hover span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
@@ -17437,8 +13490,8 @@ var richTextCSSRules = [
             text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
             text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         code.framer-text a.framer-text:hover,
         code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17447,8 +13500,8 @@ var richTextCSSRules = [
             color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
             font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         a.framer-text[data-framer-page-link-current],
         a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
@@ -17459,8 +13512,8 @@ var richTextCSSRules = [
             text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
             text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         code.framer-text a.framer-text[data-framer-page-link-current],
         code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17469,8 +13522,8 @@ var richTextCSSRules = [
             color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
             font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         a.framer-text[data-framer-page-link-current]:hover,
         a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
@@ -17481,8 +13534,8 @@ var richTextCSSRules = [
             text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
             text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         code.framer-text a.framer-text[data-framer-page-link-current]:hover,
         code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
             font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
@@ -17491,15 +13544,15 @@ var richTextCSSRules = [
             color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
             font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         .framer-image.framer-text {
             display: block;
             max-width: 100%;
             height: auto;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         .text-styles-preset-reset.framer-text {
             --framer-font-family: Inter, Inter Placeholder, sans-serif;
             --framer-font-style: normal;
@@ -17512,27 +13565,27 @@ var richTextCSSRules = [
             --framer-line-height: 1.2em;
             --framer-text-alignment: start;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         ol.framer-text {
             --list-style-type: decimal;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         ul.framer-text,
         ol.framer-text {
             display: table;
             width: 100%;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         li.framer-text {
             display: table-row;
             counter-increment: list-item;
             list-style: none;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         ol.framer-text > li.framer-text::before {
             display: table-cell;
             width: 2.25ch;
@@ -17541,8 +13594,8 @@ var richTextCSSRules = [
             content: counter(list-item, var(--list-style-type)) ".";
             white-space: nowrap;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         ul.framer-text > li.framer-text::before {
             display: table-cell;
             width: 2.25ch;
@@ -17550,20 +13603,20 @@ var richTextCSSRules = [
             padding-inline-end: 0.75ch;
             content: "\u2022";
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         .framer-text-module[style*="aspect-ratio"] > :first-child {
             width: 100%;
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         @supports not (aspect-ratio: 1) {
             .framer-text-module[style*="aspect-ratio"] {
                 position: relative;
             }
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         @supports not (aspect-ratio: 1) {
             .framer-text-module[style*="aspect-ratio"]::before {
                 content: "";
@@ -17571,8 +13624,8 @@ var richTextCSSRules = [
                 padding-bottom: calc(100% / calc(var(--aspect-ratio)));
             }
         }
-    `, /* css */
-  `
+    `,
+  /* css */ `
         @supports not (aspect-ratio: 1) {
             .framer-text-module[style*="aspect-ratio"] > :first-child {
                 position: absolute;
@@ -17598,9 +13651,8 @@ function injectCSSRule(cssRule, sheet, cache3 = defaultCache,) {
         return;
       }
       document.head.appendChild(styleElement,);
-      if (styleElement.sheet) {
-        defaultSheet = styleElement.sheet;
-      } else {
+      if (styleElement.sheet) defaultSheet = styleElement.sheet;
+      else {
         console.warn('not injecting CSS: injected <style> element does not have a sheet', styleElement,);
         return;
       }
@@ -17845,8 +13897,7 @@ var cursorCSS = [
   `[data-framer-cursor="grab"] { cursor: grab; }`,
   `[data-framer-cursor="grab"]:active { cursor: grabbing; }`,
 ];
-var frameCSS = [
-  // Non-sites prototyping projects render with FrameWithMotion and Stacks. In
+var frameCSS = [ // Non-sites prototyping projects render with FrameWithMotion and Stacks. In
   // that context this rule ensures pointer events work in a specific way
   // designed for prototypes that we don't care about anymore in sites. We
   // can't remove it for legacy reasons, but sites will never render any
@@ -17854,8 +13905,7 @@ var frameCSS = [
   // <Frame> api in code, at which point this rule will kick in. We don't
   // encourage the use of this API anymore, and bugs that come from this will
   // be the user's concern.
-  `[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }`,
-  // This is fully deprecated, and will never exist in code that is generated
+  `[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }`, // This is fully deprecated, and will never exist in code that is generated
   // after 24/01/2023. There will be existing code-generated that depends on
   // this rule existing, so we can't remove it.
   `[data-framer-generated] * { pointer-events: unset }`,
@@ -17899,9 +13949,7 @@ function injectComponentCSSRules() {
   if (didInject) return;
   didInject = true;
   const styles = RenderTarget.current() === 'PREVIEW' ? combinedCSSRulesForPreview : combinedCSSRules;
-  for (const rule of styles) {
-    injectCSSRule(rule, void 0, void 0,);
-  }
+  for (const rule of styles) injectCSSRule(rule, void 0, void 0,);
 }
 function isFunction(value,) {
   return typeof value === 'function';
@@ -17968,9 +14016,7 @@ function getControlDefaultValue(control,) {
         return isObject2(control.defaultValue,) ? control.defaultValue : void 0;
       case 'object': {
         const value = isObject2(control.defaultValue,) ? control.defaultValue : {};
-        if (isObject2(control.controls,)) {
-          applyControlDefaultsToDefaultProps(value, control.controls,);
-        }
+        if (isObject2(control.controls,)) applyControlDefaultsToDefaultProps(value, control.controls,);
         return value;
       }
       case 'array':
@@ -18008,9 +14054,7 @@ function applyControlDefaultsToDefaultProps(defaultProps, controls,) {
   }
 }
 function getDefaultProps(component,) {
-  if (isObject2(component.defaultProps,)) {
-    return component.defaultProps;
-  }
+  if (isObject2(component.defaultProps,)) return component.defaultProps;
   const defaultProps = {};
   component.defaultProps = defaultProps;
   return defaultProps;
@@ -18021,9 +14065,7 @@ function applyControlDefaultsToReactDefaultProps(component, controls,) {
   applyControlDefaultsToDefaultProps(defaultProps, controls,);
 }
 function addPropertyControls(component, propertyControls,) {
-  Object.assign(component, {
-    propertyControls,
-  },);
+  Object.assign(component, { propertyControls, },);
   applyControlDefaultsToReactDefaultProps(component, propertyControls,);
 }
 function getPropertyControls(component,) {
@@ -18031,1193 +14073,683 @@ function getPropertyControls(component,) {
 }
 var defaultPresetId = 'iphone-12-pro';
 var presetsBase = {
-  iPhonePro: {
-    // Screen mask takes care of the rounded screen corners for iPhones Pro,
+  iPhonePro: { // Screen mask takes care of the rounded screen corners for iPhones Pro,
     // and actually using a radius here produces visual artifacts in Chrome.
-    screenRadius: (
-      /* 38 */
-      0
-    ),
+    screenRadius: (/* 38 */ 0),
     clayBezelLeft: 21,
     clayBezelRight: 21,
     clayBezelTop: 21,
     clayBezelBottom: 21,
     clayBezelRadius: 38 + 21,
   },
-  iPhone8: {
-    screenRadius: 0,
-    clayBezelLeft: 24,
-    clayBezelRight: 24,
-    clayBezelTop: 96,
-    clayBezelBottom: 96,
-    clayBezelRadius: 38 * 1.5,
-  },
-  iPadPro: {
-    screenRadius: 25,
-    clayBezelLeft: 38,
-    clayBezelRight: 38,
-    clayBezelTop: 38,
-    clayBezelBottom: 38,
-    clayBezelRadius: 25 + 38,
-  },
-  desktop: {
-    clayBezelLeft: 20,
-    clayBezelRight: 20,
-    clayBezelTop: 20,
-    clayBezelBottom: 20,
-    clayBezelRadius: 20,
-  },
+  iPhone8: { screenRadius: 0, clayBezelLeft: 24, clayBezelRight: 24, clayBezelTop: 96, clayBezelBottom: 96, clayBezelRadius: 38 * 1.5, },
+  iPadPro: { screenRadius: 25, clayBezelLeft: 38, clayBezelRight: 38, clayBezelTop: 38, clayBezelBottom: 38, clayBezelRadius: 25 + 38, },
+  desktop: { clayBezelLeft: 20, clayBezelRight: 20, clayBezelTop: 20, clayBezelBottom: 20, clayBezelRadius: 20, },
 };
-var devicePresets = [{
-  id: 'iphone-12',
-  title: 'iPhone 12',
-  screenRadius: 0,
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 390,
-  screenHeight: 844,
-  externalClay: {
-    width: 500,
-    height: 974,
-    screenOffsetTop: 65,
-    screenOffsetLeft: 55,
-  },
-  screenMask:
-    '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
-  realisticImage: {
-    width: 490,
-    height: 944,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F7F3F0',
-    }, {
-      id: 'blue',
-      title: 'Blue',
-      colorValue: '#14496D',
-    }, {
-      id: 'green',
-      title: 'Green',
-      colorValue: '#DAF0D9',
-    }, {
-      id: 'red',
-      title: 'Red',
-      colorValue: '#DB4141',
-    },],
-    handOffset: {
-      left: 29,
-      right: 29,
-      bottom: 29,
+var devicePresets = [
+  {
+    id: 'iphone-12',
+    title: 'iPhone 12',
+    screenRadius: 0,
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 390,
+    screenHeight: 844,
+    externalClay: { width: 500, height: 974, screenOffsetTop: 65, screenOffsetLeft: 55, },
+    screenMask:
+      '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
+    realisticImage: {
+      width: 490,
+      height: 944,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
+        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
+        { id: 'blue', title: 'Blue', colorValue: '#14496D', },
+        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
+        { id: 'red', title: 'Red', colorValue: '#DB4141', },
+      ],
+      handOffset: { left: 29, right: 29, bottom: 29, },
     },
   },
-}, {
-  id: 'iphone-12-mini',
-  title: 'iPhone 12 Mini',
-  screenRadius: 0,
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 360,
-  screenHeight: 780,
-  externalClay: {
-    width: 450,
-    height: 890,
-    screenOffsetTop: 55,
-    screenOffsetLeft: 45,
-  },
-  screenMask:
-    '<g style="transform: scale(0.5);"><path d="M142 18c0 19 14 47 43 48h349c31 0 44-29 44-48 0-12 4-18 14-18h18c38 0 52 4 66 11 14 8 25 19 33 33v1c7 14 11 28 11 65v1340c0 38-4 52-11 66-8 14-19 25-33 33h-1c-14 7-28 11-65 11H110c-38 0-52-4-66-11-14-8-25-19-33-33v-1c-7-13-11-27-11-64V110c0-38 4-52 11-66 8-14 19-25 33-33h1C58 4 72 0 109 0h16c11 0 17 6 17 18z" fill="#000" fill-rule="evenodd"/></g>',
-  realisticImage: {
-    width: 460,
-    height: 880,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F7F3F0',
-    }, {
-      id: 'blue',
-      title: 'Blue',
-      colorValue: '#14496D',
-    }, {
-      id: 'green',
-      title: 'Green',
-      colorValue: '#DAF0D9',
-    }, {
-      id: 'red',
-      title: 'Red',
-      colorValue: '#DB4141',
-    },],
-    handOffset: {
-      left: 31.5,
-      right: 30.5,
-      bottom: 30,
+  {
+    id: 'iphone-12-mini',
+    title: 'iPhone 12 Mini',
+    screenRadius: 0,
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 360,
+    screenHeight: 780,
+    externalClay: { width: 450, height: 890, screenOffsetTop: 55, screenOffsetLeft: 45, },
+    screenMask:
+      '<g style="transform: scale(0.5);"><path d="M142 18c0 19 14 47 43 48h349c31 0 44-29 44-48 0-12 4-18 14-18h18c38 0 52 4 66 11 14 8 25 19 33 33v1c7 14 11 28 11 65v1340c0 38-4 52-11 66-8 14-19 25-33 33h-1c-14 7-28 11-65 11H110c-38 0-52-4-66-11-14-8-25-19-33-33v-1c-7-13-11-27-11-64V110c0-38 4-52 11-66 8-14 19-25 33-33h1C58 4 72 0 109 0h16c11 0 17 6 17 18z" fill="#000" fill-rule="evenodd"/></g>',
+    realisticImage: {
+      width: 460,
+      height: 880,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
+        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
+        { id: 'blue', title: 'Blue', colorValue: '#14496D', },
+        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
+        { id: 'red', title: 'Red', colorValue: '#DB4141', },
+      ],
+      handOffset: { left: 31.5, right: 30.5, bottom: 30, },
     },
   },
-}, {
-  id: 'iphone-12-pro',
-  title: 'iPhone 12 Pro',
-  screenRadius: 0,
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 390,
-  screenHeight: 844,
-  externalClay: {
-    width: 494,
-    height: 968,
-    screenOffsetTop: 62,
-    screenOffsetLeft: 52,
-  },
-  screenMask:
-    '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
-  realisticImage: {
-    width: 490,
-    height: 944,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'graphite',
-      title: 'Graphite',
-      colorValue: '#585753',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'pacific-blue',
-      title: 'Pacific Blue',
-      colorValue: '#415D6C',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FCECD5',
-    },],
-    handOffset: {
-      left: 29,
-      right: 29,
-      bottom: 29,
+  {
+    id: 'iphone-12-pro',
+    title: 'iPhone 12 Pro',
+    screenRadius: 0,
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 390,
+    screenHeight: 844,
+    externalClay: { width: 494, height: 968, screenOffsetTop: 62, screenOffsetLeft: 52, },
+    screenMask:
+      '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
+    realisticImage: {
+      width: 490,
+      height: 944,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'graphite', title: 'Graphite', colorValue: '#585753', },
+        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
+        { id: 'pacific-blue', title: 'Pacific Blue', colorValue: '#415D6C', },
+        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
+      ],
+      handOffset: { left: 29, right: 29, bottom: 29, },
     },
   },
-}, {
-  id: 'iphone-12-pro-max',
-  title: 'iPhone 12 Pro Max',
-  screenRadius: 50,
-  // to prevent leaking pixel in the corners, see https://github.com/framer/company/issues/20429
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 428,
-  screenHeight: 926,
-  externalClay: {
-    width: 532,
-    height: 1050,
-    screenOffsetTop: 62,
-    screenOffsetLeft: 52,
-  },
-  screenMask:
-    '<path d="M102 0c6 0 7 3 7 9 0 10 7 23 24 23h164c13 0 22-12 22-23 0-6 1-9 7-9h34c24 0 32 2 41 7s15 11 20 20 7 17 7 41v790c0 24-2 32-7 41s-11 15-20 20-17 7-41 7H68c-24 0-32-2-41-7s-15-11-20-20-7-17-7-41V68c0-24 2-32 7-41S18 12 27 7s17-7 41-7h34z" fill="#000" fill-rule="evenodd"/>',
-  realisticImage: {
-    width: 528,
-    height: 1026,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'graphite',
-      title: 'Graphite',
-      colorValue: '#585753',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'pacific-blue',
-      title: 'Pacific Blue',
-      colorValue: '#415D6C',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FCECD5',
-    },],
-    handOffset: {
-      left: 28.5,
-      right: 28,
-      bottom: 29,
+  {
+    id: 'iphone-12-pro-max',
+    title: 'iPhone 12 Pro Max',
+    screenRadius: 50, // to prevent leaking pixel in the corners, see https://github.com/framer/company/issues/20429
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 428,
+    screenHeight: 926,
+    externalClay: { width: 532, height: 1050, screenOffsetTop: 62, screenOffsetLeft: 52, },
+    screenMask:
+      '<path d="M102 0c6 0 7 3 7 9 0 10 7 23 24 23h164c13 0 22-12 22-23 0-6 1-9 7-9h34c24 0 32 2 41 7s15 11 20 20 7 17 7 41v790c0 24-2 32-7 41s-11 15-20 20-17 7-41 7H68c-24 0-32-2-41-7s-15-11-20-20-7-17-7-41V68c0-24 2-32 7-41S18 12 27 7s17-7 41-7h34z" fill="#000" fill-rule="evenodd"/>',
+    realisticImage: {
+      width: 528,
+      height: 1026,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'graphite', title: 'Graphite', colorValue: '#585753', },
+        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
+        { id: 'pacific-blue', title: 'Pacific Blue', colorValue: '#415D6C', },
+        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
+      ],
+      handOffset: { left: 28.5, right: 28, bottom: 29, },
     },
   },
-}, {
-  id: 'iphone-11',
-  title: 'iPhone 11',
-  // Screen mask takes care of the rounded screen corners for iPhones Pro,
-  // and actually using a radius here produces visual artifacts in Chrome.
-  screenRadius: (
-    /* 38 */
-    0
-  ),
-  clayBezelLeft: 35.5,
-  clayBezelRight: 35.5,
-  clayBezelTop: 35.5,
-  clayBezelBottom: 35.5,
-  clayBezelRadius: 77,
-  screenWidth: 414,
-  screenHeight: 896,
-  externalClay: {
-    width: 524,
-    height: 1026,
-    screenOffsetTop: 65,
-    screenOffsetLeft: 55,
+  {
+    id: 'iphone-11',
+    title: 'iPhone 11', // Screen mask takes care of the rounded screen corners for iPhones Pro,
+    // and actually using a radius here produces visual artifacts in Chrome.
+    screenRadius: (/* 38 */ 0),
+    clayBezelLeft: 35.5,
+    clayBezelRight: 35.5,
+    clayBezelTop: 35.5,
+    clayBezelBottom: 35.5,
+    clayBezelRadius: 77,
+    screenWidth: 414,
+    screenHeight: 896,
+    externalClay: { width: 524, height: 1026, screenOffsetTop: 65, screenOffsetLeft: 55, },
+    screenMask:
+      '<path d="M85.5 0C89.1 0 92 3 92 6.5c.3 6 1.5 10 3.4 13.5 2.2 4.1 5.5 7.4 9.6 9.6 4.2 2.2 8.9 3.4 17 3.4h170c8.1 0 12.8-1.2 17-3.4 4.1-2.2 7.4-5.5 9.6-9.6A31 31 0 00322 6.5c0-3.6 3-6.5 6.5-6.5h32.3c18.5 0 25.2 2 32 5.5 6.7 3.7 12 9 15.7 15.7 3.6 6.8 5.5 13.5 5.5 32v789.6c0 18.5-2 25.2-5.5 32-3.7 6.7-9 12-15.7 15.7-6.8 3.6-13.5 5.5-32 5.5H53.2c-18.5 0-25.2-2-32-5.5-6.7-3.7-12-9-15.7-15.7C2 868 0 861.3 0 842.8V53.2c0-18.5 2-25.2 5.5-32 3.7-6.7 9-12 15.7-15.7C28 2 34.7 0 53.2 0h32.3z" fill="#000" fill-rule="nonzero"/>',
+    realisticImage: {
+      width: 514,
+      height: 996,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'black', title: 'Black', colorValue: '#202120', },
+        { id: 'white', title: 'White', colorValue: '#F9F6EF', },
+        { id: 'purple', title: 'Purple', colorValue: '#D1CDDB', },
+        { id: 'green', title: 'Green', colorValue: '#ADE0CD', },
+        { id: 'red', title: 'Red', colorValue: '#B90D2E', },
+        { id: 'yellow', title: 'Yellow', colorValue: '#FFE680', },
+      ],
+      handOffset: { left: 14.5, right: 14.5, bottom: 14.5, },
+    },
   },
-  screenMask:
-    '<path d="M85.5 0C89.1 0 92 3 92 6.5c.3 6 1.5 10 3.4 13.5 2.2 4.1 5.5 7.4 9.6 9.6 4.2 2.2 8.9 3.4 17 3.4h170c8.1 0 12.8-1.2 17-3.4 4.1-2.2 7.4-5.5 9.6-9.6A31 31 0 00322 6.5c0-3.6 3-6.5 6.5-6.5h32.3c18.5 0 25.2 2 32 5.5 6.7 3.7 12 9 15.7 15.7 3.6 6.8 5.5 13.5 5.5 32v789.6c0 18.5-2 25.2-5.5 32-3.7 6.7-9 12-15.7 15.7-6.8 3.6-13.5 5.5-32 5.5H53.2c-18.5 0-25.2-2-32-5.5-6.7-3.7-12-9-15.7-15.7C2 868 0 861.3 0 842.8V53.2c0-18.5 2-25.2 5.5-32 3.7-6.7 9-12 15.7-15.7C28 2 34.7 0 53.2 0h32.3z" fill="#000" fill-rule="nonzero"/>',
-  realisticImage: {
-    width: 514,
-    height: 996,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#202120',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F9F6EF',
-    }, {
-      id: 'purple',
-      title: 'Purple',
-      colorValue: '#D1CDDB',
-    }, {
-      id: 'green',
-      title: 'Green',
-      colorValue: '#ADE0CD',
-    }, {
-      id: 'red',
-      title: 'Red',
-      colorValue: '#B90D2E',
-    }, {
-      id: 'yellow',
-      title: 'Yellow',
-      colorValue: '#FFE680',
-    },],
-    handOffset: {
-      left: 14.5,
-      right: 14.5,
-      bottom: 14.5,
+  {
+    id: 'iphone-11-pro',
+    title: 'iPhone 11 Pro',
+    ...presetsBase.iPhonePro,
+    screenWidth: 375,
+    screenHeight: 812,
+    externalClay: { width: 485, height: 942, screenOffsetTop: 65, screenOffsetLeft: 55, },
+    screenMask:
+      '<path d="M292 8.668V9c0 9.266-7.07 21-23.332 21h-162C90.402 30 83.332 18.266 83.332 9v-.332c0-4.285 0-8.668-7.664-8.668H43.332C16.312 0 0 16.313 0 43.332v725.336C0 795.688 16.313 812 43.332 812h288.336c27.02 0 43.332-16.313 43.332-43.332V43.332C375 16.312 358.687 0 331.668 0h-32C292 0 292 4.383 292 8.668zm0 0"/>',
+    realisticImage: {
+      width: 475,
+      height: 912,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'space-grey', title: 'Space Grey', colorValue: '#52514F', },
+        { id: 'silver', title: 'Silver', colorValue: '#EBEBE3', },
+        { id: 'gold', title: 'Gold', colorValue: '#FBD7BD', },
+        { id: 'midnight-green', title: 'Midnight Green', colorValue: '#4F5850', },
+      ],
+      handOffset: { left: 24.5, right: 24.5, bottom: 23.5, },
     },
   },
-}, {
-  id: 'iphone-11-pro',
-  title: 'iPhone 11 Pro',
-  ...presetsBase.iPhonePro,
-  screenWidth: 375,
-  screenHeight: 812,
-  externalClay: {
-    width: 485,
-    height: 942,
-    screenOffsetTop: 65,
-    screenOffsetLeft: 55,
+  {
+    id: 'iphone-11-pro-max',
+    title: 'iPhone 11 Pro Max',
+    ...presetsBase.iPhonePro,
+    screenWidth: 414,
+    screenHeight: 896,
+    externalClay: { width: 524, height: 1026, screenOffsetTop: 65, screenOffsetLeft: 55, },
+    screenMask:
+      '<path d="M96 0c3.313 0 5.91 2.688 6 6 .18 6.645 1.191 10.148 2.938 13.41 1.917 3.586 4.73 6.402 8.316 8.317 3.586 1.918 7.441 2.941 15.445 2.941h156.602c8.004 0 11.86-1.023 15.445-2.941 3.586-1.915 6.399-4.73 8.317-8.317 1.746-3.265 2.746-6.758 2.937-13.41.094-3.313 2.688-6 6-6h46.004c17.387 0 23.687 1.809 30.043 5.21 6.355 3.4 11.344 8.388 14.742 14.743C412.191 26.31 414 32.61 414 49.996v796.008c0 17.387-1.809 23.687-5.21 30.043-3.4 6.355-8.388 11.344-14.743 14.742-6.356 3.402-12.656 5.211-30.043 5.211H49.996c-17.387 0-23.687-1.809-30.043-5.21-6.355-3.4-11.344-8.388-14.742-14.743C1.809 869.69 0 863.39 0 846.004V49.996C0 32.61 1.809 26.31 5.21 19.953c3.4-6.355 8.388-11.344 14.743-14.742C26.31 1.809 32.61 0 49.996 0zm0 0"/>',
+    realisticImage: {
+      width: 514,
+      height: 996,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 50,
+      availableColors: [
+        { id: 'space-grey', title: 'Space Grey', colorValue: '#52514F', },
+        { id: 'silver', title: 'Silver', colorValue: '#EBEBE3', },
+        { id: 'gold', title: 'Gold', colorValue: '#FBD7BD', },
+        { id: 'midnight-green', title: 'Midnight Green', colorValue: '#4F5850', },
+      ],
+      handOffset: { left: 23.5, right: 24.5, bottom: 24, },
+    },
   },
-  screenMask:
-    '<path d="M292 8.668V9c0 9.266-7.07 21-23.332 21h-162C90.402 30 83.332 18.266 83.332 9v-.332c0-4.285 0-8.668-7.664-8.668H43.332C16.312 0 0 16.313 0 43.332v725.336C0 795.688 16.313 812 43.332 812h288.336c27.02 0 43.332-16.313 43.332-43.332V43.332C375 16.312 358.687 0 331.668 0h-32C292 0 292 4.383 292 8.668zm0 0"/>',
-  realisticImage: {
-    width: 475,
-    height: 912,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#52514F',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#EBEBE3',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FBD7BD',
-    }, {
-      id: 'midnight-green',
-      title: 'Midnight Green',
-      colorValue: '#4F5850',
-    },],
-    handOffset: {
-      left: 24.5,
-      right: 24.5,
-      bottom: 23.5,
+  {
+    id: 'iphone-8',
+    title: 'iPhone 8',
+    ...presetsBase.iPhone8,
+    screenWidth: 375,
+    screenHeight: 667,
+    externalClay: { width: 491, height: 971, screenOffsetLeft: 58, screenOffsetTop: 152, },
+    realisticImage: {
+      width: 475,
+      height: 927,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 130,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#28282A', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#DFE1E2',
+      }, { id: 'gold', title: 'Gold', colorValue: '#F6E6DB', },],
+      handOffset: { left: 22, right: 22, bottom: 18.5, },
     },
   },
-}, {
-  id: 'iphone-11-pro-max',
-  title: 'iPhone 11 Pro Max',
-  ...presetsBase.iPhonePro,
-  screenWidth: 414,
-  screenHeight: 896,
-  externalClay: {
-    width: 524,
-    height: 1026,
-    screenOffsetTop: 65,
-    screenOffsetLeft: 55,
+  {
+    id: 'iphone-8-plus',
+    title: 'iPhone 8 Plus',
+    ...presetsBase.iPhone8,
+    screenWidth: 414,
+    screenHeight: 736,
+    externalClay: { width: 530, height: 1064, screenOffsetLeft: 58, screenOffsetTop: 164, },
+    realisticImage: {
+      width: 514,
+      height: 996,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 130,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#28282A', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#DFE1E2',
+      }, { id: 'gold', title: 'Gold', colorValue: '#F6E6DB', },],
+      handOffset: { left: 21, right: 20.5, bottom: 19, },
+    },
   },
-  screenMask:
-    '<path d="M96 0c3.313 0 5.91 2.688 6 6 .18 6.645 1.191 10.148 2.938 13.41 1.917 3.586 4.73 6.402 8.316 8.317 3.586 1.918 7.441 2.941 15.445 2.941h156.602c8.004 0 11.86-1.023 15.445-2.941 3.586-1.915 6.399-4.73 8.317-8.317 1.746-3.265 2.746-6.758 2.937-13.41.094-3.313 2.688-6 6-6h46.004c17.387 0 23.687 1.809 30.043 5.21 6.355 3.4 11.344 8.388 14.742 14.743C412.191 26.31 414 32.61 414 49.996v796.008c0 17.387-1.809 23.687-5.21 30.043-3.4 6.355-8.388 11.344-14.743 14.742-6.356 3.402-12.656 5.211-30.043 5.211H49.996c-17.387 0-23.687-1.809-30.043-5.21-6.355-3.4-11.344-8.388-14.742-14.743C1.809 869.69 0 863.39 0 846.004V49.996C0 32.61 1.809 26.31 5.21 19.953c3.4-6.355 8.388-11.344 14.743-14.742C26.31 1.809 32.61 0 49.996 0zm0 0"/>',
-  realisticImage: {
-    width: 514,
-    height: 996,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 50,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#52514F',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#EBEBE3',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FBD7BD',
-    }, {
-      id: 'midnight-green',
-      title: 'Midnight Green',
-      colorValue: '#4F5850',
-    },],
-    handOffset: {
-      left: 23.5,
-      right: 24.5,
-      bottom: 24,
+  {
+    id: 'iphone-se',
+    title: 'iPhone SE',
+    screenWidth: 320,
+    screenHeight: 568,
+    screenRadius: 0,
+    clayBezelLeft: 20,
+    clayBezelRight: 20,
+    clayBezelTop: 112,
+    clayBezelBottom: 112,
+    clayBezelRadius: 38 * 1.5,
+    externalClay: { width: 436, height: 872, screenOffsetLeft: 58, screenOffsetTop: 152, },
+    realisticImage: {
+      width: 420,
+      height: 828,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 130,
+      availableColors: [
+        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
+        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
+        { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },
+        { id: 'rose-gold', title: 'Rose Gold', colorValue: '#F7CFCA', },
+      ],
+      handOffset: { left: 22, right: 22, bottom: 26.5, },
     },
   },
-}, {
-  id: 'iphone-8',
-  title: 'iPhone 8',
-  ...presetsBase.iPhone8,
-  screenWidth: 375,
-  screenHeight: 667,
-  externalClay: {
-    width: 491,
-    height: 971,
-    screenOffsetLeft: 58,
-    screenOffsetTop: 152,
+  {
+    id: 'samsung-galaxy-s7',
+    title: 'Samsung Galaxy S7',
+    screenRadius: 0,
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 360,
+    screenHeight: 640,
+    externalClay: { width: 454, height: 880, screenOffsetTop: 120, screenOffsetLeft: 47, },
+    realisticImage: {
+      width: 440,
+      height: 860,
+      screenOffsetLeft: 40,
+      screenOffsetTop: 110,
+      availableColors: [{ id: 'black', title: 'Black', colorValue: '#2E2C36', }, { id: 'white', title: 'White', colorValue: '#F7F3F0', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#E5E6E1',
+      }, { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },],
+      handOffset: { left: 26, right: 25.5, bottom: 32, },
+    },
+  }, // deprecated
+  {
+    id: 'samsung-note-10',
+    title: 'Samsung Note 10',
+    screenWidth: 360,
+    screenHeight: 760,
+    screenRadius: 10,
+    clayBezelLeft: 7,
+    clayBezelRight: 7,
+    clayBezelTop: 15,
+    clayBezelBottom: 15,
+    clayBezelRadius: 15,
   },
-  realisticImage: {
-    width: 475,
-    height: 927,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 130,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#28282A',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#DFE1E2',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#F6E6DB',
-    },],
-    handOffset: {
-      left: 22,
-      right: 22,
-      bottom: 18.5,
+  {
+    id: 'pixel-5',
+    title: 'Google Pixel 5',
+    screenRadius: 31,
+    clayBezelLeft: 22,
+    clayBezelRight: 22,
+    clayBezelTop: 22,
+    clayBezelBottom: 22,
+    clayBezelRadius: 66,
+    screenWidth: 360,
+    screenHeight: 780,
+    externalClay: { width: 460, height: 900, screenOffsetTop: 60, screenOffsetLeft: 50, },
+    realisticImage: {
+      width: 920 / 2,
+      height: 1760 / 2,
+      screenOffsetLeft: 100 / 2,
+      screenOffsetTop: 100 / 2,
+      availableColors: [{ id: 'just-black', title: 'Just Black', colorValue: '#2E2C36', }, {
+        id: 'sorta-sage',
+        title: 'Sorta Sage',
+        colorValue: '#B7C9C0',
+      },],
+      handOffset: { left: 31.5, right: 31, bottom: 31, /* 1t */ },
     },
   },
-}, {
-  id: 'iphone-8-plus',
-  title: 'iPhone 8 Plus',
-  ...presetsBase.iPhone8,
-  screenWidth: 414,
-  screenHeight: 736,
-  externalClay: {
-    width: 530,
-    height: 1064,
-    screenOffsetLeft: 58,
-    screenOffsetTop: 164,
-  },
-  realisticImage: {
-    width: 514,
-    height: 996,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 130,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#28282A',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#DFE1E2',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#F6E6DB',
-    },],
-    handOffset: {
-      left: 21,
-      right: 20.5,
-      bottom: 19,
+  {
+    id: 'pixel-4',
+    title: 'Google Pixel 4',
+    screenWidth: 360,
+    screenHeight: 760,
+    screenRadius: 34,
+    clayBezelLeft: 10,
+    clayBezelRight: 10,
+    clayBezelTop: 50,
+    clayBezelBottom: 25,
+    clayBezelRadius: 50,
+    externalClay: { width: 460, height: 938, screenOffsetLeft: 50, screenOffsetTop: 89, },
+    realisticImage: {
+      width: 460,
+      height: 920,
+      screenOffsetLeft: 50,
+      screenOffsetTop: 80,
+      availableColors: [{ id: 'clearly-white', title: 'Clearly White', colorValue: '#EAEDF2', }, {
+        id: 'just-black',
+        title: 'Just Black',
+        colorValue: '#1A1A1A',
+      }, { id: 'oh-so-orange', title: 'Oh So Orange', colorValue: '#FF7A68', },],
+      handOffset: { left: 35.5, right: 35.5, bottom: 57, /* 1t */ },
+    },
+  }, // Desktop ------------------------------------------------------------------------------------------------------------------------
+  {
+    id: 'macbook-air',
+    title: 'MacBook Air',
+    screenWidth: 1440,
+    screenHeight: 900,
+    disableRotation: true,
+    externalClay: { width: 1890, height: 1125, screenOffsetLeft: 225, screenOffsetTop: 98, },
+    realisticImage: {
+      width: 3848 / 2,
+      height: 2240 / 2,
+      screenOffsetLeft: 484 / 2,
+      screenOffsetTop: 196 / 2,
+      availableColors: [{ id: 'silver', title: 'Silver', colorValue: '#E5E6E1', }, {
+        id: 'space-grey',
+        title: 'Space Grey',
+        colorValue: '#B1B5B7',
+      }, { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },],
     },
   },
-}, {
-  id: 'iphone-se',
-  title: 'iPhone SE',
-  screenWidth: 320,
-  screenHeight: 568,
-  screenRadius: 0,
-  clayBezelLeft: 20,
-  clayBezelRight: 20,
-  clayBezelTop: 112,
-  clayBezelBottom: 112,
-  clayBezelRadius: 38 * 1.5,
-  externalClay: {
-    width: 436,
-    height: 872,
-    screenOffsetLeft: 58,
-    screenOffsetTop: 152,
+  {
+    id: 'macbook-pro-13',
+    title: `MacBook Pro 13"`,
+    screenWidth: 1440,
+    screenHeight: 900,
+    disableRotation: true,
+    externalClay: { width: 1914, height: 1169, screenOffsetLeft: 236, screenOffsetTop: 109, },
+    realisticImage: {
+      width: 3916 / 2,
+      height: 2330 / 2,
+      screenOffsetLeft: 518 / 2,
+      screenOffsetTop: 218 / 2,
+      availableColors: [{ id: 'silver', title: 'Silver', colorValue: '#E5E6E1', }, {
+        id: 'space-grey',
+        title: 'Space Grey',
+        colorValue: '#B1B5B7',
+      },],
+    },
   },
-  realisticImage: {
-    width: 420,
-    height: 828,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 130,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#EFD8BD',
-    }, {
-      id: 'rose-gold',
-      title: 'Rose Gold',
-      colorValue: '#F7CFCA',
-    },],
-    handOffset: {
-      left: 22,
-      right: 22,
-      bottom: 26.5,
+  {
+    id: 'macbook-pro-16',
+    title: `MacBook Pro 16"`,
+    screenWidth: 1536,
+    screenHeight: 960,
+    disableRotation: true,
+    externalClay: { width: 1984, height: 1179, screenOffsetLeft: 225, screenOffsetTop: 78, },
+    realisticImage: {
+      width: 4032 / 2,
+      height: 2348 / 2,
+      screenOffsetLeft: 480 / 2,
+      screenOffsetTop: 148 / 2,
+      availableColors: [{ id: 'silver', title: 'Silver', colorValue: '#E5E6E1', }, {
+        id: 'space-grey',
+        title: 'Space Grey',
+        colorValue: '#B1B5B7',
+      },],
     },
   },
-}, {
-  id: 'samsung-galaxy-s7',
-  title: 'Samsung Galaxy S7',
-  screenRadius: 0,
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 360,
-  screenHeight: 640,
-  externalClay: {
-    width: 454,
-    height: 880,
-    screenOffsetTop: 120,
-    screenOffsetLeft: 47,
+  {
+    id: 'imac-21-5',
+    title: `iMac 21.5"`,
+    screenWidth: 2048,
+    screenHeight: 1152,
+    disableRotation: true,
+    externalClay: { width: 2288, height: 1892, screenOffsetLeft: 120, screenOffsetTop: 120, },
+    realisticImage: { width: 4562 / 2, height: 3796 / 2, screenOffsetLeft: 232 / 2, screenOffsetTop: 244 / 2, },
   },
-  realisticImage: {
-    width: 440,
-    height: 860,
-    screenOffsetLeft: 40,
-    screenOffsetTop: 110,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F7F3F0',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FCECD5',
-    },],
-    handOffset: {
-      left: 26,
-      right: 25.5,
-      bottom: 32,
+  {
+    id: 'imac-27',
+    title: `iMac 27"`,
+    screenWidth: 2560,
+    screenHeight: 1440,
+    disableRotation: true,
+    externalClay: { width: 2848, height: 2351, screenOffsetLeft: 144, screenOffsetTop: 151, },
+    realisticImage: {
+      width: 5676 / 2,
+      height: 4720 / 2,
+      screenOffsetLeft: 278 / 2,
+      screenOffsetTop: 292 / 2,
+      availableColors: [{ id: 'silver', title: 'Silver', colorValue: '#E5E6E1', }, { id: 'pro', title: 'Pro', colorValue: '#5F5E63', },],
     },
   },
-}, // deprecated
-{
-  id: 'samsung-note-10',
-  title: 'Samsung Note 10',
-  screenWidth: 360,
-  screenHeight: 760,
-  screenRadius: 10,
-  clayBezelLeft: 7,
-  clayBezelRight: 7,
-  clayBezelTop: 15,
-  clayBezelBottom: 15,
-  clayBezelRadius: 15,
-}, {
-  id: 'pixel-5',
-  title: 'Google Pixel 5',
-  screenRadius: 31,
-  clayBezelLeft: 22,
-  clayBezelRight: 22,
-  clayBezelTop: 22,
-  clayBezelBottom: 22,
-  clayBezelRadius: 66,
-  screenWidth: 360,
-  screenHeight: 780,
-  externalClay: {
-    width: 460,
-    height: 900,
-    screenOffsetTop: 60,
-    screenOffsetLeft: 50,
+  {
+    id: 'pro-display-xdr',
+    title: `Pro Display XDR`,
+    screenWidth: 3008,
+    screenHeight: 1692,
+    disableRotation: true,
+    externalClay: { width: 3148, height: 2325, screenOffsetLeft: 70, screenOffsetTop: 60, },
+    realisticImage: { width: 6276 / 2, height: 4695 / 2, screenOffsetLeft: 130 / 2, screenOffsetTop: 130 / 2, },
   },
-  realisticImage: {
-    width: 920 / 2,
-    height: 1760 / 2,
-    screenOffsetLeft: 100 / 2,
-    screenOffsetTop: 100 / 2,
-    availableColors: [{
-      id: 'just-black',
-      title: 'Just Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'sorta-sage',
-      title: 'Sorta Sage',
-      colorValue: '#B7C9C0',
-    },],
-    handOffset: {
-      left: 31.5,
-      right: 31,
-      bottom: 31,
-      /* 1t */
-    },
+  {
+    id: 'dell-xps',
+    title: `Dell XPS`,
+    screenWidth: 1920,
+    screenHeight: 1080,
+    disableRotation: true,
+    externalClay: { width: 2624, height: 1381, screenOffsetLeft: 352, screenOffsetTop: 57, },
+    realisticImage: { width: 5412 / 2, height: 2746 / 2, screenOffsetLeft: 786 / 2, screenOffsetTop: 108 / 2, },
   },
-}, {
-  id: 'pixel-4',
-  title: 'Google Pixel 4',
-  screenWidth: 360,
-  screenHeight: 760,
-  screenRadius: 34,
-  clayBezelLeft: 10,
-  clayBezelRight: 10,
-  clayBezelTop: 50,
-  clayBezelBottom: 25,
-  clayBezelRadius: 50,
-  externalClay: {
-    width: 460,
-    height: 938,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 89,
+  {
+    id: 'surface-book',
+    title: `Microsoft Surface Book`,
+    screenWidth: 1500,
+    screenHeight: 1e3,
+    disableRotation: true,
+    externalClay: { width: 2089, height: 1234, screenOffsetLeft: 296, screenOffsetTop: 93, },
+    realisticImage: { width: 4200 / 2, height: 2508 / 2, screenOffsetLeft: 600 / 2, screenOffsetTop: 210 / 2, },
+  }, // Tablets ------------------------------------------------------------------------------------------------------------------------
+  {
+    id: 'ipad',
+    title: 'iPad',
+    screenRadius: 0,
+    screenWidth: 810,
+    screenHeight: 1080,
+    clayBezelLeft: 30,
+    clayBezelRight: 30,
+    clayBezelTop: 95,
+    clayBezelBottom: 95,
+    clayBezelRadius: 0,
+    externalClay: { width: 966, height: 1378, screenOffsetLeft: 78, screenOffsetTop: 149, },
+    realisticImage: {
+      width: 1920 / 2,
+      height: 2720 / 2,
+      screenOffsetLeft: 75,
+      screenOffsetTop: 140,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#E1E2E4',
+      }, { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },],
+    },
   },
-  realisticImage: {
-    width: 460,
-    height: 920,
-    screenOffsetLeft: 50,
-    screenOffsetTop: 80,
-    availableColors: [{
-      id: 'clearly-white',
-      title: 'Clearly White',
-      colorValue: '#EAEDF2',
-    }, {
-      id: 'just-black',
-      title: 'Just Black',
-      colorValue: '#1A1A1A',
-    }, {
-      id: 'oh-so-orange',
-      title: 'Oh So Orange',
-      colorValue: '#FF7A68',
-    },],
-    handOffset: {
-      left: 35.5,
-      right: 35.5,
-      bottom: 57,
-      /* 1t */
+  {
+    id: 'ipad-mini',
+    title: 'iPad Mini',
+    screenRadius: 0,
+    clayBezelLeft: 49,
+    clayBezelRight: 49,
+    clayBezelTop: 49,
+    clayBezelBottom: 49,
+    clayBezelRadius: 49,
+    screenWidth: 768,
+    screenHeight: 1024,
+    externalClay: { width: 924, height: 1384, screenOffsetLeft: 78, screenOffsetTop: 180, },
+    realisticImage: {
+      width: 1856 / 2,
+      height: 2728 / 2,
+      screenOffsetLeft: 160 / 2,
+      screenOffsetTop: 340 / 2,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#E1E2E4',
+      }, { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },],
     },
   },
-}, // Desktop ------------------------------------------------------------------------------------------------------------------------
-{
-  id: 'macbook-air',
-  title: 'MacBook Air',
-  screenWidth: 1440,
-  screenHeight: 900,
-  disableRotation: true,
-  externalClay: {
-    width: 1890,
-    height: 1125,
-    screenOffsetLeft: 225,
-    screenOffsetTop: 98,
-  },
-  realisticImage: {
-    width: 3848 / 2,
-    height: 2240 / 2,
-    screenOffsetLeft: 484 / 2,
-    screenOffsetTop: 196 / 2,
-    availableColors: [{
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#B1B5B7',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#FCECD5',
-    },],
-  },
-}, {
-  id: 'macbook-pro-13',
-  title: `MacBook Pro 13"`,
-  screenWidth: 1440,
-  screenHeight: 900,
-  disableRotation: true,
-  externalClay: {
-    width: 1914,
-    height: 1169,
-    screenOffsetLeft: 236,
-    screenOffsetTop: 109,
-  },
-  realisticImage: {
-    width: 3916 / 2,
-    height: 2330 / 2,
-    screenOffsetLeft: 518 / 2,
-    screenOffsetTop: 218 / 2,
-    availableColors: [{
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#B1B5B7',
-    },],
-  },
-}, {
-  id: 'macbook-pro-16',
-  title: `MacBook Pro 16"`,
-  screenWidth: 1536,
-  screenHeight: 960,
-  disableRotation: true,
-  externalClay: {
-    width: 1984,
-    height: 1179,
-    screenOffsetLeft: 225,
-    screenOffsetTop: 78,
-  },
-  realisticImage: {
-    width: 4032 / 2,
-    height: 2348 / 2,
-    screenOffsetLeft: 480 / 2,
-    screenOffsetTop: 148 / 2,
-    availableColors: [{
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#B1B5B7',
-    },],
-  },
-}, {
-  id: 'imac-21-5',
-  title: `iMac 21.5"`,
-  screenWidth: 2048,
-  screenHeight: 1152,
-  disableRotation: true,
-  externalClay: {
-    width: 2288,
-    height: 1892,
-    screenOffsetLeft: 120,
-    screenOffsetTop: 120,
-  },
-  realisticImage: {
-    width: 4562 / 2,
-    height: 3796 / 2,
-    screenOffsetLeft: 232 / 2,
-    screenOffsetTop: 244 / 2,
-  },
-}, {
-  id: 'imac-27',
-  title: `iMac 27"`,
-  screenWidth: 2560,
-  screenHeight: 1440,
-  disableRotation: true,
-  externalClay: {
-    width: 2848,
-    height: 2351,
-    screenOffsetLeft: 144,
-    screenOffsetTop: 151,
-  },
-  realisticImage: {
-    width: 5676 / 2,
-    height: 4720 / 2,
-    screenOffsetLeft: 278 / 2,
-    screenOffsetTop: 292 / 2,
-    availableColors: [{
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E5E6E1',
-    }, {
-      id: 'pro',
-      title: 'Pro',
-      colorValue: '#5F5E63',
-    },],
-  },
-}, {
-  id: 'pro-display-xdr',
-  title: `Pro Display XDR`,
-  screenWidth: 3008,
-  screenHeight: 1692,
-  disableRotation: true,
-  externalClay: {
-    width: 3148,
-    height: 2325,
-    screenOffsetLeft: 70,
-    screenOffsetTop: 60,
-  },
-  realisticImage: {
-    width: 6276 / 2,
-    height: 4695 / 2,
-    screenOffsetLeft: 130 / 2,
-    screenOffsetTop: 130 / 2,
-  },
-}, {
-  id: 'dell-xps',
-  title: `Dell XPS`,
-  screenWidth: 1920,
-  screenHeight: 1080,
-  disableRotation: true,
-  externalClay: {
-    width: 2624,
-    height: 1381,
-    screenOffsetLeft: 352,
-    screenOffsetTop: 57,
-  },
-  realisticImage: {
-    width: 5412 / 2,
-    height: 2746 / 2,
-    screenOffsetLeft: 786 / 2,
-    screenOffsetTop: 108 / 2,
-  },
-}, {
-  id: 'surface-book',
-  title: `Microsoft Surface Book`,
-  screenWidth: 1500,
-  screenHeight: 1e3,
-  disableRotation: true,
-  externalClay: {
-    width: 2089,
-    height: 1234,
-    screenOffsetLeft: 296,
-    screenOffsetTop: 93,
-  },
-  realisticImage: {
-    width: 4200 / 2,
-    height: 2508 / 2,
-    screenOffsetLeft: 600 / 2,
-    screenOffsetTop: 210 / 2,
-  },
-}, // Tablets ------------------------------------------------------------------------------------------------------------------------
-{
-  id: 'ipad',
-  title: 'iPad',
-  screenRadius: 0,
-  screenWidth: 810,
-  screenHeight: 1080,
-  clayBezelLeft: 30,
-  clayBezelRight: 30,
-  clayBezelTop: 95,
-  clayBezelBottom: 95,
-  clayBezelRadius: 0,
-  externalClay: {
-    width: 966,
-    height: 1378,
-    screenOffsetLeft: 78,
-    screenOffsetTop: 149,
-  },
-  realisticImage: {
-    width: 1920 / 2,
-    height: 2720 / 2,
-    screenOffsetLeft: 75,
-    screenOffsetTop: 140,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#EFD8BD',
-    },],
-  },
-}, {
-  id: 'ipad-mini',
-  title: 'iPad Mini',
-  screenRadius: 0,
-  clayBezelLeft: 49,
-  clayBezelRight: 49,
-  clayBezelTop: 49,
-  clayBezelBottom: 49,
-  clayBezelRadius: 49,
-  screenWidth: 768,
-  screenHeight: 1024,
-  externalClay: {
-    width: 924,
-    height: 1384,
-    screenOffsetLeft: 78,
-    screenOffsetTop: 180,
-  },
-  realisticImage: {
-    width: 1856 / 2,
-    height: 2728 / 2,
-    screenOffsetLeft: 160 / 2,
-    screenOffsetTop: 340 / 2,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    }, {
-      id: 'gold',
-      title: 'Gold',
-      colorValue: '#EFD8BD',
-    },],
-  },
-}, {
-  id: 'ipad-air',
-  title: 'iPad Air',
-  screenRadius: 18,
-  clayBezelLeft: 49,
-  clayBezelRight: 49,
-  clayBezelTop: 49,
-  clayBezelBottom: 49,
-  clayBezelRadius: 49,
-  screenWidth: 820,
-  screenHeight: 1180,
-  externalClay: {
-    width: 994,
-    height: 1374,
-    screenOffsetLeft: 87,
-    screenOffsetTop: 97,
-  },
-  realisticImage: {
-    width: 1960 / 2,
-    height: 2680 / 2,
-    screenOffsetLeft: 160 / 2,
-    screenOffsetTop: 160 / 2,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    }, {
-      id: 'rose-gold',
-      title: 'Rose Gold',
-      colorValue: '#ECCBC4',
-    }, {
-      id: 'blue',
-      title: 'Blue',
-      colorValue: '#CBDAE6',
-    }, {
-      id: 'green',
-      title: 'Green',
-      colorValue: '#DAF0D9',
-    },],
-  },
-}, {
-  id: 'ipad-pro-11',
-  title: 'iPad Pro 11\u2033',
-  screenRadius: 17,
-  clayBezelLeft: 49,
-  clayBezelRight: 49,
-  clayBezelTop: 49,
-  clayBezelBottom: 49,
-  clayBezelRadius: 49,
-  screenWidth: 834,
-  screenHeight: 1194,
-  externalClay: {
-    width: 990,
-    height: 1370,
-    screenOffsetLeft: 78,
-    screenOffsetTop: 88,
-  },
-  realisticImage: {
-    width: 1968 / 2,
-    height: 2688 / 2,
-    screenOffsetLeft: 75,
-    screenOffsetTop: 75,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    },],
-  },
-}, {
-  id: 'ipad-pro-12-9',
-  title: 'iPad Pro 12.9\u2033',
-  ...presetsBase.iPadPro,
-  screenRadius: 17,
-  screenWidth: 1024,
-  screenHeight: 1366,
-  externalClay: {
-    width: 1180,
-    height: 1542,
-    screenOffsetLeft: 78,
-    screenOffsetTop: 88,
-  },
-  realisticImage: {
-    width: 2348 / 2,
-    height: 3032 / 2,
-    screenOffsetLeft: 75,
-    screenOffsetTop: 75,
-    availableColors: [{
-      id: 'space-grey',
-      title: 'Space Grey',
-      colorValue: '#C3C4C8',
-    }, {
-      id: 'silver',
-      title: 'Silver',
-      colorValue: '#E1E2E4',
-    },],
-  },
-}, {
-  id: 'surface-3',
-  title: 'Microsoft Surface 3',
-  screenRadius: 0,
-  clayBezelLeft: 49,
-  clayBezelRight: 49,
-  clayBezelTop: 49,
-  clayBezelBottom: 49,
-  clayBezelRadius: 49,
-  screenWidth: 960,
-  screenHeight: 640,
-  externalClay: {
-    width: 1184,
-    height: 864,
-    screenOffsetLeft: 112,
-    screenOffsetTop: 112,
-  },
-  realisticImage: {
-    width: 2280 / 2,
-    height: 1580 / 2,
-    screenOffsetLeft: 180 / 2,
-    screenOffsetTop: 150 / 2,
-  },
-}, {
-  id: 'surface-pro-4',
-  title: 'Microsoft Surface Pro 4',
-  screenRadius: 0,
-  clayBezelLeft: 49,
-  clayBezelRight: 49,
-  clayBezelTop: 49,
-  clayBezelBottom: 49,
-  clayBezelRadius: 49,
-  screenWidth: 1368,
-  screenHeight: 912,
-  externalClay: {
-    width: 1592,
-    height: 1136,
-    screenOffsetLeft: 112,
-    screenOffsetTop: 112,
-  },
-  realisticImage: {
-    width: 3176 / 2,
-    height: 2224 / 2,
-    screenOffsetLeft: 220 / 2,
-    screenOffsetTop: 200 / 2,
-  },
-}, // Watches ------------------------------------------------------------------------------------------------------------------------
-{
-  id: 'apple-watch-44',
-  title: `Apple Watch 44mm`,
-  screenRadius: 33,
-  screenWidth: 184,
-  screenHeight: 224,
-  disableRotation: true,
-  externalClay: {
-    width: 298,
-    height: 502,
-    screenOffsetLeft: 57,
-    screenOffsetTop: 129,
-  },
-  realisticImage: {
-    width: 548 / 2,
-    height: 908 / 2,
-    screenOffsetLeft: 90 / 2,
-    screenOffsetTop: 230 / 2,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F7F3F0',
-    }, {
-      id: 'yellow',
-      title: 'Yellow',
-      colorValue: '#FDDC6C',
-    }, {
-      id: 'orange',
-      title: 'Orange',
-      colorValue: '#F35C56',
-    },],
-  },
-}, {
-  id: 'apple-watch-40',
-  title: `Apple Watch 40mm`,
-  screenRadius: 27,
-  screenWidth: 162,
-  screenHeight: 197,
-  disableRotation: true,
-  externalClay: {
-    width: 280,
-    height: 463,
-    screenOffsetLeft: 59,
-    screenOffsetTop: 124,
+  {
+    id: 'ipad-air',
+    title: 'iPad Air',
+    screenRadius: 18,
+    clayBezelLeft: 49,
+    clayBezelRight: 49,
+    clayBezelTop: 49,
+    clayBezelBottom: 49,
+    clayBezelRadius: 49,
+    screenWidth: 820,
+    screenHeight: 1180,
+    externalClay: { width: 994, height: 1374, screenOffsetLeft: 87, screenOffsetTop: 97, },
+    realisticImage: {
+      width: 1960 / 2,
+      height: 2680 / 2,
+      screenOffsetLeft: 160 / 2,
+      screenOffsetTop: 160 / 2,
+      availableColors: [
+        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
+        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
+        { id: 'rose-gold', title: 'Rose Gold', colorValue: '#ECCBC4', },
+        { id: 'blue', title: 'Blue', colorValue: '#CBDAE6', },
+        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
+      ],
+    },
   },
-  realisticImage: {
-    width: 504 / 2,
-    height: 854 / 2,
-    screenOffsetLeft: 90 / 2,
-    screenOffsetTop: 230 / 2,
-    availableColors: [{
-      id: 'black',
-      title: 'Black',
-      colorValue: '#2E2C36',
-    }, {
-      id: 'white',
-      title: 'White',
-      colorValue: '#F7F3F0',
-    }, {
-      id: 'yellow',
-      title: 'Yellow',
-      colorValue: '#FDDC6C',
-    }, {
-      id: 'orange',
-      title: 'Orange',
-      colorValue: '#F35C56',
-    },],
+  {
+    id: 'ipad-pro-11',
+    title: 'iPad Pro 11\u2033',
+    screenRadius: 17,
+    clayBezelLeft: 49,
+    clayBezelRight: 49,
+    clayBezelTop: 49,
+    clayBezelBottom: 49,
+    clayBezelRadius: 49,
+    screenWidth: 834,
+    screenHeight: 1194,
+    externalClay: { width: 990, height: 1370, screenOffsetLeft: 78, screenOffsetTop: 88, },
+    realisticImage: {
+      width: 1968 / 2,
+      height: 2688 / 2,
+      screenOffsetLeft: 75,
+      screenOffsetTop: 75,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#E1E2E4',
+      },],
+    },
   },
-}, // TVs ------------------------------------------------------------------------------------------------------------------------
-{
-  id: 'tv-full-hd',
-  title: `Full HD`,
-  screenRadius: 0,
-  screenWidth: 1920,
-  screenHeight: 1080,
-  externalClay: {
-    width: 1968,
-    height: 1168,
-    screenOffsetLeft: 24,
-    screenOffsetTop: 12,
+  {
+    id: 'ipad-pro-12-9',
+    title: 'iPad Pro 12.9\u2033',
+    ...presetsBase.iPadPro,
+    screenRadius: 17,
+    screenWidth: 1024,
+    screenHeight: 1366,
+    externalClay: { width: 1180, height: 1542, screenOffsetLeft: 78, screenOffsetTop: 88, },
+    realisticImage: {
+      width: 2348 / 2,
+      height: 3032 / 2,
+      screenOffsetLeft: 75,
+      screenOffsetTop: 75,
+      availableColors: [{ id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', }, {
+        id: 'silver',
+        title: 'Silver',
+        colorValue: '#E1E2E4',
+      },],
+    },
   },
-  realisticImage: {
-    width: 4040 / 2,
-    height: 2360 / 2,
-    screenOffsetLeft: 100 / 2,
-    screenOffsetTop: 100 / 2,
+  {
+    id: 'surface-3',
+    title: 'Microsoft Surface 3',
+    screenRadius: 0,
+    clayBezelLeft: 49,
+    clayBezelRight: 49,
+    clayBezelTop: 49,
+    clayBezelBottom: 49,
+    clayBezelRadius: 49,
+    screenWidth: 960,
+    screenHeight: 640,
+    externalClay: { width: 1184, height: 864, screenOffsetLeft: 112, screenOffsetTop: 112, },
+    realisticImage: { width: 2280 / 2, height: 1580 / 2, screenOffsetLeft: 180 / 2, screenOffsetTop: 150 / 2, },
   },
-}, {
-  id: 'tv-4k',
-  title: `4K`,
-  screenRadius: 0,
-  screenWidth: 3840,
-  screenHeight: 2160,
-  externalClay: {
-    width: 3908,
-    height: 2308,
-    screenOffsetLeft: 34,
-    screenOffsetTop: 24,
+  {
+    id: 'surface-pro-4',
+    title: 'Microsoft Surface Pro 4',
+    screenRadius: 0,
+    clayBezelLeft: 49,
+    clayBezelRight: 49,
+    clayBezelTop: 49,
+    clayBezelBottom: 49,
+    clayBezelRadius: 49,
+    screenWidth: 1368,
+    screenHeight: 912,
+    externalClay: { width: 1592, height: 1136, screenOffsetLeft: 112, screenOffsetTop: 112, },
+    realisticImage: { width: 3176 / 2, height: 2224 / 2, screenOffsetLeft: 220 / 2, screenOffsetTop: 200 / 2, },
+  }, // Watches ------------------------------------------------------------------------------------------------------------------------
+  {
+    id: 'apple-watch-44',
+    title: `Apple Watch 44mm`,
+    screenRadius: 33,
+    screenWidth: 184,
+    screenHeight: 224,
+    disableRotation: true,
+    externalClay: { width: 298, height: 502, screenOffsetLeft: 57, screenOffsetTop: 129, },
+    realisticImage: {
+      width: 548 / 2,
+      height: 908 / 2,
+      screenOffsetLeft: 90 / 2,
+      screenOffsetTop: 230 / 2,
+      availableColors: [{ id: 'black', title: 'Black', colorValue: '#2E2C36', }, { id: 'white', title: 'White', colorValue: '#F7F3F0', }, {
+        id: 'yellow',
+        title: 'Yellow',
+        colorValue: '#FDDC6C',
+      }, { id: 'orange', title: 'Orange', colorValue: '#F35C56', },],
+    },
   },
-  realisticImage: {
-    width: 7960 / 2,
-    height: 4600 / 2,
-    screenOffsetLeft: 140 / 2,
-    screenOffsetTop: 140 / 2,
+  {
+    id: 'apple-watch-40',
+    title: `Apple Watch 40mm`,
+    screenRadius: 27,
+    screenWidth: 162,
+    screenHeight: 197,
+    disableRotation: true,
+    externalClay: { width: 280, height: 463, screenOffsetLeft: 59, screenOffsetTop: 124, },
+    realisticImage: {
+      width: 504 / 2,
+      height: 854 / 2,
+      screenOffsetLeft: 90 / 2,
+      screenOffsetTop: 230 / 2,
+      availableColors: [{ id: 'black', title: 'Black', colorValue: '#2E2C36', }, { id: 'white', title: 'White', colorValue: '#F7F3F0', }, {
+        id: 'yellow',
+        title: 'Yellow',
+        colorValue: '#FDDC6C',
+      }, { id: 'orange', title: 'Orange', colorValue: '#F35C56', },],
+    },
+  }, // TVs ------------------------------------------------------------------------------------------------------------------------
+  {
+    id: 'tv-full-hd',
+    title: `Full HD`,
+    screenRadius: 0,
+    screenWidth: 1920,
+    screenHeight: 1080,
+    externalClay: { width: 1968, height: 1168, screenOffsetLeft: 24, screenOffsetTop: 12, },
+    realisticImage: { width: 4040 / 2, height: 2360 / 2, screenOffsetLeft: 100 / 2, screenOffsetTop: 100 / 2, },
   },
-}, // Old devices ------------------------------------------------------------------------------------------------------------------------
-// deprecated
-{
-  id: '720p',
-  title: '720p',
-  ...presetsBase.desktop,
-  screenWidth: 720,
-  screenHeight: 1280,
-}, // deprecated
-{
-  id: '900p',
-  title: '900p',
-  ...presetsBase.desktop,
-  screenWidth: 900,
-  screenHeight: 1440,
-}, // deprecated
-{
-  id: '1080p',
-  title: '1080p',
-  ...presetsBase.desktop,
-  screenWidth: 1080,
-  screenHeight: 1920,
-}, // deprecated
-{
-  id: '1440p',
-  title: '1440p',
-  ...presetsBase.desktop,
-  screenWidth: 1440,
-  screenHeight: 2560,
-}, // deprecated
-{
-  id: '4k',
-  title: '4K',
-  ...presetsBase.desktop,
-  screenWidth: 2160,
-  screenHeight: 3840,
-},];
+  {
+    id: 'tv-4k',
+    title: `4K`,
+    screenRadius: 0,
+    screenWidth: 3840,
+    screenHeight: 2160,
+    externalClay: { width: 3908, height: 2308, screenOffsetLeft: 34, screenOffsetTop: 24, },
+    realisticImage: { width: 7960 / 2, height: 4600 / 2, screenOffsetLeft: 140 / 2, screenOffsetTop: 140 / 2, },
+  }, // Old devices ------------------------------------------------------------------------------------------------------------------------
+  // deprecated
+  { id: '720p', title: '720p', ...presetsBase.desktop, screenWidth: 720, screenHeight: 1280, }, // deprecated
+  { id: '900p', title: '900p', ...presetsBase.desktop, screenWidth: 900, screenHeight: 1440, }, // deprecated
+  { id: '1080p', title: '1080p', ...presetsBase.desktop, screenWidth: 1080, screenHeight: 1920, }, // deprecated
+  { id: '1440p', title: '1440p', ...presetsBase.desktop, screenWidth: 1440, screenHeight: 2560, }, // deprecated
+  { id: '4k', title: '4K', ...presetsBase.desktop, screenWidth: 2160, screenHeight: 3840, },
+];
 var deviceCodeComponentPresetIds = [
   'iphone-12',
   'iphone-12-mini',
@@ -19264,13 +14796,9 @@ var defaultDeviceProps = {
   shadow: true,
   backgroundColor: void 0,
 };
-function convertPropsToDeviceOptions(props, {
-  forceOldClay = false,
-} = {},) {
+function convertPropsToDeviceOptions(props, { forceOldClay = false, } = {},) {
   var _a;
-  if (props.preset === 'no-device') {
-    return;
-  }
+  if (props.preset === 'no-device') return;
   let preset;
   if (props.preset === 'custom') {
     preset = {
@@ -19283,9 +14811,7 @@ function convertPropsToDeviceOptions(props, {
       clayBezelLeft: props.isMixedBezel ? props.bezelLeft : props.customBezel,
       clayBezelRadius: props.customBezelRadius,
     };
-  } else {
-    preset = getDevicePreset(props.preset,);
-  }
+  } else preset = getDevicePreset(props.preset,);
   const colors = getColorsFromTheme(props.theme,);
   const shadowColor = colors.shadowColor;
   const shadow = props.shadow ? `0 10px 30px ${shadowColor}` : void 0;
@@ -19328,14 +14854,12 @@ function convertPropsToDeviceOptions(props, {
         imageHeight: preset.externalClay.height,
         rotateImage: rotate,
       };
-    } else {
-      appearance = {
+    } else {appearance = {
         type: 'clay',
         bezelRadius: preset.clayBezelRadius !== void 0 ? `${preset.clayBezelRadius}px` : void 0,
         bezelColor: colors.bezelColor,
         bezelShadeColor: colors.bezelShadeColor,
-      };
-    }
+      };}
   }
   let screenWidth = preset.screenWidth;
   let screenHeight = preset.screenHeight;
@@ -19357,8 +14881,7 @@ function convertPropsToDeviceOptions(props, {
     screenRadius: preset.screenRadius !== void 0 ? `${preset.screenRadius}px` : void 0,
     screenMaskImage: appearance.type !== 'realistic' && preset.screenMask
       ? makeScreenMaskImage({
-        mask: preset.screenMask,
-        // width/height of the mask = screen width/height pre-rotation
+        mask: preset.screenMask, // width/height of the mask = screen width/height pre-rotation
         width: preset.screenWidth,
         height: preset.screenHeight,
         rotate,
@@ -19379,15 +14902,9 @@ function convertPropsToDeviceOptions(props, {
     colorId,
   };
 }
-function makeScreenMaskImage({
-  mask,
-  width,
-  height,
-  rotate = false,
-},) {
-  const transform2 = rotate
-    ? // Rotate 90 degrees counter-clockwise around (0,0), then move the
-    // result down into the viewport (rightmost transform is applied first).
+function makeScreenMaskImage({ mask, width, height, rotate = false, },) {
+  const transform2 = rotate // Rotate 90 degrees counter-clockwise around (0,0), then move the
+    ? // result down into the viewport (rightmost transform is applied first).
     `transform="translate(0 ${width}) rotate(-90)"`
     : '';
   const encoded = encodeURIComponent(
@@ -19401,18 +14918,10 @@ function colorIdForTheme(theme, availableColors,) {
   var _a;
   if (!availableColors) return;
   const colors = theme === 'light' ? lightColors : darkColors;
-  for (const color2 of availableColors) {
-    if (colors.has(color2.id,)) {
-      return color2.id;
-    }
-  }
+  for (const color2 of availableColors) if (colors.has(color2.id,)) return color2.id;
   return (_a = availableColors[0]) == null ? void 0 : _a.id;
 }
-function supportsHand({
-  preset: presetId,
-  skin,
-  orientation = 'portrait',
-},) {
+function supportsHand({ preset: presetId, skin, orientation = 'portrait', },) {
   var _a;
   if (!presetId || presetId === 'custom' || presetId === 'no-device' || orientation === 'landscape') return false;
   const preset = getDevicePreset(presetId,);
@@ -19426,34 +14935,19 @@ function applyMetaTag(name, props,) {
     (_a = document.getElementsByTagName('head',)[0]) == null ? void 0 : _a.appendChild(tag,);
     tag.setAttribute('name', name,);
   }
-  for (const [k, v,] of Object.entries(props,)) {
-    tag.setAttribute(k, v,);
-  }
+  for (const [k, v,] of Object.entries(props,)) tag.setAttribute(k, v,);
 }
 function usePrototypingMetaTags() {
   React__default.useEffect(() => {
-    applyMetaTag('mobile-web-app-capable', {
-      content: 'yes',
-    },);
-    applyMetaTag('apple-mobile-web-app-capable', {
-      content: 'yes',
-    },);
-    applyMetaTag('apple-mobile-web-app-status-bar-style', {
-      content: 'black-translucent',
-    },);
-    applyMetaTag('viewport', {
-      content: 'viewport-fit=cover, user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1',
-    },);
+    applyMetaTag('mobile-web-app-capable', { content: 'yes', },);
+    applyMetaTag('apple-mobile-web-app-capable', { content: 'yes', },);
+    applyMetaTag('apple-mobile-web-app-status-bar-style', { content: 'black-translucent', },);
+    applyMetaTag('viewport', { content: 'viewport-fit=cover, user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1', },);
   }, [],);
 }
-function DeviceCodeComponentInner({
-  children,
-  ...props
-},) {
+function DeviceCodeComponentInner({ children, ...props },) {
   usePrototypingMetaTags();
-  const deviceOptions = convertPropsToDeviceOptions(props, {
-    forceOldClay: true,
-  },);
+  const deviceOptions = convertPropsToDeviceOptions(props, { forceOldClay: true, },);
   React__default.useInsertionEffect(() => {
     injectComponentCSSRules();
   }, [],);
@@ -19461,67 +14955,31 @@ function DeviceCodeComponentInner({
     return /* @__PURE__ */ _jsx5('div', {
       'data-framer-component-type': 'DeviceComponent',
       className: 'no-device',
-      style: {
-        width: '100%',
-        height: '100%',
-      },
-      children: /* @__PURE__ */ _jsx5(ProvideParentSize, {
-        parentSize: 1,
-        children,
-      },),
+      style: { width: '100%', height: '100%', },
+      children: /* @__PURE__ */ _jsx5(ProvideParentSize, { parentSize: 1, children, },),
     },);
   }
   const child = Array.isArray(children,) ? children[0] : children;
   const resizedChild = child && React__default.isValidElement(child,)
-    ? React__default.cloneElement(child, {
-      width: deviceOptions.screenWidth,
-      height: deviceOptions.screenHeight,
-    },)
+    ? React__default.cloneElement(child, { width: deviceOptions.screenWidth, height: deviceOptions.screenHeight, },)
     : null;
-  return /* @__PURE__ */ _jsx5(Device, {
-    scaleTo: 'dynamic',
-    deviceOptions,
-    children: resizedChild,
-  },);
+  return /* @__PURE__ */ _jsx5(Device, { scaleTo: 'dynamic', deviceOptions, children: resizedChild, },);
 }
 var DeviceCodeComponent = /* @__PURE__ */ (() => {
-  const {
-    componentWidth: defaultWidth2,
-    componentHeight: defaultHeight2,
-  } = getComponentSize(convertPropsToDeviceOptions(defaultDeviceProps, {
-    forceOldClay: true,
-  },),);
-  DeviceCodeComponentInner.defaultProps = {
-    width: defaultWidth2,
-    height: defaultHeight2,
-    ...defaultDeviceProps,
-  };
+  const { componentWidth: defaultWidth2, componentHeight: defaultHeight2, } = getComponentSize(
+    convertPropsToDeviceOptions(defaultDeviceProps, { forceOldClay: true, },),
+  );
+  DeviceCodeComponentInner.defaultProps = { width: defaultWidth2, height: defaultHeight2, ...defaultDeviceProps, };
   const deviceCodeComponentPresets = devicePresets.filter((preset) => deviceCodeComponentPresetIds.includes(preset.id,));
   addPropertyControls(DeviceCodeComponentInner, {
-    children: {
-      title: 'Content',
-      type: 'componentinstance',
-      /* ComponentInstance */
-    },
+    children: { title: 'Content', type: 'componentinstance', /* ComponentInstance */ },
     preset: {
       type: 'enum',
       options: ['no-device', 'custom',].concat(deviceCodeComponentPresets.map((preset) => preset.id),),
       optionTitles: ['No Device', 'Custom',].concat(deviceCodeComponentPresets.map((preset) => preset.title),),
     },
-    customWidth: {
-      title: 'Width',
-      type: 'number',
-      min: 0,
-      displayStepper: true,
-      hidden: (props) => props.preset !== 'custom',
-    },
-    customHeight: {
-      title: 'Height',
-      type: 'number',
-      min: 0,
-      displayStepper: true,
-      hidden: (props) => props.preset !== 'custom',
-    },
+    customWidth: { title: 'Width', type: 'number', min: 0, displayStepper: true, hidden: (props) => props.preset !== 'custom', },
+    customHeight: { title: 'Height', type: 'number', min: 0, displayStepper: true, hidden: (props) => props.preset !== 'custom', },
     customBezel: {
       title: 'Bezel',
       type: 'fusednumber',
@@ -19574,10 +15032,7 @@ var DeviceCodeComponent = /* @__PURE__ */ (() => {
       type: 'boolean',
       enabledTitle: 'On',
       disabledTitle: 'Off',
-      hidden: ({
-        skin,
-        preset,
-      },) => preset !== 'custom' && skin === 'realistic' || preset === 'no-device',
+      hidden: ({ skin, preset, },) => preset !== 'custom' && skin === 'realistic' || preset === 'no-device',
     },
     hand: {
       type: 'enum',
@@ -19585,14 +15040,7 @@ var DeviceCodeComponent = /* @__PURE__ */ (() => {
       optionTitles: ['None', 'Model 1', 'Model 2',],
       hidden: (props) => !supportsHand(props,),
     },
-    backgroundColor: {
-      type: 'color',
-      title: 'Background',
-      optional: true,
-      hidden: ({
-        preset,
-      },) => preset === 'no-device',
-    },
+    backgroundColor: { type: 'color', title: 'Background', optional: true, hidden: ({ preset, },) => preset === 'no-device', },
   },);
   return DeviceCodeComponentInner;
 })();
@@ -19612,12 +15060,8 @@ function supportsThemes(presetId, skin,) {
   if (presetId === 'custom' || skin !== 'realistic') return true;
   const preset = getDevicePreset(presetId,);
   const realisticImage = preset.realisticImage;
-  if (realisticImage === void 0) {
-    return true;
-  }
-  if (colorIdForTheme('dark', realisticImage.availableColors,) !== void 0) {
-    return true;
-  }
+  if (realisticImage === void 0) return true;
+  if (colorIdForTheme('dark', realisticImage.availableColors,) !== void 0) return true;
   return false;
 }
 var asRecord = (object) => object;
@@ -19631,8 +15075,7 @@ function memoize(fn,) {
 var reactPropsRegex =
   /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/;
 var isPropValid = /* @__PURE__ */ memoize((prop) =>
-  reactPropsRegex.test(prop,) || prop.charCodeAt(0,) === 111 && prop.charCodeAt(1,) === 110 && prop.charCodeAt(2,) < 91
-  /* Z+1 */
+  reactPropsRegex.test(prop,) || prop.charCodeAt(0,) === 111 && prop.charCodeAt(1,) === 110 && prop.charCodeAt(2,) < 91 /* Z+1 */
 );
 var LibraryFeaturesContext = /* @__PURE__ */ React__default.createContext(void 0,);
 var LibraryFeaturesProvider = LibraryFeaturesContext.Provider;
@@ -19651,18 +15094,14 @@ var webkitVersion = () => {
   let version2 = -1;
   const regexp = /AppleWebKit\/([\d.]+)/;
   const result = safeNavigator && regexp.exec(safeNavigator.userAgent,);
-  if (result && result[1]) {
-    version2 = parseFloat(result[1],);
-  }
+  if (result && result[1]) version2 = parseFloat(result[1],);
   return version2;
 };
 var safariVersion = () => {
   let version2 = -1;
   const regexp = /Version\/([\d.]+)/;
   const result = safeNavigator && regexp.exec(safeNavigator.userAgent,);
-  if (result && result[1]) {
-    version2 = parseFloat(result[1],);
-  }
+  if (result && result[1]) version2 = parseFloat(result[1],);
   return version2;
 };
 var isChrome = () => safeNavigator && /Chrome/.test(safeNavigator.userAgent,) && /Google Inc/.test(safeNavigator.vendor,) && !isEdge();
@@ -19714,9 +15153,7 @@ var deviceOS = () => {
   if (isWindows()) return 'windows';
 };
 var deviceFont = (os) => {
-  if (!os) {
-    os = deviceOS();
-  }
+  if (!os) os = deviceOS();
   const fonts = {
     apple: '-apple-system, BlinkMacSystemFont, SF Pro Text, SF UI Text, Helvetica Neue',
     google: 'Roboto, Helvetica Neue',
@@ -19767,8 +15204,7 @@ var mockWithWarning = (message) => {
 var mockWithoutWarning = () => {
   return () => {};
 };
-var implementation = {
-  // We need a default implementation for useImageSource and useImageElement as it is used for rendering image backgrounds which would break otherwise.
+var implementation = { // We need a default implementation for useImageSource and useImageElement as it is used for rendering image backgrounds which would break otherwise.
   // The default value is used for HTML export and when using the library without Framer.
   useImageSource(image,) {
     return image.src ?? '';
@@ -19786,15 +15222,9 @@ var implementation = {
 var isRuntimeInjected = false;
 var runtimeProxy = {
   get(target, key7, reciever,) {
-    if (Reflect.has(target, key7,)) {
-      return Reflect.get(target, key7, reciever,);
-    }
-    if (['getLogger',].includes(String(key7,),)) {
-      return mockWithoutWarning();
-    }
-    if (isRuntimeInjected) {
-      return mockWithWarning(`${String(key7,)} is not available in this version of Framer.`,);
-    }
+    if (Reflect.has(target, key7,)) return Reflect.get(target, key7, reciever,);
+    if (['getLogger',].includes(String(key7,),)) return mockWithoutWarning();
+    if (isRuntimeInjected) return mockWithWarning(`${String(key7,)} is not available in this version of Framer.`,);
     return mockWithWarning(`${String(key7,)} is only available inside of Framer. https://www.framer.com/`,);
   },
 };
@@ -19804,45 +15234,28 @@ function _injectRuntime(injectedRuntime,) {
   isRuntimeInjected = true;
 }
 function minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3 = 1,) {
-  let {
-    width: frameWidth,
-    height: frameHeight,
-  } = containerSize;
+  let { width: frameWidth, height: frameHeight, } = containerSize;
   const imageWidth = image.pixelWidth ?? image.intrinsicWidth ?? 0;
   const imageHeight = image.pixelHeight ?? image.intrinsicHeight ?? 0;
-  if (frameWidth < 1 || frameHeight < 1 || imageWidth < 1 || imageHeight < 1) {
-    return void 0;
-  }
+  if (frameWidth < 1 || frameHeight < 1 || imageWidth < 1 || imageHeight < 1) return void 0;
   frameWidth *= devicePixelRatio3;
   frameHeight *= devicePixelRatio3;
   const frameAspectRatio = frameWidth / frameHeight;
   const imageAspectRatio = imageWidth / imageHeight;
   switch (image.fit) {
     case 'fill':
-      if (imageAspectRatio > frameAspectRatio) {
-        return imageHeight / frameHeight;
-      } else {
-        return imageWidth / frameWidth;
-      }
+      if (imageAspectRatio > frameAspectRatio) return imageHeight / frameHeight;
+      else return imageWidth / frameWidth;
     case 'fit':
     case 'stretch':
       return Math.max(imageWidth / frameWidth, imageHeight / frameHeight,);
   }
 }
 function imageRenderingForZoom(zoom, minPixelatedZoom,) {
-  if (minPixelatedZoom && Math.max(1, zoom,) > minPixelatedZoom) {
-    return 'pixelated';
-  }
+  if (minPixelatedZoom && Math.max(1, zoom,) > minPixelatedZoom) return 'pixelated';
   return 'auto';
 }
-var wrapperStyle = {
-  position: 'absolute',
-  borderRadius: 'inherit',
-  top: 0,
-  right: 0,
-  bottom: 0,
-  left: 0,
-};
+var wrapperStyle = { position: 'absolute', borderRadius: 'inherit', top: 0, right: 0, bottom: 0, left: 0, };
 var placeholderStyle = {
   backgroundSize: '16px 16px',
   backgroundImage:
@@ -19869,11 +15282,8 @@ function cssImageRendering(image, containerSize,) {
   if (!containerSize) return 'auto';
   const devicePixelRatio3 = RenderTarget.current() === 'CANVAS' ? safeWindow.devicePixelRatio : 1;
   const minPixelatedZoom = minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3,);
-  if (RenderTarget.current() === 'CANVAS') {
-    return imageRenderingForZoom(1, minPixelatedZoom,);
-  } else {
-    return imageRenderingForZoom(RenderEnvironment.zoom, minPixelatedZoom,);
-  }
+  if (RenderTarget.current() === 'CANVAS') return imageRenderingForZoom(1, minPixelatedZoom,);
+  else return imageRenderingForZoom(RenderEnvironment.zoom, minPixelatedZoom,);
 }
 function getImageStyle(image, containerSize,) {
   return {
@@ -19886,12 +15296,7 @@ function getImageStyle(image, containerSize,) {
     imageRendering: cssImageRendering(image, containerSize,),
   };
 }
-function StaticImage({
-  image,
-  containerSize,
-  nodeId,
-  alt,
-},) {
+function StaticImage({ image, containerSize, nodeId, alt, },) {
   const source = runtime.useImageSource(image, containerSize, nodeId,);
   const imageStyle = getImageStyle(image, containerSize,);
   const [measuredSizes, setMeasuredSizes,] = React__default.useState();
@@ -19909,13 +15314,10 @@ function StaticImage({
     const currentSizes = Number(image.sizes.replace('px', '',),);
     if (
       // If we successfully parsed `sizes`, and...
-      !isNaN(currentSizes,) &&
-      // ...if the image node is smaller than the currently set `sizes`
+      !isNaN(currentSizes,) && // ...if the image node is smaller than the currently set `sizes`
       // attribute,..
       imageNodeWidth < currentSizes
-    ) {
-      return;
-    }
+    ) return;
     setMeasuredSizes(imageNodeWidth + 'px',);
   }, [image.sizes,],);
   return /* @__PURE__ */ _jsx5('img', {
@@ -19929,11 +15331,7 @@ function StaticImage({
     style: imageStyle,
   },);
 }
-function CanvasImage({
-  image,
-  containerSize,
-  nodeId,
-},) {
+function CanvasImage({ image, containerSize, nodeId, },) {
   const wrapperRef = React__default.useRef(null,);
   const imageElement = runtime.useImageElement(image, containerSize, nodeId,);
   const imageStyle = getImageStyle(image, containerSize,);
@@ -19946,19 +15344,9 @@ function CanvasImage({
     };
   }, [imageElement,],);
   Object.assign(imageElement.style, imageStyle,);
-  return /* @__PURE__ */ _jsx5('div', {
-    ref: wrapperRef,
-    style: {
-      display: 'contents',
-      borderRadius: 'inherit',
-    },
-  },);
+  return /* @__PURE__ */ _jsx5('div', { ref: wrapperRef, style: { display: 'contents', borderRadius: 'inherit', }, },);
 }
-function OptimizedCanvasImage({
-  nodeId,
-  image,
-  containerSize,
-},) {
+function OptimizedCanvasImage({ nodeId, image, containerSize, },) {
   const wrapperRef = React__default.useRef(null,);
   const source = runtime.useImageSource(image, containerSize, nodeId,);
   React__default.useLayoutEffect(() => {
@@ -19967,59 +15355,27 @@ function OptimizedCanvasImage({
     const imageStyle = getImageStyle(image, containerSize,);
     runtime.renderOptimizedCanvasImage(wrapper, source, imageStyle, nodeId,);
   }, [nodeId, image, source, containerSize,],);
-  return /* @__PURE__ */ _jsx5('div', {
-    ref: wrapperRef,
-    style: {
-      display: 'contents',
-      borderRadius: 'inherit',
-    },
-  },);
+  return /* @__PURE__ */ _jsx5('div', { ref: wrapperRef, style: { display: 'contents', borderRadius: 'inherit', }, },);
 }
-function BackgroundImageComponent({
-  layoutId,
-  image,
-  ...props
-},) {
-  if (layoutId) {
-    layoutId = layoutId + '-background';
-  }
-  const fallbackWrapperStyles = {
-    ...wrapperStyle,
-    ...placeholderStyle,
-  };
+function BackgroundImageComponent({ layoutId, image, ...props },) {
+  if (layoutId) layoutId = layoutId + '-background';
+  const fallbackWrapperStyles = { ...wrapperStyle, ...placeholderStyle, };
   let imageNode = null;
   if (isString22(image.src,)) {
     if (image.fit === 'tile' && image.pixelWidth && image.pixelHeight) {
       const backgroundSize = isNumber2(image.backgroundSize,) ? image.backgroundSize : 1;
-      const tileSize = {
-        width: Math.round(backgroundSize * image.pixelWidth,),
-        height: Math.round(backgroundSize * image.pixelHeight,),
-      };
+      const tileSize = { width: Math.round(backgroundSize * image.pixelWidth,), height: Math.round(backgroundSize * image.pixelHeight,), };
       const imageSource = runtime.useImageSource(image, tileSize,);
       fallbackWrapperStyles.backgroundImage = `url(${imageSource})`;
       fallbackWrapperStyles.backgroundRepeat = 'repeat';
       fallbackWrapperStyles.backgroundPosition = cssObjectPosition(image.positionX, image.positionY,);
-      if (image.pixelWidth) {
-        fallbackWrapperStyles.backgroundSize = `${(backgroundSize * (image.pixelWidth / 2)).toFixed(2,)}px auto`;
-      }
+      if (image.pixelWidth) fallbackWrapperStyles.backgroundSize = `${(backgroundSize * (image.pixelWidth / 2)).toFixed(2,)}px auto`;
       fallbackWrapperStyles.border = 0;
       imageNode = null;
-    } else if (RenderTarget.current() !== 'CANVAS') {
-      imageNode = /* @__PURE__ */ _jsx5(StaticImage, {
-        image,
-        ...props,
-      },);
-    } else if (runtime.canRenderOptimizedCanvasImage(runtime.useImageSource(image,),)) {
-      imageNode = /* @__PURE__ */ _jsx5(OptimizedCanvasImage, {
-        image,
-        ...props,
-      },);
-    } else {
-      imageNode = /* @__PURE__ */ _jsx5(CanvasImage, {
-        image,
-        ...props,
-      },);
-    }
+    } else if (RenderTarget.current() !== 'CANVAS') imageNode = /* @__PURE__ */ _jsx5(StaticImage, { image, ...props, },);
+    else if (runtime.canRenderOptimizedCanvasImage(runtime.useImageSource(image,),)) {
+      imageNode = /* @__PURE__ */ _jsx5(OptimizedCanvasImage, { image, ...props, },);
+    } else imageNode = /* @__PURE__ */ _jsx5(CanvasImage, { image, ...props, },);
   }
   return /* @__PURE__ */ _jsx5(motion.div, {
     layoutId,
@@ -20037,52 +15393,24 @@ var BackgroundImage;
   };
 })(BackgroundImage || (BackgroundImage = {}),);
 function applyForwardOverrides(background, props,) {
-  const {
-    _forwardedOverrideId,
-    _forwardedOverrides,
-    id: id3,
-  } = props;
+  const { _forwardedOverrideId, _forwardedOverrides, id: id3, } = props;
   const forwardedOverrideId = _forwardedOverrideId ?? id3;
   const src = _forwardedOverrides && forwardedOverrideId ? _forwardedOverrides[forwardedOverrideId] : void 0;
-  if (src && typeof src === 'string') {
-    background = {
-      ...background,
-      src,
-    };
-  }
+  if (src && typeof src === 'string') background = { ...background, src, };
   return background;
 }
 function backgroundImageFromProps(props,) {
-  const {
-    background,
-    image,
-  } = props;
-  if (image !== void 0 && background && !BackgroundImage.isImageObject(background,)) {
-    return;
-  }
+  const { background, image, } = props;
+  if (image !== void 0 && background && !BackgroundImage.isImageObject(background,)) return;
   let backgroundImage = null;
-  if (isString22(image,)) {
-    backgroundImage = {
-      alt: '',
-      src: image,
-    };
-  } else {
-    backgroundImage = Animatable.get(background, null,);
-  }
-  if (!BackgroundImage.isImageObject(backgroundImage,)) {
-    return;
-  }
+  if (isString22(image,)) backgroundImage = { alt: '', src: image, };
+  else backgroundImage = Animatable.get(background, null,);
+  if (!BackgroundImage.isImageObject(backgroundImage,)) return;
   return applyForwardOverrides(backgroundImage, props,);
 }
 function collectBorderStyleForProps(props, style, collapseEqualBorders = true,) {
-  const {
-    borderWidth,
-    borderStyle,
-    borderColor,
-  } = props;
-  if (!borderWidth) {
-    return;
-  }
+  const { borderWidth, borderStyle, borderColor, } = props;
+  if (!borderWidth) return;
   let borderTop;
   let borderBottom;
   let borderLeft;
@@ -20099,9 +15427,7 @@ function collectBorderStyleForProps(props, style, collapseEqualBorders = true,)
     borderLeft = borderWidth.left || 0;
     borderRight = borderWidth.right || 0;
   }
-  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) {
-    return;
-  }
+  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) return;
   if (collapseEqualBorders && borderTop === borderBottom && borderTop === borderLeft && borderTop === borderRight) {
     style.border = `${borderTop}px ${borderStyle} ${borderColor}`;
     return;
@@ -20115,30 +15441,14 @@ function collectBorderStyleForProps(props, style, collapseEqualBorders = true,)
 }
 function Border(props,) {
   const layoutId = props.layoutId ? `${props.layoutId}-border` : void 0;
-  if (!props.borderWidth) {
-    return null;
-  }
-  const style = {
-    position: 'absolute',
-    left: 0,
-    right: 0,
-    top: 0,
-    bottom: 0,
-    borderRadius: 'inherit',
-    pointerEvents: 'none',
-  };
+  if (!props.borderWidth) return null;
+  const style = { position: 'absolute', left: 0, right: 0, top: 0, bottom: 0, borderRadius: 'inherit', pointerEvents: 'none', };
   if (props.border) {
     style.border = props.border;
-    return /* @__PURE__ */ _jsx5(motion.div, {
-      style,
-    },);
+    return /* @__PURE__ */ _jsx5(motion.div, { style, },);
   }
   collectBorderStyleForProps(props, style, false,);
-  return /* @__PURE__ */ _jsx5(motion.div, {
-    'data-frame-border': true,
-    style,
-    layoutId,
-  },);
+  return /* @__PURE__ */ _jsx5(motion.div, { 'data-frame-border': true, style, layoutId, },);
 }
 function htmlElementAsMotionComponent(asElem,) {
   return asElem && asElem !== 'search' && asElem !== 'slot' && asElem !== 'template' ? motion[asElem] : motion['div'];
@@ -20146,15 +15456,9 @@ function htmlElementAsMotionComponent(asElem,) {
 var isChrome2 = isChrome();
 function layoutHintDataPropsForCenter(center,) {
   const props = {};
-  if (!isChrome2 || RenderTarget.current() !== 'CANVAS') {
-    return props;
-  }
-  if (center === true || center === 'x') {
-    props['data-framer-layout-hint-center-x'] = true;
-  }
-  if (center === true || center === 'y') {
-    props['data-framer-layout-hint-center-y'] = true;
-  }
+  if (!isChrome2 || RenderTarget.current() !== 'CANVAS') return props;
+  if (center === true || center === 'x') props['data-framer-layout-hint-center-x'] = true;
+  if (center === true || center === 'y') props['data-framer-layout-hint-center-y'] = true;
   return props;
 }
 function nodeIdFromString(str,) {
@@ -20169,12 +15473,7 @@ function countNodeRender() {
 function processOverrideForwarding(props, children,) {
   if (!children) {
     children = props.children;
-    if (!children) {
-      return {
-        props,
-        children,
-      };
-    }
+    if (!children) return { props, children, };
   }
   let _forwardedOverrides = props._forwardedOverrides;
   const extractions = props._overrideForwardingDescription;
@@ -20186,72 +15485,36 @@ function processOverrideForwarding(props, children,) {
       if (value !== void 0) {
         if (!_forwardedOverrides) {
           _forwardedOverrides = {};
-          props = {
-            ...props,
-          };
+          props = { ...props, };
         }
         _forwardedOverrides[key7] = props[propName];
         delete props[propName];
       }
     }
   }
-  if (!_forwardedOverrides) {
-    return {
-      props,
-      children,
-    };
-  }
+  if (!_forwardedOverrides) return { props, children, };
   children = React__default.Children.map(children, (child) => {
     if (!React__default.isValidElement(child,)) return child;
-    return React__default.cloneElement(child, {
-      _forwardedOverrides,
-    },);
+    return React__default.cloneElement(child, { _forwardedOverrides, },);
   },);
-  return {
-    props,
-    children,
-  };
+  return { props, children, };
 }
 function transformTemplate(center,) {
   return (_, generated,) => {
-    if (center === true) {
-      return `translate(-50%, -50%) ${generated}`;
-    } else {
-      if (center === 'x') {
-        return `translateX(-50%) ${generated}`;
-      } else if (center === 'y') {
-        return `translateY(-50%) ${generated}`;
-      }
-    }
+    if (center === true) return `translate(-50%, -50%) ${generated}`;
+    else {if (center === 'x') return `translateX(-50%) ${generated}`;
+      else if (center === 'y') return `translateY(-50%) ${generated}`;}
     return generated || 'none';
   };
 }
-function useLayoutId2(props, {
-  specificLayoutId,
-  postfix,
-} = {},) {
-  const {
-    name,
-    layoutIdKey,
-    duplicatedFrom,
-    __fromCodeComponentNode = false,
-    drag: drag2,
-  } = props;
-  const {
-    getLayoutId,
-    enabled,
-  } = useContext3(LayoutIdContext,);
+function useLayoutId2(props, { specificLayoutId, postfix, } = {},) {
+  const { name, layoutIdKey, duplicatedFrom, __fromCodeComponentNode = false, drag: drag2, } = props;
+  const { getLayoutId, enabled, } = useContext3(LayoutIdContext,);
   return useMemo(() => {
     if (!enabled) return props.layoutId;
     const existingLayoutId = specificLayoutId || props.layoutId;
-    if (!existingLayoutId) {
-      if (drag2 || !layoutIdKey || __fromCodeComponentNode) return void 0;
-    }
-    const layoutIdCandidate = existingLayoutId || getLayoutId({
-      id: layoutIdKey,
-      name,
-      duplicatedFrom,
-    },);
+    if (!existingLayoutId) if (drag2 || !layoutIdKey || __fromCodeComponentNode) return void 0;
+    const layoutIdCandidate = existingLayoutId || getLayoutId({ id: layoutIdKey, name, duplicatedFrom, },);
     if (!layoutIdCandidate) return void 0;
     return postfix ? `${layoutIdCandidate}-${postfix}` : layoutIdCandidate;
   }, [enabled,],);
@@ -20272,11 +15535,8 @@ var hasSkippedObservations = function () {
 var msg = 'ResizeObserver loop completed with undelivered notifications.';
 var deliverResizeLoopError = function () {
   var event;
-  if (typeof ErrorEvent === 'function') {
-    event = new ErrorEvent('error', {
-      message: msg,
-    },);
-  } else {
+  if (typeof ErrorEvent === 'function') event = new ErrorEvent('error', { message: msg, },);
+  else {
     event = document.createEvent('Event',);
     event.initEvent('error', false, false,);
     event.message = msg;
@@ -20322,16 +15582,7 @@ var DOMRectReadOnly = function () {
       left = _a.left,
       width = _a.width,
       height = _a.height;
-    return {
-      x,
-      y,
-      top,
-      right,
-      bottom,
-      left,
-      width,
-      height,
-    };
+    return { x, y, top, right, bottom, left, width, height, };
   };
   DOMRectReadOnly2.fromRect = function (rectangle,) {
     return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height,);
@@ -20343,30 +15594,22 @@ var isSVG = function (target,) {
 };
 var isHidden = function (target,) {
   if (isSVG(target,)) {
-    var _a = target.getBBox(),
-      width = _a.width,
-      height = _a.height;
+    var _a = target.getBBox(), width = _a.width, height = _a.height;
     return !width && !height;
   }
-  var _b = target,
-    offsetWidth = _b.offsetWidth,
-    offsetHeight = _b.offsetHeight;
+  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
   return !(offsetWidth || offsetHeight || target.getClientRects().length);
 };
 var isElement = function (obj,) {
   var _a, _b;
-  if (obj instanceof Element) {
-    return true;
-  }
+  if (obj instanceof Element) return true;
   var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
   return !!(scope && obj instanceof scope.Element);
 };
 var isReplacedElement = function (target,) {
   switch (target.tagName) {
     case 'INPUT':
-      if (target.type !== 'image') {
-        break;
-      }
+      if (target.type !== 'image') break;
     case 'VIDEO':
     case 'AUDIO':
     case 'EMBED':
@@ -20387,15 +15630,9 @@ var parseDimension = function (pixel,) {
   return parseFloat(pixel || '0',);
 };
 var size = function (inlineSize, blockSize, switchSizes,) {
-  if (inlineSize === void 0) {
-    inlineSize = 0;
-  }
-  if (blockSize === void 0) {
-    blockSize = 0;
-  }
-  if (switchSizes === void 0) {
-    switchSizes = false;
-  }
+  if (inlineSize === void 0) inlineSize = 0;
+  if (blockSize === void 0) blockSize = 0;
+  if (switchSizes === void 0) switchSizes = false;
   return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0,);
 };
 var zeroBoxes = freeze({
@@ -20405,12 +15642,8 @@ var zeroBoxes = freeze({
   contentRect: new DOMRectReadOnly(0, 0, 0, 0,),
 },);
 var calculateBoxSizes = function (target, forceRecalculation,) {
-  if (forceRecalculation === void 0) {
-    forceRecalculation = false;
-  }
-  if (cache2.has(target,) && !forceRecalculation) {
-    return cache2.get(target,);
-  }
+  if (forceRecalculation === void 0) forceRecalculation = false;
+  if (cache2.has(target,) && !forceRecalculation) return cache2.get(target,);
   if (isHidden(target,)) {
     cache2.set(target, zeroBoxes,);
     return zeroBoxes;
@@ -20480,9 +15713,7 @@ var ResizeObserverEntry = /* @__PURE__ */ function () {
   return ResizeObserverEntry2;
 }();
 var calculateDepthForNode = function (node,) {
-  if (isHidden(node,)) {
-    return Infinity;
-  }
+  if (isHidden(node,)) return Infinity;
   var depth = 0;
   var parent = node.parentNode;
   while (parent) {
@@ -20495,18 +15726,14 @@ var broadcastActiveObservations = function () {
   var shallowestDepth = Infinity;
   var callbacks2 = [];
   resizeObservers.forEach(function processObserver(ro,) {
-    if (ro.activeTargets.length === 0) {
-      return;
-    }
+    if (ro.activeTargets.length === 0) return;
     var entries = [];
     ro.activeTargets.forEach(function processTarget(ot,) {
       var entry = new ResizeObserverEntry(ot.target,);
       var targetDepth = calculateDepthForNode(ot.target,);
       entries.push(entry,);
       ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox,);
-      if (targetDepth < shallowestDepth) {
-        shallowestDepth = targetDepth;
-      }
+      if (targetDepth < shallowestDepth) shallowestDepth = targetDepth;
     },);
     callbacks2.push(function resizeObserverCallback() {
       ro.callback.call(ro.observer, entries, ro.observer,);
@@ -20525,11 +15752,8 @@ var gatherActiveObservationsAtDepth = function (depth,) {
     ro.skippedTargets.splice(0, ro.skippedTargets.length,);
     ro.observationTargets.forEach(function processTarget(ot,) {
       if (ot.isActive()) {
-        if (calculateDepthForNode(ot.target,) > depth) {
-          ro.activeTargets.push(ot,);
-        } else {
-          ro.skippedTargets.push(ot,);
-        }
+        if (calculateDepthForNode(ot.target,) > depth) ro.activeTargets.push(ot,);
+        else ro.skippedTargets.push(ot,);
       }
     },);
   },);
@@ -20541,9 +15765,7 @@ var process3 = function () {
     depth = broadcastActiveObservations();
     gatherActiveObservationsAtDepth(depth,);
   }
-  if (hasSkippedObservations()) {
-    deliverResizeLoopError();
-  }
+  if (hasSkippedObservations()) deliverResizeLoopError();
   return depth > 0;
 };
 var trigger;
@@ -20557,9 +15779,7 @@ var queueMicroTask = function (callback,) {
   if (!trigger) {
     var toggle_1 = 0;
     var el_1 = document.createTextNode('',);
-    var config = {
-      characterData: true,
-    };
+    var config = { characterData: true, };
     new MutationObserver(function () {
       return notify2();
     },).observe(el_1, config,);
@@ -20580,12 +15800,7 @@ var isWatching = function () {
   return !!watching;
 };
 var CATCH_PERIOD = 250;
-var observerConfig = {
-  attributes: true,
-  characterData: true,
-  childList: true,
-  subtree: true,
-};
+var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true, };
 var events = [
   'resize',
   'load',
@@ -20603,9 +15818,7 @@ var events = [
   'focus',
 ];
 var time2 = function (timeout,) {
-  if (timeout === void 0) {
-    timeout = 0;
-  }
+  if (timeout === void 0) timeout = 0;
   return Date.now() + timeout;
 };
 var scheduled = false;
@@ -20619,12 +15832,8 @@ var Scheduler = function () {
   }
   Scheduler2.prototype.run = function (timeout,) {
     var _this = this;
-    if (timeout === void 0) {
-      timeout = CATCH_PERIOD;
-    }
-    if (scheduled) {
-      return;
-    }
+    if (timeout === void 0) timeout = CATCH_PERIOD;
+    if (scheduled) return;
     scheduled = true;
     var until = time2(timeout,);
     queueResizeObserver(function () {
@@ -20634,16 +15843,10 @@ var Scheduler = function () {
       } finally {
         scheduled = false;
         timeout = until - time2();
-        if (!isWatching()) {
-          return;
-        }
-        if (elementsHaveResized) {
-          _this.run(1e3,);
-        } else if (timeout > 0) {
-          _this.run(timeout,);
-        } else {
-          _this.start();
-        }
+        if (!isWatching()) return;
+        if (elementsHaveResized) _this.run(1e3,);
+        else if (timeout > 0) _this.run(timeout,);
+        else _this.start();
       }
     },);
   };
@@ -20694,19 +15897,12 @@ var ResizeObservation = function () {
   function ResizeObservation2(target, observedBox,) {
     this.target = target;
     this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
-    this.lastReportedSize = {
-      inlineSize: 0,
-      blockSize: 0,
-    };
+    this.lastReportedSize = { inlineSize: 0, blockSize: 0, };
   }
   ResizeObservation2.prototype.isActive = function () {
     var size2 = calculateBoxSize(this.target, this.observedBox, true,);
-    if (skipNotifyOnElement(this.target,)) {
-      this.lastReportedSize = size2;
-    }
-    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
-      return true;
-    }
+    if (skipNotifyOnElement(this.target,)) this.lastReportedSize = size2;
+    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) return true;
     return false;
   };
   return ResizeObservation2;
@@ -20723,11 +15919,7 @@ var ResizeObserverDetail = /* @__PURE__ */ function () {
 }();
 var observerMap = /* @__PURE__ */ new WeakMap();
 var getObservationIndex = function (observationTargets, target,) {
-  for (var i = 0; i < observationTargets.length; i += 1) {
-    if (observationTargets[i].target === target) {
-      return i;
-    }
-  }
+  for (var i = 0; i < observationTargets.length; i += 1) if (observationTargets[i].target === target) return i;
   return -1;
 };
 var ResizeObserverController = function () {
@@ -20768,9 +15960,7 @@ var ResizeObserverController = function () {
 }();
 var ResizeObserver2 = function () {
   function ResizeObserver22(callback,) {
-    if (arguments.length === 0) {
-      throw new TypeError('Failed to construct \'ResizeObserver\': 1 argument required, but only 0 present.',);
-    }
+    if (arguments.length === 0) throw new TypeError('Failed to construct \'ResizeObserver\': 1 argument required, but only 0 present.',);
     if (typeof callback !== 'function') {
       throw new TypeError('Failed to construct \'ResizeObserver\': The callback provided as parameter 1 is not a function.',);
     }
@@ -20851,23 +16041,14 @@ function useMeasuredSize(ref,) {
   function updateSize(newSize,) {
     if (newSize.width === 0 && newSize.height === 0) return;
     if (!size2.current || newSize.height !== size2.current.height || newSize.width !== size2.current.width) {
-      size2.current = {
-        width: newSize.width,
-        height: newSize.height,
-      };
+      size2.current = { width: newSize.width, height: newSize.height, };
       forceUpdate();
     }
   }
   useIsomorphicLayoutEffect2(() => {
     if (!ref.current) return;
-    const {
-      offsetWidth,
-      offsetHeight,
-    } = ref.current;
-    updateSize({
-      width: offsetWidth,
-      height: offsetHeight,
-    },);
+    const { offsetWidth, offsetHeight, } = ref.current;
+    updateSize({ width: offsetWidth, height: offsetHeight, },);
     sharedResizeObserver.observeElementWithCallback(ref.current, updateSize,);
     return () => {
       if (!ref.current) return;
@@ -20880,25 +16061,20 @@ var SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = 'data-framer-size-compatibility-wrapp
 var withMeasuredSize = (Component14) => (props) => {
   const ref = React__default.useRef(null,);
   const size2 = useMeasuredSize(ref,);
-  const dataProps = {
-    [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true,
-  };
+  const dataProps = { [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true, };
   const shouldRender = Boolean(size2,);
   const fallbackWidth = props.width ?? DEFAULT_SIZE;
   const fallbackHeight = props.height ?? DEFAULT_SIZE;
   return /* @__PURE__ */ _jsx5('div', {
-    style: {
-      width: '100%',
-      height: '100%',
-      pointerEvents: 'none',
-    },
+    style: { width: '100%', height: '100%', pointerEvents: 'none', },
     ref,
     ...dataProps,
-    children: shouldRender && /* @__PURE__ */ _jsx5(Component14, {
-      ...props,
-      width: (size2 == null ? void 0 : size2.width) ?? fallbackWidth,
-      height: (size2 == null ? void 0 : size2.height) ?? fallbackHeight,
-    },),
+    children: shouldRender && /* @__PURE__ */
+      _jsx5(Component14, {
+        ...props,
+        width: (size2 == null ? void 0 : size2.width) ?? fallbackWidth,
+        height: (size2 == null ? void 0 : size2.height) ?? fallbackHeight,
+      },),
   },);
 };
 function getMeasurableCodeComponentChildren(element,) {
@@ -20912,9 +16088,7 @@ function isMeasurable(element,) {
     element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement ||
     element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement ||
     element instanceof HTMLTitleElement
-  ) {
-    return false;
-  }
+  ) return false;
   return element instanceof HTMLElement || element instanceof SVGElement;
 }
 function unwrapInlinedDisplayContents(element,) {
@@ -20922,29 +16096,17 @@ function unwrapInlinedDisplayContents(element,) {
   if (element.children.length === 0) return element;
   if (element.style.display !== 'contents') return element;
   const firstMeasurableChild = [...element.children,].find(isMeasurable,);
-  if (firstMeasurableChild) {
-    return unwrapInlinedDisplayContents(firstMeasurableChild,);
-  }
+  if (firstMeasurableChild) return unwrapInlinedDisplayContents(firstMeasurableChild,);
   return element;
 }
 function useMeasureLayout(props, ref, getChildren = () => [], options = {},) {
-  const {
-    id: id3,
-    visible,
-    _needsMeasure,
-  } = props;
-  const {
-    skipHook = false,
-  } = options;
+  const { id: id3, visible, _needsMeasure, } = props;
+  const { skipHook = false, } = options;
   const inCodeComponent = Boolean(useContext3(ComponentContainerContext,),);
   const onCanvas = RenderTarget.current() === 'CANVAS';
   useIsomorphicLayoutEffect2(() => {
-    if (!onCanvas || inCodeComponent || skipHook) {
-      return;
-    }
-    if (!(ref.current && id3 && visible && _needsMeasure)) {
-      return;
-    }
+    if (!onCanvas || inCodeComponent || skipHook) return;
+    if (!(ref.current && id3 && visible && _needsMeasure)) return;
     runtime.queueMeasureRequest(nodeIdFromString(id3,), ref.current, getChildren(ref.current,),);
   },);
 }
@@ -20968,38 +16130,28 @@ function valueEqual(a, b,) {
 function arrayShallowEqual(a, b,) {
   const length = a.length;
   if (length !== b.length) return false;
-  for (let i = length; i-- !== 0;) {
-    if (!valueEqual(a[i], b[i],)) return false;
-  }
+  for (let i = length; i-- !== 0;) if (!valueEqual(a[i], b[i],)) return false;
   return true;
 }
 function arrayDeepEqual(a, b,) {
   const length = a.length;
   if (length !== b.length) return false;
-  for (let i = length; i-- !== 0;) {
-    if (!equal(a[i], b[i], true,)) return false;
-  }
+  for (let i = length; i-- !== 0;) if (!equal(a[i], b[i], true,)) return false;
   return true;
 }
 function mapShallowEqual(a, b,) {
   if (a.size !== b.size) return false;
-  for (const [key7, aValue,] of a.entries()) {
-    if (!valueEqual(aValue, b.get(key7,),)) return false;
-  }
+  for (const [key7, aValue,] of a.entries()) if (!valueEqual(aValue, b.get(key7,),)) return false;
   return true;
 }
 function mapDeepEqual(a, b,) {
   if (a.size !== b.size) return false;
-  for (const [key7, aValue,] of a.entries()) {
-    if (!equal(aValue, b.get(key7,), true,)) return false;
-  }
+  for (const [key7, aValue,] of a.entries()) if (!equal(aValue, b.get(key7,), true,)) return false;
   return true;
 }
 function setEqual(a, b,) {
   if (a.size !== b.size) return false;
-  for (const aValue of a.keys()) {
-    if (!b.has(aValue,)) return false;
-  }
+  for (const aValue of a.keys()) if (!b.has(aValue,)) return false;
   return true;
 }
 function objectShallowEqual(a, b,) {
@@ -21007,9 +16159,7 @@ function objectShallowEqual(a, b,) {
   if (keys3.length !== objectKeys(b,).length) return false;
   for (const key7 of keys3) {
     if (!hasProp(b, key7,)) return false;
-    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) {
-      continue;
-    }
+    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) continue;
     if (!valueEqual(a[key7], b[key7],)) return false;
   }
   return true;
@@ -21019,9 +16169,7 @@ function objectDeepEqual(a, b,) {
   if (keys3.length !== objectKeys(b,).length) return false;
   for (const key7 of keys3) {
     if (!hasProp(b, key7,)) return false;
-    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) {
-      continue;
-    }
+    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) continue;
     if (!equal(a[key7], b[key7], true,)) return false;
   }
   return true;
@@ -21036,54 +16184,30 @@ function equal(a, b, deep,) {
   const aIsArray = Array.isArray(a,);
   const bIsArray = Array.isArray(b,);
   if (aIsArray && bIsArray) {
-    if (deep) {
-      return arrayDeepEqual(a, b,);
-    } else {
-      return arrayShallowEqual(a, b,);
-    }
-  } else if (aIsArray !== bIsArray) {
-    return false;
-  }
+    if (deep) return arrayDeepEqual(a, b,);
+    else return arrayShallowEqual(a, b,);
+  } else if (aIsArray !== bIsArray) return false;
   const aIsMap = a instanceof Map;
   const bIsMap = b instanceof Map;
   if (aIsMap && bIsMap) {
-    if (deep) {
-      return mapDeepEqual(a, b,);
-    } else {
-      return mapShallowEqual(a, b,);
-    }
-  } else if (aIsMap !== bIsMap) {
-    return false;
-  }
+    if (deep) return mapDeepEqual(a, b,);
+    else return mapShallowEqual(a, b,);
+  } else if (aIsMap !== bIsMap) return false;
   const aIsSet = a instanceof Set;
   const bIsSet = b instanceof Set;
-  if (aIsSet && bIsSet) {
-    return setEqual(a, b,);
-  } else if (aIsSet !== bIsSet) {
-    return false;
-  }
+  if (aIsSet && bIsSet) return setEqual(a, b,);
+  else if (aIsSet !== bIsSet) return false;
   const dateA = a instanceof Date;
   const dateB = b instanceof Date;
-  if (dateA && dateB) {
-    return a.getTime() === b.getTime();
-  } else if (dateA !== dateB) {
-    return false;
-  }
+  if (dateA && dateB) return a.getTime() === b.getTime();
+  else if (dateA !== dateB) return false;
   const regexpA = a instanceof RegExp;
   const regexpB = b instanceof RegExp;
-  if (regexpA && regexpB) {
-    return a.toString() === b.toString();
-  } else if (regexpA !== regexpB) {
-    return false;
-  }
-  if (withEquals(a,) && withEquals(b,)) {
-    return a.equals(b,);
-  }
-  if (deep) {
-    return objectDeepEqual(a, b,);
-  } else {
-    return objectShallowEqual(a, b,);
-  }
+  if (regexpA && regexpB) return a.toString() === b.toString();
+  else if (regexpA !== regexpB) return false;
+  if (withEquals(a,) && withEquals(b,)) return a.equals(b,);
+  if (deep) return objectDeepEqual(a, b,);
+  else return objectShallowEqual(a, b,);
 }
 function isEqual(a, b, deep = true,) {
   try {
@@ -21102,9 +16226,7 @@ var useTranslateZHack = isFramerX() || isSafari() || isTest();
 function forceLayerBackingWithMotionStyle(motionStyle,) {
   motionStyle.willChange = 'transform';
   const onCanvas = RenderTarget.current() === 'CANVAS';
-  if (useTranslateZHack && onCanvas) {
-    motionStyle.translateZ = smallValue;
-  }
+  if (useTranslateZHack && onCanvas) motionStyle.translateZ = smallValue;
 }
 function forceLayerBackingWithCSSProperties(cssProperties,) {
   cssProperties.willChange = 'transform';
@@ -21112,34 +16234,23 @@ function forceLayerBackingWithCSSProperties(cssProperties,) {
 }
 function setTranslateZHack(style, enabled,) {
   const onCanvas = RenderTarget.current() === 'CANVAS';
-  if (!useTranslateZHack || !onCanvas) {
-    return;
-  }
+  if (!useTranslateZHack || !onCanvas) return;
   const transform2 = isString22(style.transform,) ? style.transform || '' : '';
   if (enabled) {
     const hasTranslateZ = transform2.includes(translateZ,);
-    if (!hasTranslateZ) {
-      style.transform = transform2 + translateZ;
-    }
-  } else {
-    style.transform = transform2.replace(translateZ, '',);
-  }
+    if (!hasTranslateZ) style.transform = transform2 + translateZ;
+  } else style.transform = transform2.replace(translateZ, '',);
 }
 function resetSetStyle(element, key7, toValue, microtask2 = true,) {
-  if (!element) {
-    return;
-  }
+  if (!element) return;
   const style = asRecord(element.style,);
   const value = toValue ? toValue : style[key7];
   const reset = () => {
     style[key7] = value;
   };
   style[key7] = null;
-  if (microtask2) {
-    void Promise.resolve().then(reset,);
-  } else {
-    setTimeout(reset, 0,);
-  }
+  if (microtask2) void Promise.resolve().then(reset,);
+  else setTimeout(reset, 0,);
 }
 var Layer = class extends Component2 {
   constructor() {
@@ -21151,18 +16262,13 @@ var Layer = class extends Component2 {
   }
   static applyWillChange(props, style, usingMotionStyle,) {
     if (props.willChangeTransform) {
-      if (usingMotionStyle) {
-        forceLayerBackingWithMotionStyle(style,);
-      } else {
-        forceLayerBackingWithCSSProperties(style,);
-      }
+      if (usingMotionStyle) forceLayerBackingWithMotionStyle(style,);
+      else forceLayerBackingWithCSSProperties(style,);
     }
-  }
-  /** @internal */
+  } /** @internal */
   shouldComponentUpdate(nextProps, nextState,) {
     return nextProps._needsMeasure || this.state !== nextState || !isEqual(this.props, nextProps,);
-  }
-  /** @internal */
+  } /** @internal */
   componentDidUpdate(prevProps,) {
     if (asRecord(this.props,)['clip'] && asRecord(this.props,)['radius'] === 0 && asRecord(prevProps,)['radius'] !== 0) {
       resetSetStyle(this.layerElement, 'overflow', 'hidden', false,);
@@ -21188,9 +16294,7 @@ function memoize2(maxEntries, cache3, key7, create,) {
   return g;
 }
 var hash = (value) => {
-  let hasher = 0,
-    i,
-    chr;
+  let hasher = 0, i, chr;
   if (value.length === 0) return hasher;
   for (i = 0; i < value.length; i++) {
     chr = value.charCodeAt(i,);
@@ -21259,23 +16363,14 @@ var ConvertColor = {
     return Color.toRgbString(Color(color2,),);
   },
   toColorPickerSquare: (h) => {
-    return Color.toRgbString(Color({
-      h,
-      s: 1,
-      l: 0.5,
-      a: 1,
-    },),);
+    return Color.toRgbString(Color({ h, s: 1, l: 0.5, a: 1, },),);
   },
   isValid: (color2) => {
     return Color(color2,).isValid !== false;
   },
   equals: (a, b,) => {
-    if (typeof a === 'string') {
-      a = Color(a,);
-    }
-    if (typeof b === 'string') {
-      b = Color(b,);
-    }
+    if (typeof a === 'string') a = Color(a,);
+    if (typeof b === 'string') b = Color(b,);
     return Color.equal(a, b,);
   },
   toHexOrRgbaString: (input) => {
@@ -21287,32 +16382,15 @@ var CSSVariableRegExp = /var\(.+\)/;
 var colorCache = /* @__PURE__ */ new Map();
 function cachedMultiplyAlpha(s, a,) {
   const key7 = [s, a,];
-  if (CSSVariableRegExp.test(s,)) {
-    return s;
-  }
+  if (CSSVariableRegExp.test(s,)) return s;
   return memoize2(1e3, colorCache, key7, () => ConvertColor.multiplyAlpha(s, a,),);
 }
 function gradientColorStops(gradient, alpha2 = 1,) {
   let stops;
-  if ('stops' in gradient) {
-    stops = gradient.stops;
-  } else {
-    stops = [{
-      value: gradient.start,
-      position: 0,
-    }, {
-      value: gradient.end,
-      position: 1,
-    },];
-  }
-  if (alpha2 === 1) {
-    return stops;
-  } else {
-    return stops.map((stop) => ({
-      ...stop,
-      value: cachedMultiplyAlpha(stop.value, alpha2,),
-    }));
-  }
+  if ('stops' in gradient) stops = gradient.stops;
+  else stops = [{ value: gradient.start, position: 0, }, { value: gradient.end, position: 1, },];
+  if (alpha2 === 1) return stops;
+  else return stops.map((stop) => ({ ...stop, value: cachedMultiplyAlpha(stop.value, alpha2,), }));
 }
 function gradientColorStopsHash(gradient, alpha2,) {
   let result = 0;
@@ -21333,16 +16411,13 @@ var linearGradientKeys = ['angle', 'alpha',];
 var LinearGradient = {
   /**
    * @param value -
-   */
-  isLinearGradient: (value) => {
+   */ isLinearGradient: (value) => {
     return value && linearGradientKeys.every((key7) => key7 in value) && (isSimpleGradient(value,) || isMultiStopGradient(value,));
   },
-  /** @internal */
-  hash: (linearGradient) => {
+  /** @internal */ hash: (linearGradient) => {
     return linearGradient.angle ^ gradientColorStopsHash(linearGradient, linearGradient.alpha,);
   },
-  /** @internal */
-  toCSS: (linearGradient, overrideAngle,) => {
+  /** @internal */ toCSS: (linearGradient, overrideAngle,) => {
     const stops = gradientColorStops(linearGradient, linearGradient.alpha,);
     const angle = overrideAngle !== void 0 ? overrideAngle : linearGradient.angle;
     const cssStops = stops.map((stop) => `${stop.value} ${stop.position * 100}%`);
@@ -21354,24 +16429,15 @@ var RadialGradient = {
   /**
    * @param value -
    * @public
-   */
-  isRadialGradient: (value) => {
+   */ isRadialGradient: (value) => {
     return value && radialGradientKeys.every((key7) => key7 in value) && (isSimpleGradient(value,) || isMultiStopGradient(value,));
   },
-  /** @internal */
-  hash: (radialGradient) => {
+  /** @internal */ hash: (radialGradient) => {
     return radialGradient.centerAnchorX ^ radialGradient.centerAnchorY ^ radialGradient.widthFactor ^ radialGradient.heightFactor ^
       gradientColorStopsHash(radialGradient, radialGradient.alpha,);
   },
-  /** @internal */
-  toCSS: (radialGradient) => {
-    const {
-      alpha: alpha2,
-      widthFactor,
-      heightFactor,
-      centerAnchorX,
-      centerAnchorY,
-    } = radialGradient;
+  /** @internal */ toCSS: (radialGradient) => {
+    const { alpha: alpha2, widthFactor, heightFactor, centerAnchorX, centerAnchorY, } = radialGradient;
     const stops = gradientColorStops(radialGradient, alpha2,);
     const cssStops = stops.map((stop, index,) => {
       const nextStop = stops[index + 1];
@@ -21383,33 +16449,20 @@ var RadialGradient = {
     })`;
   },
 };
-function collectBackgroundFromProps({
-  background,
-  backgroundColor,
-}, style,) {
+function collectBackgroundFromProps({ background, backgroundColor, }, style,) {
   if (backgroundColor) {
-    if (typeof backgroundColor === 'string' || isMotionValue2(backgroundColor,)) {
-      style.backgroundColor = backgroundColor;
-    } else if (Color.isColorObject(background,)) {
-      style.backgroundColor = background.initialValue || Color.toRgbString(background,);
-    }
+    if (typeof backgroundColor === 'string' || isMotionValue2(backgroundColor,)) style.backgroundColor = backgroundColor;
+    else if (Color.isColorObject(background,)) style.backgroundColor = background.initialValue || Color.toRgbString(background,);
   } else if (background) {
     background = Animatable.get(background, null,);
-    if (typeof background === 'string' || isMotionValue2(background,)) {
-      style.background = background;
-    } else if (LinearGradient.isLinearGradient(background,)) {
-      style.background = LinearGradient.toCSS(background,);
-    } else if (RadialGradient.isRadialGradient(background,)) {
-      style.background = RadialGradient.toCSS(background,);
-    } else if (Color.isColorObject(background,)) {
-      style.backgroundColor = background.initialValue || Color.toRgbString(background,);
-    }
+    if (typeof background === 'string' || isMotionValue2(background,)) style.background = background;
+    else if (LinearGradient.isLinearGradient(background,)) style.background = LinearGradient.toCSS(background,);
+    else if (RadialGradient.isRadialGradient(background,)) style.background = RadialGradient.toCSS(background,);
+    else if (Color.isColorObject(background,)) style.backgroundColor = background.initialValue || Color.toRgbString(background,);
   }
 }
 function extractStyleFromProps(props, name, styleRef, into,) {
-  if (into === void 0) {
-    into = name;
-  }
+  if (into === void 0) into = name;
   if (props[name] !== void 0) {
     styleRef[into] = props[name];
     return;
@@ -21424,37 +16477,20 @@ function hasTopAndBottom(style,) {
   return style.top !== void 0 && style.bottom !== void 0;
 }
 function getStyleForFrameProps(props,) {
-  if (!props) {
-    return {};
-  }
+  if (!props) return {};
   const style = {};
-  if (props.preserve3d === true) {
-    style.transformStyle = 'preserve-3d';
-  } else if (props.preserve3d === false) {
-    style.transformStyle = 'flat';
-  }
-  if (props.backfaceVisible === true) {
-    style.backfaceVisibility = 'visible';
-  } else if (props.backfaceVisible === false) {
-    style.backfaceVisibility = 'hidden';
-  }
-  if (style.backfaceVisibility) {
-    style.WebkitBackfaceVisibility = style.backfaceVisibility;
-  }
-  if (props.perspective !== void 0) {
-    style.perspective = style.WebkitPerspective = props.perspective;
-  }
+  if (props.preserve3d === true) style.transformStyle = 'preserve-3d';
+  else if (props.preserve3d === false) style.transformStyle = 'flat';
+  if (props.backfaceVisible === true) style.backfaceVisibility = 'visible';
+  else if (props.backfaceVisible === false) style.backfaceVisibility = 'hidden';
+  if (style.backfaceVisibility) style.WebkitBackfaceVisibility = style.backfaceVisibility;
+  if (props.perspective !== void 0) style.perspective = style.WebkitPerspective = props.perspective;
   if (!props.__fromCanvasComponent) {
     if (props.center === true) {
       style.left = '50%';
       style.top = '50%';
-    } else {
-      if (props.center === 'x') {
-        style.left = '50%';
-      } else if (props.center === 'y') {
-        style.top = '50%';
-      }
-    }
+    } else {if (props.center === 'x') style.left = '50%';
+      else if (props.center === 'y') style.top = '50%';}
   }
   extractStyleFromProps(props, 'size', style,);
   extractStyleFromProps(props, 'width', style,);
@@ -21497,9 +16533,7 @@ function hasEvents(props,) {
     if (
       key7 === 'drag' || key7.startsWith('while',) ||
       typeof asRecord(props,)[key7] === 'function' && key7.startsWith('on',) && !key7.includes('Animation',)
-    ) {
-      return true;
-    }
+    ) return true;
   }
   return false;
 }
@@ -21519,17 +16553,11 @@ var pointerEvents = [
   'onTouchDown',
   'onTouchUp',
 ];
-var pointerEventsSet = /* @__PURE__ */ new Set([...pointerEvents, ...pointerEvents.map((event) => `${event}Capture`),// Add capture event variants
+var pointerEventsSet = /* @__PURE__ */ new Set([...pointerEvents, ...pointerEvents.map((event) => `${event}Capture`), // Add capture event variants
 ],);
 function getCursorFromEvents(props,) {
-  if (props.drag) {
-    return 'grab';
-  }
-  for (const key7 in props) {
-    if (pointerEventsSet.has(key7,)) {
-      return 'pointer';
-    }
-  }
+  if (props.drag) return 'grab';
+  for (const key7 in props) if (pointerEventsSet.has(key7,)) return 'pointer';
   return void 0;
 }
 var overflowKey = 'overflow';
@@ -21584,23 +16612,13 @@ function unwrapFrameProps(frameProps,) {
   };
   return constraintProps;
 }
-var defaultFrameRect = {
-  x: 0,
-  y: 0,
-  width: 200,
-  height: 200,
-};
+var defaultFrameRect = { x: 0, y: 0, width: 200, height: 200, };
 function useStyleAndRect(props,) {
   React__default.useInsertionEffect(() => {
     injectComponentCSSRules();
   }, [],);
   const inCodeComponent = Boolean(useContext3(ComponentContainerContext,),);
-  const {
-    style,
-    _initialStyle,
-    __fromCanvasComponent,
-    size: size2,
-  } = props;
+  const { style, _initialStyle, __fromCanvasComponent, size: size2, } = props;
   const unwrappedProps = unwrapFrameProps(props,);
   const constraintsRect = useConstraints(unwrappedProps,);
   const defaultStyle = {
@@ -21608,39 +16626,22 @@ function useStyleAndRect(props,) {
     flex: (style == null ? void 0 : style.flex) ?? '0 0 auto',
     userSelect: RenderTarget.current() !== 'PREVIEW' ? 'none' : void 0,
   };
-  if (!props.__fromCanvasComponent) {
-    defaultStyle.backgroundColor = props.background === void 0 ? 'rgba(0, 170, 255, 0.3)' : void 0;
-  }
+  if (!props.__fromCanvasComponent) defaultStyle.backgroundColor = props.background === void 0 ? 'rgba(0, 170, 255, 0.3)' : void 0;
   const shouldDisablePointerEvents = !hasEvents(props,) && !props.__fromCanvasComponent && !hasScrollableContent(props,);
   const safeToEditPointerEvents = props.style ? !('pointerEvents' in props.style) : true;
-  if (shouldDisablePointerEvents && safeToEditPointerEvents) {
-    defaultStyle.pointerEvents = 'none';
-  }
+  if (shouldDisablePointerEvents && safeToEditPointerEvents) defaultStyle.pointerEvents = 'none';
   const addTextCentering = React__default.Children.count(props.children,) > 0 &&
     React__default.Children.toArray(props.children,).every((child) => {
       return typeof child === 'string' || typeof child === 'number';
     },);
-  const centerTextStyle = addTextCentering && {
-    display: 'flex',
-    alignItems: 'center',
-    justifyContent: 'center',
-    textAlign: 'center',
-  };
+  const centerTextStyle = addTextCentering && { display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', };
   const propsStyle = getStyleForFrameProps(props,);
   if (size2 === void 0 && !__fromCanvasComponent) {
-    if (!hasLeftAndRight(propsStyle,)) {
-      defaultStyle.width = defaultFrameRect.width;
-    }
-    if (!hasTopAndBottom(propsStyle,)) {
-      defaultStyle.height = defaultFrameRect.height;
-    }
-  }
-  if (unwrappedProps.minWidth !== void 0) {
-    defaultStyle.minWidth = unwrappedProps.minWidth;
-  }
-  if (unwrappedProps.minHeight !== void 0) {
-    defaultStyle.minHeight = unwrappedProps.minHeight;
+    if (!hasLeftAndRight(propsStyle,)) defaultStyle.width = defaultFrameRect.width;
+    if (!hasTopAndBottom(propsStyle,)) defaultStyle.height = defaultFrameRect.height;
   }
+  if (unwrappedProps.minWidth !== void 0) defaultStyle.minWidth = unwrappedProps.minWidth;
+  if (unwrappedProps.minHeight !== void 0) defaultStyle.minHeight = unwrappedProps.minHeight;
   let constraintsStyle = {};
   if (constraintsEnabled(unwrappedProps,)) {
     if (constraintsRect && !isAutoSized(props,)) {
@@ -21662,13 +16663,7 @@ function useStyleAndRect(props,) {
   },);
   Layer.applyWillChange(props, defaultStyle, true,);
   let resultStyle = defaultStyle;
-  if (!defaultStyle.transform) {
-    resultStyle = {
-      x: 0,
-      y: 0,
-      ...defaultStyle,
-    };
-  }
+  if (!defaultStyle.transform) resultStyle = { x: 0, y: 0, ...defaultStyle, };
   const onCanvas = RenderTarget.current() === 'CANVAS';
   if (props.positionSticky) {
     if (!onCanvas || inCodeComponent) {
@@ -21680,12 +16675,8 @@ function useStyleAndRect(props,) {
       resultStyle.bottom = props.positionStickyBottom;
       resultStyle.left = props.positionStickyLeft;
     }
-  } else if (onCanvas && (props.positionFixed || props.positionAbsolute)) {
-    resultStyle.position = 'absolute';
-  }
-  if ('rotate' in resultStyle && resultStyle.rotate === void 0) {
-    delete resultStyle.rotate;
-  }
+  } else if (onCanvas && (props.positionFixed || props.positionAbsolute)) resultStyle.position = 'absolute';
+  if ('rotate' in resultStyle && resultStyle.rotate === void 0) delete resultStyle.rotate;
   return [resultStyle, constraintsRect,];
 }
 var filteredProps = /* @__PURE__ */ new Set([
@@ -21717,13 +16708,10 @@ function getMotionProps(props,) {
   const motionProps = {};
   for (const key7 in props) {
     const isValid = isValidMotionProp(key7,) || isPropValid(key7,);
-    if (isValid && !filteredProps.has(key7,)) {
-      motionProps[key7] = asRecord(props,)[key7];
-    } else if (key7 === 'positionTransition' || key7 === 'layoutTransition') {
+    if (isValid && !filteredProps.has(key7,)) motionProps[key7] = asRecord(props,)[key7];
+    else if (key7 === 'positionTransition' || key7 === 'layoutTransition') {
       motionProps['layout'] = true;
-      if (typeof asRecord(props,)[key7] !== 'boolean' && !props.transition) {
-        motionProps['transition'] = asRecord(props,)[key7];
-      }
+      if (typeof asRecord(props,)[key7] !== 'boolean' && !props.transition) motionProps['transition'] = asRecord(props,)[key7];
     }
   }
   return motionProps;
@@ -21732,17 +16720,8 @@ function hasDataFramerName(props,) {
   return 'data-framer-name' in props;
 }
 var VisibleFrame = /* @__PURE__ */ forwardRef(function VisibleFrame2(props, forwardedRef,) {
-  const {
-    name,
-    center,
-    border,
-    _border,
-    __portal,
-  } = props;
-  const {
-    props: propsWithOverrides,
-    children,
-  } = processOverrideForwarding(props,);
+  const { name, center, border, _border, __portal, } = props;
+  const { props: propsWithOverrides, children, } = processOverrideForwarding(props,);
   const motionProps = getMotionProps(propsWithOverrides,);
   const layoutId = useLayoutId2(props,);
   const cursor = getCursorFromEvents(props,);
@@ -21755,18 +16734,14 @@ var VisibleFrame = /* @__PURE__ */ forwardRef(function VisibleFrame2(props, forw
     'data-layoutid': layoutId,
     'data-framer-offset-parent-id': asRecord(props,)['data-framer-offset-parent-id'],
   };
-  if (!hasDataFramerName(props,) && name) {
-    asRecord(dataProps,)['data-framer-name'] = name;
-  }
+  if (!hasDataFramerName(props,) && name) asRecord(dataProps,)['data-framer-name'] = name;
   const [currentStyle, rect,] = useStyleAndRect(propsWithOverrides,);
   const unwrappedProps = unwrapFrameProps(propsWithOverrides,);
   const autoSized = isAutoSized(unwrappedProps,);
   if (center && !(rect && !autoSized && constraintsEnabled(unwrappedProps,))) {
     if (!motionProps.transformTemplate) motionProps.transformTemplate = transformTemplate(center,);
     Object.assign(dataProps, layoutHintDataPropsForCenter(center,),);
-  } else if (!motionProps.transformTemplate) {
-    motionProps.transformTemplate = void 0;
-  }
+  } else if (!motionProps.transformTemplate) motionProps.transformTemplate = void 0;
   useMeasureLayout(props, ref,);
   const backgroundImage = backgroundImageFromProps(props,);
   const inCodeComponent = Boolean(useContext3(ComponentContainerContext,),);
@@ -21784,29 +16759,17 @@ var VisibleFrame = /* @__PURE__ */ forwardRef(function VisibleFrame2(props, forw
           },)
           : null,
         children,
-        /* @__PURE__ */ _jsx5(Border, {
-          ..._border,
-          border,
-          layoutId,
-        },),
+        /* @__PURE__ */ _jsx5(Border, { ..._border, border, layoutId, },),
       ],
     },),
     parentSize,
   );
   const MotionComponent = htmlElementAsMotionComponent(props.as,);
-  const {
-    size: size2,
-    radius,
-    shadow,
-  } = currentStyle;
+  const { size: size2, radius, shadow, } = currentStyle;
   if (size2 !== void 0) {
     delete currentStyle.size;
-    if (currentStyle.height === void 0) {
-      currentStyle.height = size2;
-    }
-    if (currentStyle.width === void 0) {
-      currentStyle.width = size2;
-    }
+    if (currentStyle.height === void 0) currentStyle.height = size2;
+    if (currentStyle.width === void 0) currentStyle.width = size2;
   }
   if (radius !== void 0) {
     delete currentStyle.radius;
@@ -21827,72 +16790,40 @@ var VisibleFrame = /* @__PURE__ */ forwardRef(function VisibleFrame2(props, forw
 },);
 var FrameWithMotion = /* @__PURE__ */ forwardRef(function FrameWithMotion2(props, ref,) {
   countNodeRender();
-  const {
-    visible = true,
-  } = props;
+  const { visible = true, } = props;
   if (!visible) return null;
-  return /* @__PURE__ */ _jsx5(VisibleFrame, {
-    ...props,
-    ref,
-  },);
+  return /* @__PURE__ */ _jsx5(VisibleFrame, { ...props, ref, },);
 },);
 function resolveParentSize(props, unwrappedProps, rect, inCodeComponent,) {
   if (inCodeComponent) {
-    const parentSize = rect
-      ? {
-        width: rect.width,
-        height: rect.height,
-      }
-      : 1;
+    const parentSize = rect ? { width: rect.width, height: rect.height, } : 1;
     return parentSize;
   }
-  const {
-    _usesDOMRect,
-  } = props;
-  const {
-    widthType = 0,
-    heightType = 0,
-    width,
-    height,
-  } = unwrappedProps;
-  if (rect && !_usesDOMRect) {
-    return rect;
-  }
-  if (widthType === 0 && heightType === 0 && typeof width === 'number' && typeof height === 'number') {
-    return {
-      width,
-      height,
-    };
-  }
-  if (_usesDOMRect || props.positionFixed || props.positionAbsolute) {
-    return 2;
-  }
+  const { _usesDOMRect, } = props;
+  const { widthType = 0, heightType = 0, width, height, } = unwrappedProps;
+  if (rect && !_usesDOMRect) return rect;
+  if (widthType === 0 && heightType === 0 && typeof width === 'number' && typeof height === 'number') return { width, height, };
+  if (_usesDOMRect || props.positionFixed || props.positionAbsolute) return 2;
   return 0;
 }
-function isAutoSized({
-  width,
-  height,
-},) {
+function isAutoSized({ width, height, },) {
   return width === 'auto' || width === 'min-content' || height === 'auto' || height === 'min-content';
 }
-function EmptyState({
-  title = '',
-  description = 'Click and drag the connector to any frame on the canvas \u2192',
-  children,
-  size: size2,
-  hide,
-  insideUserCodeComponent = false,
-  position = 'absolute',
-},) {
-  const {
-    target,
-  } = RenderEnvironment;
+function EmptyState(
+  {
+    title = '',
+    description = 'Click and drag the connector to any frame on the canvas \u2192',
+    children,
+    size: size2,
+    hide,
+    insideUserCodeComponent = false,
+    position = 'absolute',
+  },
+) {
+  const { target, } = RenderEnvironment;
   const childCount = React__default.Children.count(children,);
   if (insideUserCodeComponent && childCount === 0) {
-    return /* @__PURE__ */ _jsx5(FrameWithMotion, {
-      ...size2,
-      'data-name': 'placeholder',
-    },);
+    return /* @__PURE__ */ _jsx5(FrameWithMotion, { ...size2, 'data-name': 'placeholder', },);
   }
   if (target !== 'CANVAS') return null;
   if (hide) return null;
@@ -21903,44 +16834,25 @@ function EmptyState({
     left: 0,
     bottom: 0,
     right: 0,
-    style: {
-      position,
-      ...size2,
-    },
+    style: { position, ...size2, },
     children: /* @__PURE__ */ _jsx5('div', {
-      style: {
-        display: 'flex',
-        alignItems: 'center',
-        lineHeight: '1.4',
-        height: '100%',
-        width: '100%',
-      },
+      style: { display: 'flex', alignItems: 'center', lineHeight: '1.4', height: '100%', width: '100%', },
       children: /* @__PURE__ */ _jsxs('div', {
         style: {
           display: 'flex',
           alignItems: 'center',
           justifyContent: 'center',
           flexDirection: 'column',
-          width: '100%',
-          // Use a mask to fade out the right edge of the content as it gets cropped.
+          width: '100%', // Use a mask to fade out the right edge of the content as it gets cropped.
           WebkitMaskImage: `linear-gradient(90deg, black, black calc(100% - 12px * ${scaleFactor}), transparent)`,
         },
-        children: [
-          /* @__PURE__ */ _jsx5(Title, {
-            children: title,
-          },),
-          /* @__PURE__ */ _jsx5(Description, {
-            children: description,
-          },),
-        ],
+        children: [/* @__PURE__ */ _jsx5(Title, { children: title, },), /* @__PURE__ */ _jsx5(Description, { children: description, },),],
       },),
     },),
   }, 'empty-state',);
 }
 var scaleFactor = 'var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)';
-function Title({
-  children,
-},) {
+function Title({ children, },) {
   return /* @__PURE__ */ _jsx5('span', {
     style: {
       display: 'flex',
@@ -21954,9 +16866,7 @@ function Title({
     children,
   },);
 }
-function Description({
-  children,
-},) {
+function Description({ children, },) {
   return /* @__PURE__ */ _jsx5('span', {
     style: {
       display: 'flex',
@@ -21998,17 +16908,14 @@ var SharedLayoutRoot = class extends Component2 {
     __publicField(this, 'initLead', (tree, shouldAnimate,) => {
       this.follow = this.lead;
       this.lead = tree;
-      if (this.follow && shouldAnimate) {
-        this.follow.layoutMaybeMutated = true;
-      }
+      if (this.follow && shouldAnimate) this.follow.layoutMaybeMutated = true;
     },);
     __publicField(this, 'sharedLayoutContext', {
       schedulePromoteTree: this.schedulePromoteTree,
       scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate,
       initLead: this.initLead,
     },);
-  }
-  // Runs after all descendent SharedLayoutTree finish taking snapshots in
+  } // Runs after all descendent SharedLayoutTree finish taking snapshots in
   // their getSnapshotBeforeUpdate lifecycle method.
   getSnapshotBeforeUpdate() {
     var _a;
@@ -22016,17 +16923,17 @@ var SharedLayoutRoot = class extends Component2 {
     const needsReset = !!((_a = this.lead) == null ? void 0 : _a.layoutMaybeMutated) && !this.shouldAnimate;
     this.lead.projectionNodes.forEach((projectionNode) => {
       var _a2;
-      projectionNode == null ? void 0 : projectionNode.promote({
-        needsReset,
-        transition: this.shouldAnimate ? this.transition : void 0,
-        preserveFollowOpacity: projectionNode.options.layoutId === TREE_ROOT_ID && !((_a2 = this.follow) == null ? void 0 : _a2.isExiting),
-      },);
+      projectionNode == null
+        ? void 0
+        : projectionNode.promote({
+          needsReset,
+          transition: this.shouldAnimate ? this.transition : void 0,
+          preserveFollowOpacity: projectionNode.options.layoutId === TREE_ROOT_ID &&
+            !((_a2 = this.follow) == null ? void 0 : _a2.isExiting),
+        },);
     },);
-    if (this.shouldAnimate) {
-      this.follow.layoutMaybeMutated = true;
-    } else {
-      this.scheduleProjectionDidUpdate();
-    }
+    if (this.shouldAnimate) this.follow.layoutMaybeMutated = true;
+    else this.scheduleProjectionDidUpdate();
     this.lead.layoutMaybeMutated = false;
     this.transition = void 0;
     this.scheduledPromotion = false;
@@ -22041,23 +16948,12 @@ var SharedLayoutRoot = class extends Component2 {
     }
   }
   render() {
-    return /* @__PURE__ */ _jsx5(SharedLayoutContext.Provider, {
-      value: this.sharedLayoutContext,
-      children: this.props.children,
-    },);
+    return /* @__PURE__ */ _jsx5(SharedLayoutContext.Provider, { value: this.sharedLayoutContext, children: this.props.children, },);
   }
 };
-var rootStyles = {
-  width: '100%',
-  height: '100%',
-  backgroundColor: 'none',
-};
+var rootStyles = { width: '100%', height: '100%', backgroundColor: 'none', };
 function MagicMotionCrossfadeRoot(props,) {
-  return /* @__PURE__ */ _jsx5(motion.div, {
-    layoutId: TREE_ROOT_ID,
-    style: rootStyles,
-    children: props.children,
-  },);
+  return /* @__PURE__ */ _jsx5(motion.div, { layoutId: TREE_ROOT_ID, style: rootStyles, children: props.children, },);
 }
 var _sharedIntersectionObserver;
 var _callbacks2;
@@ -22096,23 +16992,15 @@ function useSharedIntersectionObserver(ref, callback, options,) {
   if (typeof IntersectionObserver === 'undefined') return;
   const key7 = useConstant2(() => `${options.rootMargin}`);
   const observers2 = React__default.useContext(SharedIntersectionObserverContext,);
-  const {
-    enabled,
-  } = options;
+  const { enabled, } = options;
   React__default.useEffect(() => {
     var _a;
     const element = ref.current;
     if (!enabled || !element) return;
     let observer2 = observers2.get(key7,);
     if (!observer2 || observer2.root !== ((_a = options.root) == null ? void 0 : _a.current)) {
-      const {
-        root,
-        ...rest
-      } = options;
-      observer2 = new SharedIntersectionObserver({
-        ...rest,
-        root: root == null ? void 0 : root.current,
-      },);
+      const { root, ...rest } = options;
+      observer2 = new SharedIntersectionObserver({ ...rest, root: root == null ? void 0 : root.current, },);
       observers2.set(key7, observer2,);
     }
     observer2.observeElementWithCallback(element, callback,);
@@ -22122,22 +17010,11 @@ function useSharedIntersectionObserver(ref, callback, options,) {
 var thresholds2 = /* @__PURE__ */ new Array(100,).fill(void 0,).map((_, i,) => i * 0.01);
 var ViewportContext = /* @__PURE__ */ React__default.createContext(null,);
 function useAppearEffect(ref, appearCallback, options,) {
-  const internalState = React__default.useRef({
-    isInView: false,
-    hasAnimatedOnce: false,
-  },);
-  const {
-    enabled,
-    animateOnce,
-    threshold,
-    rootMargin = `0px 0px 0px 0px`,
-  } = options;
+  const internalState = React__default.useRef({ isInView: false, hasAnimatedOnce: false, },);
+  const { enabled, animateOnce, threshold, rootMargin = `0px 0px 0px 0px`, } = options;
   const callback = React__default.useCallback(([entry,],) => {
     if (!entry) return;
-    const {
-      isInView,
-      hasAnimatedOnce,
-    } = internalState.current;
+    const { isInView, hasAnimatedOnce, } = internalState.current;
     const isIntersecting = isIntersectingWithThreshold(entry, (threshold == null ? void 0 : threshold.y) ?? 0,);
     if (isIntersecting && !isInView) {
       if (animateOnce && hasAnimatedOnce) return;
@@ -22153,54 +17030,31 @@ function useAppearEffect(ref, appearCallback, options,) {
       return;
     }
   }, [animateOnce, threshold == null ? void 0 : threshold.y, appearCallback,],);
-  useSharedIntersectionObserver(ref, callback, {
-    threshold: thresholds2,
-    rootMargin,
-    enabled: enabled ?? true,
-  },);
+  useSharedIntersectionObserver(ref, callback, { threshold: thresholds2, rootMargin, enabled: enabled ?? true, },);
 }
 function calculatedIntersection(intersectionRect, boundingClientRect,) {
   if (boundingClientRect.height === 0) return 0;
   return intersectionRect.height / Math.min(boundingClientRect.height, safeWindow.innerHeight,);
 }
-function isIntersectingWithThreshold({
-  boundingClientRect,
-  intersectionRect,
-  isIntersecting,
-}, threshold,) {
+function isIntersectingWithThreshold({ boundingClientRect, intersectionRect, isIntersecting, }, threshold,) {
   if (boundingClientRect.height === 0) return isIntersecting;
   return isIntersecting && calculatedIntersection(intersectionRect, boundingClientRect,) >= threshold;
 }
 var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs(), 1,);
 function pointForEvent(event, customTarget = null,) {
   let target;
-  if (customTarget instanceof HTMLElement) {
-    target = customTarget;
-  }
-  if (!target && event.target instanceof HTMLElement) {
-    target = event.target;
-  }
-  if (!target) {
-    return {
-      x: event.pageX,
-      y: event.pageY,
-    };
-  }
+  if (customTarget instanceof HTMLElement) target = customTarget;
+  if (!target && event.target instanceof HTMLElement) target = event.target;
+  if (!target) return { x: event.pageX, y: event.pageY, };
   if ('webkitConvertPointFromPageToNode' in safeWindow) {
     let webkitPoint = new safeWindow.WebKitPoint(event.pageX, event.pageY,);
     webkitPoint = safeWindow.webkitConvertPointFromPageToNode(target, webkitPoint,);
-    return {
-      x: webkitPoint.x,
-      y: webkitPoint.y,
-    };
+    return { x: webkitPoint.x, y: webkitPoint.y, };
   }
   const rect = target.getBoundingClientRect();
   const width = parseFloat(target.style.width,);
   const height = parseFloat(target.style.height,);
-  const scale2 = {
-    x: width ? width / rect.width : 1,
-    y: height ? height / rect.height : 1,
-  };
+  const scale2 = { x: width ? width / rect.width : 1, y: height ? height / rect.height : 1, };
   const point2 = {
     x: scale2.x * (event.pageX - rect.left - target.clientLeft + target.scrollLeft),
     y: scale2.y * (event.pageY - rect.top - target.clientTop + target.scrollTop),
@@ -22210,8 +17064,7 @@ function pointForEvent(event, customTarget = null,) {
 var FramerEvent = class {
   /**
    * @internal
-   */
-  constructor(originalEvent, session,) {
+   */ constructor(originalEvent, session,) {
     this.originalEvent = originalEvent;
     this.session = session;
     __publicField(this, 'time', Date.now(),);
@@ -22227,71 +17080,41 @@ var FramerEvent = class {
     this.devicePoint = pointForEvent(eventLike, deviceTarget,);
     this.target = originalEvent.target || null;
     const lastEvent = session && session.lastEvent;
-    if (originalEvent instanceof WheelEvent) {
-      this.delta = {
-        x: originalEvent.deltaX,
-        y: originalEvent.deltaY,
-      };
-    } else if (lastEvent && this.devicePoint && lastEvent.devicePoint) {
-      this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint,);
-    } else {
-      this.delta = {
-        x: 0,
-        y: 0,
-      };
-    }
+    if (originalEvent instanceof WheelEvent) this.delta = { x: originalEvent.deltaX, y: originalEvent.deltaY, };
+    else if (lastEvent && this.devicePoint && lastEvent.devicePoint) this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint,);
+    else this.delta = { x: 0, y: 0, };
   }
   static eventLikeFromOriginalEvent(originalEvent,) {
     if ('touches' in originalEvent) {
       let touches = originalEvent.touches;
       if (!touches || !touches.length) {
-        if (originalEvent.changedTouches && originalEvent.changedTouches.length) {
-          touches = originalEvent.changedTouches;
-        }
+        if (originalEvent.changedTouches && originalEvent.changedTouches.length) touches = originalEvent.changedTouches;
       }
       const firstTouch = touches[0];
-      if (!touches || !firstTouch) {
-        return {
-          pageX: 0,
-          pageY: 0,
-          target: null,
-        };
-      }
+      if (!touches || !firstTouch) return { pageX: 0, pageY: 0, target: null, };
       const pageX = firstTouch.clientX || firstTouch.screenX || firstTouch.pageX;
       const pageY = firstTouch.clientY || firstTouch.screenY || firstTouch.pageY;
-      return {
-        pageX,
-        pageY,
-        target: originalEvent.target,
-      };
+      return { pageX, pageY, target: originalEvent.target, };
     }
     return originalEvent;
-  }
-  /**
+  } /**
    * @internal
    */
+
   velocity(t,) {
-    return this.session ? this.session.velocity(t,) : {
-      x: 0,
-      y: 0,
-    };
-  }
-  /**
+    return this.session ? this.session.velocity(t,) : { x: 0, y: 0, };
+  } /**
    * @internal
    */
+
   get offset() {
-    return this.session ? this.session.offset(this,) : {
-      x: 0,
-      y: 0,
-    };
-  }
-  /**
+    return this.session ? this.session.offset(this,) : { x: 0, y: 0, };
+  } /**
    * @internal
    */
+
   get isLeftMouseClick() {
-    if (environment.isTouch()) {
-      return void 0;
-    }
+    if (environment.isTouch()) return void 0;
     if ('button' in this.originalEvent && 'buttons' in this.originalEvent && 'ctrlKey' in this.originalEvent) {
       return (this.originalEvent.button === 0 || this.originalEvent.buttons === 1) && !this.originalEvent.ctrlKey;
     }
@@ -22302,33 +17125,21 @@ var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs
 var clamp2 = (value, a, b,) => {
   const min = Math.min(a, b,);
   const max = Math.max(a, b,);
-  if (value < min) {
-    value = min;
-  }
-  if (value > max) {
-    value = max;
-  }
+  if (value < min) value = min;
+  if (value > max) value = max;
   return value;
 };
-var DraggingContext = React__default.createContext({
-  dragging: false,
-},);
+var DraggingContext = React__default.createContext({ dragging: false, },);
 function WithDragging(Component14,) {
   const _WithDraggingHOC = class extends React__default.Component {
     constructor(props, defaultProps,) {
       super(props, defaultProps,);
-      __publicField(this, 'state', {
-        isDragging: false,
-      },);
+      __publicField(this, 'state', { isDragging: false, },);
       __publicField(this, 'x', Animatable(0,),);
       __publicField(this, 'y', Animatable(0,),);
       __publicField(this, 'onChangePosition', (change, transaction,) => {
-        if (change.value === change.oldValue) {
-          return;
-        }
-        if (this.props.onMove) {
-          this.props.onMove(this.point, this,);
-        }
+        if (change.value === change.oldValue) return;
+        if (this.props.onMove) this.props.onMove(this.point, this,);
       },);
       __publicField(this, 'isMoving', false,);
       __publicField(this, 'isAnimating', false,);
@@ -22339,9 +17150,7 @@ function WithDragging(Component14,) {
       __publicField(this, '_constraints', null,);
       __publicField(this, 'animation',);
       __publicField(this, 'panStart', (event) => {
-        if (!this.props.enabled) {
-          return;
-        }
+        if (!this.props.enabled) return;
         this.isMoving = this.isAnimating;
         this.stopAnimation();
         this.resetdirectionLock();
@@ -22355,14 +17164,8 @@ function WithDragging(Component14,) {
           );
         }
         this.previousPoint = this.correctedLayerStartPoint;
-        if (!this.state.isDragging) {
-          this.setState({
-            isDragging: true,
-          },);
-        }
-        if (this.props.onDragSessionStart) {
-          this.props.onDragSessionStart(event, this,);
-        }
+        if (!this.state.isDragging) this.setState({ isDragging: true, },);
+        if (this.props.onDragSessionStart) this.props.onDragSessionStart(event, this,);
       },);
       __publicField(this, 'pan', (event) => {
         const {
@@ -22379,20 +17182,12 @@ function WithDragging(Component14,) {
           onDragDidMove,
           onDragSessionMove,
         } = this.props;
-        if (!enabled) {
-          return;
-        }
-        let point2 = {
-          ...this.previousPoint,
-        };
+        if (!enabled) return;
+        let point2 = { ...this.previousPoint, };
         point2.x += event.delta.x * speedX;
         point2.y += event.delta.y * speedY;
-        this.previousPoint = {
-          ...point2,
-        };
-        if (this._constraints) {
-          point2 = this.constrainPosition(point2, this._constraints, overdragScale,);
-        }
+        this.previousPoint = { ...point2, };
+        if (this._constraints) point2 = this.constrainPosition(point2, this._constraints, overdragScale,);
         if (directionLock) {
           if (this.directionLockAxis === null) {
             const offset = event.offset;
@@ -22401,69 +17196,35 @@ function WithDragging(Component14,) {
             this.updatedirectionLock(offset,);
             return;
           } else {
-            if (this.directionLockAxis === 'y') {
-              point2.x = this.layerStartPoint.x;
-            }
-            if (this.directionLockAxis === 'x') {
-              point2.y = this.layerStartPoint.y;
-            }
+            if (this.directionLockAxis === 'y') point2.x = this.layerStartPoint.x;
+            if (this.directionLockAxis === 'x') point2.y = this.layerStartPoint.y;
           }
         }
         if (!this.state.isDragging) {
-          this.setState({
-            isDragging: true,
-          },);
+          this.setState({ isDragging: true, },);
           this.isMoving = true;
-          if (onDragStart) {
-            onDragStart(event, this,);
-          }
-        }
-        if (onDragWillMove) {
-          onDragWillMove(event, this,);
+          if (onDragStart) onDragStart(event, this,);
         }
+        if (onDragWillMove) onDragWillMove(event, this,);
         if (pixelAlign) {
           point2.x = Math.round(point2.x,);
           point2.y = Math.round(point2.y,);
         }
-        if (!horizontal && !vertical) {
-          return;
-        }
+        if (!horizontal && !vertical) return;
         let axis = null;
-        if (horizontal && !vertical) {
-          axis = 'x';
-        } else if (vertical && !horizontal) {
-          axis = 'y';
-        }
+        if (horizontal && !vertical) axis = 'x';
+        else if (vertical && !horizontal) axis = 'y';
         this.setPoint(point2, axis,);
-        if (onDragDidMove) {
-          onDragDidMove(event, this,);
-        }
-        if (onDragSessionMove) {
-          onDragSessionMove(event, this,);
-        }
+        if (onDragDidMove) onDragDidMove(event, this,);
+        if (onDragSessionMove) onDragSessionMove(event, this,);
       },);
       __publicField(this, 'panEnd', (event) => {
-        if (!this.props.enabled) {
-          return;
-        }
+        if (!this.props.enabled) return;
         this.startAnimation(event,);
-        const {
-          onDragSessionEnd,
-          onDragEnd,
-        } = this.props;
-        if (this.state.isDragging) {
-          if (onDragEnd) {
-            onDragEnd(event, this,);
-          }
-        }
-        if (onDragSessionEnd) {
-          onDragSessionEnd(event, this,);
-        }
-        if (this.state.isDragging) {
-          this.setState({
-            isDragging: false,
-          },);
-        }
+        const { onDragSessionEnd, onDragEnd, } = this.props;
+        if (this.state.isDragging) if (onDragEnd) onDragEnd(event, this,);
+        if (onDragSessionEnd) onDragSessionEnd(event, this,);
+        if (this.state.isDragging) this.setState({ isDragging: false, },);
         this.isMoving = this.isAnimating;
       },);
       __publicField(this, 'mouseWheelStart', (event) => {
@@ -22472,160 +17233,84 @@ function WithDragging(Component14,) {
         this.stopAnimation();
       },);
       __publicField(this, 'mouseWheel', (event) => {
-        const {
-          enabled,
-          speedX,
-          speedY,
-          vertical,
-          horizontal,
-          pixelAlign,
-          onDragWillMove,
-          onDragDidMove,
-          mouseWheel,
-        } = this.props;
-        if (!mouseWheel || !enabled) {
-          return;
-        }
-        let point2 = {
-          ...this.point,
-        };
+        const { enabled, speedX, speedY, vertical, horizontal, pixelAlign, onDragWillMove, onDragDidMove, mouseWheel, } = this.props;
+        if (!mouseWheel || !enabled) return;
+        let point2 = { ...this.point, };
         point2.x -= event.delta.x * speedX;
         point2.y -= event.delta.y * speedY;
-        if (this._constraints) {
-          point2 = this.constrainPosition(point2, this._constraints, 0, false,);
-        }
-        if (onDragWillMove) {
-          onDragWillMove(event, this,);
-        }
+        if (this._constraints) point2 = this.constrainPosition(point2, this._constraints, 0, false,);
+        if (onDragWillMove) onDragWillMove(event, this,);
         if (pixelAlign) {
           point2.x = Math.round(point2.x,);
           point2.y = Math.round(point2.y,);
         }
-        if (!horizontal && !vertical) {
-          return;
-        }
+        if (!horizontal && !vertical) return;
         let axis = null;
-        if (horizontal && !vertical) {
-          axis = 'x';
-        } else if (vertical && !horizontal) {
-          axis = 'y';
-        }
+        if (horizontal && !vertical) axis = 'x';
+        else if (vertical && !horizontal) axis = 'y';
         this.setPoint(point2, axis,);
-        if (onDragDidMove) {
-          onDragDidMove(event, this,);
-        }
+        if (onDragDidMove) onDragDidMove(event, this,);
       },);
       __publicField(this, 'mouseWheelEnd', (event) => {},);
       __publicField(this, 'onAnimationStep', (axis, value,) => {
-        if (axis === 'x' && this.props.horizontal === false) {
-          return;
-        }
-        if (axis === 'y' && this.props.vertical === false) {
-          return;
-        }
+        if (axis === 'x' && this.props.horizontal === false) return;
+        if (axis === 'y' && this.props.vertical === false) return;
         let delta = 0;
         if (this.constraints) {
-          if (this.props.bounce) {
-            delta = value - this.getValue(axis,);
-          } else {
-            const {
-              minX,
-              minY,
-              maxX,
-              maxY,
-            } = this.calculateConstraints(this._constraints,);
-            if (axis === 'x') {
-              delta = clamp2(value, minX, maxX,) - this.getValue(axis,);
-            }
-            if (axis === 'y') {
-              delta = clamp2(value, minY, maxY,) - this.getValue(axis,);
-            }
+          if (this.props.bounce) delta = value - this.getValue(axis,);
+          else {
+            const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
+            if (axis === 'x') delta = clamp2(value, minX, maxX,) - this.getValue(axis,);
+            if (axis === 'y') delta = clamp2(value, minY, maxY,) - this.getValue(axis,);
           }
-        } else {
-          delta = value - this.getValue(axis,);
-        }
+        } else delta = value - this.getValue(axis,);
         const updatePoint = this.point;
-        if (axis === 'x') {
-          updatePoint[axis] = updatePoint[axis] + delta;
-        }
-        if (axis === 'y') {
-          updatePoint[axis] = updatePoint[axis] + delta;
-        }
+        if (axis === 'x') updatePoint[axis] = updatePoint[axis] + delta;
+        if (axis === 'y') updatePoint[axis] = updatePoint[axis] + delta;
         this.setPoint(updatePoint, axis,);
       },);
       __publicField(this, 'onAnimationStop', (axis) => {
-        if (axis === 'x' && this.props.horizontal === false) {
-          return;
-        }
-        if (axis === 'y' && this.props.vertical === false) {
-          return;
-        }
-        if (!this.animation) {
-          return;
-        }
+        if (axis === 'x' && this.props.horizontal === false) return;
+        if (axis === 'y' && this.props.vertical === false) return;
+        if (!this.animation) return;
         if (this.props.pixelAlign) {
           const point2 = this.point;
           point2.x = Math.round(point2.x,);
           point2.y = Math.round(point2.y,);
           this.setPoint(point2, axis,);
         }
-        if (this.animation.x.isFinished() && this.animation.y.isFinished()) {
-          return this.stopAnimation();
-        }
+        if (this.animation.x.isFinished() && this.animation.y.isFinished()) return this.stopAnimation();
       },);
       __publicField(this, 'stopAnimation', () => {
         this.isAnimating = false;
         this.isMoving = false;
-        if (!this.animation) {
-          return;
-        }
+        if (!this.animation) return;
         this.animation.x.cancel();
         this.animation.y.cancel();
-        if (this.props.onDragAnimationEnd) {
-          this.props.onDragAnimationEnd(this.animation, this,);
-        }
+        if (this.props.onDragAnimationEnd) this.props.onDragAnimationEnd(this.animation, this,);
         this.animation = null;
       },);
       const x = this.props.left;
       const y = this.props.top;
-      if (!x) {
-        this.x = Animatable(0,);
-      } else if (isAnimatable2(x,)) {
-        this.x = x;
-      } else {
-        this.x = Animatable(x,);
-      }
-      if (!y) {
-        this.y = Animatable(0,);
-      } else if (isAnimatable2(y,)) {
-        this.y = y;
-      } else {
-        this.y = Animatable(y,);
-      }
+      if (!x) this.x = Animatable(0,);
+      else if (isAnimatable2(x,)) this.x = x;
+      else this.x = Animatable(x,);
+      if (!y) this.y = Animatable(0,);
+      else if (isAnimatable2(y,)) this.y = y;
+      else this.y = Animatable(y,);
       this.x.onUpdate(this.onChangePosition,);
       this.y.onUpdate(this.onChangePosition,);
       const constraints = this.props.constraints;
-      if (constraints) {
-        this.constraints = constraints;
-      }
+      if (constraints) this.constraints = constraints;
     }
     UNSAFE_componentWillReceiveProps(props,) {
-      if (this.props.left !== props.left && isFiniteNumber(props.left,)) {
-        this.x.set(props.left,);
-      }
-      if (this.props.top !== props.top && isFiniteNumber(props.top,)) {
-        this.y.set(props.top,);
-      }
+      if (this.props.left !== props.left && isFiniteNumber(props.left,)) this.x.set(props.left,);
+      if (this.props.top !== props.top && isFiniteNumber(props.top,)) this.y.set(props.top,);
       const constraints = props.constraints;
-      if (constraints) {
-        this.constraints = constraints;
-      }
+      if (constraints) this.constraints = constraints;
     }
     get point() {
-      return {
-        x: this.x.get(),
-        y: this.y.get(),
-      };
+      return { x: this.x.get(), y: this.y.get(), };
     }
     setPoint(point2, axis = null,) {
       switch (axis) {
@@ -22651,28 +17336,16 @@ function WithDragging(Component14,) {
     }
     get width() {
       const width = this.props.width;
-      if (!width) {
-        return 100;
-      }
-      if (isAnimatable2(width,)) {
-        return width.get();
-      }
-      if (typeof width === 'string') {
-        return parseFloat(width,);
-      }
+      if (!width) return 100;
+      if (isAnimatable2(width,)) return width.get();
+      if (typeof width === 'string') return parseFloat(width,);
       return width;
     }
     get height() {
       const height = this.props.height;
-      if (!height) {
-        return 100;
-      }
-      if (isAnimatable2(height,)) {
-        return height.get();
-      }
-      if (typeof height === 'string') {
-        return parseFloat(height,);
-      }
+      if (!height) return 100;
+      if (isAnimatable2(height,)) return height.get();
+      if (typeof height === 'string') return parseFloat(height,);
       return height;
     }
     get constraints() {
@@ -22680,141 +17353,66 @@ function WithDragging(Component14,) {
     }
     set constraints(value,) {
       if (value !== null && typeof value === 'object') {
-        this._constraints = {
-          x: value.x || 0,
-          y: value.y || 0,
-          width: value.width || 0,
-          height: value.height || 0,
-        };
-      } else {
-        this._constraints = null;
-      }
-      if (this._constraints) {
-        this.updateAnimationConstraints(this._constraints,);
-      }
+        this._constraints = { x: value.x || 0, y: value.y || 0, width: value.width || 0, height: value.height || 0, };
+      } else this._constraints = null;
+      if (this._constraints) this.updateAnimationConstraints(this._constraints,);
     }
     get constraintsOffset() {
-      if (!this.constraints) {
-        return {
-          x: 0,
-          y: 0,
-        };
-      }
-      const {
-        minX,
-        minY,
-        maxX,
-        maxY,
-      } = this.calculateConstraints(this._constraints,);
+      if (!this.constraints) return { x: 0, y: 0, };
+      const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
       const point2 = this.point;
-      const constrainedPoint = {
-        x: clamp2(point2.x, minX, maxX,),
-        y: clamp2(point2.y, minY, maxY,),
-      };
-      const offset = {
-        x: point2.x - constrainedPoint.x,
-        y: point2.y - constrainedPoint.y,
-      };
+      const constrainedPoint = { x: clamp2(point2.x, minX, maxX,), y: clamp2(point2.y, minY, maxY,), };
+      const offset = { x: point2.x - constrainedPoint.x, y: point2.y - constrainedPoint.y, };
       return offset;
     }
     get isBeyondConstraints() {
       const constraintsOffset = this.constraintsOffset;
-      if (constraintsOffset.x !== 0) {
-        return true;
-      }
-      if (constraintsOffset.y !== 0) {
-        return true;
-      }
+      if (constraintsOffset.x !== 0) return true;
+      if (constraintsOffset.y !== 0) return true;
       return false;
     }
     clampAndScale(value, min, max, scale2, scaleAllowed,) {
-      if (!scaleAllowed) {
-        return clamp2(value, min, max,);
-      }
-      if (value < min) {
-        value = min + (value - min) * scale2;
-      }
-      if (value > max) {
-        value = max + (value - max) * scale2;
-      }
+      if (!scaleAllowed) return clamp2(value, min, max,);
+      if (value < min) value = min + (value - min) * scale2;
+      if (value > max) value = max + (value - max) * scale2;
       return value;
     }
     calculateConstraints(bounds,) {
-      if (!bounds) {
-        return {
-          minX: Infinity,
-          maxX: Infinity,
-          minY: Infinity,
-          maxY: Infinity,
-        };
-      }
-      if (bounds.width < this.width) {
-        bounds.width = this.width;
-      }
-      if (bounds.height < this.height) {
-        bounds.height = this.height;
-      }
-      const constraints = {
-        minX: Rect.minX(bounds,),
-        maxX: Rect.maxX(bounds,),
-        minY: Rect.minY(bounds,),
-        maxY: Rect.maxY(bounds,),
-      };
+      if (!bounds) return { minX: Infinity, maxX: Infinity, minY: Infinity, maxY: Infinity, };
+      if (bounds.width < this.width) bounds.width = this.width;
+      if (bounds.height < this.height) bounds.height = this.height;
+      const constraints = { minX: Rect.minX(bounds,), maxX: Rect.maxX(bounds,), minY: Rect.minY(bounds,), maxY: Rect.maxY(bounds,), };
       constraints.maxX -= this.width;
       constraints.maxY -= this.height;
       return constraints;
     }
     constrainPosition(proposedPoint, bounds, scale2, overdrag = this.props.overdrag,) {
-      const {
-        maxX,
-        maxY,
-        minX,
-        minY,
-      } = this.calculateConstraints(this._constraints,);
+      const { maxX, maxY, minX, minY, } = this.calculateConstraints(this._constraints,);
       const point2 = {
         x: this.clampAndScale(proposedPoint.x, minX, maxX, scale2, overdrag,),
         y: this.clampAndScale(proposedPoint.y, minY, maxY, scale2, overdrag,),
       };
-      if (this.props.speedX === 0 || this.props.horizontal === false) {
-        point2.x = proposedPoint.x;
-      }
-      if (this.props.speedY === 0 || this.props.vertical === false) {
-        point2.y = proposedPoint.y;
-      }
+      if (this.props.speedX === 0 || this.props.horizontal === false) point2.x = proposedPoint.x;
+      if (this.props.speedY === 0 || this.props.vertical === false) point2.y = proposedPoint.y;
       return point2;
-    }
-    /* private */
+    } /* private */
     updatedirectionLock(correctedDelta,) {
-      if (Math.abs(correctedDelta.y,) > this.props.directionLockThreshold.y) {
-        this.directionLockAxis = 'y';
-      } else if (Math.abs(correctedDelta.x,) > this.props.directionLockThreshold.x) {
-        this.directionLockAxis = 'x';
-      }
+      if (Math.abs(correctedDelta.y,) > this.props.directionLockThreshold.y) this.directionLockAxis = 'y';
+      else if (Math.abs(correctedDelta.x,) > this.props.directionLockThreshold.x) this.directionLockAxis = 'x';
       if (this.directionLockAxis !== null) {
-        if (this.props.onDragDirectionLockStart) {
-          this.props.onDragDirectionLockStart(this.directionLockAxis, this,);
-        }
+        if (this.props.onDragDirectionLockStart) this.props.onDragDirectionLockStart(this.directionLockAxis, this,);
       }
     }
     resetdirectionLock() {
       this.directionLockAxis = null;
-    }
-    // Inertial scroll animation
+    } // Inertial scroll animation
     setupAnimation() {
-      if (this.animation) {
-        return;
-      }
-      this.animation = {
-        x: this.setupAnimationForAxis('x',),
-        y: this.setupAnimationForAxis('y',),
-      };
+      if (this.animation) return;
+      this.animation = { x: this.setupAnimationForAxis('x',), y: this.setupAnimationForAxis('y',), };
       this.updateAnimationConstraints(this._constraints,);
     }
     setupAnimationForAxis(axis,) {
-      const animator = new InertialScrollAnimator({
-        momentum: this.props.momentumOptions,
-        bounce: this.props.bounceOptions,
-      },);
+      const animator = new InertialScrollAnimator({ momentum: this.props.momentumOptions, bounce: this.props.bounceOptions, },);
       const updateCallback = (value) => {
         this.onAnimationStep(axis, value,);
       };
@@ -22824,16 +17422,9 @@ function WithDragging(Component14,) {
       return new MainLoopAnimationDriver(animator, updateCallback, doneCallback,);
     }
     updateAnimationConstraints(constraints,) {
-      if (!this.animation) {
-        return;
-      }
+      if (!this.animation) return;
       if (constraints) {
-        const {
-          minX,
-          minY,
-          maxX,
-          maxY,
-        } = this.calculateConstraints(constraints,);
+        const { minX, minY, maxX, maxY, } = this.calculateConstraints(constraints,);
         this.animation.x.animator.setLimits(minX, maxX,);
         this.animation.y.animator.setLimits(minY, maxY,);
       } else {
@@ -22842,90 +17433,39 @@ function WithDragging(Component14,) {
       }
     }
     startAnimation(event,) {
-      const {
-        momentum,
-        bounce,
-        momentumVelocityMultiplier,
-        speedX,
-        speedY,
-        overdrag,
-        onDragAnimationStart,
-      } = this.props;
-      if (!(momentum || bounce)) {
-        return;
-      }
-      if (this.isBeyondConstraints === false && momentum === false) {
-        return;
-      }
-      if (this.isBeyondConstraints === false && this.state.isDragging === false) {
-        return;
-      }
-      const {
-        minX,
-        minY,
-        maxX,
-        maxY,
-      } = this.calculateConstraints(this._constraints,);
+      const { momentum, bounce, momentumVelocityMultiplier, speedX, speedY, overdrag, onDragAnimationStart, } = this.props;
+      if (!(momentum || bounce)) return;
+      if (this.isBeyondConstraints === false && momentum === false) return;
+      if (this.isBeyondConstraints === false && this.state.isDragging === false) return;
+      const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
       const startAnimationX = overdrag === true || this.point.x > minX && this.point.x < maxX;
       const startAnimationY = overdrag === true || this.point.y > minY && this.point.y < maxY;
-      if (startAnimationX === startAnimationY && startAnimationY === false) {
-        return;
-      }
+      if (startAnimationX === startAnimationY && startAnimationY === false) return;
       const velocity = event.velocity(0.1,);
       let velocityX = velocity.x * momentumVelocityMultiplier * speedX;
       let velocityY = velocity.y * momentumVelocityMultiplier * speedY;
-      if (this.directionLockAxis === 'x') {
-        velocityY = 0;
-      }
-      if (this.directionLockAxis === 'y') {
-        velocityX = 0;
-      }
+      if (this.directionLockAxis === 'x') velocityY = 0;
+      if (this.directionLockAxis === 'y') velocityX = 0;
       this.setupAnimation();
       this.isAnimating = true;
       this.isMoving = true;
-      if (!this.animation) {
-        return;
-      }
-      this.animation.x.animator.setState({
-        x: this.point.x,
-        v: velocityX,
-      },);
-      if (startAnimationX) {
-        this.animation.x.play();
-      }
-      this.animation.y.animator.setState({
-        x: this.point.y,
-        v: velocityY,
-      },);
-      if (startAnimationY) {
-        this.animation.y.play();
-      }
-      if (onDragAnimationStart) {
-        onDragAnimationStart(this.animation, this,);
-      }
+      if (!this.animation) return;
+      this.animation.x.animator.setState({ x: this.point.x, v: velocityX, },);
+      if (startAnimationX) this.animation.x.play();
+      this.animation.y.animator.setState({ x: this.point.y, v: velocityY, },);
+      if (startAnimationY) this.animation.y.play();
+      if (onDragAnimationStart) onDragAnimationStart(this.animation, this,);
     }
     wrapHandler(ownHandler, originalHandler,) {
-      if (!originalHandler) {
-        return ownHandler;
-      }
+      if (!originalHandler) return ownHandler;
       return (event) => {
         ownHandler(event,);
         originalHandler(event,);
       };
     }
     render() {
-      const {
-        onPanStart,
-        onPan,
-        onPanEnd,
-        onMouseWheelStart,
-        onMouseWheel,
-        onMouseWheelEnd,
-        ...attributes
-      } = this.props;
-      const originalProps = {
-        ...attributes,
-      };
+      const { onPanStart, onPan, onPanEnd, onMouseWheelStart, onMouseWheel, onMouseWheelEnd, ...attributes } = this.props;
+      const originalProps = { ...attributes, };
       Object.keys(_WithDraggingHOC.draggingDefaultProps,).forEach((key7) => {
         delete asRecord(originalProps,)[key7];
       },);
@@ -22938,36 +17478,22 @@ function WithDragging(Component14,) {
       originalProps.left = this.x;
       originalProps.top = this.y;
       return /* @__PURE__ */ _jsx5(DraggingContext.Provider, {
-        value: {
-          dragging: this.state.isDragging,
-        },
-        children: /* @__PURE__ */ _jsx5(Component14, {
-          ...originalProps,
-        },),
+        value: { dragging: this.state.isDragging, },
+        children: /* @__PURE__ */ _jsx5(Component14, { ...originalProps, },),
       },);
     }
   };
   let WithDraggingHOC = _WithDraggingHOC;
   __publicField(WithDraggingHOC, 'draggingDefaultProps', {
     momentum: true,
-    momentumOptions: {
-      friction: 2.1,
-      tolerance: 1,
-    },
+    momentumOptions: { friction: 2.1, tolerance: 1, },
     momentumVelocityMultiplier: 800,
     speedX: 1,
     speedY: 1,
     bounce: true,
-    bounceOptions: {
-      friction: 40,
-      tension: 200,
-      tolerance: 1,
-    },
+    bounceOptions: { friction: 40, tension: 200, tolerance: 1, },
     directionLock: false,
-    directionLockThreshold: {
-      x: 10,
-      y: 10,
-    },
+    directionLockThreshold: { x: 10, y: 10, },
     overdrag: true,
     overdragScale: 0.5,
     pixelAlign: true,
@@ -22984,10 +17510,7 @@ function WithDragging(Component14,) {
   (0, import_hoist_non_react_statics.default)(withDragging, Component14,);
   return withDragging;
 }
-var hoverProps = {
-  onMouseEnter: 'mouseenter',
-  onMouseLeave: 'mouseleave',
-};
+var hoverProps = { onMouseEnter: 'mouseenter', onMouseLeave: 'mouseleave', };
 var hoverEventKeys = Object.keys(hoverProps,);
 var eventHandlerMapping = {
   panstart: ['onPanStart',],
@@ -23025,20 +17548,15 @@ function WithEvents(BaseComponent,) {
     }
     addEventListeners(prevProps,) {
       if (this.element && !this.hasFramerEventListener) {
-        this.element.addEventListener('FramerEvent', ({
-          detail,
-        },) => {
+        this.element.addEventListener('FramerEvent', ({ detail, },) => {
           const type = detail.type;
           const framerEvent = detail.event;
           this.handleEvent(type, framerEvent,);
         },);
         hoverEventKeys.forEach((eventName) => this.addHoverEvent(eventName,));
         this.hasFramerEventListener = true;
-      } else if (this.element && prevProps) {
-        hoverEventKeys.forEach((eventName) => this.checkHoverEvent(eventName, prevProps,));
-      } else if (!this.element) {
-        this.hasFramerEventListener = false;
-      }
+      } else if (this.element && prevProps) hoverEventKeys.forEach((eventName) => this.checkHoverEvent(eventName, prevProps,));
+      else if (!this.element) this.hasFramerEventListener = false;
     }
     removeEventListeners() {
       hoverEventKeys.forEach((eventName) => this.removeHoverEvent(eventName,));
@@ -23075,19 +17593,14 @@ function WithEvents(BaseComponent,) {
       eventListenerKeys.forEach((eventKey) => {
         const eventListener = this.props[eventKey];
         const cancelEvent = this.shouldCancelTap && tapEventKeys.has(eventKey,);
-        if (eventListener && !cancelEvent) {
-          eventListener(framerEvent,);
-        }
+        if (eventListener && !cancelEvent) eventListener(framerEvent,);
       },);
     }
     render() {
       return /* @__PURE__ */ _jsx5(DraggingContext.Consumer, {
         children: (value) => {
           this.shouldCancelTap = value.dragging;
-          return /* @__PURE__ */ _jsx5(BaseComponent, {
-            ...this.props,
-            ref: this.component,
-          },);
+          return /* @__PURE__ */ _jsx5(BaseComponent, { ...this.props, ref: this.component, },);
         },
       },);
     }
@@ -23110,11 +17623,8 @@ var ObservableObject = /* @__PURE__ */ (() => {
           for (const key7 in state) {
             if (hasOwnProperty(state, key7,)) {
               const value = hasOwnProperty(initial, key7,) ? asRecord(initial,)[key7] : void 0;
-              if (value !== void 0) {
-                state[key7] = value;
-              } else {
-                delete state[key7];
-              }
+              if (value !== void 0) state[key7] = value;
+              else delete state[key7];
             }
           }
         },
@@ -23136,18 +17646,14 @@ var ObservableObject = /* @__PURE__ */ (() => {
 var ObservableObjectProxyHandler = class {
   constructor() {
     __publicField(this, 'set', (target, key7, value, receiver,) => {
-      if (key7 === $private) {
-        return false;
-      }
+      if (key7 === $private) return false;
       const privateObject = target[$private];
       let animatable;
       let rawValue;
       if (isAnimatable2(value,)) {
         animatable = value;
         rawValue = animatable.get();
-      } else {
-        rawValue = value;
-      }
+      } else rawValue = value;
       if (privateObject.makeAnimatables && typeof value !== 'function' && typeof value !== 'object' && !animatable) {
         animatable = Animatable(value,);
       }
@@ -23155,17 +17661,11 @@ var ObservableObjectProxyHandler = class {
         const transactions = privateObject.transactions;
         animatable.onUpdate({
           update: (change, transaction,) => {
-            if (transaction) {
-              transactions.add(transaction,);
-            }
-            privateObject.observers.notify({
-              value: receiver,
-            }, transaction,);
+            if (transaction) transactions.add(transaction,);
+            privateObject.observers.notify({ value: receiver, }, transaction,);
           },
           finish: (transaction) => {
-            if (transactions.delete(transaction,)) {
-              privateObject.observers.finishTransaction(transaction,);
-            }
+            if (transactions.delete(transaction,)) privateObject.observers.finishTransaction(transaction,);
           },
         },);
       }
@@ -23184,45 +17684,31 @@ var ObservableObjectProxyHandler = class {
         if (Array.isArray(rawValue,) || rawValueIsObject) changed = true;
         result = true;
       } else {
-        if (animatable) {
-          value = animatable;
-        }
+        if (animatable) value = animatable;
         result = Reflect.set(target, key7, value,);
       }
-      if (changed) {
-        privateObject.observers.notify({
-          value: receiver,
-        },);
-      }
+      if (changed) privateObject.observers.notify({ value: receiver, },);
       return result;
     },);
     __publicField(this, 'get', (target, key7, receiver,) => {
-      if (key7 === $private) {
-        return asRecord(target,)[key7];
-      }
+      if (key7 === $private) return asRecord(target,)[key7];
       const value = Reflect.get(target, key7, receiver,);
       return typeof value === 'function' ? value.bind(receiver,) : value;
     },);
   }
   deleteProperty(target, key7,) {
     const result = Reflect.deleteProperty(target, key7,);
-    target[$private].observers.notify({
-      value: target,
-    },);
+    target[$private].observers.notify({ value: target, },);
     return result;
   }
   ownKeys(target,) {
     const keys3 = Reflect.ownKeys(target,);
     const privateIndex = keys3.indexOf($private,);
-    if (privateIndex !== -1) {
-      keys3.splice(privateIndex, 1,);
-    }
+    if (privateIndex !== -1) keys3.splice(privateIndex, 1,);
     return keys3;
   }
   getOwnPropertyDescriptor(target, key7,) {
-    if (key7 === $private) {
-      return void 0;
-    }
+    if (key7 === $private) return void 0;
     return Reflect.getOwnPropertyDescriptor(target, key7,);
   }
 };
@@ -23242,9 +17728,7 @@ function collectOpacityFromProps(props, style,) {
   style.opacity = opacity;
 }
 function collectOverflowFromProps(props, style,) {
-  if (props.overflow) {
-    style.overflow = props.overflow;
-  }
+  if (props.overflow) style.overflow = props.overflow;
 }
 var key4 = 'radius';
 function hasRadius(props,) {
@@ -23252,11 +17736,8 @@ function hasRadius(props,) {
 }
 function getRadiusValue(value,) {
   let num = Number(value,);
-  if (typeof value === 'string' && isNaN(num,)) {
-    return value;
-  } else if (isAnimatable2(value,)) {
-    num = Animatable.getNumber(value,);
-  }
+  if (typeof value === 'string' && isNaN(num,)) return value;
+  else if (isAnimatable2(value,)) num = Animatable.getNumber(value,);
   return num ? `${num}px` : '0';
 }
 function hasRadiusValue(value,) {
@@ -23264,9 +17745,7 @@ function hasRadiusValue(value,) {
 }
 function collectRadiusFromProps(props, style,) {
   if (!hasRadius(props,)) return;
-  const {
-    radius,
-  } = props;
+  const { radius, } = props;
   if (typeof radius === 'string' || isAnimatable2(radius,) || isFiniteNumber(radius,)) {
     const radiusValue = getRadiusValue(radius,);
     if (hasRadiusValue(radiusValue,)) {
@@ -23290,14 +17769,9 @@ function collectRadiusFromProps(props, style,) {
   }
 }
 function collectTextColorFromProps(props, style,) {
-  const {
-    color: color2,
-  } = props;
-  if (typeof color2 === 'string') {
-    style.color = color2;
-  } else if (Color.isColorObject(color2,)) {
-    style.color = color2.initialValue || Color.toRgbString(color2,);
-  }
+  const { color: color2, } = props;
+  if (typeof color2 === 'string') style.color = color2;
+  else if (Color.isColorObject(color2,)) style.color = color2.initialValue || Color.toRgbString(color2,);
 }
 var shadowKeys = ['color', 'x', 'y', 'blur',];
 var Shadow = {
@@ -23348,14 +17822,8 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
   const insetShadows = [];
   const boxShadowsCount = boxShadows.length;
   const svgShadowClass = 'svg-shadow';
-  const svgShadowProps = RenderTarget.current() === 'CANVAS'
-    ? {
-      className: svgShadowClass,
-    }
-    : {};
-  for (const shadow of boxShadows) {
-    shadow.inset ? insetShadows.push(shadow,) : shadows.push(shadow,);
-  }
+  const svgShadowProps = RenderTarget.current() === 'CANVAS' ? { className: svgShadowClass, } : {};
+  for (const shadow of boxShadows) shadow.inset ? insetShadows.push(shadow,) : shadows.push(shadow,);
   if (shadows.length > 0) {
     shadows.reverse();
     const outsideShadowId = shapeId.add('_shadow_out',);
@@ -23363,9 +17831,7 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
     const shadowRects = [normalizedFrame,];
     for (const shadow of shadows) {
       const shadowFrame = localShadowFrame(shadow, normalizedFrame, true,);
-      if (shadowFrame === null) {
-        continue;
-      }
+      if (shadowFrame === null) continue;
       shadowRects.push(shadowFrame,);
     }
     let maxBlur = 0;
@@ -23399,14 +17865,7 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
       height: `${filterHeight.toFixed(1,)}%`,
       filterUnits: 'objectBoundingBox',
       ...svgShadowProps,
-      children: [
-        filterElements,
-        shadows.length > 1
-          ? /* @__PURE__ */ _jsx5('feMerge', {
-            children: mergeElements,
-          },)
-          : null,
-      ],
+      children: [filterElements, shadows.length > 1 ? /* @__PURE__ */ _jsx5('feMerge', { children: mergeElements, },) : null,],
     }, outsideShadowId.id,),);
     outsetElement = /* @__PURE__ */ _jsx5('g', {
       filter: outsideShadowId.urlLink,
@@ -23430,9 +17889,7 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
     const shadowFrames = [normalizedFrame,];
     for (const shadow of insetShadows) {
       const shadowFrame = localShadowFrame(shadow, normalizedFrame, true,);
-      if (shadowFrame === null) {
-        continue;
-      }
+      if (shadowFrame === null) continue;
       shadowFrames.push(shadowFrame,);
     }
     const shadowRect = Rect.merge(...shadowFrames,);
@@ -23459,19 +17916,10 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
       height: `${filterHeight.toFixed(1,)}%`,
       filterUnits: 'objectBoundingBox',
       ...svgShadowProps,
-      children: [
-        filterElements,
-        insetShadows.length > 1
-          ? /* @__PURE__ */ _jsx5('feMerge', {
-            children: mergeElements,
-          },)
-          : null,
-      ],
+      children: [filterElements, insetShadows.length > 1 ? /* @__PURE__ */ _jsx5('feMerge', { children: mergeElements, },) : null,],
     }, insideShadowId.id,),);
     let clipPath;
-    if (needsStrokeClip) {
-      clipPath = strokeClipId.urlLink;
-    }
+    if (needsStrokeClip) clipPath = strokeClipId.urlLink;
     insetElement = /* @__PURE__ */ _jsx5('use', {
       fill: 'black',
       fillOpacity: '1',
@@ -23481,12 +17929,7 @@ function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strok
       ...svgShadowProps,
     },);
   }
-  return {
-    definition,
-    outsetElement,
-    insetElement,
-    needsStrokeClip,
-  };
+  return { definition, outsetElement, insetElement, needsStrokeClip, };
 }
 function outerShadowElements(shapeID, shadow, index,) {
   const shadowKey = shapeID.add('_outer_shadow' + index,);
@@ -23499,21 +17942,11 @@ function outerShadowElements(shapeID, shadow, index,) {
     offsetId: offsetResultId,
     matrixId: matrixResultId,
   }, shadowKey.id + '-filters',);
-  const mergeElement = /* @__PURE__ */ _jsx5('feMergeNode', {
-    in: matrixResultId,
-  }, shadowKey.id + '-merge',);
-  return {
-    filterElements,
-    mergeElement,
-  };
+  const mergeElement = /* @__PURE__ */ _jsx5('feMergeNode', { in: matrixResultId, }, shadowKey.id + '-merge',);
+  return { filterElements, mergeElement, };
 }
 var OuterShadowFilterElements = (props) => {
-  const {
-    shadow,
-    blurId,
-    offsetId,
-    matrixId,
-  } = props;
+  const { shadow, blurId, offsetId, matrixId, } = props;
   const color2 = shadow.color;
   const rgb = ConvertColor.toRgb(color2,);
   const r = roundedNumberString(rgb.r / 255, 3,);
@@ -23522,17 +17955,8 @@ var OuterShadowFilterElements = (props) => {
   const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b}  0 0 0 ${rgb.a} 0`;
   return /* @__PURE__ */ _jsxs(Fragment, {
     children: [
-      /* @__PURE__ */ _jsx5('feOffset', {
-        dx: shadow.x,
-        dy: shadow.y,
-        in: 'SourceAlpha',
-        result: offsetId,
-      },),
-      /* @__PURE__ */ _jsx5('feGaussianBlur', {
-        stdDeviation: shadow.blur / 2,
-        in: offsetId,
-        result: blurId,
-      },),
+      /* @__PURE__ */ _jsx5('feOffset', { dx: shadow.x, dy: shadow.y, in: 'SourceAlpha', result: offsetId, },),
+      /* @__PURE__ */ _jsx5('feGaussianBlur', { stdDeviation: shadow.blur / 2, in: offsetId, result: blurId, },),
       /* @__PURE__ */ _jsx5('feColorMatrix', {
         colorInterpolationFilters: 'sRGB',
         values: matrixValues,
@@ -23549,29 +17973,16 @@ function innerShadowElements(shapeID, shadow, index,) {
   const offsetId = shadowKey.add('offset',).id;
   const compositeId = shadowKey.add('composite',).id;
   const matrixId = shadowKey.add('matrix',).id;
-  const filterElements = /* @__PURE__ */ _jsx5(InnerShadowFilterElements, {
-    shadow,
-    blurId,
-    offsetId,
-    compositeId,
-    matrixId,
-  }, shadowKey.id + '-filters',);
-  const mergeElement = /* @__PURE__ */ _jsx5('feMergeNode', {
-    in: matrixId,
-  }, shadowKey.id + '-merge',);
-  return {
-    filterElements,
-    mergeElement,
-  };
+  const filterElements = /* @__PURE__ */ _jsx5(
+    InnerShadowFilterElements,
+    { shadow, blurId, offsetId, compositeId, matrixId, },
+    shadowKey.id + '-filters',
+  );
+  const mergeElement = /* @__PURE__ */ _jsx5('feMergeNode', { in: matrixId, }, shadowKey.id + '-merge',);
+  return { filterElements, mergeElement, };
 }
 var InnerShadowFilterElements = (props) => {
-  const {
-    shadow,
-    blurId,
-    offsetId,
-    compositeId,
-    matrixId,
-  } = props;
+  const { shadow, blurId, offsetId, compositeId, matrixId, } = props;
   const color2 = shadow.color;
   const rgb = ConvertColor.toRgb(color2,);
   const r = rgb.r / 255;
@@ -23580,17 +17991,8 @@ var InnerShadowFilterElements = (props) => {
   const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b}  0 0 0 ${rgb.a} 0`;
   return /* @__PURE__ */ _jsxs(Fragment, {
     children: [
-      /* @__PURE__ */ _jsx5('feGaussianBlur', {
-        stdDeviation: shadow.blur / 2,
-        in: 'SourceAlpha',
-        result: blurId,
-      },),
-      /* @__PURE__ */ _jsx5('feOffset', {
-        dx: shadow.x,
-        dy: shadow.y,
-        in: blurId,
-        result: offsetId,
-      },),
+      /* @__PURE__ */ _jsx5('feGaussianBlur', { stdDeviation: shadow.blur / 2, in: 'SourceAlpha', result: blurId, },),
+      /* @__PURE__ */ _jsx5('feOffset', { dx: shadow.x, dy: shadow.y, in: blurId, result: offsetId, },),
       /* @__PURE__ */ _jsx5('feComposite', {
         in: offsetId,
         in2: 'SourceAlpha',
@@ -23652,49 +18054,24 @@ function localShadowFrame(shadow, frame2, isSVG2 = false,) {
     maxY = shadow.y + frame2.height + growth;
   }
   if (maxX <= minX || maxY <= minY) return null;
-  return {
-    x: minX,
-    y: minY,
-    width: maxX - minX,
-    height: maxY - minY,
-  };
+  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, };
 }
 function collectLayerFilters(props, style,) {
   const filters = [];
-  if (isFiniteNumber(props.brightness,)) {
-    filters.push(`brightness(${props.brightness / 100})`,);
-  }
-  if (isFiniteNumber(props.contrast,)) {
-    filters.push(`contrast(${props.contrast / 100})`,);
-  }
-  if (isFiniteNumber(props.grayscale,)) {
-    filters.push(`grayscale(${props.grayscale / 100})`,);
-  }
-  if (isFiniteNumber(props.hueRotate,)) {
-    filters.push(`hue-rotate(${props.hueRotate}deg)`,);
-  }
-  if (isFiniteNumber(props.invert,)) {
-    filters.push(`invert(${props.invert / 100})`,);
-  }
-  if (isFiniteNumber(props.saturate,)) {
-    filters.push(`saturate(${props.saturate / 100})`,);
-  }
-  if (isFiniteNumber(props.sepia,)) {
-    filters.push(`sepia(${props.sepia / 100})`,);
-  }
-  if (isFiniteNumber(props.blur,)) {
-    filters.push(`blur(${props.blur}px)`,);
-  }
-  if (props.dropShadows) {
-    filters.push(...shadowsAsFilter(props.dropShadows,),);
-  }
+  if (isFiniteNumber(props.brightness,)) filters.push(`brightness(${props.brightness / 100})`,);
+  if (isFiniteNumber(props.contrast,)) filters.push(`contrast(${props.contrast / 100})`,);
+  if (isFiniteNumber(props.grayscale,)) filters.push(`grayscale(${props.grayscale / 100})`,);
+  if (isFiniteNumber(props.hueRotate,)) filters.push(`hue-rotate(${props.hueRotate}deg)`,);
+  if (isFiniteNumber(props.invert,)) filters.push(`invert(${props.invert / 100})`,);
+  if (isFiniteNumber(props.saturate,)) filters.push(`saturate(${props.saturate / 100})`,);
+  if (isFiniteNumber(props.sepia,)) filters.push(`sepia(${props.sepia / 100})`,);
+  if (isFiniteNumber(props.blur,)) filters.push(`blur(${props.blur}px)`,);
+  if (props.dropShadows) filters.push(...shadowsAsFilter(props.dropShadows,),);
   if (filters.length === 0) return;
   style.filter = style.WebkitFilter = filters.join(' ',);
 }
 function collectBackgroundFilters(props, style,) {
-  if (isFiniteNumber(props.backgroundBlur,)) {
-    style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;
-  }
+  if (isFiniteNumber(props.backgroundBlur,)) style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;
 }
 function collectFiltersFromProps(props, style,) {
   collectBackgroundFilters(props, style,);
@@ -23708,15 +18085,10 @@ function collectVisualStyleFromProps(props, style, isTextNode = false,) {
   collectOverflowFromProps(props, style,);
   collectOpacityFromProps(props, style,);
   collectTextColorFromProps(props, style,);
-  if (isTextNode) {
-    collectTextShadowsForProps(props, style,);
-  } else {
-    collectBoxShadowsForProps(props, style,);
-  }
+  if (isTextNode) collectTextShadowsForProps(props, style,);
+  else collectBoxShadowsForProps(props, style,);
 }
-var {
-  getNumber,
-} = Animatable;
+var { getNumber, } = Animatable;
 var transformDefaults = {
   z: 0,
   rotation: 0,
@@ -23735,9 +18107,7 @@ var transformDefaults = {
   originZ: 0,
 };
 function getRotation(rotation, rotate,) {
-  if (typeof rotate === 'string') {
-    rotate = parseFloat(rotate,);
-  }
+  if (typeof rotate === 'string') rotate = parseFloat(rotate,);
   return isFiniteNumber(rotate,) ? rotate : getNumber(rotation,);
 }
 function collectTransformFromProps(props, rect, style,) {
@@ -23770,15 +18140,13 @@ function collectTransformFromProps(props, rect, style,) {
             rotateY(${rotationY}deg)
             rotateZ(${(rotation + rotationZ).toFixed(4,)}deg)
             translateZ(${-originZ}px)`;
-  } else {
-    style.transform = `
+  } else {style.transform = `
             ${`translate(${x}, ${y})`}
             scale(${scaleX * scale2}, ${scaleY * scale2})
             skew(${skew}deg,${skew}deg)
             skewX(${skewX}deg)
             skewY(${skewY}deg)
-            rotate(${rotation.toFixed(4,)}deg)`;
-  }
+            rotate(${rotation.toFixed(4,)}deg)`;}
   const transformOrigin = `${getNumber(props.originX,) * 100}% ${getNumber(props.originY,) * 100}%`;
   style.transformOrigin = transformOrigin;
   style.WebkitTransformOrigin = transformOrigin;
@@ -23817,13 +18185,9 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
       super(...arguments,);
       __publicField(this, 'element', null,);
       __publicField(this, 'imageDidChange', false,);
-      __publicField(this, 'state', {
-        size: null,
-      },);
+      __publicField(this, 'state', { size: null, },);
       __publicField(this, 'updateStyle', () => {
-        if (!this.element) {
-          return;
-        }
+        if (!this.element) return;
         Object.assign(this.element.style, this.getStyle(),);
       },);
       __publicField(this, 'setElement', (element) => {
@@ -23850,13 +18214,7 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
     }
     static rect(props,) {
       const constraintValues = ConstraintValues.fromProperties(props,);
-      const parentSizeInfo = props.parentSize
-        ? {
-          sizing: props.parentSize,
-          positioning: props.parentSize,
-          viewport: null,
-        }
-        : null;
+      const parentSizeInfo = props.parentSize ? { sizing: props.parentSize, positioning: props.parentSize, viewport: null, } : null;
       return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, true,);
     }
     get rect() {
@@ -23864,53 +18222,29 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
     }
     static getDerivedStateFromProps(nextProps, prevState,) {
       const size2 = _DeprecatedFrameInner.updatedSize(nextProps, prevState,);
-      const {
-        target,
-      } = RenderEnvironment;
+      const { target, } = RenderEnvironment;
       const nextBackgroundImageSrc = nextProps.background && BackgroundImage.isImageObject(nextProps.background,)
         ? nextProps.background.src
         : null;
-      if (nextBackgroundImageSrc) {
-        return {
-          size: size2,
-        };
-      }
+      if (nextBackgroundImageSrc) return { size: size2, };
       if (prevState.size) {
-        if (target === 'PREVIEW') {
-          return null;
-        }
-        if (prevState.size.width === size2.width && prevState.size.height === size2.height) {
-          return null;
-        }
+        if (target === 'PREVIEW') return null;
+        if (prevState.size.width === size2.width && prevState.size.height === size2.height) return null;
       }
-      return {
-        size: size2,
-      };
+      return { size: size2, };
     }
     static updatedSize(props, state,) {
       const rect = _DeprecatedFrameInner.rect(props,);
       let size2 = state.size;
-      const newSize = {
-        width: rect.width,
-        height: rect.height,
-      };
-      const {
-        target,
-      } = RenderEnvironment;
+      const newSize = { width: rect.width, height: rect.height, };
+      const { target, } = RenderEnvironment;
       if (!size2) {
-        if (target === 'PREVIEW') {
-          size2 = ObservableObject(newSize, true,);
-        } else {
-          size2 = newSize;
-        }
-      } else {
-        if (isAnimatable2(size2.width,) && isAnimatable2(size2.height,)) {
+        if (target === 'PREVIEW') size2 = ObservableObject(newSize, true,);
+        else size2 = newSize;
+      } else {if (isAnimatable2(size2.width,) && isAnimatable2(size2.height,)) {
           size2.width.set(newSize.width,);
           size2.height.set(newSize.height,);
-        } else {
-          size2 = newSize;
-        }
-      }
+        } else size2 = newSize;}
       return size2;
     }
     getStyle() {
@@ -23920,8 +18254,7 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
         position: 'absolute',
         width: `${rect.width}px`,
         height: `${rect.height}px`,
-        pointerEvents: void 0,
-        // TODO: this should be "none" for non-event consuming instances, for performance.
+        pointerEvents: void 0, // TODO: this should be "none" for non-event consuming instances, for performance.
         userSelect: 'none',
       };
       let left = Animatable.get(this.props.left, void 0,);
@@ -23933,19 +18266,13 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
       style.WebkitPerspective = perspective;
       let backfaceVisibility = void 0;
       const backfaceVisible = Animatable.get(this.props.backfaceVisible, void 0,);
-      if (backfaceVisible === true) {
-        backfaceVisibility = 'visible';
-      } else if (backfaceVisible === false) {
-        backfaceVisibility = 'hidden';
-      }
+      if (backfaceVisible === true) backfaceVisibility = 'visible';
+      else if (backfaceVisible === false) backfaceVisibility = 'hidden';
       style.backfaceVisibility = backfaceVisibility;
       style.WebkitBackfaceVisibility = backfaceVisibility;
       const preserve3d = Animatable.get(this.props.preserve3d, void 0,);
-      if (preserve3d === true) {
-        style.transformStyle = 'preserve-3d';
-      } else if (preserve3d === false) {
-        style.transformStyle = 'flat';
-      }
+      if (preserve3d === true) style.transformStyle = 'preserve-3d';
+      else if (preserve3d === false) style.transformStyle = 'flat';
       if (!hasParentSize) {
         applyLayoutProp(style, this.props, 'right',);
         applyLayoutProp(style, this.props, 'bottom',);
@@ -23964,38 +18291,24 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
         if (top !== void 0 && style.bottom !== void 0) {
           style.height = void 0;
           top = toPixelString(Animatable.get(this.props.top, void 0,),);
-        } else {
-          style.height = stringHeight;
-        }
+        } else style.height = stringHeight;
         if (left !== void 0 && style.right !== void 0) {
           style.width = void 0;
           left = toPixelString(Animatable.get(this.props.left, void 0,),);
-        } else {
-          style.width = stringWidth;
-        }
-      }
-      const transformRect = {
-        ...rect,
-      };
-      if (typeof left !== 'undefined') {
-        transformRect.x = left;
-      }
-      if (typeof top !== 'undefined') {
-        transformRect.y = top;
+        } else style.width = stringWidth;
       }
+      const transformRect = { ...rect, };
+      if (typeof left !== 'undefined') transformRect.x = left;
+      if (typeof top !== 'undefined') transformRect.y = top;
       collectTransformFromProps(this.props, transformRect, style,);
       collectVisualStyleFromProps(this.props, style,);
       collectBackgroundImageFromProps(this.props, style,);
       Layer.applyWillChange(this.props, style, false,);
-      if (this.props.style) {
-        Object.assign(style, this.props.style,);
-      }
+      if (this.props.style) Object.assign(style, this.props.style,);
       return style;
     }
     componentDidMount() {
-      const {
-        target,
-      } = RenderEnvironment;
+      const { target, } = RenderEnvironment;
       if (target === 'PREVIEW') {
         this.propsObserver = ObservableObject(this.props, true,);
         this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange,);
@@ -24006,9 +18319,7 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
       }
     }
     componentDidUpdate() {
-      const {
-        target,
-      } = RenderEnvironment;
+      const { target, } = RenderEnvironment;
       this.propsObserverCancel && this.propsObserverCancel();
       this.sizeObserverCancel && this.sizeObserverCancel();
       if (target === 'PREVIEW') {
@@ -24028,33 +18339,19 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
     }
     render() {
       countNodeRender();
-      const {
-        visible,
-        id: id3,
-        className,
-      } = this.props;
-      if (!visible) {
-        return null;
-      }
+      const { visible, id: id3, className, } = this.props;
+      if (!visible) return null;
       const style = this.getStyle();
       const rect = this.rect;
-      const parentSize = {
-        width: rect.width,
-        height: rect.height,
-      };
+      const parentSize = { width: rect.width, height: rect.height, };
       return /* @__PURE__ */ _jsxs('div', {
         id: id3,
         style,
         ref: this.setElement,
         className,
         children: [
-          /* @__PURE__ */ _jsx5(ProvideParentSize, {
-            parentSize,
-            children: this.layoutChildren(),
-          },),
-          /* @__PURE__ */ _jsx5(Border, {
-            ...this.props,
-          },),
+          /* @__PURE__ */ _jsx5(ProvideParentSize, { parentSize, children: this.layoutChildren(), },),
+          /* @__PURE__ */ _jsx5(Border, { ...this.props, },),
         ],
       },);
     }
@@ -24068,28 +18365,16 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
           added = true;
           _forwardedOverrides[key7] = asRecord(this.props,)[value];
         }
-        if (!added) {
-          _forwardedOverrides = void 0;
-        }
+        if (!added) _forwardedOverrides = void 0;
       }
       let children = React__default.Children.map(this.props.children, (child) => {
         if (isConstraintSupportingChild(child,)) {
-          return React__default.cloneElement(child, {
-            parentSize: this.state.size,
-            _forwardedOverrides,
-          },);
-        } else if (_forwardedOverrides && child) {
-          return React__default.cloneElement(child, {
-            _forwardedOverrides,
-          },);
-        } else {
-          return child;
-        }
+          return React__default.cloneElement(child, { parentSize: this.state.size, _forwardedOverrides, },);
+        } else if (_forwardedOverrides && child) return React__default.cloneElement(child, { _forwardedOverrides, },);
+        else return child;
       },);
       if (children && children.length === 1 && typeof children[0] === 'string') {
-        children = [/* @__PURE__ */ _jsx5(Center, {
-          children,
-        }, '0',),];
+        children = [/* @__PURE__ */ _jsx5(Center, { children, }, '0',),];
       }
       return children;
     }
@@ -24106,10 +18391,7 @@ var DeprecatedFrame = /* @__PURE__ */ (() => {
     borderColor: '#222',
     borderStyle: 'solid',
   },);
-  __publicField(DeprecatedFrameInner, 'defaultProps', {
-    ...Layer.defaultProps,
-    ..._DeprecatedFrameInner.defaultFrameSpecificProps,
-  },);
+  __publicField(DeprecatedFrameInner, 'defaultProps', { ...Layer.defaultProps, ..._DeprecatedFrameInner.defaultFrameSpecificProps, },);
   DeprecatedFrameInner.contextType = ConstraintsContext;
   return DeprecatedFrameInner;
 })();
@@ -24121,10 +18403,7 @@ function Center(props,) {
     justifyContent: 'center',
     fontFamily: 'Helvetica',
   }, props.style || {},);
-  return /* @__PURE__ */ _jsx5('div', {
-    style,
-    children: props.children,
-  },);
+  return /* @__PURE__ */ _jsx5('div', { style, children: props.children, },);
 }
 var frameWithMotionPropsFields = [
   '_border',
@@ -24175,15 +18454,9 @@ var frameWithMotionPropsFields = [
 var deprecatedFramePropsFields = ['autoSize', 'aspectRatio', 'borderWidth', 'borderStyle', 'borderColor', 'centerX', 'centerY',];
 function isDeprecatedFrameProps(props,) {
   let field;
-  for (const propKey in props) {
-    if (isAnimatable2(props[propKey],)) return true;
-  }
-  for (field of frameWithMotionPropsFields) {
-    if (props.hasOwnProperty(field,)) return false;
-  }
-  for (field of deprecatedFramePropsFields) {
-    if (props.hasOwnProperty(field,)) return true;
-  }
+  for (const propKey in props) if (isAnimatable2(props[propKey],)) return true;
+  for (field of frameWithMotionPropsFields) if (props.hasOwnProperty(field,)) return false;
+  for (field of deprecatedFramePropsFields) if (props.hasOwnProperty(field,)) return true;
   return false;
 }
 var DeprecatedFrameWithEvents = /* @__PURE__ */ WithEvents(DeprecatedFrame,);
@@ -24192,15 +18465,9 @@ var Frame = /* @__PURE__ */ (() => {
     const parentSize = useParentSize();
     if (isDeprecatedFrameProps(props,)) {
       const currentParentSize = props.parentSize || deprecatedParentSize(parentSize,);
-      return /* @__PURE__ */ _jsx5(DeprecatedFrameWithEvents, {
-        ...props,
-        parentSize: currentParentSize,
-      },);
+      return /* @__PURE__ */ _jsx5(DeprecatedFrameWithEvents, { ...props, parentSize: currentParentSize, },);
     }
-    return /* @__PURE__ */ _jsx5(FrameWithMotion, {
-      ...props,
-      ref,
-    },);
+    return /* @__PURE__ */ _jsx5(FrameWithMotion, { ...props, ref, },);
   },);
   FrameInner['displayName'] = 'Frame';
   return FrameInner;
@@ -24217,26 +18484,16 @@ var LayoutTree = class extends Component2 {
     },);
     __publicField(this, 'switchLayoutGroupContext', {
       register: (child) => this.addChild(child,),
-      deregister: (child) => this.removeChild(child,),
-      // Configs to use for the initial promotion on mount in Motion
+      deregister: (child) => this.removeChild(child,), // Configs to use for the initial promotion on mount in Motion
       transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0,
       shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity,
     },);
   }
   componentDidMount() {
-    if (this.props.isLead) {
-      this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout,);
-    }
+    if (this.props.isLead) this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout,);
   }
   shouldComponentUpdate(nextProps,) {
-    const {
-      isLead,
-      isExiting,
-      isOverlayed,
-      animatesLayout,
-      transition,
-      sharedLayoutContext,
-    } = nextProps;
+    const { isLead, isExiting, isOverlayed, animatesLayout, transition, sharedLayoutContext, } = nextProps;
     this.isExiting = isExiting;
     if (isLead === void 0) return true;
     const hasBecomeLead = !this.props.isLead && !!isLead;
@@ -24244,14 +18501,9 @@ var LayoutTree = class extends Component2 {
     const shouldPromote = hasBecomeLead || hasExitBeenCancelled;
     const shouldDemote = !!this.props.isLead && !isLead;
     const overlayChanged = this.props.isOverlayed !== isOverlayed;
-    if (shouldPromote || shouldDemote) {
-      this.projectionNodes.forEach((projection) => projection == null ? void 0 : projection.willUpdate());
-    }
-    if (shouldPromote) {
-      sharedLayoutContext.schedulePromoteTree(this, transition, !!animatesLayout,);
-    } else if (overlayChanged) {
-      sharedLayoutContext.scheduleProjectionDidUpdate();
-    }
+    if (shouldPromote || shouldDemote) this.projectionNodes.forEach((projection) => projection == null ? void 0 : projection.willUpdate());
+    if (shouldPromote) sharedLayoutContext.schedulePromoteTree(this, transition, !!animatesLayout,);
+    else if (overlayChanged) sharedLayoutContext.scheduleProjectionDidUpdate();
     return !!shouldPromote && !!animatesLayout;
   }
   addChild(child,) {
@@ -24260,20 +18512,18 @@ var LayoutTree = class extends Component2 {
       this.projectionNodes.set(layoutId, child,);
       this.setRootChild(child,);
     }
-  }
-  /**
+  } /**
    * As children are added, make sure that `this.rootProjectionNode` is always the
    * child with the smallest depth.
    */
+
   setRootChild(child,) {
     if (!this.rootProjectionNode) return this.rootProjectionNode = child;
     this.rootProjectionNode = this.rootProjectionNode.depth < child.depth ? this.rootProjectionNode : child;
   }
   removeChild(child,) {
     const layoutId = child.options.layoutId;
-    if (layoutId) {
-      this.projectionNodes.delete(layoutId,);
-    }
+    if (layoutId) this.projectionNodes.delete(layoutId,);
   }
   render() {
     return /* @__PURE__ */ _jsx5(SwitchLayoutGroupContext.Provider, {
@@ -24284,10 +18534,7 @@ var LayoutTree = class extends Component2 {
 };
 var SharedLayoutTree = (props) => {
   const sharedLayoutContext = React__default.useContext(SharedLayoutContext,);
-  return /* @__PURE__ */ _jsx5(LayoutTree, {
-    ...props,
-    sharedLayoutContext,
-  },);
+  return /* @__PURE__ */ _jsx5(LayoutTree, { ...props, sharedLayoutContext, },);
 };
 var NavigationContainerContext = React__default.createContext(true,);
 function useIsInCurrentNavigationTarget() {
@@ -24300,15 +18547,8 @@ function newMap() {
 function useMap() {
   return useConstant2(newMap,);
 }
-var NavigationTargetContext = /* @__PURE__ */ createContext({
-  register: () => {},
-  deregister: () => {},
-},);
-var NavigationTargetWrapper = ({
-  isCurrent,
-  isOverlayed,
-  children,
-},) => {
+var NavigationTargetContext = /* @__PURE__ */ createContext({ register: () => {}, deregister: () => {}, },);
+var NavigationTargetWrapper = ({ isCurrent, isOverlayed, children, },) => {
   const callbacks2 = useMap();
   const register = useCallback((fn) => {
     if (callbacks2.has(fn,)) {
@@ -24316,18 +18556,13 @@ var NavigationTargetWrapper = ({
       return;
     }
     callbacks2.set(fn, void 0,);
-  }, [callbacks2,/* constant, so should never change */
-  ],);
+  }, [callbacks2, /* constant, so should never change */],);
   const deregister = useCallback((fn) => {
     const cleanup = callbacks2.get(fn,);
     cleanup == null ? void 0 : cleanup();
     callbacks2.delete(fn,);
-  }, [callbacks2,/* constant, so should never change */
-  ],);
-  const value = useRef({
-    register,
-    deregister,
-  },).current;
+  }, [callbacks2, /* constant, so should never change */],);
+  const value = useRef({ register, deregister, },).current;
   useEffect(() => {
     callbacks2.forEach((_, cb,) => {
       const newCleanup = cb(isCurrent, isOverlayed,);
@@ -24340,18 +18575,11 @@ var NavigationTargetWrapper = ({
         callbacks2.set(cb, void 0,);
       },);
     };
-  }, [isCurrent, isOverlayed, callbacks2,/* constant, so should never change */
-  ],);
-  return /* @__PURE__ */ _jsx5(NavigationTargetContext.Provider, {
-    value,
-    children,
-  },);
+  }, [isCurrent, isOverlayed, callbacks2, /* constant, so should never change */],);
+  return /* @__PURE__ */ _jsx5(NavigationTargetContext.Provider, { value, children, },);
 };
 function useOnCurrentTargetChange(callback, deps = [],) {
-  const {
-    register,
-    deregister,
-  } = useContext3(NavigationTargetContext,);
+  const { register, deregister, } = useContext3(NavigationTargetContext,);
   useEffect(() => {
     if (!callback) return;
     register(callback,);
@@ -24375,12 +18603,7 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
   instant,
   initialProps,
   exitProps,
-  position = {
-    top: 0,
-    right: 0,
-    bottom: 0,
-    left: 0,
-  },
+  position = { top: 0, right: 0, bottom: 0, left: 0, },
   withMagicMotion,
   index,
   areMagicMotionLayersPresent,
@@ -24389,9 +18612,7 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
 },) {
   const animate3 = useAnimation();
   const presence = useContext3(PresenceContext,);
-  const {
-    persistLayoutIdCache,
-  } = useContext3(LayoutIdContext,);
+  const { persistLayoutIdCache, } = useContext3(LayoutIdContext,);
   const previousState = useRef({
     wasCurrent: void 0,
     wasPrevious: false,
@@ -24405,18 +18626,11 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
   useEffect(() => {
     if (isLayeredContainer || !animate3) return;
     if (isBeingRemoved) {
-      previousState.current = {
-        ...previousState.current,
-        wasBeingRemoved: isBeingRemoved,
-      };
+      previousState.current = { ...previousState.current, wasBeingRemoved: isBeingRemoved, };
       return;
     }
-    const {
-      wasPrevious,
-      wasCurrent,
-    } = previousState.current;
-    const shouldAnimateIn = isCurrent && !wasCurrent ||
-      // If the screen was being removed as a result of a "go back" transition, but that removal is interrupted,
+    const { wasPrevious, wasCurrent, } = previousState.current;
+    const shouldAnimateIn = isCurrent && !wasCurrent || // If the screen was being removed as a result of a "go back" transition, but that removal is interrupted,
       // resulting in this screen being restored to the current screen, we need to trigger an animation.
       !isBeingRemoved && previousState.current.wasBeingRemoved && isCurrent;
     const shouldAnimateOut = isPrevious && !wasPrevious;
@@ -24424,82 +18638,30 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
     let wasReset = previousState.current.wasReset;
     if (shouldAnimateIn || shouldAnimateOut) {
       animate3.stop();
-      animate3.start({
-        zIndex: index,
-        ...origins,
-        ...transitionProps,
-      },);
+      animate3.start({ zIndex: index, ...origins, ...transitionProps, },);
       wasReset = false;
     } else if (wasReset === false) {
       animate3.stop();
-      animate3.set({
-        zIndex: index,
-        ...allAnimatableProperties,
-        opacity: 0,
-      },);
+      animate3.set({ zIndex: index, ...allAnimatableProperties, opacity: 0, },);
       wasReset = true;
     }
-    previousState.current = {
-      wasCurrent: !!isCurrent,
-      wasPrevious: !!isPrevious,
-      wasBeingRemoved: false,
-      wasReset,
-      origins,
-    };
+    previousState.current = { wasCurrent: !!isCurrent, wasPrevious: !!isPrevious, wasBeingRemoved: false, wasReset, origins, };
   }, [isCurrent, isPrevious, isBeingRemoved,],);
-  const transition = instant
-    ? {
-      type: false,
-    }
-    : 'velocity' in animation
-    ? {
-      ...animation,
-      velocity: 0,
-    }
-    : animation;
-  const exitTransition = instant
-    ? {
-      type: false,
-    }
-    : exitAnimation || animation;
-  const layout2 = {
-    ...position,
-  };
+  const transition = instant ? { type: false, } : 'velocity' in animation ? { ...animation, velocity: 0, } : animation;
+  const exitTransition = instant ? { type: false, } : exitAnimation || animation;
+  const layout2 = { ...position, };
   if (layout2.left === void 0 || layout2.right === void 0) layout2.width = 'auto';
   if (layout2.top === void 0 || layout2.bottom === void 0) layout2.height = 'auto';
   const needsPerspective = contains3Dprops(transitionProps,) || contains3Dprops(initialProps,);
   const perspective = needsPerspective && (isLayeredContainer || isCurrent || isPrevious) ? 1200 : void 0;
-  const identity = {
-    ...allAnimatableProperties,
-    ...previousState.current.origins,
-  };
+  const identity = { ...allAnimatableProperties, ...previousState.current.origins, };
   const animations2 = isLayeredContainer
     ? {
-      initial: {
-        ...identity,
-        ...initialProps,
-      },
-      animate: {
-        ...identity,
-        ...transitionProps,
-        transition,
-      },
-      // Overlay animations are sometimes instant
-      exit: {
-        ...identity,
-        ...exitProps,
-        transition: animation,
-      },
-      // Overlay exits are always animated
-    }
-    : {
-      animate: animate3,
-      exit: {
-        ...identity,
-        ...exitProps,
-        transition: exitTransition,
-      },
-    };
+      initial: { ...identity, ...initialProps, },
+      animate: { ...identity, ...transitionProps, transition, }, // Overlay animations are sometimes instant
+      exit: { ...identity, ...exitProps, transition: animation, }, // Overlay exits are always animated
+    }
+    : { animate: animate3, exit: { ...identity, ...exitProps, transition: exitTransition, }, };
   const isPresent2 = isBeingRemoved || areMagicMotionLayersPresent === false ? false : true;
   const isCurrentTarget = !!isCurrent && isPresent2;
   const forceOpacity = isCurrent && isInitial;
@@ -24511,8 +18673,7 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
       position: 'absolute',
       transformStyle: 'flat',
       backgroundColor: 'transparent',
-      overflow: 'hidden',
-      // Unlike Overlays, Screens set zIndex via animation controls to ensure it's set in parallel with the animation being played.
+      overflow: 'hidden', // Unlike Overlays, Screens set zIndex via animation controls to ensure it's set in parallel with the animation being played.
       // However, when a screen exits, it needs to preserve it's zIndex, which can't be applied through an `exit` animation,
       // and might be impacted by the layer created by `perspective`.
       zIndex: isLayeredContainer || isBeingRemoved || isCurrent && withMagicMotion ? index : void 0,
@@ -24526,40 +18687,22 @@ var NavigationContainer = /* @__PURE__ */ React__default.memo(function Navigatio
         height: '100%',
         'data-framer-component-type': 'NavigationContainerBackdrop',
         transition: animation,
-        initial: {
-          opacity: instant && visible ? 1 : 0,
-        },
-        animate: {
-          opacity: 1,
-        },
-        exit: {
-          opacity: 0,
-        },
+        initial: { opacity: instant && visible ? 1 : 0, },
+        animate: { opacity: 1, },
+        exit: { opacity: 0, },
         backgroundColor: backdropColor ? backdropColor : 'transparent',
         onTap: !isBeingRemoved ? onTapBackdrop : void 0,
       },),
       /* @__PURE__ */ _jsx5(FrameWithMotion, {
         ...layout2,
         ...animations2,
-        transition: {
-          default: transition,
-          originX: {
-            type: false,
-          },
-          originY: {
-            type: false,
-          },
-          originZ: {
-            type: false,
-          },
-        },
+        transition: { default: transition, originX: { type: false, }, originY: { type: false, }, originZ: { type: false, }, },
         backgroundColor: 'transparent',
         backfaceVisible: !isBeingRemoved ? backfaceVisible : exitBackfaceVisible,
         'data-framer-component-type': 'NavigationContainer',
         'data-framer-is-current-navigation-target': !!isCurrent,
         style: {
-          pointerEvents: void 0,
-          // When we mount a new screen that is going to be animated in with animation controls,
+          pointerEvents: void 0, // When we mount a new screen that is going to be animated in with animation controls,
           // we need to ensure that the screen is hidden until the animation starts.
           opacity: forceOpacity || isLayeredContainer || isCurrent && withMagicMotion ? 1 : 0,
         },
@@ -24596,9 +18739,7 @@ function shouldUsePreviousValue(prevProps, nextProps,) {
   return true;
 }
 function getOriginProps(currentOriginProps, initialProps, transitionProps,) {
-  const result = {
-    ...currentOriginProps,
-  };
+  const result = { ...currentOriginProps, };
   if (initialProps) {
     if (isFiniteNumber(initialProps.originX,)) result.originX = initialProps.originX;
     if (isFiniteNumber(initialProps.originY,)) result.originY = initialProps.originY;
@@ -24662,152 +18803,22 @@ var NavigatorMock = class {
 var navigatorMock = new NavigatorMock();
 var NavigationContext = createContext(navigatorMock,);
 var TransitionDefaults = {
-  Fade: {
-    exit: {
-      opacity: 0,
-    },
-    enter: {
-      opacity: 0,
-    },
-  },
-  PushLeft: {
-    exit: {
-      x: '-30%',
-    },
-    enter: {
-      x: '100%',
-    },
-  },
-  PushRight: {
-    exit: {
-      x: '30%',
-    },
-    enter: {
-      x: '-100%',
-    },
-  },
-  PushUp: {
-    exit: {
-      y: '-30%',
-    },
-    enter: {
-      y: '100%',
-    },
-  },
-  PushDown: {
-    exit: {
-      y: '30%',
-    },
-    enter: {
-      y: '-100%',
-    },
-  },
-  Instant: {
-    animation: {
-      type: false,
-    },
-    enter: {
-      opacity: 0,
-    },
-  },
-  Modal: {
-    overCurrentContext: true,
-    goBackOnTapOutside: true,
-    position: {
-      center: true,
-    },
-    enter: {
-      opacity: 0,
-      scale: 1.2,
-    },
-  },
-  OverlayLeft: {
-    overCurrentContext: true,
-    goBackOnTapOutside: true,
-    position: {
-      right: 0,
-      top: 0,
-      bottom: 0,
-    },
-    enter: {
-      x: '100%',
-    },
-  },
-  OverlayRight: {
-    overCurrentContext: true,
-    goBackOnTapOutside: true,
-    position: {
-      left: 0,
-      top: 0,
-      bottom: 0,
-    },
-    enter: {
-      x: '-100%',
-    },
-  },
-  OverlayUp: {
-    overCurrentContext: true,
-    goBackOnTapOutside: true,
-    position: {
-      bottom: 0,
-      left: 0,
-      right: 0,
-    },
-    enter: {
-      y: '100%',
-    },
-  },
-  OverlayDown: {
-    overCurrentContext: true,
-    goBackOnTapOutside: true,
-    position: {
-      top: 0,
-      left: 0,
-      right: 0,
-    },
-    enter: {
-      y: '-100%',
-    },
-  },
-  FlipLeft: {
-    backfaceVisible: false,
-    exit: {
-      rotateY: -180,
-    },
-    enter: {
-      rotateY: 180,
-    },
-  },
-  FlipRight: {
-    backfaceVisible: false,
-    exit: {
-      rotateY: 180,
-    },
-    enter: {
-      rotateY: -180,
-    },
-  },
-  FlipUp: {
-    backfaceVisible: false,
-    exit: {
-      rotateX: 180,
-    },
-    enter: {
-      rotateX: -180,
-    },
-  },
-  FlipDown: {
-    backfaceVisible: false,
-    exit: {
-      rotateX: -180,
-    },
-    enter: {
-      rotateX: 180,
-    },
-  },
-  MagicMotion: {
-    withMagicMotion: true,
-  },
+  Fade: { exit: { opacity: 0, }, enter: { opacity: 0, }, },
+  PushLeft: { exit: { x: '-30%', }, enter: { x: '100%', }, },
+  PushRight: { exit: { x: '30%', }, enter: { x: '-100%', }, },
+  PushUp: { exit: { y: '-30%', }, enter: { y: '100%', }, },
+  PushDown: { exit: { y: '30%', }, enter: { y: '-100%', }, },
+  Instant: { animation: { type: false, }, enter: { opacity: 0, }, },
+  Modal: { overCurrentContext: true, goBackOnTapOutside: true, position: { center: true, }, enter: { opacity: 0, scale: 1.2, }, },
+  OverlayLeft: { overCurrentContext: true, goBackOnTapOutside: true, position: { right: 0, top: 0, bottom: 0, }, enter: { x: '100%', }, },
+  OverlayRight: { overCurrentContext: true, goBackOnTapOutside: true, position: { left: 0, top: 0, bottom: 0, }, enter: { x: '-100%', }, },
+  OverlayUp: { overCurrentContext: true, goBackOnTapOutside: true, position: { bottom: 0, left: 0, right: 0, }, enter: { y: '100%', }, },
+  OverlayDown: { overCurrentContext: true, goBackOnTapOutside: true, position: { top: 0, left: 0, right: 0, }, enter: { y: '-100%', }, },
+  FlipLeft: { backfaceVisible: false, exit: { rotateY: -180, }, enter: { rotateY: 180, }, },
+  FlipRight: { backfaceVisible: false, exit: { rotateY: 180, }, enter: { rotateY: -180, }, },
+  FlipUp: { backfaceVisible: false, exit: { rotateX: 180, }, enter: { rotateX: -180, }, },
+  FlipDown: { backfaceVisible: false, exit: { rotateX: -180, }, enter: { rotateX: 180, }, },
+  MagicMotion: { withMagicMotion: true, },
 };
 function pushTransition(options,) {
   const side = options && options.appearsFrom ? options.appearsFrom : 'right';
@@ -24886,23 +18897,13 @@ function reduceNavigationStateForAction(state, action,) {
   }
 }
 function updateComponent(currentState, key7, component,) {
-  return {
-    ...currentState,
-    containers: {
-      ...currentState.containers,
-      [key7]: component,
-    },
-  };
+  return { ...currentState, containers: { ...currentState.containers, [key7]: component, }, };
 }
 function addOverlay(currentState, transition, component,) {
   const currentOverlay = currentState.overlayStack[currentState.currentOverlay];
   if (currentOverlay && currentOverlay.component === component) return;
   const overlayItemId = currentState.overlayItemId + 1;
-  const overlayStack = [...currentState.overlayStack, {
-    key: `stack-${overlayItemId}`,
-    component,
-    transition,
-  },];
+  const overlayStack = [...currentState.overlayStack, { key: `stack-${overlayItemId}`, component, transition, },];
   return {
     ...currentState,
     overlayStack,
@@ -24912,12 +18913,7 @@ function addOverlay(currentState, transition, component,) {
   };
 }
 function removeOverlay(currentState,) {
-  return {
-    ...currentState,
-    overlayStack: [],
-    currentOverlay: -1,
-    previousOverlay: currentState.currentOverlay,
-  };
+  return { ...currentState, overlayStack: [], currentOverlay: -1, previousOverlay: currentState.currentOverlay, };
 }
 function add(currentState, key7, transition, component,) {
   if (!currentState.containers[key7]) currentState.containers[key7] = component;
@@ -24927,11 +18923,7 @@ function add(currentState, key7, transition, component,) {
   const isCurrentScreen = currentItem && currentItem.key === key7;
   currentState.overlayStack = [];
   if (isCurrentScreen && currentState.currentOverlay > -1) {
-    return {
-      ...currentState,
-      currentOverlay: -1,
-      previousOverlay: currentState.currentOverlay,
-    };
+    return { ...currentState, currentOverlay: -1, previousOverlay: currentState.currentOverlay, };
   }
   if (isCurrentScreen) return;
   const nextIndex = currentState.containerVisualIndex[key7];
@@ -24952,10 +18944,7 @@ function add(currentState, key7, transition, component,) {
     }
   }
   currentState.containerIndex[key7] = current;
-  const {
-    containerVisualIndex,
-    containerIsRemoved,
-  } = magicMotionPropsForAdd(currentState, key7, shouldMoveForward,);
+  const { containerVisualIndex, containerIsRemoved, } = magicMotionPropsForAdd(currentState, key7, shouldMoveForward,);
   const transitionForContainer = updateTransitions(
     current,
     previous,
@@ -24977,9 +18966,7 @@ function add(currentState, key7, transition, component,) {
   };
 }
 function back(currentState,) {
-  const containers = {
-    ...currentState.containers,
-  };
+  const containers = { ...currentState.containers, };
   const nextState = remove(currentState,);
   if (!nextState) return;
   nextState.containers = containers;
@@ -24988,11 +18975,7 @@ function back(currentState,) {
 function forward(currentState,) {
   const nextItem = currentState.history[currentState.current + 1];
   if (!nextItem) return;
-  const {
-    key: key7,
-    transition,
-    component,
-  } = nextItem;
+  const { key: key7, transition, component, } = nextItem;
   const history = [...currentState.history,];
   const nextState = add(currentState, key7, transition, component,);
   if (!nextState) return;
@@ -25008,17 +18991,14 @@ function remove(currentState,) {
   assert(target, 'The navigation history must have at least one component',);
   currentState.containerIndex[target.key] = history.length - 1;
   const shouldRemoveContainer = history.every((item) => item.key !== currentItem.key);
-  if (shouldRemoveContainer) {
-    delete currentState.containers[currentItem.key];
-  }
+  if (shouldRemoveContainer) delete currentState.containers[currentItem.key];
   const current = currentState.current - 1;
   const previous = currentState.current;
-  const {
-    containerIsRemoved,
-    containerVisualIndex,
-    previousTransition,
-    visualIndex,
-  } = magicMotionPropsForRemove(currentState, target, currentItem,);
+  const { containerIsRemoved, containerVisualIndex, previousTransition, visualIndex, } = magicMotionPropsForRemove(
+    currentState,
+    target,
+    currentItem,
+  );
   const transitionForContainer = updateTransitions(
     current,
     previous,
@@ -25039,12 +19019,8 @@ function remove(currentState,) {
 }
 function magicMotionPropsForAdd(currentState, nextKey, shouldMoveForward,) {
   const update = {
-    containerVisualIndex: {
-      ...currentState.containerVisualIndex,
-    },
-    containerIsRemoved: {
-      ...currentState.containerIsRemoved,
-    },
+    containerVisualIndex: { ...currentState.containerVisualIndex, },
+    containerIsRemoved: { ...currentState.containerIsRemoved, },
   };
   if (shouldMoveForward) {
     update.containerVisualIndex[nextKey] = currentState.history.length - 1;
@@ -25052,9 +19028,7 @@ function magicMotionPropsForAdd(currentState, nextKey, shouldMoveForward,) {
   } else {
     const nextVisualIndex = currentState.containerVisualIndex[nextKey];
     for (const [key7, visualIndex,] of Object.entries(currentState.containerVisualIndex,)) {
-      if (nextVisualIndex !== void 0 && visualIndex > nextVisualIndex) {
-        update.containerIsRemoved[key7] = true;
-      }
+      if (nextVisualIndex !== void 0 && visualIndex > nextVisualIndex) update.containerIsRemoved[key7] = true;
     }
   }
   return update;
@@ -25062,16 +19036,10 @@ function magicMotionPropsForAdd(currentState, nextKey, shouldMoveForward,) {
 function magicMotionPropsForRemove(currentState, target, currentItem,) {
   const validTargets = [target.key, currentItem.key,];
   const nextValidTarget = currentState.history[currentState.history.length - 2];
-  const previousTransition = currentState.previousTransition === null ? null : {
-    ...currentState.previousTransition,
-  };
+  const previousTransition = currentState.previousTransition === null ? null : { ...currentState.previousTransition, };
   const update = {
-    containerIsRemoved: {
-      ...currentState.containerIsRemoved,
-    },
-    containerVisualIndex: {
-      ...currentState.containerVisualIndex,
-    },
+    containerIsRemoved: { ...currentState.containerIsRemoved, },
+    containerVisualIndex: { ...currentState.containerVisualIndex, },
     previousTransition,
     visualIndex: currentState.visualIndex,
   };
@@ -25100,18 +19068,10 @@ function findLatestHistoryIndex(key7, history,) {
   return -1;
 }
 function updateTransitions(current, previous, history, containerIndex, transitionForContainer,) {
-  const transitions = {
-    ...transitionForContainer,
-  };
+  const transitions = { ...transitionForContainer, };
   for (const [key7, screenIndex,] of Object.entries(containerIndex,)) {
-    const transition = transitionForScreen(screenIndex, {
-      current,
-      previous,
-      history,
-    },);
-    if (transition) {
-      transitions[key7] = transition;
-    }
+    const transition = transitionForScreen(screenIndex, { current, previous, history, },);
+    if (transition) transitions[key7] = transition;
   }
   return transitions;
 }
@@ -25125,11 +19085,7 @@ function isNextTargetForward(key7, index, removed, history,) {
   return true;
 }
 function transitionForScreen(screenIndex, stackState,) {
-  const {
-    current,
-    previous,
-    history,
-  } = stackState;
+  const { current, previous, history, } = stackState;
   if (screenIndex !== current && screenIndex !== previous) return void 0;
   if (screenIndex === current && current > previous) {
     const item = history[screenIndex];
@@ -25154,10 +19110,7 @@ function sequence(direction, transition, animation,) {
   const from = {};
   allAnimatableKeys.forEach((property) => {
     value[property] = allAnimatableProperties[property];
-    from[property] = {
-      ...animation,
-      from: allAnimatableProperties[property],
-    };
+    from[property] = { ...animation, from: allAnimatableProperties[property], };
   },);
   if (transition) {
     Object.keys(transition,).forEach((property) => {
@@ -25167,19 +19120,10 @@ function sequence(direction, transition, animation,) {
         ? `${asRecord(allAnimatableProperties,)[property]}%`
         : asRecord(allAnimatableProperties,)[property];
       asRecord(value,)[property] = direction === 'enter' ? transitionFrom : transitionTo;
-      from[property] = {
-        ...animation,
-        from: direction === 'enter' ? transitionTo : transitionFrom,
-        velocity: 0,
-      };
+      from[property] = { ...animation, from: direction === 'enter' ? transitionTo : transitionFrom, velocity: 0, };
     },);
   }
-  return {
-    ...value,
-    transition: {
-      ...from,
-    },
-  };
+  return { ...value, transition: { ...from, }, };
 }
 var NavigationConsumer = NavigationContext.Consumer;
 var NavigationCallbackContext = React__default.createContext(void 0,);
@@ -25195,9 +19139,7 @@ var Navigation = class extends Component2 {
       if (!this.props.enabled && this.state.history.length > 0) return;
       const newState2 = reduceNavigationStateForAction(this.state, action2,);
       if (!newState2) return;
-      const {
-        skipLayoutAnimation,
-      } = this.props;
+      const { skipLayoutAnimation, } = this.props;
       const historyItem = newState2.history[newState2.current];
       const withMagicMotion = action2.type === 'add' && action2.transition.withMagicMotion ||
         action2.type === 'forward' && (historyItem == null ? void 0 : historyItem.transition.withMagicMotion) ||
@@ -25205,41 +19147,23 @@ var Navigation = class extends Component2 {
       const updateState = () => {
         var _a2;
         this.setState(newState2,);
-        if (historyItem == null ? void 0 : historyItem.key) {
-          (_a2 = this.context) == null ? void 0 : _a2.call(this, historyItem.key,);
-        }
+        if (historyItem == null ? void 0 : historyItem.key) (_a2 = this.context) == null ? void 0 : _a2.call(this, historyItem.key,);
       };
-      if (skipLayoutAnimation && !withMagicMotion) {
-        skipLayoutAnimation(updateState,);
-      } else {
-        updateState();
-      }
+      if (skipLayoutAnimation && !withMagicMotion) skipLayoutAnimation(updateState,);
+      else updateState();
     },);
     __publicField(this, 'goBack', () => {
       var _a2;
       if (this.isSameEventTransition()) return;
       this.lastEventTimeStamp = ((_a2 = globalThis.event) == null ? void 0 : _a2.timeStamp) || null;
-      if (this.state.currentOverlay !== -1) {
-        return this.navigationAction({
-          type: 'removeOverlay',
-        },);
-      }
-      return this.navigationAction({
-        type: 'remove',
-      },);
+      if (this.state.currentOverlay !== -1) return this.navigationAction({ type: 'removeOverlay', },);
+      return this.navigationAction({ type: 'remove', },);
     },);
     const component = this.props.children;
     if (!component || !isReactChild(component,) || !isReactElement(component,)) return;
-    const transition = {
-      ...TransitionDefaults.Instant,
-    };
+    const transition = { ...TransitionDefaults.Instant, };
     const key7 = ((_a = component.key) == null ? void 0 : _a.toString()) || `stack-${this.state.historyItemId + 1}`;
-    const action = {
-      type: 'add',
-      key: key7,
-      transition,
-      component,
-    };
+    const action = { type: 'add', key: key7, transition, component, };
     const newState = reduceNavigationStateForAction(this.state, action,);
     if (!newState) return;
     this.state = newState;
@@ -25256,41 +19180,18 @@ var Navigation = class extends Component2 {
     if (!isReactChild(component,) || !isReactElement(component,)) return;
     const key7 = (_a = component.key) == null ? void 0 : _a.toString();
     if (!key7) return;
-    if (this.state.history.length === 0) {
-      this.transition(component, TransitionDefaults.Instant,);
-    } else {
-      this.navigationAction({
-        type: 'update',
-        key: key7,
-        component,
-      },);
-    }
+    if (this.state.history.length === 0) this.transition(component, TransitionDefaults.Instant,);
+    else this.navigationAction({ type: 'update', key: key7, component, },);
   }
   componentWillUnmount() {
     var _a, _b;
     (_b = (_a = this.props).resetProjection) == null ? void 0 : _b.call(_a,);
   }
   getStackState(options,) {
-    const {
-      current,
-      previous,
-      currentOverlay,
-      previousOverlay,
-    } = this.state;
-    if (options.overCurrentContext) {
-      return {
-        current: currentOverlay,
-        previous: previousOverlay,
-        history: this.state.overlayStack,
-      };
-    }
-    return {
-      current,
-      previous,
-      history: this.state.history,
-    };
-  }
-  /**
+    const { current, previous, currentOverlay, previousOverlay, } = this.state;
+    if (options.overCurrentContext) return { current: currentOverlay, previous: previousOverlay, history: this.state.overlayStack, };
+    return { current, previous, history: this.state.history, };
+  } /**
    * To prevent bubbling events from triggering multiple transitions,
    * we ensure that the current event has a different timestamp then the event that triggered the last transition.
    * We use Window.event to ensure that even transitions invoked by code components - and may not pass a reference to the event - are caught.
@@ -25298,6 +19199,7 @@ var Navigation = class extends Component2 {
    * because the time between calls can get longer and longer as more screens are added to the stack,
    * preventing a deterministic time between transitions to be used to determine if they were triggered at the same time or not.
    */
+
   isSameEventTransition() {
     if (!globalThis.event) return false;
     return this.lastEventTimeStamp === globalThis.event.timeStamp;
@@ -25307,25 +19209,11 @@ var Navigation = class extends Component2 {
     if (this.isSameEventTransition()) return;
     this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;
     if (!component || !isReactChild(component,) || !isReactElement(component,)) return;
-    const transition = {
-      ...transitionTraits,
-      ...transitionOptions,
-    };
+    const transition = { ...transitionTraits, ...transitionOptions, };
     const overCurrentContext = !!transition.overCurrentContext;
-    if (overCurrentContext) {
-      return this.navigationAction({
-        type: 'addOverlay',
-        transition,
-        component,
-      },);
-    }
+    if (overCurrentContext) return this.navigationAction({ type: 'addOverlay', transition, component, },);
     const key7 = ((_b = component.key) == null ? void 0 : _b.toString()) || `stack-${this.state.historyItemId + 1}`;
-    this.navigationAction({
-      type: 'add',
-      key: key7,
-      transition,
-      component,
-    },);
+    this.navigationAction({ type: 'add', key: key7, transition, component, },);
   }
   instant(component,) {
     this.transition(component, TransitionDefaults.Instant, void 0,);
@@ -25353,12 +19241,8 @@ var Navigation = class extends Component2 {
   }
   render() {
     var _a, _b, _c, _d, _e;
-    const stackState = this.getStackState({
-      overCurrentContext: false,
-    },);
-    const overlayStackState = this.getStackState({
-      overCurrentContext: true,
-    },);
+    const stackState = this.getStackState({ overCurrentContext: false, },);
+    const overlayStackState = this.getStackState({ overCurrentContext: true, },);
     const activeOverlay = activeOverlayItem(overlayStackState,);
     const isOverlayVisible = overlayStackState.current > -1;
     const isInitial = this.state.history.length === 1;
@@ -25395,10 +19279,7 @@ var Navigation = class extends Component2 {
         withMagicMotion,
         areMagicMotionLayersPresent: areMagicMotionLayersPresent ? false : void 0,
         children: /* @__PURE__ */ _jsx5(MagicMotionCrossfadeRoot, {
-          children: containerContent({
-            component,
-            transition: historyItem == null ? void 0 : historyItem.transition,
-          },),
+          children: containerContent({ component, transition: historyItem == null ? void 0 : historyItem.transition, },),
         },),
       }, key7,),);
     }
@@ -25417,10 +19298,7 @@ var Navigation = class extends Component2 {
         backfaceVisible: getBackfaceVisibleForOverlay(stackIndex, overlayStackState,),
         onTapBackdrop: backdropTapAction(item.transition, this.goBack,),
         index: this.state.current + 1 + stackIndex,
-        children: containerContent({
-          component: item.component,
-          transition: item.transition,
-        },),
+        children: containerContent({ component: item.component, transition: item.transition, },),
       }, item.key,);
     },);
     return /* @__PURE__ */ _jsx5(FrameWithMotion, {
@@ -25430,12 +19308,7 @@ var Navigation = class extends Component2 {
       width: '100%',
       height: '100%',
       position: 'relative',
-      style: {
-        overflow: 'hidden',
-        backgroundColor: 'unset',
-        pointerEvents: void 0,
-        ...this.props.style,
-      },
+      style: { overflow: 'hidden', backgroundColor: 'unset', pointerEvents: void 0, ...this.props.style, },
       children: /* @__PURE__ */ _jsx5(NavigationContext.Provider, {
         value: this,
         children: /* @__PURE__ */ _jsxs(IsInitialNavigationContext.Provider, {
@@ -25455,66 +19328,36 @@ var Navigation = class extends Component2 {
               index: 0,
               children: /* @__PURE__ */ _jsx5(LayoutIdProvider, {
                 children: /* @__PURE__ */ _jsx5(SharedLayoutRoot, {
-                  children: /* @__PURE__ */ _jsx5(AnimatePresence, {
-                    presenceAffectsLayout: false,
-                    children: contentContainers,
-                  },),
+                  children: /* @__PURE__ */ _jsx5(AnimatePresence, { presenceAffectsLayout: false, children: contentContainers, },),
                 },),
               },),
             },),
-            /* @__PURE__ */ _jsx5(AnimatePresence, {
-              children: overlayContainers,
-            },),
+            /* @__PURE__ */ _jsx5(AnimatePresence, { children: overlayContainers, },),
           ],
         },),
       },),
     },);
   }
 };
-__publicField(Navigation, 'defaultProps', {
-  enabled: true,
-},);
+__publicField(Navigation, 'defaultProps', { enabled: true, },);
 __publicField(Navigation, 'contextType', NavigationCallbackContext,);
-var animationDefault = {
-  stiffness: 500,
-  damping: 50,
-  restDelta: 1,
-  type: 'spring',
-};
+var animationDefault = { stiffness: 500, damping: 50, restDelta: 1, type: 'spring', };
 function activeOverlayItem(overlayStack,) {
   let currentOverlayItem;
   let previousOverlayItem;
-  if (overlayStack.current !== -1) {
-    currentOverlayItem = overlayStack.history[overlayStack.current];
-  } else {
-    previousOverlayItem = overlayStack.history[overlayStack.previous];
-  }
-  return {
-    currentOverlayItem,
-    previousOverlayItem,
-  };
+  if (overlayStack.current !== -1) currentOverlayItem = overlayStack.history[overlayStack.current];
+  else previousOverlayItem = overlayStack.history[overlayStack.previous];
+  return { currentOverlayItem, previousOverlayItem, };
 }
-function transitionPropsForStackWrapper({
-  currentOverlayItem,
-},) {
+function transitionPropsForStackWrapper({ currentOverlayItem, },) {
   return currentOverlayItem && currentOverlayItem.transition.exit;
 }
-function animationForStackWrapper({
-  currentOverlayItem,
-  previousOverlayItem,
-},) {
-  if (currentOverlayItem && currentOverlayItem.transition.animation) {
-    return currentOverlayItem.transition.animation;
-  }
-  if (previousOverlayItem && previousOverlayItem.transition.animation) {
-    return previousOverlayItem.transition.animation;
-  }
+function animationForStackWrapper({ currentOverlayItem, previousOverlayItem, },) {
+  if (currentOverlayItem && currentOverlayItem.transition.animation) return currentOverlayItem.transition.animation;
+  if (previousOverlayItem && previousOverlayItem.transition.animation) return previousOverlayItem.transition.animation;
   return animationDefault;
 }
-function backfaceVisibleForStackWrapper({
-  currentOverlayItem,
-  previousOverlayItem,
-},) {
+function backfaceVisibleForStackWrapper({ currentOverlayItem, previousOverlayItem, },) {
   if (currentOverlayItem) return currentOverlayItem.transition.backfaceVisible;
   return previousOverlayItem && previousOverlayItem.transition.backfaceVisible;
 }
@@ -25524,27 +19367,18 @@ function backdropColorForTransition(transition,) {
   return void 0;
 }
 function getBackfaceVisibleForOverlay(containerIndex, stackState,) {
-  const {
-    current,
-    history,
-  } = stackState;
+  const { current, history, } = stackState;
   if (containerIndex === current) {
     const navigationItem = history[containerIndex];
-    if (navigationItem && navigationItem.transition) {
-      return navigationItem.transition.backfaceVisible;
-    }
+    if (navigationItem && navigationItem.transition) return navigationItem.transition.backfaceVisible;
     return true;
   } else if (containerIndex < current) {
     const navigationItem = history[containerIndex + 1];
-    if (navigationItem && navigationItem.transition) {
-      return navigationItem.transition.backfaceVisible;
-    }
+    if (navigationItem && navigationItem.transition) return navigationItem.transition.backfaceVisible;
     return true;
   } else {
     const navigationItem = history[containerIndex];
-    if (navigationItem && navigationItem.transition) {
-      return navigationItem.transition.backfaceVisible;
-    }
+    if (navigationItem && navigationItem.transition) return navigationItem.transition.backfaceVisible;
     return true;
   }
 }
@@ -25554,76 +19388,47 @@ function initialPropsForOverlay(containerIndex, stackState,) {
 }
 function getBackfaceVisibleForScreen(screenIndex, stackState,) {
   var _a, _b, _c, _d;
-  const {
-    current,
-    previous,
-    history,
-  } = stackState;
+  const { current, previous, history, } = stackState;
   if (screenIndex === previous && current > previous || screenIndex === current && current < previous) {
     return (_b = (_a = history[screenIndex + 1]) == null ? void 0 : _a.transition) == null ? void 0 : _b.backfaceVisible;
   }
   return (_d = (_c = history[screenIndex]) == null ? void 0 : _c.transition) == null ? void 0 : _d.backfaceVisible;
 }
 function transitionPropsForOverlay(overlayIndex, stackState,) {
-  const {
-    current,
-    history,
-  } = stackState;
-  if (overlayIndex === current) {
-    return;
-  } else if (overlayIndex < current) {
+  const { current, history, } = stackState;
+  if (overlayIndex === current) return;
+  else if (overlayIndex < current) {
     const navigationItem = history[overlayIndex + 1];
-    if (navigationItem && navigationItem.transition) {
-      return navigationItem.transition.exit;
-    }
+    if (navigationItem && navigationItem.transition) return navigationItem.transition.exit;
   } else {
     const navigationItem = history[overlayIndex];
-    if (navigationItem && navigationItem.transition) {
-      return navigationItem.transition.enter;
-    }
+    if (navigationItem && navigationItem.transition) return navigationItem.transition.enter;
   }
 }
 function animationPropsForContainer(containerIndex, stackState,) {
-  const {
-    current,
-    previous,
-    history,
-  } = stackState;
+  const { current, previous, history, } = stackState;
   const containerCurrent = previous > current ? previous : current;
   if (containerIndex < containerCurrent) {
     const navigationItem = history[containerIndex + 1];
-    if (navigationItem && navigationItem.transition.animation) {
-      return navigationItem.transition.animation;
-    }
+    if (navigationItem && navigationItem.transition.animation) return navigationItem.transition.animation;
   } else if (containerIndex !== containerCurrent) {
     const navigationItem = history[containerIndex];
-    if (navigationItem && navigationItem.transition.animation) {
-      return navigationItem.transition.animation;
-    }
+    if (navigationItem && navigationItem.transition.animation) return navigationItem.transition.animation;
   } else {
     const navigationItem = history[containerIndex];
-    if (navigationItem == null ? void 0 : navigationItem.transition.animation) {
-      return navigationItem.transition.animation;
-    }
+    if (navigationItem == null ? void 0 : navigationItem.transition.animation) return navigationItem.transition.animation;
   }
   return animationDefault;
 }
 function isInstantContainerTransition(containerIndex, stackState, overCurrentContext,) {
-  const {
-    current,
-    previous,
-    history,
-  } = stackState;
+  const { current, previous, history, } = stackState;
   if (overCurrentContext && history.length > 1) return true;
   if (containerIndex !== previous && containerIndex !== current) return true;
   if (current === previous) return true;
   return false;
 }
 function containerIsVisible(containerIndex, stackState,) {
-  const {
-    current,
-    previous,
-  } = stackState;
+  const { current, previous, } = stackState;
   if (containerIndex > current && containerIndex > previous) return false;
   if (containerIndex === current) return true;
   return false;
@@ -25631,12 +19436,8 @@ function containerIsVisible(containerIndex, stackState,) {
 function containerContent(item,) {
   const content = React__default.Children.map(item.component, (child) => {
     var _a;
-    if (!isReactChild(child,) || !isReactElement(child,) || !child.props) {
-      return child;
-    }
-    const props = {
-      style: child.props.style ?? {},
-    };
+    if (!isReactChild(child,) || !isReactElement(child,) || !child.props) return child;
+    const props = { style: child.props.style ?? {}, };
     const position = (_a = item == null ? void 0 : item.transition) == null ? void 0 : _a.position;
     const shouldStretchWidth = !position || position.left !== void 0 && position.right !== void 0;
     const shouldStretchHeight = !position || position.top !== void 0 && position.bottom !== void 0;
@@ -25713,41 +19514,27 @@ function WithNavigator(BaseComponent, navigationTransition, navigationTransition
                 navigation.modal(component, navigationTransitionOptions,);
                 break;
               case 'push':
-                navigation.push(component, {
-                  appearsFrom,
-                },);
+                navigation.push(component, { appearsFrom, },);
                 break;
               case 'overlay':
-                navigation.overlay(component, {
-                  ...navigationTransitionOptions,
-                  appearsFrom,
-                },);
+                navigation.overlay(component, { ...navigationTransitionOptions, appearsFrom, },);
                 break;
               case 'flip':
-                navigation.flip(component, {
-                  appearsFrom,
-                },);
+                navigation.flip(component, { appearsFrom, },);
                 break;
               case 'magicMotion':
                 navigation.magicMotion(component, {},);
                 break;
             }
           };
-          const {
-            onTap,
-            ...props
-          } = this.props;
+          const { onTap, ...props } = this.props;
           if (onTap) {
             props.onTap = (...args) => {
               onTap.apply(this, args,);
               navigate.apply(this, args,);
             };
-          } else {
-            props.onTap = navigate;
-          }
-          return /* @__PURE__ */ _jsx5(BaseComponent, {
-            ...props,
-          },);
+          } else props.onTap = navigate;
+          return /* @__PURE__ */ _jsx5(BaseComponent, { ...props, },);
         },
       },);
     }
@@ -25782,35 +19569,15 @@ function debounce(fn, time22,) {
   debounced.cancel = cancel;
   return debounced;
 }
-function useWheelScroll(ref, {
-  enabled,
-  initial,
-  prev,
-  direction,
-  constraints,
-  offsetX,
-  offsetY,
-  onScrollStart,
-  onScroll,
-  onScrollEnd,
-},) {
+function useWheelScroll(ref, { enabled, initial, prev, direction, constraints, offsetX, offsetY, onScrollStart, onScroll, onScrollEnd, },) {
   const isWheelScrollActive = useRef(false,);
   const getPointData = useCallback(() => {
     const point2 = getPoint(offsetX, offsetY,);
     const data2 = {
       point: point2,
-      velocity: {
-        x: offsetX.getVelocity(),
-        y: offsetY.getVelocity(),
-      },
-      offset: {
-        x: point2.x - initial.x,
-        y: point2.y - initial.y,
-      },
-      delta: {
-        x: point2.x - prev.x,
-        y: point2.y - prev.y,
-      },
+      velocity: { x: offsetX.getVelocity(), y: offsetY.getVelocity(), },
+      offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
+      delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
     };
     prev.x = point2.x;
     prev.y = point2.y;
@@ -25863,35 +19630,18 @@ function useWheelScroll(ref, {
       debouncedOnScrollEnd();
     };
   }
-  useDomEvent(ref, 'wheel', handler, {
-    passive: false,
-  },);
+  useDomEvent(ref, 'wheel', handler, { passive: false, },);
 }
 function getPoint(x, y,) {
-  return {
-    x: x.get(),
-    y: y.get(),
-  };
+  return { x: x.get(), y: y.get(), };
 }
 function hasPaddingPerSide(props,) {
-  const {
-    paddingPerSide,
-    paddingTop,
-    paddingBottom,
-    paddingLeft,
-    paddingRight,
-  } = props;
+  const { paddingPerSide, paddingTop, paddingBottom, paddingLeft, paddingRight, } = props;
   return paddingPerSide !== false &&
     (paddingTop !== void 0 || paddingBottom !== void 0 || paddingLeft !== void 0 || paddingRight !== void 0);
 }
 function paddingFromProps(props,) {
-  const {
-    padding = 0,
-    paddingTop,
-    paddingBottom,
-    paddingLeft,
-    paddingRight,
-  } = props;
+  const { padding = 0, paddingTop, paddingBottom, paddingLeft, paddingRight, } = props;
   if (hasPaddingPerSide(props,)) {
     return {
       top: paddingTop !== void 0 ? paddingTop : padding,
@@ -25900,22 +19650,10 @@ function paddingFromProps(props,) {
       right: paddingRight !== void 0 ? paddingRight : padding,
     };
   }
-  return {
-    top: padding,
-    bottom: padding,
-    left: padding,
-    right: padding,
-  };
+  return { top: padding, bottom: padding, left: padding, right: padding, };
 }
-function makePaddingString({
-  top,
-  left,
-  bottom,
-  right,
-},) {
-  if (top === right && right === bottom && bottom === left) {
-    return `${top}px`;
-  }
+function makePaddingString({ top, left, bottom, right, },) {
+  if (top === right && right === bottom && bottom === left) return `${top}px`;
   return `${top}px ${right}px ${bottom}px ${left}px`;
 }
 function triggerStackReflow(element, display,) {
@@ -25976,37 +19714,21 @@ var Stack = /* @__PURE__ */ (() => {
     const padding = hasPaddingPerSide(containerProps,) || containerProps.padding
       ? makePaddingString(paddingFromProps(containerProps,),)
       : void 0;
-    const style = {
-      ...styleProp,
-    };
-    Layer.applyWillChange(
-      {
-        willChangeTransform,
-      },
-      style,
-      true,
-    );
+    const style = { ...styleProp, };
+    Layer.applyWillChange({ willChangeTransform, }, style, true,);
     if (__fromCodeComponentNode && !constraintsEnabled(unwrapFrameProps(containerProps,),)) {
       containerProps.width = '100%';
       containerProps.height = '100%';
-      containerProps._constraints = {
-        enabled: true,
-      };
+      containerProps._constraints = { enabled: true, };
     }
     const layoutId = useLayoutId2(stackProps,);
-    const {
-      children: _children,
-      props,
-    } = processOverrideForwarding(containerProps, children,);
+    const { children: _children, props, } = processOverrideForwarding(containerProps, children,);
     const widthType = containerProps.widthType ?? (containerProps.width === 'auto' ? 2 : 0);
     const heightType = containerProps.heightType ?? (containerProps.height === 'auto' ? 2 : 0);
     const fractionChildren = handleFraction(_children, direction, widthType, heightType,);
     const gapChildren = wrapInGapElementForLegacyGap(fractionChildren, gap, flexDirection, justifyContent, useFlexboxGap, wrap2,);
-    const content = useProvideParentSize(gapChildren, parentSize ?? 1,/* Disabled */
-    );
-    const attributes = {
-      'data-framer-component-type': 'Stack',
-    };
+    const content = useProvideParentSize(gapChildren, parentSize ?? 1, /* Disabled */);
+    const attributes = { 'data-framer-component-type': 'Stack', };
     const fromCanvasComponent = containerProps.__fromCanvasComponent;
     if (fromCanvasComponent) attributes['data-framer-generated'] = true;
     const alignItems = toJustifyOrAlignment(alignment,);
@@ -26023,19 +19745,11 @@ var Stack = /* @__PURE__ */ (() => {
     const gapEnabled = isGapEnabled(gap, justifyContent, wrap2,);
     if (useFlexboxGap && gapEnabled) {
       const gapSupportedInMainAxis = isGapSupportedInMainAxis(justifyContent,);
-      if (gapSupportedInMainAxis || direction !== 'horizontal') {
-        asRecord(contentWrapperStyle,)['--stack-native-column-gap'] = `${gap}px`;
-      }
-      if (gapSupportedInMainAxis || direction !== 'vertical') {
-        asRecord(contentWrapperStyle,)['--stack-native-row-gap'] = `${gap}px`;
-      }
-    }
-    if (contentWrapperStyle.width === void 0) {
-      contentWrapperStyle.width = widthType === 2 ? 'min-content' : '100%';
-    }
-    if (contentWrapperStyle.height === void 0) {
-      contentWrapperStyle.height = heightType === 2 ? 'min-content' : '100%';
+      if (gapSupportedInMainAxis || direction !== 'horizontal') asRecord(contentWrapperStyle,)['--stack-native-column-gap'] = `${gap}px`;
+      if (gapSupportedInMainAxis || direction !== 'vertical') asRecord(contentWrapperStyle,)['--stack-native-row-gap'] = `${gap}px`;
     }
+    if (contentWrapperStyle.width === void 0) contentWrapperStyle.width = widthType === 2 ? 'min-content' : '100%';
+    if (contentWrapperStyle.height === void 0) contentWrapperStyle.height = heightType === 2 ? 'min-content' : '100%';
     if (fromCanvasComponent) {
       if (styleProp == null ? void 0 : styleProp.width) contentWrapperStyle.width = styleProp == null ? void 0 : styleProp.width;
       if (styleProp == null ? void 0 : styleProp.height) contentWrapperStyle.height = styleProp == null ? void 0 : styleProp.height;
@@ -26060,17 +19774,10 @@ var Stack = /* @__PURE__ */ (() => {
       },),
     },);
   },);
-  StackInner.defaultProps = {
-    distribution: 'start',
-  };
+  StackInner.defaultProps = { distribution: 'start', };
   StackInner.displayName = 'Stack';
   addPropertyControls(StackInner, {
-    direction: {
-      type: 'segmentedenum',
-      options: ['horizontal', 'vertical',],
-      title: 'Direction',
-      defaultValue: 'vertical',
-    },
+    direction: { type: 'segmentedenum', options: ['horizontal', 'vertical',], title: 'Direction', defaultValue: 'vertical', },
     distribution: {
       type: 'enum',
       options: ['start', 'center', 'end', 'space-between', 'space-around', 'space-evenly',],
@@ -26078,12 +19785,7 @@ var Stack = /* @__PURE__ */ (() => {
       title: 'Distribute',
       defaultValue: 'space-around',
     },
-    alignment: {
-      type: 'segmentedenum',
-      options: ['start', 'center', 'end',],
-      title: 'Align',
-      defaultValue: 'center',
-    },
+    alignment: { type: 'segmentedenum', options: ['start', 'center', 'end',], title: 'Align', defaultValue: 'center', },
     gap: {
       type: 'number',
       min: 0,
@@ -26119,14 +19821,8 @@ function handleFraction(children, direction, widthType, heightType,) {
     const isVertical = direction === 'vertical';
     const style = {};
     let hasFraction = false;
-    const {
-      style: propsStyle,
-      size: size2,
-    } = child.props;
-    let {
-      width,
-      height,
-    } = child.props;
+    const { style: propsStyle, size: size2, } = child.props;
+    let { width, height, } = child.props;
     if (size2 !== void 0) {
       if (width === void 0) width = size2;
       if (height === void 0) height = size2;
@@ -26140,9 +19836,7 @@ function handleFraction(children, direction, widthType, heightType,) {
         if (widthType === 2) {
           style.alignSelf = 'stretch';
           newWidth = 'auto';
-        } else {
-          newWidth = `${fraction(width,) * 100}%`;
-        }
+        } else newWidth = `${fraction(width,) * 100}%`;
       } else {
         newWidth = 1;
         style.flexGrow = fraction(width,);
@@ -26156,26 +19850,15 @@ function handleFraction(children, direction, widthType, heightType,) {
         newHeight = 1;
         style.flexGrow = fraction(height,);
         style.flexBasis = 0;
-      } else {
-        if (heightType === 2) {
+      } else {if (heightType === 2) {
           style.alignSelf = 'stretch';
           newHeight = 'auto';
-        } else {
-          newHeight = `${fraction(height,) * 100}%`;
-        }
-      }
+        } else newHeight = `${fraction(height,) * 100}%`;}
       style.height = newHeight;
     }
     if (!hasFraction) return child;
-    const nextStyle = {
-      ...propsStyle,
-      ...style,
-    };
-    return React__default.cloneElement(child, {
-      width: newWidth,
-      height: newHeight,
-      style: nextStyle,
-    },);
+    const nextStyle = { ...propsStyle, ...style, };
+    return React__default.cloneElement(child, { width: newWidth, height: newHeight, style: nextStyle, },);
   },);
 }
 function isGapSupportedInMainAxis(justifyContent,) {
@@ -26183,17 +19866,12 @@ function isGapSupportedInMainAxis(justifyContent,) {
   return !['space-between', 'space-around', 'space-evenly', 'stretch',].includes(justifyContent,);
 }
 function isGapEnabled(gap, justifyContent, wrap2,) {
-  if (!gap) {
-    return false;
-  }
-  if (!wrap2 && !isGapSupportedInMainAxis(justifyContent,)) {
-    return false;
-  }
+  if (!gap) return false;
+  if (!wrap2 && !isGapSupportedInMainAxis(justifyContent,)) return false;
   return true;
 }
 function wrapInGapElementForLegacyGap(children, gap, direction, justifyContent, useFlexboxGap, wrap2,) {
-  const gapStyle = {
-    // We need the wrapper to have `display: contents` to prevent the child
+  const gapStyle = { // We need the wrapper to have `display: contents` to prevent the child
     // margins from collapsing when using the fallback gap solution.
     // https://codesandbox.io/s/dreamy-haslett-01ie5?file=/src/styles.css
     display: 'contents',
@@ -26246,32 +19924,31 @@ function toJustifyOrAlignment(distribution,) {
 function useForwardedRef(forwardedRef, innerRef,) {
   return (element) => {
     innerRef.current = element;
-    if (typeof forwardedRef === 'function') {
-      forwardedRef(element,);
-    } else if (forwardedRef) {
-      forwardedRef.current = element;
-    }
+    if (typeof forwardedRef === 'function') forwardedRef(element,);
+    else if (forwardedRef) forwardedRef.current = element;
   };
 }
 var pageContentWrapperType = 'PageContentWrapper';
-function PageContainer({
-  children,
-  effect,
-  dragEnabled,
-  direction,
-  contentHeight,
-  contentWidth,
-  alignment,
-  gap,
-  isLastPage,
-  contentOffsetRef,
-  constraintsRef,
-  directionLock,
-  onDragStart,
-  onDrag,
-  onDragEnd,
-  layoutId,
-},) {
+function PageContainer(
+  {
+    children,
+    effect,
+    dragEnabled,
+    direction,
+    contentHeight,
+    contentWidth,
+    alignment,
+    gap,
+    isLastPage,
+    contentOffsetRef,
+    constraintsRef,
+    directionLock,
+    onDragStart,
+    onDrag,
+    onDragEnd,
+    layoutId,
+  },
+) {
   const isHorizontalDirection = direction === 'horizontal';
   const dragAxis = isHorizontalDirection ? 'x' : 'y';
   const hasHorizontalGap = isHorizontalDirection && !isLastPage && gap;
@@ -26298,11 +19975,7 @@ function PageContainer({
     onDragStart,
     onDragEnd,
     preserve3d: true,
-    style: {
-      pointerEvents: void 0,
-      paddingRight: hasHorizontalGap ? gap : 0,
-      paddingBottom: hasVerticalGap ? gap : 0,
-    },
+    style: { pointerEvents: void 0, paddingRight: hasHorizontalGap ? gap : 0, paddingBottom: hasVerticalGap ? gap : 0, },
     children: /* @__PURE__ */ _jsx5(FrameWithMotion, {
       position: 'relative',
       'data-framer-component-type': pageContentWrapperType,
@@ -26356,37 +20029,17 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     layoutId: specificLayoutId,
     ...rest
   } = props;
-  const layoutId = useLayoutId2(props, {
-    specificLayoutId,
-    postfix: 'page',
-  },);
-  const containerProps = {
-    ...rest,
-    background,
-  };
+  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'page', },);
+  const containerProps = { ...rest, background, };
   const hasMountedRef = React__default.useRef(false,);
   const hasFixedSize = RenderTarget.hasRestrictions() && props.__fromCodeComponentNode && isFiniteNumber(containerProps.width,) &&
     isFiniteNumber(containerProps.height,);
   if (!hasFixedSize && __fromCodeComponentNode && !containerProps.__fromCanvasComponent) {
     containerProps.width = '100%';
     containerProps.height = '100%';
-    containerProps._constraints = {
-      enabled: true,
-    };
+    containerProps._constraints = { enabled: true, };
   }
-  const {
-    initial,
-    prev,
-  } = React__default.useRef({
-    initial: {
-      x: 0,
-      y: 0,
-    },
-    prev: {
-      x: 0,
-      y: 0,
-    },
-  },).current;
+  const { initial, prev, } = React__default.useRef({ initial: { x: 0, y: 0, }, prev: { x: 0, y: 0, }, },).current;
   const isHorizontal = direction === 'horizontal';
   let gap = gapValue;
   if (gap < 0) {
@@ -26398,12 +20051,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
   }, [],);
   const pageCount = React__default.Children.count(children,);
   const maxOffsetRef = React__default.useRef(0,);
-  const constraints = React__default.useRef({
-    top: 0,
-    left: 0,
-    right: 0,
-    bottom: 0,
-  },);
+  const constraints = React__default.useRef({ top: 0, left: 0, right: 0, bottom: 0, },);
   const fallbackContainerRef = React__default.useRef(null,);
   const containerRef = forwardedRef || fallbackContainerRef;
   const scrollableRef = React__default.useRef(null,);
@@ -26422,10 +20070,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
   const lastDirectionRef = React__default.useRef(props.direction,);
   const snapToPage = useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal,);
   const [_, setForceUpdateCount,] = React__default.useState(0,);
-  const containerSizeRef = React__default.useRef({
-    width: 200,
-    height: 200,
-  },);
+  const containerSizeRef = React__default.useRef({ width: 200, height: 200, },);
   if (hasFixedSize && isFiniteNumber(containerProps.width,) && isFiniteNumber(containerProps.height,)) {
     containerSizeRef.current.width = containerProps.width;
     containerSizeRef.current.height = containerProps.height;
@@ -26446,9 +20091,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
       if (!effectDictionary || !values) return;
       for (const [key7, value,] of Object.entries(values,)) {
         const effectValue = effectDictionary[key7];
-        if (isMotionValue2(effectValue,)) {
-          effectValue.set(value,);
-        }
+        if (isMotionValue2(effectValue,)) effectValue.set(value,);
       }
     },);
   };
@@ -26466,16 +20109,10 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
   const measureContainerSize = () => {
     const element = containerRef.current;
     if (!element) return null;
-    const {
-      offsetWidth,
-      offsetHeight,
-    } = element;
+    const { offsetWidth, offsetHeight, } = element;
     const currentSize = containerSizeRef.current;
     if (offsetWidth !== currentSize.width || offsetHeight !== currentSize.height) {
-      containerSizeRef.current = {
-        width: offsetWidth,
-        height: offsetHeight,
-      };
+      containerSizeRef.current = { width: offsetWidth, height: offsetHeight, };
       return containerSizeRef.current;
     }
     return null;
@@ -26489,9 +20126,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     }
     const offset = offsetForPage(newBoundedCurrentPage, pageCount, pageRectsRef, isHorizontal, maxOffsetRef,);
     const animated = animateCurrentPageUpdate && RenderTarget.current() !== 'CANVAS' && !mount;
-    snapToPage(newBoundedCurrentPage, offset, {
-      animated,
-    },);
+    snapToPage(newBoundedCurrentPage, offset, { animated, },);
   };
   useIsomorphicLayoutEffect2(() => {
     if (hasMountedRef.current) return;
@@ -26515,11 +20150,8 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     updateMaxOffsetFromPageContents(newContainerSize ?? containerSizeRef.current,);
     updateAndSnapToPage(currentContentPageRef.current,);
     if (newContainerSize || direction !== lastDirectionRef.current) {
-      if (direction === 'horizontal') {
-        contentOffsetRef.current.y.set(0,);
-      } else {
-        contentOffsetRef.current.x.set(0,);
-      }
+      if (direction === 'horizontal') contentOffsetRef.current.y.set(0,);
+      else contentOffsetRef.current.x.set(0,);
       lastDirectionRef.current = direction;
     }
   };
@@ -26542,28 +20174,13 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
   const onDragTransitionEnd = () => {
     if (props.onDragTransitionEnd) props.onDragTransitionEnd();
     if (onScrollEnd) {
-      const {
-        x,
-        y,
-      } = contentOffsetRef.current;
-      const point2 = {
-        x: x.get(),
-        y: y.get(),
-      };
+      const { x, y, } = contentOffsetRef.current;
+      const point2 = { x: x.get(), y: y.get(), };
       onScrollEnd({
         point: point2,
-        velocity: {
-          x: x.getVelocity(),
-          y: y.getVelocity(),
-        },
-        offset: {
-          x: point2.x - initial.x,
-          y: point2.y - initial.y,
-        },
-        delta: {
-          x: point2.x - prev.x,
-          y: point2.y - prev.y,
-        },
+        velocity: { x: x.getVelocity(), y: y.getVelocity(), },
+        offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
+        delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
       },);
     }
   };
@@ -26590,28 +20207,12 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     if (onDragEnd) onDragEnd(event, info,);
     const handler = contentOffsetRef.current[axis];
     handler.set(startPosition,);
-    animate(handler, offset, {
-      type: 'spring',
-      velocity,
-      stiffness: 500,
-      damping: 50,
-      onComplete: onDragTransitionEnd,
-    },);
+    animate(handler, offset, { type: 'spring', velocity, stiffness: 500, damping: 50, onComplete: onDragTransitionEnd, },);
   };
   pageEffectValuesRef.current = [];
   const childComponents = React__default.Children.map(children, (child, index,) => {
-    if (!isReactChild(child,) || !isReactElement(child,)) {
-      return child;
-    }
-    const update = {
-      right: void 0,
-      bottom: void 0,
-      top: void 0,
-      left: void 0,
-      _constraints: {
-        enabled: false,
-      },
-    };
+    if (!isReactChild(child,) || !isReactElement(child,)) return child;
+    const update = { right: void 0, bottom: void 0, top: void 0, left: void 0, _constraints: { enabled: false, }, };
     if (containerProps.__fromCanvasComponent) {
       update.style = child.props.style ?? {};
       if (contentWidth === 'stretch') update.style.width = '100%';
@@ -26624,9 +20225,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef,);
     if (values) {
       effectDictionary = {};
-      for (const key7 in values) {
-        effectDictionary[key7] = motionValue(values[key7],);
-      }
+      for (const key7 in values) effectDictionary[key7] = motionValue(values[key7],);
     }
     pageEffectValuesRef.current.push(effectDictionary,);
     return /* @__PURE__ */ _jsx5(PageContainer, {
@@ -26665,11 +20264,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
     preserve3d: false,
     perspective: hasEffect(props,) ? 1200 : void 0,
     ...containerProps,
-    style: {
-      pointerEvents: void 0,
-      ...containerProps.style,
-      overflow,
-    },
+    style: { pointerEvents: void 0, ...containerProps.style, overflow, },
     layoutId,
     ref: containerRef,
     onLayoutMeasure: handleMeasureLifecycle,
@@ -26704,10 +20299,7 @@ var Page = /* @__PURE__ */ React__default.forwardRef(function Page2(props, forwa
   },);
 },);
 function cubeEffect(info,) {
-  const {
-    normalizedOffset,
-    direction,
-  } = info;
+  const { normalizedOffset, direction, } = info;
   const isHorizontal = direction === 'horizontal';
   return {
     originX: normalizedOffset < 0 ? 1 : 0,
@@ -26719,11 +20311,7 @@ function cubeEffect(info,) {
   };
 }
 function coverflowEffect(info,) {
-  const {
-    normalizedOffset,
-    direction,
-    size: size2,
-  } = info;
+  const { normalizedOffset, direction, size: size2, } = info;
   const isHorizontal = direction === 'horizontal';
   return {
     rotateY: isHorizontal ? Math.min(45, Math.max(-45, normalizedOffset * -45,),) : 0,
@@ -26740,11 +20328,7 @@ function calcPileAxisOffset(offset, length,) {
   return offset * length - offset * 8;
 }
 function pileEffect(info,) {
-  const {
-    normalizedOffset,
-    direction,
-    size: size2,
-  } = info;
+  const { normalizedOffset, direction, size: size2, } = info;
   const isHorizontal = direction === 'horizontal';
   const absoluteOffset = Math.abs(normalizedOffset,);
   return {
@@ -26754,11 +20338,7 @@ function pileEffect(info,) {
   };
 }
 function wheelEffect(info,) {
-  const {
-    normalizedOffset,
-    direction,
-    size: size2,
-  } = info;
+  const { normalizedOffset, direction, size: size2, } = info;
   const isHorizontal = direction === 'horizontal';
   const originZ = (isHorizontal ? size2.width : size2.height) * 18 / (2 * Math.PI);
   const rotateX = isHorizontal ? 0 : normalizedOffset * -20;
@@ -26817,9 +20397,7 @@ function getPageContentRects(containerRef, containerSize, direction, gap,) {
     const childNode = node.firstChild;
     if (!(childNode instanceof HTMLElement)) return;
     const componentType = childNode.getAttribute('data-framer-component-type',);
-    if (componentType === pageContentWrapperType) {
-      contentWrappers.push(childNode,);
-    }
+    if (componentType === pageContentWrapperType) contentWrappers.push(childNode,);
   },);
   const sizes = [];
   contentWrappers.forEach((contentWrapper) => {
@@ -26830,13 +20408,8 @@ function getPageContentRects(containerRef, containerSize, direction, gap,) {
         width = 100;
         height = 100;
       }
-      sizes.push({
-        width,
-        height,
-      },);
-    } else {
-      sizes.push(null,);
-    }
+      sizes.push({ width, height, },);
+    } else sizes.push(null,);
   },);
   let maxX = 0;
   let maxY = 0;
@@ -26845,16 +20418,9 @@ function getPageContentRects(containerRef, containerSize, direction, gap,) {
     const size2 = queriedSize || containerSize;
     const x = maxX;
     const y = maxY;
-    if (isHorizontal) {
-      maxX += size2.width + gap;
-    } else {
-      maxY += size2.height + gap;
-    }
-    return {
-      ...size2,
-      x,
-      y,
-    };
+    if (isHorizontal) maxX += size2.width + gap;
+    else maxY += size2.height + gap;
+    return { ...size2, x, y, };
   },);
 }
 function getMaxOffset(containerSize, pageContentRects, direction, paddingProps,) {
@@ -26874,14 +20440,9 @@ function getMaxOffset(containerSize, pageContentRects, direction, paddingProps,)
 function offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef,) {
   const pageIndex = Math.max(0, Math.min(pageCount - 1, index,),);
   const currentPageRect = pageRectsRef.current[pageIndex];
-  if (!currentPageRect) {
-    return 0;
-  }
-  if (isHorizontal) {
-    return -Math.min(currentPageRect.x, maxOffsetRef.current,);
-  } else {
-    return -Math.min(currentPageRect.y, maxOffsetRef.current,);
-  }
+  if (!currentPageRect) return 0;
+  if (isHorizontal) return -Math.min(currentPageRect.x, maxOffsetRef.current,);
+  else return -Math.min(currentPageRect.y, maxOffsetRef.current,);
 }
 function useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal,) {
   return (pageIndex, offset, options,) => {
@@ -26894,31 +20455,18 @@ function useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal,) {
     const axis = isHorizontal ? 'x' : 'y';
     const value = contentOffsetRef.current[axis];
     value.set(contentOffset.get(),);
-    animate(value, offset, {
-      type: 'spring',
-      velocity: contentOffset.getVelocity(),
-      stiffness: 500,
-      damping: 50,
-    },);
+    animate(value, offset, { type: 'spring', velocity: contentOffset.getVelocity(), stiffness: 500, damping: 50, },);
   };
 }
 function getBoundedCurrentPage(pageIndex, pageCount,) {
   return pageIndex >= 0 ? Math.min(pageIndex, pageCount - 1,) : (pageIndex % pageCount + pageCount) % pageCount;
 }
 function effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef,) {
-  const {
-    direction: latestDirection = 'horizontal',
-    defaultEffect: latestDefaultEffect,
-    effect: latestEffect,
-    gap: latestGap = 10,
-  } = latestPropsRef.current;
+  const { direction: latestDirection = 'horizontal', defaultEffect: latestDefaultEffect, effect: latestEffect, gap: latestGap = 10, } =
+    latestPropsRef.current;
   const latestIsHorizontal = latestDirection === 'horizontal';
-  const pageRect = pageRectsRef.current[index] || {
-    x: latestIsHorizontal ? index * 200 + latestGap : 0,
-    y: latestIsHorizontal ? 0 : index * 200 + latestGap,
-    width: 200,
-    height: 200,
-  };
+  const pageRect = pageRectsRef.current[index] ||
+    { x: latestIsHorizontal ? index * 200 + latestGap : 0, y: latestIsHorizontal ? 0 : index * 200 + latestGap, width: 200, height: 200, };
   const effectFunction = latestEffect || getDefaultEffect(latestDefaultEffect,);
   if (!effectFunction) return null;
   let offset;
@@ -26932,10 +20480,7 @@ function effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, max
     offset = Math.min(pageRect.y, maxScrollOffset,) + (contentOffset ? contentOffset.y.get() : 0);
     normalizedOffset = offset / (pageRect.height + latestGap);
   }
-  const size2 = {
-    width: pageRect.width,
-    height: pageRect.height,
-  };
+  const size2 = { width: pageRect.width, height: pageRect.height, };
   return effectFunction({
     offset,
     normalizedOffset,
@@ -26955,10 +20500,7 @@ function updateCurrentPage(newPageIndex, currentContentPageRef, onChangePage,) {
   currentContentPageRef.current = newPageIndex;
 }
 var Page3 = /* @__PURE__ */ (() => {
-  const ContentDimension = {
-    Auto: 'auto',
-    Stretch: 'stretch',
-  };
+  const ContentDimension = { Auto: 'auto', Stretch: 'stretch', };
   const pageContentDimensionOptions = [ContentDimension.Auto, ContentDimension.Stretch,];
   const pageContentDimensionTitles = /* @__PURE__ */ pageContentDimensionOptions.map((option) => {
     switch (option) {
@@ -26994,10 +20536,7 @@ var Page3 = /* @__PURE__ */ (() => {
         return 'End';
     }
   },);
-  Page.defaultProps = {
-    gap: 10,
-    directionLock: false,
-  };
+  Page.defaultProps = { gap: 10, directionLock: false, };
   addPropertyControls(Page, {
     direction: {
       type: 'enum',
@@ -27007,13 +20546,7 @@ var Page3 = /* @__PURE__ */ (() => {
       displaySegmentedControl: true,
       optionIcons: ['direction-horizontal', 'direction-vertical',],
     },
-    directionLock: {
-      type: 'boolean',
-      title: 'Lock',
-      enabledTitle: '1 Axis',
-      disabledTitle: 'Off',
-      defaultValue: true,
-    },
+    directionLock: { type: 'boolean', title: 'Lock', enabledTitle: '1 Axis', disabledTitle: 'Off', defaultValue: true, },
     contentWidth: {
       type: 'enum',
       options: pageContentDimensionOptions,
@@ -27036,11 +20569,7 @@ var Page3 = /* @__PURE__ */ (() => {
       optionTitles: genericAlignmentTitles,
       title: 'Align',
       hidden(props,) {
-        const {
-          direction,
-          contentWidth,
-          contentHeight,
-        } = props;
+        const { direction, contentWidth, contentHeight, } = props;
         const isHorizontalDirection = direction === 'horizontal';
         const crossDimension = isHorizontalDirection ? contentHeight : contentWidth;
         return crossDimension === ContentDimension.Stretch;
@@ -27054,12 +20583,7 @@ var Page3 = /* @__PURE__ */ (() => {
         },
       },
     },
-    gap: {
-      type: 'number',
-      min: 0,
-      title: 'Gap',
-      defaultValue: 0,
-    },
+    gap: { type: 'number', min: 0, title: 'Gap', defaultValue: 0, },
     padding: {
       type: 'fusednumber',
       toggleKey: 'paddingPerSide',
@@ -27078,49 +20602,12 @@ var Page3 = /* @__PURE__ */ (() => {
       optionTitles: ['Visible', 'Hidden',],
       displaySegmentedControl: true,
     },
-    currentPage: {
-      type: 'number',
-      min: 0,
-      title: 'Current',
-      displayStepper: true,
-      defaultValue: 0,
-    },
-    momentum: {
-      type: 'boolean',
-      enabledTitle: 'On',
-      disabledTitle: 'Off',
-      title: 'Momentum',
-      defaultValue: false,
-    },
-    dragEnabled: {
-      type: 'boolean',
-      title: 'Drag',
-      enabledTitle: 'On',
-      disabledTitle: 'Off',
-      defaultValue: true,
-    },
-    wheelEnabled: {
-      type: 'boolean',
-      title: 'Wheel',
-      enabledTitle: 'On',
-      disabledTitle: 'Off',
-      defaultValue: false,
-    },
-    defaultEffect: {
-      type: 'enum',
-      options: pageEffectOptions,
-      optionTitles: pageEffectTitles,
-      title: 'Effect',
-      defaultValue: 'none',
-    },
-    children: {
-      type: 'array',
-      title: 'Content',
-      control: {
-        type: 'componentinstance',
-        title: 'Page',
-      },
-    },
+    currentPage: { type: 'number', min: 0, title: 'Current', displayStepper: true, defaultValue: 0, },
+    momentum: { type: 'boolean', enabledTitle: 'On', disabledTitle: 'Off', title: 'Momentum', defaultValue: false, },
+    dragEnabled: { type: 'boolean', title: 'Drag', enabledTitle: 'On', disabledTitle: 'Off', defaultValue: true, },
+    wheelEnabled: { type: 'boolean', title: 'Wheel', enabledTitle: 'On', disabledTitle: 'Off', defaultValue: false, },
+    defaultEffect: { type: 'enum', options: pageEffectOptions, optionTitles: pageEffectTitles, title: 'Effect', defaultValue: 'none', },
+    children: { type: 'array', title: 'Content', control: { type: 'componentinstance', title: 'Page', }, },
   },);
   Page.supportsConstraints = true;
   return Page;
@@ -27150,8 +20637,7 @@ function containsBitmask(value, bitmask,) {
 }
 var GestureRecognizer = class {
   constructor() {
-    __publicField(this, '_state', 2,/* Possible */
-    );
+    __publicField(this, '_state', 2, /* Possible */);
     __publicField(this, 'handler',);
     __publicField(this, 'preventers', [],);
   }
@@ -27205,23 +20691,11 @@ var GestureRecognizer = class {
     this.setState(newState,);
   }
   cancel() {
-    if (
-      this.hasState(4 | 8,/* Changed */
-      )
-    ) {
-      this.setState(64,/* Cancelled */
-      );
-    }
+    if (this.hasState(4 | 8, /* Changed */)) this.setState(64, /* Cancelled */);
     this.reset();
   }
   reset() {
-    if (
-      !this.hasState(2,/* Possible */
-      )
-    ) {
-      this.stateSwitch(2,/* Possible */
-      );
-    }
+    if (!this.hasState(2, /* Possible */)) this.stateSwitch(2, /* Possible */);
   }
 };
 var MouseWheelGestureRecognizer = class extends GestureRecognizer {
@@ -27234,8 +20708,7 @@ var MouseWheelGestureRecognizer = class extends GestureRecognizer {
       'onMouseWheelEnd',
       debounce((event) => {
         if (this.handler && this.startEvent) {
-          this.stateSwitch(16,/* Ended */
-          );
+          this.stateSwitch(16, /* Ended */);
           this.handler.gestureEnded(this.eventType, event, this.startEvent.target,);
           this.startEvent = null;
           this.reset();
@@ -27248,22 +20721,14 @@ var MouseWheelGestureRecognizer = class extends GestureRecognizer {
   pointerSessionEnded(session, event,) {}
   mouseWheel(session, event,) {
     if (!this.handler) return;
-    if (
-      this.hasState(2,/* Possible */
-      )
-    ) {
+    if (this.hasState(2, /* Possible */)) {
       this.startEvent = event;
-      this.stateSwitch(4,/* Began */
-      );
+      this.stateSwitch(4, /* Began */);
       this.handler.gestureBegan(this.eventType, event, this.startEvent.target,);
       return;
     }
-    if (
-      this.hasState(4 | 8,/* Changed */
-      ) && this.startEvent
-    ) {
-      this.stateSwitch(8,/* Changed */
-      );
+    if (this.hasState(4 | 8, /* Changed */) && this.startEvent) {
+      this.stateSwitch(8, /* Changed */);
       this.handler.gestureChanged(this.eventType, event, this.startEvent.target,);
     }
     this.onMouseWheelEnd(event,);
@@ -27286,11 +20751,8 @@ var PanGestureRecognizer = class extends GestureRecognizer {
   }
   recognize(session, event,) {
     if (Math.abs(event.delta.x,) > 0 || Math.abs(event.delta.y,) > 0) {
-      if (this.startEvent) {
-        this.pan(event,);
-      } else {
-        this.panstart(event,);
-      }
+      if (this.startEvent) this.pan(event,);
+      else this.panstart(event,);
     }
   }
   reset() {
@@ -27298,50 +20760,22 @@ var PanGestureRecognizer = class extends GestureRecognizer {
     super.reset();
   }
   panstart(event,) {
-    if (
-      !this.hasState(2,/* Possible */
-      ) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick
-    ) {
-      return;
-    }
-    this.stateSwitch(4,/* Began */
-    );
+    if (!this.hasState(2, /* Possible */) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick) return;
+    this.stateSwitch(4, /* Began */);
     this.startEvent = event;
-    if (this.handler && this.startEvent.target) {
-      this.handler.gestureBegan(this.eventType, event, this.startEvent.target,);
-    }
+    if (this.handler && this.startEvent.target) this.handler.gestureBegan(this.eventType, event, this.startEvent.target,);
   }
   pan(event,) {
-    if (
-      !this.hasState(4 | 8,/* Changed */
-      )
-    ) {
-      return;
-    }
-    if (!this.startEvent) {
-      return;
-    }
-    this.stateSwitch(8,/* Changed */
-    );
-    if (this.handler && this.startEvent.target) {
-      this.handler.gestureChanged(this.eventType, event, this.startEvent.target,);
-    }
+    if (!this.hasState(4 | 8, /* Changed */)) return;
+    if (!this.startEvent) return;
+    this.stateSwitch(8, /* Changed */);
+    if (this.handler && this.startEvent.target) this.handler.gestureChanged(this.eventType, event, this.startEvent.target,);
   }
   panend(event,) {
-    if (
-      !this.hasState(4 | 8,/* Changed */
-      )
-    ) {
-      return;
-    }
-    if (!this.startEvent) {
-      return;
-    }
-    this.stateSwitch(16,/* Ended */
-    );
-    if (this.handler && this.startEvent.target) {
-      this.handler.gestureEnded(this.eventType, event, this.startEvent.target,);
-    }
+    if (!this.hasState(4 | 8, /* Changed */)) return;
+    if (!this.startEvent) return;
+    this.stateSwitch(16, /* Ended */);
+    if (this.handler && this.startEvent.target) this.handler.gestureEnded(this.eventType, event, this.startEvent.target,);
   }
 };
 var TapGestureRecognizer = class extends GestureRecognizer {
@@ -27356,22 +20790,12 @@ var TapGestureRecognizer = class extends GestureRecognizer {
   }
   pointerSessionMoved(session, event,) {}
   pointerSessionEnded(session, event,) {
-    if (this.isPrevented) {
-      this.stateSwitch(32,/* Failed */
-      );
-    } else if (!session.startEvent || session.startEvent.target === event.target) {
-      this.stateSwitch(128,/* Recognized */
-      );
-      if (this.handler) {
-        this.handler.gestureChanged(this.eventType, event, null,);
-      }
-    } else {
-      this.stateSwitch(32,/* Failed */
-      );
-    }
-    if (this.handler) {
-      this.handler.gestureEnded(this.eventType, event, null,);
-    }
+    if (this.isPrevented) this.stateSwitch(32, /* Failed */);
+    else if (!session.startEvent || session.startEvent.target === event.target) {
+      this.stateSwitch(128, /* Recognized */);
+      if (this.handler) this.handler.gestureChanged(this.eventType, event, null,);
+    } else this.stateSwitch(32, /* Failed */);
+    if (this.handler) this.handler.gestureEnded(this.eventType, event, null,);
   }
 };
 var FramerEventSession = class {
@@ -27382,11 +20806,8 @@ var FramerEventSession = class {
     __publicField(this, 'dispatcher',);
     __publicField(this, 'originElement',);
     this.dispatcher = dispatcher;
-    if (customOrigin) {
-      this.originElement = customOrigin;
-    } else {
-      this.originElement = document.body;
-    }
+    if (customOrigin) this.originElement = customOrigin;
+    else this.originElement = document.body;
     const pan = new PanGestureRecognizer();
     const tap = new TapGestureRecognizer();
     pan.handler = this;
@@ -27402,16 +20823,13 @@ var FramerEventSession = class {
   }
   get lastEvent() {
     return this.events[this.events.length - 1];
-  }
-  // Event handling
+  } // Event handling
   processEvent(event,) {
     this.events.push(event,);
     return event;
   }
   pointerDown(event,) {
-    if (this.isStarted) {
-      return;
-    }
+    if (this.isStarted) return;
     this.processEvent(event,);
     this.recognizers.map((r) => {
       r.cancel();
@@ -27419,18 +20837,14 @@ var FramerEventSession = class {
     },);
   }
   pointerMove(event,) {
-    if (!this.isStarted) {
-      return;
-    }
+    if (!this.isStarted) return;
     this.processEvent(event,);
     this.recognizers.map((r) => {
       r.pointerSessionMoved(this, event,);
     },);
   }
   pointerUp(event,) {
-    if (!this.isStarted) {
-      return;
-    }
+    if (!this.isStarted) return;
     this.processEvent(event,);
     this.recognizers.map((r) => {
       r.pointerSessionEnded(this, event,);
@@ -27450,11 +20864,8 @@ var FramerEventSession = class {
   }
   dispatch(type, event, target = null,) {
     const dispatchTarget = target || this.startEvent && this.startEvent.target || event.target;
-    if (dispatchTarget) {
-      this.dispatcher(type, event, dispatchTarget,);
-    }
-  }
-  // Gesture Handler
+    if (dispatchTarget) this.dispatcher(type, event, dispatchTarget,);
+  } // Gesture Handler
   gestureBegan(type, event, target,) {
     this.dispatch(`${type}start`, event, target,);
   }
@@ -27463,73 +20874,37 @@ var FramerEventSession = class {
   }
   gestureEnded(type, event, target,) {
     this.dispatch(`${type}end`, event, target,);
-  }
-  // Calculatinos
+  } // Calculatinos
   /**
    * Average velocity over last n seconds in pixels per second.
    * @param n - number of events to use for calculation
-   */
-  velocity(t = Loop.TimeStep * 2,) {
-    if (!this.isStarted || this.events.length < 2) {
-      return {
-        x: 0,
-        y: 0,
-      };
-    }
+   */ velocity(t = Loop.TimeStep * 2,) {
+    if (!this.isStarted || this.events.length < 2) return { x: 0, y: 0, };
     const events2 = this.events;
     let i = events2.length - 1;
     let event = null;
     while (i >= 0) {
       event = events2[i] ?? null;
-      if (!event || MainLoop.time - event.loopTime > t) {
-        break;
-      }
+      if (!event || MainLoop.time - event.loopTime > t) break;
       i--;
     }
-    if (!event) {
-      return {
-        x: 0,
-        y: 0,
-      };
-    }
+    if (!event) return { x: 0, y: 0, };
     const current = events2[events2.length - 1];
-    if (!current) {
-      return {
-        x: 0,
-        y: 0,
-      };
-    }
+    if (!current) return { x: 0, y: 0, };
     const time22 = (MainLoop.time - event.loopTime) * 1e3;
-    if (time22 === 0) {
-      return {
-        x: 0,
-        y: 0,
-      };
-    }
+    if (time22 === 0) return { x: 0, y: 0, };
     const velocity = {
       x: (current.devicePoint.x - event.devicePoint.x) / time22,
       y: (current.devicePoint.y - event.devicePoint.y) / time22,
     };
-    if (velocity.x === Infinity) {
-      velocity.x = 0;
-    }
-    if (velocity.y === Infinity) {
-      velocity.y = 0;
-    }
+    if (velocity.x === Infinity) velocity.x = 0;
+    if (velocity.y === Infinity) velocity.y = 0;
     return velocity;
   }
   offset(event,) {
-    if (!this.startEvent) {
-      return {
-        x: 0,
-        y: 0,
-      };
-    }
+    if (!this.startEvent) return { x: 0, y: 0, };
     const subtract = (pointA, pointB,) => {
-      return {
-        x: pointA.x - pointB.x,
-        y: pointA.y - pointB.y,
-      };
+      return { x: pointA.x - pointB.x, y: pointA.y - pointB.y, };
     };
     return subtract(event.devicePoint, this.startEvent.devicePoint,);
   }
@@ -27562,23 +20937,23 @@ var MouseEventListener = class extends Component2 {
       const event = new FramerEvent(originalEvent, this.props.session,);
       this.props.session.mouseWheel(event,);
     },);
-  }
-  /**
+  } /**
    * @internal
    */
+
   render() {
     return this.props.children;
-  }
-  /**
+  } /**
    * @internal
    */
+
   componentDidMount() {
     safeWindow.addEventListener('mousedown', this.domMouseDown,);
     safeWindow.addEventListener('wheel', this.domMouseWheel,);
-  }
-  /**
+  } /**
    * @internal
    */
+
   componentWillUnmount() {
     safeWindow.removeEventListener('mousemove', this.domMouseMove,);
     safeWindow.removeEventListener('mousedown', this.domMouseDown,);
@@ -27605,22 +20980,22 @@ var TouchEventListener = class extends Component2 {
       const event = new FramerEvent(originalEvent, this.props.session,);
       this.props.session.pointerUp(event,);
     },);
-  }
-  /**
+  } /**
    * @internal
    */
+
   render() {
     return this.props.children;
-  }
-  /**
+  } /**
    * @internal
    */
+
   componentDidMount() {
     safeWindow.addEventListener('touchstart', this.domTouchStart,);
-  }
-  /**
+  } /**
    * @internal
    */
+
   componentWillUnmount() {
     safeWindow.removeEventListener('touchstart', this.domTouchStart,);
     safeWindow.removeEventListener('touchmove', this.domTouchMove,);
@@ -27628,24 +21003,14 @@ var TouchEventListener = class extends Component2 {
   }
 };
 var FramerEventListener = /* @__PURE__ */ environment.isTouch() ? TouchEventListener : MouseEventListener;
-var directionMap = {
-  horizontal: 'x',
-  vertical: 'y',
-  both: true,
-};
+var directionMap = { horizontal: 'x', vertical: 'y', both: true, };
 function convertScrollDirectionToDrag(scrollDirection,) {
   return scrollDirection ? directionMap[scrollDirection] : scrollDirection;
 }
-var useUpdateChildSize = ({
-  dragDirection,
-  children,
-  fromCanvasComponent,
-},) => {
+var useUpdateChildSize = ({ dragDirection, children, fromCanvasComponent, },) => {
   return useMemo(() => {
     return React__default.Children.map(children, (child) => {
-      if (child === null || typeof child !== 'object' || typeof child.type === 'string') {
-        return child;
-      }
+      if (child === null || typeof child !== 'object' || typeof child.type === 'string') return child;
       const updatedSize = {};
       switch (dragDirection) {
         case 'vertical':
@@ -27657,11 +21022,7 @@ var useUpdateChildSize = ({
         default:
           return child;
       }
-      const update = fromCanvasComponent
-        ? {
-          style: Object.assign({}, child.props.style, updatedSize,),
-        }
-        : updatedSize;
+      const update = fromCanvasComponent ? { style: Object.assign({}, child.props.style, updatedSize,), } : updatedSize;
       return React__default.cloneElement(child, update,);
     },);
   }, [dragDirection, children,],);
@@ -27699,10 +21060,7 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
     native,
     ...containerProps
   } = props;
-  const layoutId = useLayoutId2(props, {
-    specificLayoutId,
-    postfix: 'scroll',
-  },);
+  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'scroll', },);
   const defaultX = useMotionValue(typeof contentOffsetX === 'number' ? contentOffsetX : 0,);
   const defaultY = useMotionValue(typeof contentOffsetY === 'number' ? contentOffsetY : 0,);
   const x = isMotionValue2(contentOffsetX,) ? contentOffsetX : defaultX;
@@ -27720,19 +21078,7 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
     if (contentHeight !== void 0) constraints.top = -contentHeight;
     return measuredConstraints.current = constraints;
   }
-  const {
-    initial,
-    prev,
-  } = useRef({
-    initial: {
-      x: 0,
-      y: 0,
-    },
-    prev: {
-      x: 0,
-      y: 0,
-    },
-  },).current;
+  const { initial, prev, } = useRef({ initial: { x: 0, y: 0, }, prev: { x: 0, y: 0, }, },).current;
   const isPreview = RenderTarget.current() === 'PREVIEW';
   const containerFallbackRef = useRef(null,);
   const containerRef = forwardedRef || containerFallbackRef;
@@ -27786,10 +21132,7 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
     if (shouldResetScroll(isInTarget,)) measureAndUpdateScrollOffset();
     if (isInTarget === false) wasInTargetRef.current = false;
   }, [isInTarget,],);
-  const getLatestPoint = () => ({
-    x: x.get(),
-    y: y.get(),
-  });
+  const getLatestPoint = () => ({ x: x.get(), y: y.get(), });
   const resetInitialPoint = useCallback(() => {
     const point2 = getLatestPoint();
     initial.x = point2.x;
@@ -27801,28 +21144,16 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
     const point2 = getLatestPoint();
     const data2 = {
       point: point2,
-      velocity: {
-        x: x.getVelocity(),
-        y: y.getVelocity(),
-      },
-      offset: {
-        x: point2.x - initial.x,
-        y: point2.y - initial.y,
-      },
-      delta: {
-        x: point2.x - prev.x,
-        y: point2.y - prev.y,
-      },
+      velocity: { x: x.getVelocity(), y: y.getVelocity(), },
+      offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
+      delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
     };
     prev.x = point2.x;
     prev.y = point2.y;
     return data2;
   }, [x, y,],);
   const updateScrollListeners = useCallback(() => {
-    onUpdate && onUpdate({
-      x: x.get(),
-      y: y.get(),
-    },);
+    onUpdate && onUpdate({ x: x.get(), y: y.get(), },);
     onScroll && onScroll(getPointData(),);
   }, [onScroll, onUpdate, getPointData, x, y,],);
   const scheduleUpdateScrollListeners = useCallback(() => {
@@ -27911,8 +21242,7 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
     ...size2,
     style: {
       ...style,
-      willChange: isPreview ? 'transform' : void 0,
-      // allows the scroll content to be hardware accelerated
+      willChange: isPreview ? 'transform' : void 0, // allows the scroll content to be hardware accelerated
       overflow: 'hidden',
     },
     onScroll: nativeOnScroll,
@@ -27947,8 +21277,7 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
       ref: contentRef,
       style: {
         display: isEmpty2 ? 'block' : 'inline-block',
-        willChange: isPreview ? 'transform' : void 0,
-        // makes the scroll content hardware accelerated
+        willChange: isPreview ? 'transform' : void 0, // makes the scroll content hardware accelerated
         backgroundColor: 'transparent',
         overflow: 'visible',
         minWidth: '100%',
@@ -27966,29 +21295,15 @@ var EmulatedScroll = /* @__PURE__ */ React__default.forwardRef(function Emulated
           title: 'Scroll',
           description: 'Click and drag the connector to any frame on the canvas \u2192',
         },),
-        useUpdateChildSize({
-          dragDirection: direction,
-          children,
-          fromCanvasComponent: containerProps.__fromCanvasComponent,
-        },),
+        useUpdateChildSize({ dragDirection: direction, children, fromCanvasComponent: containerProps.__fromCanvasComponent, },),
       ],
     },),
   },);
 },);
-function offsetToZero({
-  top,
-  left,
-  right,
-  bottom,
-},) {
+function offsetToZero({ top, left, right, bottom, },) {
   const width = right - left;
   const height = bottom - top;
-  return {
-    top: -height,
-    left: -width,
-    right: 0,
-    bottom: 0,
-  };
+  return { top: -height, left: -width, right: 0, bottom: 0, };
 }
 function cx(...classNames) {
   return classNames.filter(Boolean,).join(' ',);
@@ -28003,30 +21318,19 @@ function isRunningAnimation(...phases) {
   return runningAny && !cancelledAny;
 }
 function didFinishAnimations(...phases) {
-  return phases.every((phase) => phase === 0 || phase === 2/* Completed */
-  );
+  return phases.every((phase) => phase === 0 || phase === 2 /* Completed */);
 }
 var timeConstant = 400;
-function animatePointWithInertia({
-  from,
-  velocity,
-  onUpdate,
-  onComplete,
-  onStop,
-},) {
+function animatePointWithInertia({ from, velocity, onUpdate, onComplete, onStop, },) {
   const latest = from;
   let animationPhaseX = 0;
   let animationPhaseY = 0;
   const animations2 = [];
   const updateHandler = () => {
-    if (isRunningAnimation(animationPhaseX, animationPhaseY,)) {
-      onUpdate(latest,);
-    }
+    if (isRunningAnimation(animationPhaseX, animationPhaseY,)) onUpdate(latest,);
   };
   const completionHandler = () => {
-    if (didFinishAnimations(animationPhaseX, animationPhaseY,)) {
-      onComplete();
-    }
+    if (didFinishAnimations(animationPhaseX, animationPhaseY,)) onComplete();
   };
   if (velocity.x) {
     animationPhaseX = 1;
@@ -28039,9 +21343,7 @@ function animatePointWithInertia({
         frame.update(updateHandler, false, true,);
       },
       onComplete: () => {
-        if (animationPhaseX !== 1) {
-          throw Error('animation x should be running when completing',);
-        }
+        if (animationPhaseX !== 1) throw Error('animation x should be running when completing',);
         animationPhaseX = 2;
         completionHandler();
       },
@@ -28058,17 +21360,13 @@ function animatePointWithInertia({
         frame.update(updateHandler, false, true,);
       },
       onComplete: () => {
-        if (animationPhaseY !== 1) {
-          throw Error('animation y should be running when completing',);
-        }
+        if (animationPhaseY !== 1) throw Error('animation y should be running when completing',);
         animationPhaseY = 2;
         completionHandler();
       },
     },),);
   }
-  if (!isRunningAnimation(animationPhaseX, animationPhaseY,)) {
-    completionHandler();
-  }
+  if (!isRunningAnimation(animationPhaseX, animationPhaseY,)) completionHandler();
   return {
     stop: () => {
       if (!isRunningAnimation(animationPhaseX, animationPhaseY,)) return;
@@ -28106,23 +21404,14 @@ function isInteractiveElement(element,) {
 function canStartScrollFromElement(element, direction,) {
   if (!(element instanceof Element)) return false;
   if (isInteractiveElement(element,)) return false;
-  if (element.hasAttribute('draggable',)) {
-    if (!canPanInDirection(element, direction,)) {
-      return false;
-    }
-  }
+  if (element.hasAttribute('draggable',)) if (!canPanInDirection(element, direction,)) return false;
   return true;
 }
 function getEventPoint(event,) {
-  return {
-    x: event.pageX,
-    y: event.pageY,
-  };
+  return { x: event.pageX, y: event.pageY, };
 }
 function setPointerEvents(element, value,) {
-  if (element == null ? void 0 : element.style) {
-    element.style['pointerEvents'] = value;
-  }
+  if (element == null ? void 0 : element.style) element.style['pointerEvents'] = value;
 }
 function getPointerEvents(element,) {
   var _a;
@@ -28185,10 +21474,7 @@ function useEmulateTouchScroll(ref, direction, enabled,) {
         targets.forEach(([target, originalPointerEventsValue,],) => setPointerEvents(target, originalPointerEventsValue || 'auto',));
       }
       targets = null;
-      const velocity = calculateVelocity({
-        mouseMoveEvents,
-        mouseUpEvent: event,
-      },);
+      const velocity = calculateVelocity({ mouseMoveEvents, mouseUpEvent: event, },);
       downPoint = null;
       if (phase === 2) {
         const shouldAnimateY = direction !== 'horizontal' && velocity.y !== 0;
@@ -28199,35 +21485,23 @@ function useEmulateTouchScroll(ref, direction, enabled,) {
         }
         phase = 4;
         scrollAnimationControlsRef.current = animatePointWithInertia({
-          from: {
-            x: element.scrollLeft,
-            y: element.scrollTop,
-          },
-          velocity: {
-            x: shouldAnimateX ? velocity.x : 0,
-            y: shouldAnimateY ? velocity.y : 0,
-          },
+          from: { x: element.scrollLeft, y: element.scrollTop, },
+          velocity: { x: shouldAnimateX ? velocity.x : 0, y: shouldAnimateY ? velocity.y : 0, },
           onUpdate: (position) => {
             if (shouldAnimateX) element.scrollLeft = position.x;
             if (shouldAnimateY) element.scrollTop = position.y;
           },
           onStop: () => {
-            if (phase !== 5) {
-              phase = 0;
-            }
+            if (phase !== 5) phase = 0;
             scrollAnimationControlsRef.current = null;
           },
           onComplete: () => {
-            if (phase !== 4) {
-              throw Error('On animation completion we should still be in the animation phase',);
-            }
+            if (phase !== 4) throw Error('On animation completion we should still be in the animation phase',);
             phase = 0;
             scrollAnimationControlsRef.current = null;
           },
         },);
-      } else {
-        phase = 0;
-      }
+      } else phase = 0;
     }
     function onMouseWheel() {
       var _a;
@@ -28250,15 +21524,10 @@ function useEmulateTouchScroll(ref, direction, enabled,) {
       targets = document.elementsFromPoint(downPoint.x, downPoint.y,).filter((targetEl) =>
         targetEl instanceof HTMLElement || targetEl instanceof SVGElement
       ).map((targetEl) => [targetEl, getPointerEvents(targetEl,),]);
-      scrollOffsetStart = {
-        x: element.scrollLeft,
-        y: element.scrollTop,
-      };
+      scrollOffsetStart = { x: element.scrollLeft, y: element.scrollTop, };
       mouseMoveEvents = [];
       if (scrollAnimationControlsRef.current) {
-        if (previousPhase !== 4) {
-          throw Error('When stopping a drag animation we need to be animating',);
-        }
+        if (previousPhase !== 4) throw Error('When stopping a drag animation we need to be animating',);
         scrollAnimationControlsRef.current.stop();
       }
       safeWindow.addEventListener('mousemove', onMouseMove,);
@@ -28291,14 +21560,8 @@ function getRecentEvents(events2,) {
   const maxAge = currentTime - timeDelta;
   return events2.filter((event) => event.timeStamp > maxAge);
 }
-var zeroPoint = {
-  x: 0,
-  y: 0,
-};
-function calculateVelocity({
-  mouseMoveEvents,
-  mouseUpEvent,
-},) {
+var zeroPoint = { x: 0, y: 0, };
+function calculateVelocity({ mouseMoveEvents, mouseUpEvent, },) {
   const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents,);
   const oldestMouseMoveEvent = recentMouseMoveEvents[0];
   if (!oldestMouseMoveEvent) return zeroPoint;
@@ -28306,30 +21569,29 @@ function calculateVelocity({
   const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;
   const time22 = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;
   if (time22 === 0) return zeroPoint;
-  return {
-    x: deltaX / time22 * 1e3,
-    y: deltaY / time22 * 1e3,
-  };
+  return { x: deltaX / time22 * 1e3, y: deltaY / time22 * 1e3, };
 }
 function useUpdateScrollOffset(ref, side, offset, cancelEmulatedTouchScrollAnimation,) {
-  useIsomorphicLayoutEffect2(() => {
-    if (isMotionValue2(offset,)) {
-      const updateScrollLeft = () => {
-        cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
+  useIsomorphicLayoutEffect2(
+    () => {
+      if (isMotionValue2(offset,)) {
+        const updateScrollLeft = () => {
+          cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
+          const element = ref.current;
+          if (element) element[side] = Math.abs(offset.get(),);
+        };
+        updateScrollLeft();
+        return offset.on('change', updateScrollLeft,);
+      } else if (isFiniteNumber(offset,)) {
         const element = ref.current;
-        if (element) element[side] = Math.abs(offset.get(),);
-      };
-      updateScrollLeft();
-      return offset.on('change', updateScrollLeft,);
-    } else if (isFiniteNumber(offset,)) {
-      const element = ref.current;
-      if (!element) return;
-      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
-      element[side] = Math.abs(offset,);
-    }
-  }, // We only want to update on contentOffset changes
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  [offset,],);
+        if (!element) return;
+        cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
+        element[side] = Math.abs(offset,);
+      }
+    }, // We only want to update on contentOffset changes
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [offset,],
+  );
 }
 var NativeScroll = /* @__PURE__ */ React__default.forwardRef(function NativeScroll2(props, forwardedRef,) {
   const {
@@ -28343,8 +21605,7 @@ var NativeScroll = /* @__PURE__ */ React__default.forwardRef(function NativeScro
     children,
     resetOffset,
     onScroll,
-    className,
-    // Not (yet) supported
+    className, // Not (yet) supported
     directionLock = false,
     wheelEnabled = true,
     scrollAnimate,
@@ -28360,19 +21621,13 @@ var NativeScroll = /* @__PURE__ */ React__default.forwardRef(function NativeScro
     onUpdate,
     onDirectionLock,
     layoutId: specificLayoutId,
-    native,
-    // Rest
+    native, // Rest
     ...containerProps
   } = props;
-  const layoutId = useLayoutId2(props, {
-    specificLayoutId,
-    postfix: 'scroll',
-  },);
+  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'scroll', },);
   const fallbackRef = React__default.useRef(null,);
   const ref = forwardedRef || fallbackRef;
-  const {
-    cancelEmulatedTouchScrollAnimation,
-  } = useEmulateTouchScroll(ref, direction, dragEnabled,);
+  const { cancelEmulatedTouchScrollAnimation, } = useEmulateTouchScroll(ref, direction, dragEnabled,);
   useInsertionEffect(() => {
     injectComponentCSSRules();
   }, [],);
@@ -28432,32 +21687,13 @@ var NativeScroll = /* @__PURE__ */ React__default.forwardRef(function NativeScro
 },);
 var Scroll = /* @__PURE__ */ (() => {
   const ScrollInner = React__default.forwardRef(function ScrollInner2(props, forwardedRef,) {
-    if (props.native) {
-      return /* @__PURE__ */ _jsx5(NativeScroll, {
-        ref: forwardedRef,
-        ...props,
-      },);
-    } else {
-      return /* @__PURE__ */ _jsx5(EmulatedScroll, {
-        ref: forwardedRef,
-        ...props,
-      },);
-    }
+    if (props.native) return /* @__PURE__ */ _jsx5(NativeScroll, { ref: forwardedRef, ...props, },);
+    else return /* @__PURE__ */ _jsx5(EmulatedScroll, { ref: forwardedRef, ...props, },);
   },);
-  ScrollInner.defaultProps = {
-    directionLock: false,
-  };
+  ScrollInner.defaultProps = { directionLock: false, };
   addPropertyControls(ScrollInner, {
-    native: {
-      type: 'boolean',
-      defaultValue: false,
-    },
-    direction: {
-      type: 'segmentedenum',
-      title: 'Direction',
-      options: ['vertical', 'horizontal', 'both',],
-      defaultValue: 'vertical',
-    },
+    native: { type: 'boolean', defaultValue: false, },
+    direction: { type: 'segmentedenum', title: 'Direction', options: ['vertical', 'horizontal', 'both',], defaultValue: 'vertical', },
     contentOffsetX: {
       type: 'number',
       title: 'Offset X',
@@ -28465,9 +21701,7 @@ var Scroll = /* @__PURE__ */ (() => {
       min: 0,
       step: 10,
       displayStepper: true,
-      hidden: ({
-        direction,
-      },) => direction === 'vertical',
+      hidden: ({ direction, },) => direction === 'vertical',
     },
     contentOffsetY: {
       type: 'number',
@@ -28476,9 +21710,7 @@ var Scroll = /* @__PURE__ */ (() => {
       min: 0,
       step: 10,
       displayStepper: true,
-      hidden: ({
-        direction,
-      },) => direction === 'horizontal',
+      hidden: ({ direction, },) => direction === 'horizontal',
     },
     directionLock: {
       type: 'boolean',
@@ -28486,26 +21718,16 @@ var Scroll = /* @__PURE__ */ (() => {
       enabledTitle: '1 Axis',
       disabledTitle: 'Off',
       defaultValue: true,
-      hidden: ({
-        native,
-      },) => native === true,
-    },
-    dragEnabled: {
-      type: 'boolean',
-      title: 'Drag',
-      enabledTitle: 'On',
-      disabledTitle: 'Off',
-      defaultValue: true,
+      hidden: ({ native, },) => native === true,
     },
+    dragEnabled: { type: 'boolean', title: 'Drag', enabledTitle: 'On', disabledTitle: 'Off', defaultValue: true, },
     overdragEnabled: {
       type: 'boolean',
       title: 'Overdrag',
       enabledTitle: 'On',
       disabledTitle: 'Off',
       defaultValue: true,
-      hidden: ({
-        native,
-      },) => native === true,
+      hidden: ({ native, },) => native === true,
     },
     wheelEnabled: {
       type: 'boolean',
@@ -28513,9 +21735,7 @@ var Scroll = /* @__PURE__ */ (() => {
       enabledTitle: 'On',
       disabledTitle: 'Off',
       defaultValue: true,
-      hidden: ({
-        native,
-      },) => native === true,
+      hidden: ({ native, },) => native === true,
     },
     scrollBarVisible: {
       type: 'boolean',
@@ -28523,15 +21743,9 @@ var Scroll = /* @__PURE__ */ (() => {
       enabledTitle: 'Visible',
       disabledTitle: 'Hidden',
       defaultValue: false,
-      hidden: ({
-        native,
-      },) => native === false,
-    },
-    resetOffset: {
-      type: 'boolean',
-      title: 'Reset',
-      defaultValue: false,
+      hidden: ({ native, },) => native === false,
     },
+    resetOffset: { type: 'boolean', title: 'Reset', defaultValue: false, },
   },);
   ScrollInner.supportsConstraints = true;
   return ScrollInner;
@@ -28608,9 +21822,7 @@ function createData(defaultState2, actions,) {
     const contextId = useContext3(DataContext,);
     id3 = id3 || contextId;
     const store = useMemo(() => {
-      if (!stores.has(id3,)) {
-        stores.set(id3, createStore(initialState2 || defaultState2, actions,),);
-      }
+      if (!stores.has(id3,)) stores.set(id3, createStore(initialState2 || defaultState2, actions,),);
       return stores.get(id3,);
     }, [id3,],);
     const [, notifyUpdates,] = useState(store.getVersion(),);
@@ -28624,12 +21836,8 @@ function createData(defaultState2, actions,) {
   };
   return useData;
 }
-var initialState = {
-  update: 0,
-};
-var DataObserverContext = /* @__PURE__ */ React__default.createContext({
-  update: NaN,
-},);
+var initialState = { update: 0, };
+var DataObserverContext = /* @__PURE__ */ React__default.createContext({ update: NaN, },);
 function useObserveData() {
   const context = React__default.useContext(DataObserverContext,);
   return !isNaN(context.update,);
@@ -28641,9 +21849,7 @@ var DataObserver = class extends Component2 {
     __publicField(this, 'state', initialState,);
     __publicField(this, 'taskAdded', false,);
     __publicField(this, 'frameTask', () => {
-      this.setState({
-        update: this.state.update + 1,
-      },);
+      this.setState({ update: this.state.update + 1, },);
       this.taskAdded = false;
     },);
     __publicField(this, 'observer', () => {
@@ -28657,45 +21863,29 @@ var DataObserver = class extends Component2 {
     Data.reset();
   }
   render() {
-    const {
-      children,
-    } = this.props;
+    const { children, } = this.props;
     this.observers.map((cancel) => cancel());
     this.observers = [];
     Data._stores.forEach((d) => {
       const observer2 = Data.addObserver(d, this.observer,);
       this.observers.push(observer2,);
     },);
-    return /* @__PURE__ */ _jsx5(DataObserverContext.Provider, {
-      value: {
-        ...this.state,
-      },
-      children,
-    },);
+    return /* @__PURE__ */ _jsx5(DataObserverContext.Provider, { value: { ...this.state, }, children, },);
   }
 };
 var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs(), 1,);
 function convertColorObject(prop,) {
-  if (typeof prop === 'string' || isMotionValue2(prop,)) {
-    return prop;
-  } else if (LinearGradient.isLinearGradient(prop,)) {
-    return LinearGradient.toCSS(prop,);
-  } else if (RadialGradient.isRadialGradient(prop,)) {
-    return RadialGradient.toCSS(prop,);
-  } else if (Color.isColorObject(prop,)) {
-    return Color.toRgbString(prop,);
-  }
+  if (typeof prop === 'string' || isMotionValue2(prop,)) return prop;
+  else if (LinearGradient.isLinearGradient(prop,)) return LinearGradient.toCSS(prop,);
+  else if (RadialGradient.isRadialGradient(prop,)) return RadialGradient.toCSS(prop,);
+  else if (Color.isColorObject(prop,)) return Color.toRgbString(prop,);
   return prop;
 }
 function convertColorProps(props,) {
   if (props.background || props.color) {
     const converted = Object.assign({}, props,);
-    if (props.background) {
-      converted.background = convertColorObject(props.background,);
-    }
-    if (props.color) {
-      converted.color = convertColorObject(props.color,);
-    }
+    if (props.background) converted.background = convertColorObject(props.background,);
+    if (props.color) converted.color = convertColorObject(props.color,);
     return converted;
   }
   return props;
@@ -28705,15 +21895,8 @@ function WithOverride(Component14, override,) {
   const ComponentWithOverride = function (props,) {
     useContext3(DataObserverContext,);
     const overrideProps = useOverride(props,);
-    const {
-      style,
-      ...rest
-    } = props;
-    return /* @__PURE__ */ _jsx5(Component14, {
-      ...rest,
-      ...overrideProps,
-      _initialStyle: style,
-    },);
+    const { style, ...rest } = props;
+    return /* @__PURE__ */ _jsx5(Component14, { ...rest, ...overrideProps, _initialStyle: style, },);
   };
   (0, import_hoist_non_react_statics4.default)(ComponentWithOverride, Component14,);
   ComponentWithOverride['displayName'] = `WithOverride(${Component14.displayName || Component14.name})`;
@@ -28735,9 +21918,7 @@ function extractPrefixedProps(props, keys3,) {
   return [result, rest,];
 }
 function stripPrefixFromPrefixedKey(key7,) {
-  if (key7.startsWith(prefix,)) {
-    return key7.substr(prefixLength,);
-  }
+  if (key7.startsWith(prefix,)) return key7.substr(prefixLength,);
   return void 0;
 }
 var effectValuesKeys = [
@@ -28749,8 +21930,8 @@ var effectValuesKeys = [
   'rotateX',
   'rotateY',
   'skewX',
-  'skewY', /** @deprecated */
-  'transformPerspective',
+  'skewY',
+  /** @deprecated */ 'transformPerspective',
 ];
 var makeFXValues = (defaults) => {
   return {
@@ -28763,8 +21944,7 @@ var makeFXValues = (defaults) => {
     rotateY: motionValue((defaults == null ? void 0 : defaults.rotateY) ?? 0,),
     skewX: motionValue((defaults == null ? void 0 : defaults.skewX) ?? 0,),
     skewY: motionValue((defaults == null ? void 0 : defaults.skewY) ?? 0,),
-    /** @deprecated */
-    transformPerspective: motionValue((defaults == null ? void 0 : defaults.transformPerspective) ?? 0,),
+    /** @deprecated */ transformPerspective: motionValue((defaults == null ? void 0 : defaults.transformPerspective) ?? 0,),
   };
 };
 var defaultFXValues = {
@@ -28777,16 +21957,13 @@ var defaultFXValues = {
   rotateY: 0,
   skewX: 0,
   skewY: 0,
-  /** @deprecated */
-  transformPerspective: 0,
+  /** @deprecated */ transformPerspective: 0,
 };
 function isFXValuesKey(key7,) {
   return key7 in defaultFXValues;
 }
 function useFXValues(values, enabled,) {
-  const effect = useConstant2(() => ({
-    values: makeFXValues(enabled ? values : void 0,),
-  }));
+  const effect = useConstant2(() => ({ values: makeFXValues(enabled ? values : void 0,), }));
   React__default.useEffect(() => {
     if (enabled) return;
     for (const key7 of effectValuesKeys) {
@@ -28812,17 +21989,9 @@ var useDelay = () => {
       }, d * 1e3,);
     },);
 };
-function useLoop({
-  loopEffectEnabled,
-  loopRepeatDelay,
-  loopTransition,
-  loopRepeatType,
-  loop,
-},) {
+function useLoop({ loopEffectEnabled, loopRepeatDelay, loopTransition, loopRepeatType, loop, },) {
   const shouldReduceMotion = useReducedMotionConfig();
-  const effect = useConstant2(() => ({
-    values: makeFXValues(),
-  }));
+  const effect = useConstant2(() => ({ values: makeFXValues(), }));
   const mirrorStateRef = React__default.useRef(false,);
   const delay2 = useDelay();
   const animateValues = async () => {
@@ -28836,10 +22005,7 @@ function useLoop({
       if (shouldReduceMotion && key7 !== 'opacity') return;
       effect.values[key7].set(from[key7] ?? defaultFXValues[key7],);
       return new Promise((resolve) => {
-        const opts = {
-          ...transition,
-          onComplete: () => resolve(),
-        };
+        const opts = { ...transition, onComplete: () => resolve(), };
         animate(effect.values[key7], to[key7] ?? from[key7], opts,);
       },);
     },),);
@@ -28860,11 +22026,8 @@ function useLoop({
     mirrorStateRef.current = false;
   }, [effect,],);
   React__default.useEffect(() => {
-    if (loopEffectEnabled && loop) {
-      start();
-    } else {
-      stop();
-    }
+    if (loopEffectEnabled && loop) start();
+    else stop();
     return () => stop();
   }, [loopEffectEnabled,],);
   return effect;
@@ -28877,12 +22040,7 @@ function parallaxTransform(scrollY, originalPosition, speed, offset, adjustPosit
 }
 var parallaxOptionsKeys = /* @__PURE__ */ new Set(['speed', 'adjustPosition', 'offset', 'parallaxTransformEnabled',],);
 function useParallax(options, ref, visibilityStyle,) {
-  const {
-    speed = 100,
-    offset = 0,
-    adjustPosition = false,
-    parallaxTransformEnabled,
-  } = options;
+  const { speed = 100, offset = 0, adjustPosition = false, parallaxTransformEnabled, } = options;
   const originalPosition = React__default.useRef(null,);
   const shouldReduceMotion = useReducedMotionConfig();
   const transform2 = React__default.useCallback((yValue) => {
@@ -28897,26 +22055,16 @@ function useParallax(options, ref, visibilityStyle,) {
     },);
     frame.update(() => {
       parallaxY.set(transform2(scrollY.get(),),);
-      if (adjustPosition) {
-        visibility.set(visibilityStyle ?? 'initial',);
-      }
+      if (adjustPosition) visibility.set(visibilityStyle ?? 'initial',);
     },);
   }, [ref, originalPosition, adjustPosition,],);
-  const {
-    scrollY,
-  } = useScroll();
+  const { scrollY, } = useScroll();
   const parallaxY = useTransform(scrollY, transform2,);
   const visibility = useMotionValue(adjustPosition && originalPosition.current === null ? 'hidden' : visibilityStyle,);
   const defaultValue = useMotionValue(0,);
   return {
-    values: {
-      y: shouldReduceMotion || !parallaxTransformEnabled ? defaultValue : parallaxY,
-    },
-    style: parallaxTransformEnabled
-      ? {
-        visibility,
-      }
-      : void 0,
+    values: { y: shouldReduceMotion || !parallaxTransformEnabled ? defaultValue : parallaxY, },
+    style: parallaxTransformEnabled ? { visibility, } : void 0,
   };
 }
 function getTransition(value,) {
@@ -28937,34 +22085,16 @@ async function runEffectAnimation(target, effect, shouldReduceMotion, ref, appea
       if (visualElement) visualElement.setBaseTarget(key7, value,);
       const handoff =
         isString22(appearId,) && !(motionValue2 == null ? void 0 : motionValue2.hasAnimated) && safeWindow.HandoffAppearAnimations
-          ? {
-            elapsed: safeWindow.HandoffAppearAnimations(appearId, key7, motionValue2, frame,),
-          }
+          ? { elapsed: safeWindow.HandoffAppearAnimations(appearId, key7, motionValue2, frame,), }
           : void 0;
-      if (instant) {
-        motionValue2.set(value,);
-      } else {
-        animate(motionValue2, value, {
-          ...transition,
-          velocity: 0,
-          elapsed: 0,
-          ...handoff,
-          onComplete: () => resolve(),
-        },);
-      }
+      if (instant) motionValue2.set(value,);
+      else animate(motionValue2, value, { ...transition, velocity: 0, elapsed: 0, ...handoff, onComplete: () => resolve(), },);
     },);
   },),);
 }
 var presenceOptionsKeys = /* @__PURE__ */ new Set(['presenceInitial', 'presenceAnimate', 'presenceExit',],);
 function usePresenceAnimation(
-  {
-    initial: motionInitial,
-    animate: motionAnimate,
-    exit: motionExit,
-    presenceInitial,
-    presenceAnimate,
-    presenceExit,
-  },
+  { initial: motionInitial, animate: motionAnimate, exit: motionExit, presenceInitial, presenceAnimate, presenceExit, },
   ref,
   enabled,
   style,
@@ -28980,20 +22110,14 @@ function usePresenceAnimation(
   const effect = useConstant2(() => {
     var _a;
     const base = initial ?? style;
-    if (!isObject2(base,)) {
-      return {
-        values: makeFXValues(),
-      };
-    }
+    if (!isObject2(base,)) return { values: makeFXValues(), };
     const defaults = {};
     for (const key7 in base) {
       const value = isObject2(base,) ? (_a = asRecord(base,)) == null ? void 0 : _a[key7] : void 0;
       if (!isNumber2(value,)) continue;
       defaults[key7] = value;
     }
-    return {
-      values: makeFXValues(defaults,),
-    };
+    return { values: makeFXValues(defaults,), };
   },);
   useLayoutEffect(() => {
     if (hasMounted.current && animateConfig) return;
@@ -29014,17 +22138,9 @@ function usePresenceAnimation(
     }
     if (isPresent2 !== lastPresence.current) {
       lastPresence.current = isPresent2;
-      if (isPresent2) {
-        if (initial && animateConfig) {
-          runEffectAnimation(animateConfig, effect, shouldReduceMotion, ref, appearId,);
-        }
-      } else {
-        if (exit) {
-          runEffectAnimation(exit, effect, shouldReduceMotion, ref, appearId,).then(() => safeToRemove());
-        } else {
-          safeToRemove();
-        }
-      }
+      if (isPresent2) if (initial && animateConfig) runEffectAnimation(animateConfig, effect, shouldReduceMotion, ref, appearId,);
+      else {if (exit) runEffectAnimation(exit, effect, shouldReduceMotion, ref, appearId,).then(() => safeToRemove());
+        else safeToRemove();}
     } else {
       const hasAnimateChanged = !isEqual(animateConfig, lastAnimate.current,);
       if (!hasAnimateChanged || !animateConfig) return;
@@ -29050,10 +22166,7 @@ function createTransformInputRange(transformTargets, threshold = 0, callback,) {
   const starts = [];
   const inputRange = [];
   for (let index = transformTargets.length; index >= 0; index--) {
-    const {
-      ref: targetRef,
-      offset,
-    } = transformTargets[index] ?? {};
+    const { ref: targetRef, offset, } = transformTargets[index] ?? {};
     if (!targetRef || !targetRef.current) continue;
     const offsetTop = calcOffsetTop(targetRef.current, document.documentElement,);
     const top = offsetTop - scrollObserverOffset - (offset ?? 0) - threshold;
@@ -29072,23 +22185,15 @@ function currentScrollDirection(offset, lastOffset = 0,) {
 }
 var scrollDirectionThreshold = 4;
 function useScrollDirectionChange(scrollDirection, cb, options = {},) {
-  const {
-    direction,
-    target,
-  } = scrollDirection ?? {};
-  const {
-    repeat = true,
-    enabled = true,
-  } = options;
+  const { direction, target, } = scrollDirection ?? {};
+  const { repeat = true, enabled = true, } = options;
   React__default.useEffect(() => {
     if (!direction || !enabled) return;
     let lastOffset = void 0;
     let directionChangeOffset = 0;
     let lastDirection = void 0;
     let currentTarget = void 0;
-    return scrollInfo(({
-      y: scrollY,
-    },) => {
+    return scrollInfo(({ y: scrollY, },) => {
       if (!repeat && currentTarget === target) return;
       if (scrollY.current > scrollY.scrollLength) return;
       if (scrollY.current < 0) return;
@@ -29096,9 +22201,8 @@ function useScrollDirectionChange(scrollDirection, cb, options = {},) {
       lastOffset = scrollY.current;
       const hasDirectionChanged = d !== lastDirection;
       lastDirection = d;
-      if (hasDirectionChanged) {
-        directionChangeOffset = scrollY.current;
-      } else {
+      if (hasDirectionChanged) directionChangeOffset = scrollY.current;
+      else {
         const delta = Math.abs(scrollY.current - directionChangeOffset,);
         if (delta < scrollDirectionThreshold) return;
         const nextTarget = d === direction ? target : void 0;
@@ -29129,10 +22233,7 @@ var styleAppearOptionsKeys = /* @__PURE__ */ new Set([
   'scrollDirection',
 ],);
 var defaultOutputRange = ['animate', 'animate',];
-var defaultRanges = {
-  inputRange: [],
-  outputRange: [],
-};
+var defaultRanges = { inputRange: [], outputRange: [], };
 function createInputOutputRange(targets, threshold, hasExit,) {
   const inputRange = createTransformInputRange(targets, threshold,);
   const outputRange = [...defaultOutputRange,];
@@ -29149,10 +22250,7 @@ function createInputOutputRange(targets, threshold, hasExit,) {
     inputRange.push(last + 1,);
     outputRange.push('exit',);
   }
-  return {
-    inputRange,
-    outputRange,
-  };
+  return { inputRange, outputRange, };
 }
 function makeStyle(defaults,) {
   return {
@@ -29169,29 +22267,20 @@ function makeStyle(defaults,) {
     transition: (defaults == null ? void 0 : defaults.transition) ?? void 0,
   };
 }
-function useAnimationVariants({
-  opacity,
-  targetOpacity,
-  perspective: transformPerspective,
-  enter,
-  exit,
-  animate: animateVariant2,
-  ...defaultStyles
-},) {
-  return React__default.useMemo(() => ({
-    initial: enter ?? makeStyle({
-      ...defaultStyles,
-      opacity: opacity ?? targetOpacity ?? 1,
-      transformPerspective,
-    },),
-    animate: animateVariant2 ?? makeStyle({
-      opacity: targetOpacity,
-    },),
-    exit: exit ?? makeStyle(),
-  }), [animateVariant2, defaultStyles, enter, exit, opacity, targetOpacity, transformPerspective,],);
-}
-function useStyleAppearEffect(options, ref,) {
-  const shouldReduceMotion = useReducedMotionConfig();
+function useAnimationVariants(
+  { opacity, targetOpacity, perspective: transformPerspective, enter, exit, animate: animateVariant2, ...defaultStyles },
+) {
+  return React__default.useMemo(
+    () => ({
+      initial: enter ?? makeStyle({ ...defaultStyles, opacity: opacity ?? targetOpacity ?? 1, transformPerspective, },),
+      animate: animateVariant2 ?? makeStyle({ opacity: targetOpacity, },),
+      exit: exit ?? makeStyle(),
+    }),
+    [animateVariant2, defaultStyles, enter, exit, opacity, targetOpacity, transformPerspective,],
+  );
+}
+function useStyleAppearEffect(options, ref,) {
+  const shouldReduceMotion = useReducedMotionConfig();
   const variants = useAnimationVariants(options,);
   const enabled = options.styleAppearEffectEnabled;
   const effect = useFXValues(enabled ? variants.initial : variants.animate, enabled,);
@@ -29201,43 +22290,32 @@ function useStyleAppearEffect(options, ref,) {
     lastAppearState: !options.styleAppearEffectEnabled,
   },);
   const animation = React__default.useRef();
-  const runAnimation = React__default.useCallback(async ({
-    transition,
-    ...target
-  }, fromInitial,) => {
-    const transitionWithFallback = transition ?? variants.animate.transition ?? options.transition;
-    await animation.current;
-    animation.current = Promise.all(effectValuesKeys.map((key7) => {
-      if (fromInitial) effect.values[key7].set(variants.initial[key7] ?? defaultFXValues[key7],);
-      const toValue = target[key7] ?? defaultFXValues[key7];
-      const visualElement = visualElementStore.get(ref.current,);
-      if (visualElement && typeof toValue !== 'object') {
-        visualElement.setBaseTarget(key7, toValue,);
-      }
-      return new Promise((resolve) => {
-        if (shouldReduceMotion && key7 !== 'opacity') {
-          resolve();
-        } else {
-          const opts = {
-            restDelta: key7 === 'scale' ? 1e-3 : void 0,
-            ...transitionWithFallback,
-            onComplete: () => resolve(),
-          };
-          animate(effect.values[key7], toValue, opts,);
-        }
-      },);
-    },),);
-  }, // All dependencies are object values or stable.
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  [],);
+  const runAnimation = React__default.useCallback(
+    async ({ transition, ...target }, fromInitial,) => {
+      const transitionWithFallback = transition ?? variants.animate.transition ?? options.transition;
+      await animation.current;
+      animation.current = Promise.all(effectValuesKeys.map((key7) => {
+        if (fromInitial) effect.values[key7].set(variants.initial[key7] ?? defaultFXValues[key7],);
+        const toValue = target[key7] ?? defaultFXValues[key7];
+        const visualElement = visualElementStore.get(ref.current,);
+        if (visualElement && typeof toValue !== 'object') visualElement.setBaseTarget(key7, toValue,);
+        return new Promise((resolve) => {
+          if (shouldReduceMotion && key7 !== 'opacity') resolve();
+          else {
+            const opts = { restDelta: key7 === 'scale' ? 1e-3 : void 0, ...transitionWithFallback, onComplete: () => resolve(), };
+            animate(effect.values[key7], toValue, opts,);
+          }
+        },);
+      },),);
+    }, // All dependencies are object values or stable.
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [],
+  );
   const hasAnimatedOnce = options.animateOnce && playState.current.lastAppearState === true;
   const animateWithIntersectionObserver = !options.targets && options.styleAppearEffectEnabled && !options.scrollDirection &&
     !hasAnimatedOnce;
   useAppearEffect(ref, (appears) => {
-    const {
-      isPlaying,
-      lastAppearState,
-    } = playState.current;
+    const { isPlaying, lastAppearState, } = playState.current;
     if (isPlaying) {
       playState.current.scheduledAppearState = appears;
       return;
@@ -29246,32 +22324,21 @@ function useStyleAppearEffect(options, ref,) {
     playState.current.lastAppearState = appears;
     if (lastAppearState === appears) return;
     runAnimation(appears ? variants.animate : variants.exit, appears,);
-  }, {
-    enabled: animateWithIntersectionObserver,
-    animateOnce: !!options.animateOnce,
-    threshold: {
-      y: options.threshold,
-    },
-  },);
+  }, { enabled: animateWithIntersectionObserver, animateOnce: !!options.animateOnce, threshold: { y: options.threshold, }, },);
   const animateWithScrollInfo = options.targets && enabled && !options.scrollDirection;
   React__default.useEffect(() => {
     if (!animateWithScrollInfo) return;
-    const playedState = {
-      initial: true,
-    };
+    const playedState = { initial: true, };
     let lastVariant = 'initial';
-    return scrollInfo(({
-      y: scrollY,
-    },) => {
-      const {
-        targets,
-      } = options;
+    return scrollInfo(({ y: scrollY, },) => {
+      const { targets, } = options;
       if (!targets) return;
       if (!targets[0] || targets[0].ref && !targets[0].ref.current) return;
-      const {
-        inputRange,
-        outputRange,
-      } = createInputOutputRange(targets, (options.threshold ?? 0) * scrollY.containerLength, !!options.exit,);
+      const { inputRange, outputRange, } = createInputOutputRange(
+        targets,
+        (options.threshold ?? 0) * scrollY.containerLength,
+        !!options.exit,
+      );
       if (inputRange.length === 0 || inputRange.length !== outputRange.length) return;
       const variant = transform(scrollY.current, inputRange, outputRange,);
       if (options.animateOnce && playedState[variant]) return;
@@ -29299,11 +22366,7 @@ var styleTransformOptionsKeys = /* @__PURE__ */ new Set([
 var defaultValues = (transformTargets, shouldReduceMotion,) => {
   var _a;
   const initial = (_a = transformTargets == null ? void 0 : transformTargets[0]) == null ? void 0 : _a.target;
-  return shouldReduceMotion
-    ? {
-      opacity: (initial == null ? void 0 : initial.opacity) ?? 1,
-    }
-    : initial;
+  return shouldReduceMotion ? { opacity: (initial == null ? void 0 : initial.opacity) ?? 1, } : initial;
 };
 var defaultRanges2 = () => ({
   opacity: [],
@@ -29335,9 +22398,7 @@ function useAttachOptionalSpring(values, spring2,) {
         },);
         if (!frameData.isProcessing) {
           const delta = performance.now() - frameData.timestamp;
-          if (delta < 40) {
-            springs.current[key7].time = delta / 1e3;
-          }
+          if (delta < 40) springs.current[key7].time = delta / 1e3;
         }
         return m2.get();
       },);
@@ -29359,64 +22420,45 @@ function createInputOutputRanges(transformTargets, threshold,) {
         );
     }
   },);
-  return {
-    inputRange,
-    effectKeyOutputRange,
-  };
+  return { inputRange, effectKeyOutputRange, };
 }
 function createPageOutputRange(transformTargets,) {
   var _a;
   const keyOutputRange = defaultRanges2();
-  for (
-    const {
-      target,
-    } of transformTargets
-  ) {
-    for (const key7 of effectValuesKeys) (_a = keyOutputRange[key7]) == null ? void 0 : _a.push(target[key7],);
+  for (const { target, } of transformTargets) {
+    for (const key7 of effectValuesKeys) {
+      (_a = keyOutputRange[key7]) == null
+        ? void 0
+        : _a.push(target[key7],);
+    }
   }
   return keyOutputRange;
 }
 var pageInputRange = [0, 1,];
-function useStyleTransform({
-  transformTrigger,
-  styleTransformEffectEnabled,
-  transformTargets,
-  spring: spring2,
-  transformViewportThreshold = 0,
-}, ref,) {
+function useStyleTransform(
+  { transformTrigger, styleTransformEffectEnabled, transformTargets, spring: spring2, transformViewportThreshold = 0, },
+  ref,
+) {
   const shouldReduceMotion = useReducedMotionConfig();
   const effect = useFXValues(defaultValues(transformTargets, shouldReduceMotion,), styleTransformEffectEnabled,);
   React__default.useLayoutEffect(() => {
     if (!styleTransformEffectEnabled || !transformTargets) return;
     if (transformTrigger !== 'onScrollTarget') {
       const outputRange = createPageOutputRange(transformTargets,);
-      return scrollInfo(
-        ({
-          y: scrollY,
-        },) => {
-          for (const key7 of effectValuesKeys) {
-            if (shouldReduceMotion && key7 !== 'opacity') continue;
-            if (pageInputRange.length !== outputRange[key7].length) continue;
-            if (outputRange[key7][0] === void 0) continue;
-            effect.values[key7].set(transform(scrollY.progress, pageInputRange, outputRange[key7],),);
-          }
-        },
-        transformTrigger === 'onInView'
-          ? {
-            target: ref.current ?? void 0,
-            offset: [`start end`, `end end`,],
-          }
-          : void 0,
-      );
-    } else {
-      return scrollInfo(({
-        y: scrollY,
-      },) => {
+      return scrollInfo(({ y: scrollY, },) => {
+        for (const key7 of effectValuesKeys) {
+          if (shouldReduceMotion && key7 !== 'opacity') continue;
+          if (pageInputRange.length !== outputRange[key7].length) continue;
+          if (outputRange[key7][0] === void 0) continue;
+          effect.values[key7].set(transform(scrollY.progress, pageInputRange, outputRange[key7],),);
+        }
+      }, transformTrigger === 'onInView' ? { target: ref.current ?? void 0, offset: [`start end`, `end end`,], } : void 0,);
+    } else {return scrollInfo(({ y: scrollY, },) => {
         if (!transformTargets[0] || transformTargets[0].ref && !transformTargets[0].ref.current) return;
-        const {
-          inputRange: scrollYInputRange,
-          effectKeyOutputRange,
-        } = createInputOutputRanges(transformTargets, transformViewportThreshold * scrollY.containerLength,);
+        const { inputRange: scrollYInputRange, effectKeyOutputRange, } = createInputOutputRanges(
+          transformTargets,
+          transformViewportThreshold * scrollY.containerLength,
+        );
         if (scrollYInputRange.length === 0) return;
         for (const key7 of effectValuesKeys) {
           if (shouldReduceMotion && key7 !== 'opacity') continue;
@@ -29424,8 +22466,7 @@ function useStyleTransform({
           if (effectKeyOutputRange[key7][0] === void 0) continue;
           effect.values[key7].set(transform(scrollY.current, scrollYInputRange, effectKeyOutputRange[key7],),);
         }
-      },);
-    }
+      },);}
   }, [shouldReduceMotion, transformTrigger, ref, transformViewportThreshold, styleTransformEffectEnabled, effect, transformTargets,],);
   useAttachOptionalSpring(effect.values, spring2,);
   return effect;
@@ -29446,11 +22487,7 @@ function extractFXOptions(props,) {
     parallax: {},
     styleAppear: {},
     styleTransform: {},
-    presence: {
-      animate: props.animate,
-      initial: props.initial,
-      exit: props.exit,
-    },
+    presence: { animate: props.animate, initial: props.initial, exit: props.exit, },
     loop: {},
     forwardedProps: {},
   };
@@ -29497,65 +22534,36 @@ function isVariantOrVariantList(value,) {
 var withFX = (Component14) =>
   React__default.forwardRef((props, forwardedRef,) => {
     if (props.__withFX) {
-      return /* @__PURE__ */ _jsx5(Component14, {
-        ...props,
-        animate: void 0,
-        initial: void 0,
-        exit: void 0,
-        ref: forwardedRef,
-      },);
+      return /* @__PURE__ */ _jsx5(Component14, { ...props, animate: void 0, initial: void 0, exit: void 0, ref: forwardedRef, },);
     }
     if (RenderTarget.current() === 'CANVAS') {
       const animate4 = isVariantOrVariantList(props.animate,) ? props.animate : void 0;
       const initial2 = isVariantOrVariantList(props.initial,) ? props.initial : void 0;
-      return /* @__PURE__ */ _jsx5(Component14, {
-        ...props,
-        animate: animate4,
-        initial: initial2,
-        exit: void 0,
-        ref: forwardedRef,
-      },);
+      return /* @__PURE__ */ _jsx5(Component14, { ...props, animate: animate4, initial: initial2, exit: void 0, ref: forwardedRef, },);
     }
     const fallbackRef = React__default.useRef(null,);
     const ref = forwardedRef ?? fallbackRef;
-    const {
-      parallax = {},
-      styleAppear = {},
-      styleTransform = {},
-      presence = {},
-      loop = {},
-      forwardedProps,
-    } = extractFXOptions(props,);
-    const {
-      __targetOpacity: targetOpacityValue,
-      __perspectiveFX: withPerspective,
-      __smartComponentFX: inSmartComponent = false,
-    } = props;
+    const { parallax = {}, styleAppear = {}, styleTransform = {}, presence = {}, loop = {}, forwardedProps, } = extractFXOptions(props,);
+    const { __targetOpacity: targetOpacityValue, __perspectiveFX: withPerspective, __smartComponentFX: inSmartComponent = false, } = props;
     const targetOpacity = useMotionValue(targetOpacityValue ?? 1,);
-    const {
-      values: presenceEffectValues,
-    } = usePresenceAnimation(presence, ref, inSmartComponent, props.style, props[optimizedAppearDataAttribute],);
-    const {
-      values: parallaxValues,
-      style: parallaxStyle,
-    } = useParallax(parallax, ref,);
-    const {
-      values: transformValues2,
-    } = useStyleTransform(styleTransform, ref,);
-    const {
-      values: appearEffectValues,
-    } = useStyleAppearEffect(styleAppear, ref,);
-    const {
-      values: loopValues,
-    } = useLoop(loop,);
+    const { values: presenceEffectValues, } = usePresenceAnimation(
+      presence,
+      ref,
+      inSmartComponent,
+      props.style,
+      props[optimizedAppearDataAttribute],
+    );
+    const { values: parallaxValues, style: parallaxStyle, } = useParallax(parallax, ref,);
+    const { values: transformValues2, } = useStyleTransform(styleTransform, ref,);
+    const { values: appearEffectValues, } = useStyleAppearEffect(styleAppear, ref,);
+    const { values: loopValues, } = useLoop(loop,);
     const fxValues = React__default.useMemo(() => {
       return {
         scale: [appearEffectValues.scale, loopValues.scale, presenceEffectValues.scale, transformValues2.scale,],
         opacity: [
           appearEffectValues.opacity,
           loopValues.opacity,
-          presenceEffectValues.opacity,
-          // Ensure that the layers opacity is always represented.
+          presenceEffectValues.opacity, // Ensure that the layers opacity is always represented.
           targetOpacity,
           transformValues2.opacity,
         ],
@@ -29566,8 +22574,7 @@ var withFX = (Component14) =>
         rotateY: [appearEffectValues.rotateY, loopValues.rotateY, presenceEffectValues.rotateY, transformValues2.rotateY,],
         skewX: [appearEffectValues.skewX, loopValues.skewX, presenceEffectValues.skewX, transformValues2.skewX,],
         skewY: [appearEffectValues.skewY, loopValues.skewY, presenceEffectValues.skewY, transformValues2.skewY,],
-        /** @deprecated */
-        transformPerspective: [transformValues2.transformPerspective, appearEffectValues.transformPerspective,// We stopped animating transformPerspective with `withFX`
+        /** @deprecated */ transformPerspective: [transformValues2.transformPerspective, appearEffectValues.transformPerspective, // We stopped animating transformPerspective with `withFX`
           // before introducing `useLoop` etc, so it does not have a
           // value here on purpose.
         ],
@@ -29584,42 +22591,21 @@ var withFX = (Component14) =>
     const skewX = useTransform(fxValues.skewX, add2,);
     const skewY = useTransform(fxValues.skewY, add2,);
     const transformPerspective = useTransform(fxValues.transformPerspective, add2,);
-    const {
-      drag: drag2,
-      dragConstraints,
-    } = forwardedProps;
+    const { drag: drag2, dragConstraints, } = forwardedProps;
     useRerenderOnResize(drag2 && isReactRefObject(dragConstraints,) ? dragConstraints : void 0,);
-    const motionValueStyle = {
-      opacity,
-      scale: scale2,
-      x,
-      y,
-      rotate,
-      rotateX,
-      rotateY,
-      skewX,
-      skewY,
-    };
-    if (isUndefined(withPerspective,)) motionValueStyle.transformPerspective = transformPerspective;
+    const motionValueStyle = { opacity, scale: scale2, x, y, rotate, rotateX, rotateY, skewX, skewY, };
+    if (isUndefined(withPerspective,)) {
+      motionValueStyle.transformPerspective = transformPerspective;
+    }
     const animate3 = isVariantOrVariantList(props.animate,) ? props.animate : void 0;
     const initial = isVariantOrVariantList(props.initial,) ? props.initial : void 0;
     const exit = isVariantOrVariantList(props.exit,) ? props.exit : void 0;
-    const motionGestures = inSmartComponent && !presence.presenceInitial
-      ? {
-        initial,
-        animate: animate3,
-        exit,
-      }
-      : {};
+    const motionGestures = inSmartComponent && !presence.presenceInitial ? { initial, animate: animate3, exit, } : {};
     return /* @__PURE__ */ _jsx5(Component14, {
       ...forwardedProps,
       ...motionGestures,
       __withFX: true,
-      style: {
-        ...props.style,
-        ...parallaxStyle,
-        ...motionValueStyle,
-      },
+      style: { ...props.style, ...parallaxStyle, ...motionValueStyle, },
       values: presenceEffectValues,
       ref,
     },);
@@ -29627,23 +22613,12 @@ var withFX = (Component14) =>
 var withParallaxTransform = withFX;
 var withStyleAppearEffect = withFX;
 var Context = /* @__PURE__ */ createContext({},);
-function ComponentPresetsProvider({
-  presets,
-  children,
-},) {
+function ComponentPresetsProvider({ presets, children, },) {
   const lastPresets = useRef(presets,);
-  if (!isEqual(presets, lastPresets.current, false,)) {
-    lastPresets.current = presets;
-  }
-  return /* @__PURE__ */ _jsx5(Context.Provider, {
-    value: lastPresets.current,
-    children,
-  },);
+  if (!isEqual(presets, lastPresets.current, false,)) lastPresets.current = presets;
+  return /* @__PURE__ */ _jsx5(Context.Provider, { value: lastPresets.current, children, },);
 }
-function ComponentPresetsConsumer({
-  componentIdentifier,
-  children,
-},) {
+function ComponentPresetsConsumer({ componentIdentifier, children, },) {
   const componentPresets = useContext3(Context,);
   const presetProps = componentPresets[componentIdentifier] ?? {};
   return children(presetProps,);
@@ -29654,11 +22629,7 @@ function useCloneChildrenWithPropsAndRef(forwardedRef,) {
   return hook.cloneAsElement;
 }
 function createHook(forwardedRef,) {
-  const state = {
-    forwardedRef,
-    childRef: null,
-    ref: null,
-  };
+  const state = { forwardedRef, childRef: null, ref: null, };
   state.ref = createRefFunction(state,);
   const updateIfNeeded = (nextForwardedRef, ref,) => {
     if (!state.forwardedRef && state.forwardedRef === nextForwardedRef) {
@@ -29696,30 +22667,21 @@ function createHook(forwardedRef,) {
       if (React.isValidElement(child,)) {
         const ownRef = 'ref' in child ? child.ref : void 0;
         updateIfNeeded(state.forwardedRef, ownRef,);
-        const newProps = state.ref !== ownRef
-          ? {
-            ...props,
-            ref: state.ref,
-          }
-          : props;
+        const newProps = state.ref !== ownRef ? { ...props, ref: state.ref, } : props;
         return React.cloneElement(child, newProps,);
       }
       return child;
     },);
   }
   const cloneAsElement = function cloneAsElement2(children, props,) {
-    return /* @__PURE__ */ _jsx5(Fragment, {
-      children: cloneChildrenWithPropsAndRef(children, props,),
-    },);
+    return /* @__PURE__ */ _jsx5(Fragment, { children: cloneChildrenWithPropsAndRef(children, props,), },);
   };
   cloneAsElement.cloneAsArray = cloneChildrenWithPropsAndRef;
-  return {
-    // used during render phase to sync props with state
+  return { // used during render phase to sync props with state
     useSetup: (newRef) => {
       preventNextCall = false;
       updateIfNeeded(newRef, state.childRef,);
-    },
-    /**
+    }, /**
      * Clones children and adds props and refs and returns them as a JSX.Element
      * Making it easier to use as it wraps them in a Fragment.
      */
@@ -29728,21 +22690,15 @@ function createHook(forwardedRef,) {
 }
 function createRefFunction(state,) {
   if (!state.forwardedRef) return state.childRef;
-  const {
-    forwardedRef: prevForwardedRef,
-    childRef: prevChildRef,
-  } = state;
+  const { forwardedRef: prevForwardedRef, childRef: prevChildRef, } = state;
   return (value) => {
     setRef(prevChildRef, value,);
     setRef(prevForwardedRef, value,);
   };
 }
 function setRef(ref, value,) {
-  if (isFunction(ref,)) {
-    ref(value,);
-  } else if (isMutableRef(ref,)) {
-    ref.current = value;
-  }
+  if (isFunction(ref,)) ref(value,);
+  else if (isMutableRef(ref,)) ref.current = value;
 }
 function isMutableRef(ref,) {
   return isObject2(ref,) && 'current' in ref;
@@ -29751,15 +22707,9 @@ var ComponentViewportContext = /* @__PURE__ */ React__default.createContext({},)
 function useComponentViewport() {
   return React__default.useContext(ComponentViewportContext,);
 }
-var ComponentViewportProvider = /* @__PURE__ */ React__default.forwardRef(({
-  width,
-  children,
-  ...rest
-}, ref,) => {
+var ComponentViewportProvider = /* @__PURE__ */ React__default.forwardRef(({ width, children, ...rest }, ref,) => {
   const componentViewport = React__default.useMemo(() => {
-    return {
-      width,
-    };
+    return { width, };
   }, [width,],);
   const cloneWithPropsAndRef = useCloneChildrenWithPropsAndRef(ref,);
   return /* @__PURE__ */ _jsx5(ComponentViewportContext.Provider, {
@@ -29770,42 +22720,24 @@ var ComponentViewportProvider = /* @__PURE__ */ React__default.forwardRef(({
 var withGeneratedLayoutId = (Component14) =>
   React__default.forwardRef((props, ref,) => {
     const layoutId = useLayoutId2(props,);
-    return /* @__PURE__ */ _jsx5(Component14, {
-      layoutId,
-      ...props,
-      layoutIdKey: void 0,
-      duplicatedFrom: void 0,
-      ref,
-    },);
+    return /* @__PURE__ */ _jsx5(Component14, { layoutId, ...props, layoutIdKey: void 0, duplicatedFrom: void 0, ref, },);
   },);
 var ContainerErrorBoundary = class extends React__default.Component {
   constructor() {
     super(...arguments,);
-    __publicField(this, 'state', {
-      hasError: false,
-    },);
+    __publicField(this, 'state', { hasError: false, },);
   }
   static getDerivedStateFromError() {
     console.error('Error in component (see previous error log). This component has been hidden.',);
-    return {
-      hasError: true,
-    };
+    return { hasError: true, };
   }
   render() {
-    const {
-      children,
-    } = this.props;
-    const {
-      hasError,
-    } = this.state;
+    const { children, } = this.props;
+    const { hasError, } = this.state;
     return hasError ? null : children;
   }
 };
-var Providers = /* @__PURE__ */ React__default.forwardRef(({
-  children,
-  layoutId,
-  ...props
-}, ref,) => {
+var Providers = /* @__PURE__ */ React__default.forwardRef(({ children, layoutId, ...props }, ref,) => {
   const outerLayoutId = useConstant2(() => layoutId ? `${layoutId}-container` : void 0);
   return /* @__PURE__ */ _jsx5(motion.div, {
     layoutId: outerLayoutId,
@@ -29820,11 +22752,7 @@ var Providers = /* @__PURE__ */ React__default.forwardRef(({
           inherit: 'id',
           children: /* @__PURE__ */ _jsx5(ContainerErrorBoundary, {
             children: React__default.Children.map(children, (child) => {
-              return React__default.isValidElement(child,)
-                ? React__default.cloneElement(child, {
-                  layoutId,
-                },)
-                : child;
+              return React__default.isValidElement(child,) ? React__default.cloneElement(child, { layoutId, },) : child;
             },),
           },),
         },),
@@ -29834,11 +22762,7 @@ var Providers = /* @__PURE__ */ React__default.forwardRef(({
 },);
 var Container = /* @__PURE__ */ withGeneratedLayoutId(Providers,);
 var StyleSheetContext = /* @__PURE__ */ React__default.createContext(void 0,);
-if (isBrowser2()) {
-  for (const node of document.querySelectorAll('style[data-framer-css-ssr]',)) {
-    document.head.appendChild(node,);
-  }
-}
+if (isBrowser2()) for (const node of document.querySelectorAll('style[data-framer-css-ssr]',)) document.head.appendChild(node,);
 var componentsWithServerRenderedStyles = /* @__PURE__ */ (() => {
   var _a;
   if (!isBrowser2()) return /* @__PURE__ */ new Set();
@@ -29848,15 +22772,10 @@ var componentsWithServerRenderedStyles = /* @__PURE__ */ (() => {
   if (!componentsWithSSRStylesAttr) return /* @__PURE__ */ new Set();
   return new Set(componentsWithSSRStylesAttr.split(' ',),);
 })();
-var styleTagSSRMarker = {
-  'data-framer-css-ssr': true,
-};
+var styleTagSSRMarker = { 'data-framer-css-ssr': true, };
 var withCSS = (Component14, escapedCSS, componentSerializationId,) =>
   React__default.forwardRef((props, ref,) => {
-    const {
-      sheet,
-      cache: cache3,
-    } = React__default.useContext(StyleSheetContext,) ?? {};
+    const { sheet, cache: cache3, } = React__default.useContext(StyleSheetContext,) ?? {};
     if (!isBrowser2()) {
       const concatenatedCSS = Array.isArray(escapedCSS,) ? escapedCSS.join('\n',) : escapedCSS;
       return /* @__PURE__ */ _jsxs(Fragment, {
@@ -29864,14 +22783,9 @@ var withCSS = (Component14, escapedCSS, componentSerializationId,) =>
           /* @__PURE__ */ _jsx5('style', {
             ...styleTagSSRMarker,
             'data-framer-component': componentSerializationId,
-            dangerouslySetInnerHTML: {
-              __html: concatenatedCSS,
-            },
-          },),
-          /* @__PURE__ */ _jsx5(Component14, {
-            ...props,
-            ref,
+            dangerouslySetInnerHTML: { __html: concatenatedCSS, },
           },),
+          /* @__PURE__ */ _jsx5(Component14, { ...props, ref, },),
         ],
       },);
     }
@@ -29880,20 +22794,12 @@ var withCSS = (Component14, escapedCSS, componentSerializationId,) =>
       const css = Array.isArray(escapedCSS,) ? escapedCSS : escapedCSS.split('\n',);
       css.forEach((rule) => rule && injectCSSRule(rule, sheet, cache3,));
     }, [],);
-    return /* @__PURE__ */ _jsx5(Component14, {
-      ...props,
-      ref,
-    },);
+    return /* @__PURE__ */ _jsx5(Component14, { ...props, ref, },);
   },);
-var CustomCursorContext = /* @__PURE__ */ React__default.createContext({
-  onRegisterCursors: () => () => {},
-  registerCursors: () => {},
-},);
+var CustomCursorContext = /* @__PURE__ */ React__default.createContext({ onRegisterCursors: () => () => {}, registerCursors: () => {}, },);
 var replaceCursorClassName = 'framer-cursor-none';
 var cursorComponentClassName = 'framer-pointer-events-none';
-var CustomCursorContextProvider = /* @__PURE__ */ React__default.memo(function CustomCursorList({
-  children,
-},) {
+var CustomCursorContextProvider = /* @__PURE__ */ React__default.memo(function CustomCursorList({ children, },) {
   const value = useConstant2(() => {
     const events2 = /* @__PURE__ */ new Set();
     let allCursors = {};
@@ -29928,8 +22834,7 @@ var staticCursorStyle = {
   position: 'fixed',
   top: 0,
   left: 0,
-  zIndex: 12 + 1,
-  // Max framer z-index + 1
+  zIndex: 12 + 1, // Max framer z-index + 1
   pointerEvents: 'none',
 };
 function customCursorReplacesNativeCursor(cursor,) {
@@ -29974,9 +22879,7 @@ function getCursorHash(x, y,) {
       const id3 = el.getAttribute(portalIdAttribute,);
       el = el.parentElement;
       if (id3) el = document.getElementById(id3,) ?? el;
-    } else {
-      el = el.parentElement;
-    }
+    } else el = el.parentElement;
   }
   return void 0;
 }
@@ -29985,17 +22888,12 @@ function isEmptyObject(object,) {
   return true;
 }
 var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomCursorComponent2() {
-  const {
-    onRegisterCursors,
-  } = useContext3(CustomCursorContext,);
+  const { onRegisterCursors, } = useContext3(CustomCursorContext,);
   const pointerX = useMotionValue(0,);
   const pointerY = useMotionValue(0,);
   const opacity = useMotionValue(0,);
   const cursorRef = React__default.useRef(null,);
-  const internalState = React__default.useRef({
-    cursors: {},
-    cursorHash: void 0,
-  },);
+  const internalState = React__default.useRef({ cursors: {}, cursorHash: void 0, },);
   const forceRender = useForceUpdate3();
   const hasCursors = !isEmptyObject(internalState.current.cursors,);
   React__default.useEffect(() => {
@@ -30004,10 +22902,7 @@ var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomC
     function updateValues() {
       pointerX.set(x2,);
       pointerY.set(y2,);
-      animate(opacity, 1, {
-        type: 'tween',
-        duration: 0.2,
-      },);
+      animate(opacity, 1, { type: 'tween', duration: 0.2, },);
     }
     function updateCursor(e,) {
       if (e.pointerType === 'touch') return;
@@ -30053,10 +22948,7 @@ var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomC
   }, [opacity, pointerX, pointerY, hasCursors, forceRender,],);
   React__default.useEffect(() => {
     function hideCursor() {
-      animate(opacity, 0, {
-        type: 'tween',
-        duration: 0.2,
-      },);
+      animate(opacity, 0, { type: 'tween', duration: 0.2, },);
     }
     document.addEventListener('mouseleave', hideCursor,);
     safeWindow.addEventListener('blur', hideCursor,);
@@ -30077,19 +22969,14 @@ var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomC
       document.body.classList.toggle(replaceCursorClassName, false,);
     };
   }, [pointerX, pointerY, onRegisterCursors, forceRender,],);
-  const {
-    cursors,
-    cursorHash,
-  } = internalState.current;
+  const { cursors, cursorHash, } = internalState.current;
   const cursor = cursorHash ? cursors[cursorHash] : null;
   const replaceNativeCursor = customCursorReplacesNativeCursor(cursor,);
   React__default.useLayoutEffect(() => {
     document.body.classList.toggle(replaceCursorClassName, replaceNativeCursor,);
   }, [replaceNativeCursor,],);
   const Cursor = cursor == null ? void 0 : cursor.component;
-  const spring2 = (cursor == null ? void 0 : cursor.transition) ?? {
-    duration: 0,
-  };
+  const spring2 = (cursor == null ? void 0 : cursor.transition) ?? { duration: 0, };
   const sprungX = useSpring(pointerX, spring2,);
   const sprungY = useSpring(pointerY, spring2,);
   const x = useTransform(() => {
@@ -30109,12 +22996,7 @@ var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomC
   if (!cursor || !Cursor) return null;
   return /* @__PURE__ */ _jsx5(Cursor, {
     transformTemplate: transformTemplate2,
-    style: {
-      ...staticCursorStyle,
-      x,
-      y,
-      opacity,
-    },
+    style: { ...staticCursorStyle, x, y, opacity, },
     globalTapTarget: true,
     variant: cursor == null ? void 0 : cursor.variant,
     ref: cursorRef,
@@ -30122,9 +23004,7 @@ var CustomCursorComponent = /* @__PURE__ */ React__default.memo(function CustomC
   },);
 },);
 function useCustomCursors(webPageCursors,) {
-  const {
-    registerCursors,
-  } = useContext3(CustomCursorContext,);
+  const { registerCursors, } = useContext3(CustomCursorContext,);
   const cursors = useConstant2(() => webPageCursors);
   React__default.useLayoutEffect(() => {
     registerCursors(cursors,);
@@ -30136,11 +23016,9 @@ var Polygon = {
    * (non-self-intersecting) convex polygons. If the polygon is collapsed into a line (signedArea = 0), we consider it
    * clockwise for it works with how Framer draws the polygons.
    * See: https://paulbourke.net/geometry/polygonmesh/
-   * @internal */
-  isClockwise: (points) => {
+   * @internal */ isClockwise: (points) => {
     return Polygon.signedArea(points,) <= 0;
-  },
-  /**
+  }, /**
    * Calculate the signed area to determine if the vertices go clockwise or counter clockwise. We flip all the y
    * values because the y axis in our canvas coordinate is fipped.
    * See: https://mathworld.wolfram.com/PolygonArea.html
@@ -30155,8 +23033,7 @@ var Polygon = {
       sum += pointA.x * -pointB.y - pointB.x * -pointA.y;
     }
     return 1 / 2 * sum;
-  },
-  /**
+  }, /**
    * Determine if some Point lies inside (or on) the polygon formed by other
    * Points. The other points must be provided in a clockwise/counter
    * clockwise order otherwise the line segments we create to test the polygon
@@ -30189,8 +23066,7 @@ var Polygon = {
     }
     return true;
   },
-  /** @internal */
-  intersects: (pointsA, pointsB,) => {
+  /** @internal */ intersects: (pointsA, pointsB,) => {
     if (pointsA.length < 1 || pointsB.length < 1) return false;
     const boundingRectA = Rect.boundingRectFromPoints(pointsA,);
     const boundingRectB = Rect.boundingRectFromPoints(pointsB,);
@@ -30219,15 +23095,11 @@ var Polygon = {
     if (Polygon.containsPoint(pointsA, pointsB[0],)) return true;
     return false;
   },
-  /** @internal */
-  contains: (pointsA, pointsB,) => {
-    for (let i = 0; i < pointsB.length; i++) {
-      if (!Polygon.containsPoint(pointsA, pointsB[i],)) return false;
-    }
+  /** @internal */ contains: (pointsA, pointsB,) => {
+    for (let i = 0; i < pointsB.length; i++) if (!Polygon.containsPoint(pointsA, pointsB[i],)) return false;
     return true;
   },
-  /** @internal */
-  clipToRect: (points, rect,) => {
+  /** @internal */ clipToRect: (points, rect,) => {
     const edges = Rect.edges(rect,);
     const seen = /* @__PURE__ */ new Set();
     const count = points.length;
@@ -30302,23 +23174,11 @@ function collisionAxis(placement, rect, windowSize,) {
 function getPlacementAndOffsetAvoidingScreenCollision(rect, placement, offset, windowSize,) {
   switch (collisionAxis(placement, rect, windowSize,)) {
     case 'x':
-      return {
-        placement: invertPlacement(placement,),
-        x: offset.x * -1,
-        y: offset.y,
-      };
+      return { placement: invertPlacement(placement,), x: offset.x * -1, y: offset.y, };
     case 'y':
-      return {
-        placement: invertPlacement(placement,),
-        x: offset.x,
-        y: offset.y * -1,
-      };
+      return { placement: invertPlacement(placement,), x: offset.x, y: offset.y * -1, };
     default:
-      return {
-        placement,
-        x: offset.x,
-        y: offset.y,
-      };
+      return { placement, x: offset.x, y: offset.y, };
   }
 }
 function getSafePlacementFloatingPositionRect(
@@ -30331,18 +23191,14 @@ function getSafePlacementFloatingPositionRect(
   collisionDetectionPadding,
 ) {
   const rebasedRect = Rect.rebaseRectOnto(element, anchor, placement, alignment,);
-  const preferredRect = {
-    x: rebasedRect.x + offset.x,
-    y: rebasedRect.y + offset.y,
-    width: element.width,
-    height: element.height,
-  };
+  const preferredRect = { x: rebasedRect.x + offset.x, y: rebasedRect.y + offset.y, width: element.width, height: element.height, };
   if (!collisionDetectionSize) return [placement, preferredRect,];
-  const {
-    x,
-    y,
-    placement: safePlacement,
-  } = getPlacementAndOffsetAvoidingScreenCollision(preferredRect, placement, offset, collisionDetectionSize,);
+  const { x, y, placement: safePlacement, } = getPlacementAndOffsetAvoidingScreenCollision(
+    preferredRect,
+    placement,
+    offset,
+    collisionDetectionSize,
+  );
   const rebasedCollisionRect = Rect.rebaseRectOnto(element, anchor, safePlacement, alignment,);
   return [safePlacement, {
     x: preferredOffset(rebasedCollisionRect.x + x, element.width, collisionDetectionSize.width, collisionDetectionPadding,),
@@ -30363,46 +23219,23 @@ function safeAreaPolygonConstraints(rect,) {
   };
 }
 var mouseOffset = 4;
-function polygonPoints(
-  {
-    x,
-    y,
-  },
-  placement,
-  rect,
-  {
-    constrainX,
-    constrainY,
-  },
-) {
+function polygonPoints({ x, y, }, placement, rect, { constrainX, constrainY, },) {
   const [tl, bl, tr, br,] = Rect.points(rect,);
   switch (placement) {
     case 'left': {
-      const mousePoint = {
-        x: constrainX(x - mouseOffset,),
-        y,
-      };
+      const mousePoint = { x: constrainX(x - mouseOffset,), y, };
       return [mousePoint, preferredPoint(br, bl, [mousePoint, tr,],), preferredPoint(tr, tl, [mousePoint, br,],),];
     }
     case 'right': {
-      const mousePoint = {
-        x: constrainX(x + mouseOffset,),
-        y,
-      };
+      const mousePoint = { x: constrainX(x + mouseOffset,), y, };
       return [mousePoint, preferredPoint(bl, br, [mousePoint, tl,],), preferredPoint(tl, tr, [mousePoint, bl,],),];
     }
     case 'top': {
-      const mousePoint = {
-        x,
-        y: constrainY(y - mouseOffset,),
-      };
+      const mousePoint = { x, y: constrainY(y - mouseOffset,), };
       return [mousePoint, preferredPoint(bl, tl, [mousePoint, br,],), preferredPoint(br, tr, [mousePoint, bl,],),];
     }
     case 'bottom': {
-      const mousePoint = {
-        x,
-        y: constrainY(y + mouseOffset,),
-      };
+      const mousePoint = { x, y: constrainY(y + mouseOffset,), };
       return [mousePoint, preferredPoint(tl, bl, [mousePoint, tr,],), preferredPoint(tr, br, [mousePoint, tl,],),];
     }
     default:
@@ -30427,15 +23260,9 @@ function floatingPositionSafeAreaStyle(x, y, placement, anchorRect, floatingRect
   const minX = Math.min(floatingRect.x, anchorRect.x,);
   const minY = Math.min(floatingRect.y, anchorRect.y,);
   const rect = Rect.merge(anchorRect, floatingRect,);
-  const points = polygonPoints(
-    {
-      x,
-      y,
-    },
-    placement,
-    floatingRect,
-    safeAreaPolygonConstraints(anchorRect,),
-  ).map((point2) => `${point2.x - minX}px ${point2.y - minY}px`).join(', ',);
+  const points = polygonPoints({ x, y, }, placement, floatingRect, safeAreaPolygonConstraints(anchorRect,),).map((point2) =>
+    `${point2.x - minX}px ${point2.y - minY}px`
+  ).join(', ',);
   return {
     height: `${rect.height}px`,
     width: `${rect.width}px`,
@@ -30458,25 +23285,13 @@ function valueForFloatingAlignment(alignment,) {
 function motionOriginFromFloatingPosition(placement = 'bottom', alignment = 'center',) {
   switch (placement) {
     case 'top':
-      return {
-        originX: valueForFloatingAlignment(alignment,),
-        originY: 1,
-      };
+      return { originX: valueForFloatingAlignment(alignment,), originY: 1, };
     case 'right':
-      return {
-        originX: 0,
-        originY: valueForFloatingAlignment(alignment,),
-      };
+      return { originX: 0, originY: valueForFloatingAlignment(alignment,), };
     case 'bottom':
-      return {
-        originX: valueForFloatingAlignment(alignment,),
-        originY: 0,
-      };
+      return { originX: valueForFloatingAlignment(alignment,), originY: 0, };
     case 'left':
-      return {
-        originX: 1,
-        originY: valueForFloatingAlignment(alignment,),
-      };
+      return { originX: 1, originY: valueForFloatingAlignment(alignment,), };
     default:
       assertNever(placement,);
   }
@@ -30487,10 +23302,7 @@ function isRef(value,) {
 function getAncestorInfo(anchorRef,) {
   var _a;
   let el = anchorRef.current;
-  const info = {
-    position: 'absolute',
-    scrolls: false,
-  };
+  const info = { position: 'absolute', scrolls: false, };
   while (el) {
     if ((el == null ? void 0 : el.tagName) === 'BODY') return info;
     if (((_a = getComputedStyle(el,)) == null ? void 0 : _a.position) === 'fixed') info.position = 'fixed';
@@ -30525,17 +23337,13 @@ function updatePosition(floatingPositionRef, position, rect,) {
   if (!floatingPositionRef.current) return;
   Object.assign(floatingPositionRef.current.style, {
     position,
-    visibility: 'visible',
-    // Append "px" because we are assigning this object straight to style.
+    visibility: 'visible', // Append "px" because we are assigning this object straight to style.
     left: ((rect == null ? void 0 : rect.x) ?? 0) + (position === 'fixed' ? 0 : safeWindow.scrollX) + 'px',
     top: ((rect == null ? void 0 : rect.y) ?? 0) + (position === 'fixed' ? 0 : safeWindow.scrollY) + 'px',
   },);
 }
 var FloatingStackingContext = /* @__PURE__ */ React__default.createContext(/* @__PURE__ */ new Set(),);
-function useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, {
-  safeArea,
-  onDismiss,
-},) {
+function useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, { safeArea, onDismiss, },) {
   const descendantStackingContext = useConstant2(() => /* @__PURE__ */ new Set());
   const ancestorStackingContext = React__default.useContext(FloatingStackingContext,);
   const [isPresent2, safeToRemove,] = usePresence();
@@ -30585,26 +23393,14 @@ function useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, {
   ],);
   return descendantStackingContext;
 }
-function makeGetSafePlacementFloatingPositionRect({
-  placement,
-  alignment,
-  offset,
-  collisionDetectionSize,
-  collisionDetectionPadding,
-},) {
+function makeGetSafePlacementFloatingPositionRect({ placement, alignment, offset, collisionDetectionSize, collisionDetectionPadding, },) {
   return (anchor, element,) =>
     getSafePlacementFloatingPositionRect(anchor, element, placement, alignment, offset, collisionDetectionSize, collisionDetectionPadding,);
 }
 function useDynamicMotionOrigin(initialPlacement, alignment,) {
   return useConstant2(() => {
-    const {
-      originX,
-      originY,
-    } = motionOriginFromFloatingPosition(initialPlacement, alignment,);
-    const origin = {
-      x: motionValue(originX,),
-      y: motionValue(originY,),
-    };
+    const { originX, originY, } = motionOriginFromFloatingPosition(initialPlacement, alignment,);
+    const origin = { x: motionValue(originX,), y: motionValue(originY,), };
     return [origin, (placement) => {
       const values = motionOriginFromFloatingPosition(placement, alignment,);
       origin.x.set(values.originX,);
@@ -30612,63 +23408,45 @@ function useDynamicMotionOrigin(initialPlacement, alignment,) {
     },];
   },);
 }
-function childrenWithOrigin(child, {
-  x,
-  y,
-},) {
+function childrenWithOrigin(child, { x, y, },) {
   if (!child || !isReactChild(child,) || !isReactElement(child,)) return null;
   if (!isObject2(child.props.style,) && !isUndefined(child.props.style,)) return null;
-  const style = {
-    ...child.props.style,
-    originX: x,
-    originY: y,
-  };
-  return React__default.cloneElement(child, {
-    style,
-  },);
+  const style = { ...child.props.style, originX: x, originY: y, };
+  return React__default.cloneElement(child, { style, },);
 }
-function Floating({
-  alignment,
-  placement,
-  safeArea,
-  offsetX,
-  offsetY,
-  anchorRef,
-  className,
-  children,
-  portalSelector,
-  zIndex,
-  collisionDetection = false,
-  collisionDetectionPadding,
-  onDismiss,
-  ...rest
-},) {
+function Floating(
+  {
+    alignment,
+    placement,
+    safeArea,
+    offsetX,
+    offsetY,
+    anchorRef,
+    className,
+    children,
+    portalSelector,
+    zIndex,
+    collisionDetection = false,
+    collisionDetectionPadding,
+    onDismiss,
+    ...rest
+  },
+) {
   const floatingPositionRef = React__default.useRef(null,);
   const safeAreaRef = React__default.useRef(null,);
   const contentRef = React__default.useRef(null,);
   const [origin, updateOrigin,] = useDynamicMotionOrigin(placement, alignment,);
   React__default.useLayoutEffect(() => {
     if (!isRef(anchorRef,) || !contentRef.current || !placement || !alignment) return;
-    const {
-      position,
-      scrolls,
-    } = getAncestorInfo(anchorRef,);
+    const { position, scrolls, } = getAncestorInfo(anchorRef,);
     const elementRect = contentRef.current.getBoundingClientRect();
     const initialAnchorRect = anchorRef.current.getBoundingClientRect();
-    const offset = {
-      x: offsetX ?? 0,
-      y: offsetY ?? 0,
-    };
+    const offset = { x: offsetX ?? 0, y: offsetY ?? 0, };
     const getSafePlacementRect = makeGetSafePlacementFloatingPositionRect({
       placement,
       alignment,
       offset,
-      collisionDetectionSize: collisionDetection
-        ? {
-          width: safeWindow.innerWidth,
-          height: safeWindow.innerHeight,
-        }
-        : void 0,
+      collisionDetectionSize: collisionDetection ? { width: safeWindow.innerWidth, height: safeWindow.innerHeight, } : void 0,
       collisionDetectionPadding,
     },);
     const [initialSafePlacement, initialCalculatedRect,] = getSafePlacementRect(initialAnchorRect, elementRect,);
@@ -30696,16 +23474,12 @@ function Floating({
       anchor.removeEventListener('mousemove', handleMouseMove,);
     };
   }, [safeArea, placement, alignment, offsetX, offsetY, anchorRef, collisionDetection, collisionDetectionPadding, updateOrigin,],);
-  const descendantContext = useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, {
-    safeArea,
-    onDismiss,
-  },);
+  const descendantContext = useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, { safeArea, onDismiss, },);
   return ReactDOM.createPortal(
     /* @__PURE__ */ _jsxs('div', {
       ref: floatingPositionRef,
       className,
-      style: {
-        // Initially rendered as hidden, but the layout effect will set
+      style: { // Initially rendered as hidden, but the layout effect will set
         // to visible when the position is calculated.
         visibility: 'hidden',
         width: 'auto',
@@ -30716,27 +23490,11 @@ function Floating({
       ...rest,
       children: [
         safeArea
-          ? /* @__PURE__ */ _jsx5('div', {
-            ref: safeAreaRef,
-            style: {
-              position: 'absolute',
-            },
-            'data-safearea': true,
-          },)
-          : /* @__PURE__ */ _jsx5('div', {
-            style: {
-              position: 'fixed',
-              inset: 0,
-            },
-            'aria-hidden': true,
-            onMouseDown: onDismiss,
-          },),
+          ? /* @__PURE__ */ _jsx5('div', { ref: safeAreaRef, style: { position: 'absolute', }, 'data-safearea': true, },)
+          : /* @__PURE__ */ _jsx5('div', { style: { position: 'fixed', inset: 0, }, 'aria-hidden': true, onMouseDown: onDismiss, },),
         /* @__PURE__ */ _jsx5(FloatingStackingContext.Provider, {
           value: descendantContext,
-          children: /* @__PURE__ */ _jsx5('div', {
-            ref: contentRef,
-            children: childrenWithOrigin(children, origin,),
-          },),
+          children: /* @__PURE__ */ _jsx5('div', { ref: contentRef, children: childrenWithOrigin(children, origin,), },),
         },),
       ],
     },),
@@ -30751,8 +23509,7 @@ var LazyValue = class {
   }
   static is(value,) {
     return value instanceof LazyValue;
-  }
-  /** Preload the value so it can be read() later. */
+  } /** Preload the value so it can be read() later. */
   preload() {
     if (this.status) {
       const status = this.status;
@@ -30760,28 +23517,16 @@ var LazyValue = class {
       return status.promise;
     }
     const promise = this.resolver().then((value) => {
-      this.status = {
-        type: 'fulfilled',
-        value,
-      };
+      this.status = { type: 'fulfilled', value, };
     }, (error) => {
-      this.status = {
-        type: 'rejected',
-        error,
-      };
+      this.status = { type: 'rejected', error, };
     },);
-    this.status = {
-      type: 'pending',
-      promise,
-    };
+    this.status = { type: 'pending', promise, };
     return promise;
-  }
-  /** Synchronously read the value after calling preload() before. */
+  } /** Synchronously read the value after calling preload() before. */
   read() {
     const status = this.status;
-    if (!status) {
-      throw new Error('Need to call preload() before read()',);
-    }
+    if (!status) throw new Error('Need to call preload() before read()',);
     switch (status.type) {
       case 'pending':
         throw new Error('Need to wait for preload() to resolve',);
@@ -30795,13 +23540,9 @@ var LazyValue = class {
   }
 };
 function findAnchorElement(target, withinElement,) {
-  if (target instanceof HTMLAnchorElement) {
-    return target;
-  }
+  if (target instanceof HTMLAnchorElement) return target;
   if (target instanceof Element) {
-    if (target === withinElement) {
-      return null;
-    }
+    if (target === withinElement) return null;
     return findAnchorElement(target.parentElement, withinElement,);
   }
   return null;
@@ -30817,9 +23558,7 @@ function isFramerPageLink(value,) {
 function createFramerPageLink(targetId = null, options = {},) {
   const target = targetId ? targetId : 'none';
   const link = new URL(`data:${mediaType}${target}`,);
-  if (options.element) {
-    link.searchParams.append(elementKey, options.element,);
-  }
+  if (options.element) link.searchParams.append(elementKey, options.element,);
   if (options.collectionItem) {
     link.searchParams.append(collectionKey, options.collectionItem.collection,);
     link.searchParams.append(collectionItemIdKey, options.collectionItem.collectionItemId,);
@@ -30840,15 +23579,10 @@ function parseFramerPageLink(link,) {
     const pathVariablesValue = searchParams.get(pathVariablesKey,);
     if (collection && collectionItemId && pathVariablesValue) {
       const pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesValue,).entries(),);
-      collectionItem = {
-        collection,
-        collectionItemId,
-        pathVariables,
-      };
+      collectionItem = { collection, collectionItemId, pathVariables, };
     }
     return {
-      target: target === 'none' ? null : target,
-      /**
+      target: target === 'none' ? null : target, /**
        * For historical reason we used to set "element=none" into the
        * datalink, we no longer do that today, but we still keep this code
        * so we could parse legacy links correctly.
@@ -30865,18 +23599,13 @@ function shouldOpenLinkInNewTab(link,) {
 }
 function navigateFromAttributes(navigate, element, implicitPathVariables,) {
   var _a;
-  let routeId = element.getAttribute('data-framer-page-link-target',/* Page */
-  );
+  let routeId = element.getAttribute('data-framer-page-link-target', /* Page */);
   let elementId;
   let pathVariables;
   if (routeId) {
-    elementId = element.getAttribute('data-framer-page-link-element',/* Element */
-    ) ?? void 0;
-    const pathVariablesRaw = element.getAttribute('data-framer-page-link-path-variables',/* PathVariables */
-    );
-    if (pathVariablesRaw) {
-      pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesRaw,).entries(),);
-    }
+    elementId = element.getAttribute('data-framer-page-link-element', /* Element */) ?? void 0;
+    const pathVariablesRaw = element.getAttribute('data-framer-page-link-path-variables', /* PathVariables */);
+    if (pathVariablesRaw) pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesRaw,).entries(),);
   } else {
     const href = element.getAttribute('href',);
     if (!href) return false;
@@ -30938,17 +23667,9 @@ function linkFromFramerPageLink(link,) {
   if (!isFramerPageLink(link,)) return link;
   const parsed = parseFramerPageLink(link,);
   if (!parsed) return void 0;
-  const {
-    target,
-    element,
-    collectionItem,
-  } = parsed;
+  const { target, element, collectionItem, } = parsed;
   if (!target) return void 0;
-  return {
-    webPageId: target,
-    hash: element ?? void 0,
-    pathVariables: createVariablesFromPageLinkCollectionItem(collectionItem,),
-  };
+  return { webPageId: target, hash: element ?? void 0, pathVariables: createVariablesFromPageLinkCollectionItem(collectionItem,), };
 }
 var pathVariablesRegExp2 = /:([a-z]\w*)/gi;
 var PathVariablesContext = React__default.createContext(void 0,);
@@ -30959,20 +23680,14 @@ function useImplicitPathVariables() {
   const pathVariables = contextPathVariables || currentPathVariables;
   return pathVariables;
 }
-function linkMatchesRoute(route, {
-  webPageId,
-  hash: hash2,
-  pathVariables,
-}, implicitPathVariables,) {
+function linkMatchesRoute(route, { webPageId, hash: hash2, pathVariables, }, implicitPathVariables,) {
   if (webPageId !== route.id) return false;
   if (hash2) return false;
   if (route.path && route.pathVariables) {
     const combinedPathVariable = Object.assign({}, implicitPathVariables, pathVariables,);
     for (const [, key7,] of route.path.matchAll(pathVariablesRegExp2,)) {
       if (!key7) return false;
-      if (route.pathVariables[key7] !== combinedPathVariable[key7]) {
-        return false;
-      }
+      if (route.pathVariables[key7] !== combinedPathVariable[key7]) return false;
     }
   }
   return true;
@@ -31002,19 +23717,13 @@ var AnchorLinkTarget = /* @__PURE__ */ ((AnchorLinkTarget2) => {
   return AnchorLinkTarget2;
 })(AnchorLinkTarget || {},);
 function getTargetAttrValue(openInNewTab, isInternal,) {
-  if (openInNewTab !== void 0) {
-    return openInNewTab ? '_blank' : void 0;
-  }
+  if (openInNewTab !== void 0) return openInNewTab ? '_blank' : void 0;
   return isInternal ? void 0 : '_blank';
 }
 function propsForLink(href, openInNewTab = void 0,) {
   const isInternal = isInternalURL(href,);
   const anchorTarget = getTargetAttrValue(openInNewTab, isInternal,);
-  return {
-    href: isValidURL(href, isInternal,) ? href : `https://${href}`,
-    target: anchorTarget,
-    rel: !isInternal ? 'noopener' : void 0,
-  };
+  return { href: isValidURL(href, isInternal,) ? href : `https://${href}`, target: anchorTarget, rel: !isInternal ? 'noopener' : void 0, };
 }
 function createOnClickLinkHandler(router, routeId, elementId, combinedPathVariables, smoothScroll,) {
   return async (event) => {
@@ -31024,34 +23733,26 @@ function createOnClickLinkHandler(router, routeId, elementId, combinedPathVariab
     if (!anchorElement || anchorElement.getAttribute('target',) === '_blank') return;
     event.preventDefault();
     const route = (_a = router.getRoute) == null ? void 0 : _a.call(router, routeId,);
-    if (route && isLazyComponentType(route == null ? void 0 : route.page,)) {
-      await route.page.preload();
-    }
+    if (route && isLazyComponentType(route == null ? void 0 : route.page,)) await route.page.preload();
     (_b = router.navigate) == null ? void 0 : _b.call(router, routeId, elementId, combinedPathVariables, smoothScroll,);
   };
 }
 function propsForRoutePath(href, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll,) {
   const isInternal = isInternalURL(href,);
-  if (!router.routes || !router.getRoute || !currentRoute || !isInternal) {
-    return propsForLink(href, openInNewTab,);
-  }
+  if (!router.routes || !router.getRoute || !currentRoute || !isInternal) return propsForLink(href, openInNewTab,);
   try {
     const [pathnameWithQueryParams, hash2,] = href.split('#', 2,);
     assert(pathnameWithQueryParams !== void 0, 'A href must have a defined pathname.',);
     const [pathname,] = pathnameWithQueryParams.split('?', 2,);
     assert(pathname !== void 0, 'A href must have a defined pathname.',);
-    const {
-      routeId,
-      pathVariables,
-    } = inferInitialRouteFromPath(router.routes, pathname,);
+    const { routeId, pathVariables, } = inferInitialRouteFromPath(router.routes, pathname,);
     const route = router.getRoute(routeId,);
     if (route) {
       preloadComponent(route.page,);
       const combinedPathVariables = Object.assign({}, implicitPathVariables, pathVariables,);
       const path = getPathForRoute(route, {
         currentRoutePath: currentRoute.path,
-        currentPathVariables: currentRoute.pathVariables,
-        // The hash value is already fully resolved so we don't need to
+        currentPathVariables: currentRoute.pathVariables, // The hash value is already fully resolved so we don't need to
         // provide any hashVariables.
         hash: hash2 || void 0,
         pathVariables: combinedPathVariables,
@@ -31077,56 +23778,31 @@ function resolveSlugsWithSuspense(unresolvedPathSlugs, unresolvedHashSlugs, coll
       assert(unresolvedSlug, 'unresolvedSlug should be defined',);
       const lazyValue = resolveSlug(unresolvedSlug, collectionUtils, activeLocale,);
       const promise = lazyValue.preload();
-      if (promise) {
-        promises.push(promise,);
-      } else {
+      if (promise) promises.push(promise,);
+      else {
         const value = lazyValue.read();
-        if (value) {
-          result2[slugKey] = value;
-        }
+        if (value) result2[slugKey] = value;
       }
     }
     return result2;
   }
-  const result = {
-    path: handleSlugs(unresolvedPathSlugs,),
-    hash: handleSlugs(unresolvedHashSlugs,),
-  };
-  if (promises.length) {
-    throw Promise.allSettled(promises,);
-  }
+  const result = { path: handleSlugs(unresolvedPathSlugs,), hash: handleSlugs(unresolvedHashSlugs,), };
+  if (promises.length) throw Promise.allSettled(promises,);
   return result;
 }
-var Link = /* @__PURE__ */ React__default.forwardRef(({
-  children,
-  href,
-  openInNewTab,
-  smoothScroll,
-  ...restProps
-}, forwardedRef,) => {
+var Link = /* @__PURE__ */ React__default.forwardRef(({ children, href, openInNewTab, smoothScroll, ...restProps }, forwardedRef,) => {
   const router = useRouter();
   const currentRoute = useCurrentRoute();
   const implicitPathVariables = useImplicitPathVariables();
-  const {
-    activeLocale,
-  } = useLocaleInfo();
+  const { activeLocale, } = useLocaleInfo();
   const clone = useCloneChildrenWithPropsAndRef(forwardedRef,);
   const props = React__default.useMemo(() => {
     var _a;
     if (!href) return {};
     const pageLink = isLinkToWebPage(href,) ? href : linkFromFramerPageLink(href,);
     if (!pageLink) return {};
-    if (isString22(pageLink,)) {
-      return propsForRoutePath(pageLink, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll,);
-    }
-    const {
-      webPageId,
-      hash: hash2,
-      pathVariables,
-      hashVariables,
-      unresolvedHashSlugs,
-      unresolvedPathSlugs,
-    } = pageLink;
+    if (isString22(pageLink,)) return propsForRoutePath(pageLink, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll,);
+    const { webPageId, hash: hash2, pathVariables, hashVariables, unresolvedHashSlugs, unresolvedPathSlugs, } = pageLink;
     const route = (_a = router.getRoute) == null ? void 0 : _a.call(router, webPageId,);
     const resolvedSlugs = resolveSlugsWithSuspense(unresolvedPathSlugs, unresolvedHashSlugs, router.collectionUtils, activeLocale,);
     if (route) preloadComponent(route.page,);
@@ -31159,10 +23835,7 @@ var Link = /* @__PURE__ */ React__default.forwardRef(({
       'data-framer-page-link-current': currentRoute && linkMatchesRoute(currentRoute, pageLink, implicitPathVariables,) || void 0,
     };
   }, [href, router, activeLocale, implicitPathVariables, openInNewTab, currentRoute, smoothScroll,],);
-  return clone(children, {
-    ...restProps,
-    ...props,
-  },);
+  return clone(children, { ...restProps, ...props, },);
 },);
 function resolveLink(href, router, implicitPathVariables,) {
   return resolveLinkInternal(href, router, implicitPathVariables,);
@@ -31172,14 +23845,7 @@ function resolveLinkInternal(href, router, implicitPathVariables, resolveSlugs,)
   if (!isLinkToWebPage(pageLink,)) return isString22(href,) ? propsForLink(href,).href : void 0;
   if (!router.getRoute || !router.currentRouteId) return void 0;
   const currentRoute = router.getRoute(router.currentRouteId,);
-  const {
-    webPageId,
-    hash: hash2,
-    pathVariables,
-    hashVariables,
-    unresolvedHashSlugs,
-    unresolvedPathSlugs,
-  } = pageLink;
+  const { webPageId, hash: hash2, pathVariables, hashVariables, unresolvedHashSlugs, unresolvedPathSlugs, } = pageLink;
   const route = router.getRoute(webPageId,);
   const resolvedSlugs = unresolvedPathSlugs || unresolvedHashSlugs
     ? resolveSlugs == null ? void 0 : resolveSlugs(unresolvedPathSlugs, unresolvedHashSlugs,)
@@ -31211,9 +23877,7 @@ function resolveLinkInternal(href, router, implicitPathVariables, resolveSlugs,)
 function resolvePageScope(pageLink, router,) {
   if (!router.getRoute || !router.currentRouteId) return void 0;
   const currentRoute = router.getRoute(router.currentRouteId,);
-  const {
-    webPageId,
-  } = pageLink;
+  const { webPageId, } = pageLink;
   const route = router.getRoute(webPageId,);
   return getPathForRoute(route, {
     currentRoutePath: currentRoute == null ? void 0 : currentRoute.path,
@@ -31222,22 +23886,24 @@ function resolvePageScope(pageLink, router,) {
     preserveQueryParams: false,
   },);
 }
-function PageRoot({
-  RootComponent,
-  isWebsite,
-  routeId,
-  pathVariables,
-  routes,
-  collectionUtils,
-  notFoundPage,
-  isReducedMotion = false,
-  includeDataObserver = false,
-  localeId,
-  locales,
-  preserveQueryParams,
-  enableImproveInpDuringHydration,
-  shouldMarkHydrationEnd = false,
-},) {
+function PageRoot(
+  {
+    RootComponent,
+    isWebsite,
+    routeId,
+    pathVariables,
+    routes,
+    collectionUtils,
+    notFoundPage,
+    isReducedMotion = false,
+    includeDataObserver = false,
+    localeId,
+    locales,
+    preserveQueryParams,
+    enableImproveInpDuringHydration,
+    shouldMarkHydrationEnd = false,
+  },
+) {
   React__default.useEffect(() => {
     if (isWebsite) return;
     MainLoop.start();
@@ -31254,10 +23920,7 @@ function PageRoot({
           collectionUtils,
           notFoundPage,
           locales,
-          defaultPageStyle: {
-            minHeight: '100vh',
-            width: 'auto',
-          },
+          defaultPageStyle: { minHeight: '100vh', width: 'auto', },
           preserveQueryParams,
           enableImproveInpDuringHydration,
           shouldMarkHydrationEnd,
@@ -31270,13 +23933,10 @@ function PageRoot({
       children: /* @__PURE__ */ _jsx5(RoutesProvider, {
         routes,
         children: /* @__PURE__ */ _jsx5(NavigationWrapper, {
-          children: React__default.isValidElement(RootComponent,) ? RootComponent : React__default.createElement(
-            // @ts-expect-error to figure out how to type this properly, as tests are using different
+          children: React__default.isValidElement(RootComponent,) ? RootComponent : React__default.createElement( // @ts-expect-error to figure out how to type this properly, as tests are using different
             // $$typeof symbol and isValidElement fails
             RootComponent,
-            {
-              key: routeId,
-            },
+            { key: routeId, },
           ),
         },),
       },),
@@ -31285,15 +23945,11 @@ function PageRoot({
 }
 function cloneChildrenWithProps(children, props, asNode,) {
   const cloned = React.Children.map(children, (child) => {
-    if (React.isValidElement(child,)) {
-      return React.cloneElement(child, props,);
-    }
+    if (React.isValidElement(child,)) return React.cloneElement(child, props,);
     return child;
   },);
   if (asNode) return cloned;
-  return /* @__PURE__ */ _jsx5(Fragment, {
-    children: cloned,
-  },);
+  return /* @__PURE__ */ _jsx5(Fragment, { children: cloned, },);
 }
 var SSRParentVariantsContext = /* @__PURE__ */ React__default.createContext(void 0,);
 var SSRVariantClassName = 'ssr-variant';
@@ -31306,9 +23962,7 @@ function renderBranchedChildrenFromPropertyOverridesOnServer(
   parentVariants,
   type,
 ) {
-  if (isBrowser2()) {
-    throw new Error('This should not be called on the client',);
-  }
+  if (isBrowser2()) throw new Error('This should not be called on the client',);
   const childrenArray = React__default.Children.toArray(children,);
   const child = childrenArray[0];
   if (childrenArray.length !== 1 || !React__default.isValidElement(child,)) {
@@ -31325,87 +23979,54 @@ function renderBranchedChildrenFromPropertyOverridesOnServer(
       continue;
     }
     const effectiveVariants = intersection([variantId,], parentVariants,);
-    if (effectiveVariants.length) {
-      branches.push({
-        variants: effectiveVariants,
-        propOverrides,
-      },);
-    }
+    if (effectiveVariants.length) branches.push({ variants: effectiveVariants, propOverrides, },);
   }
   if (branches.length === 0) return cloneChildrenWithProps(child, props,);
   const remainingVariants = [primaryVariantId, ...nonOverriddenVariants,];
   const effectiveRemainingVariants = intersection(remainingVariants, parentVariants,);
-  if (effectiveRemainingVariants.length) {
-    branches.unshift({
-      variants: effectiveRemainingVariants,
-    },);
-  }
+  if (effectiveRemainingVariants.length) branches.unshift({ variants: effectiveRemainingVariants, },);
   const displayContents = `.${SSRVariantClassName} { display: contents }`;
   return /* @__PURE__ */ _jsxs(Fragment, {
     children: [
-      !parentVariants && /* @__PURE__ */ _jsx5('style', {
-        ...styleTagSSRMarker,
-        children: displayContents,
-      },),
-      branches.map(({
-        variants,
-        propOverrides,
-      },) => {
+      !parentVariants && /* @__PURE__ */ _jsx5('style', { ...styleTagSSRMarker, children: displayContents, },),
+      branches.map(({ variants, propOverrides, },) => {
         const key7 = variants.join('+',);
-        let element =
-          // We could omit the SSRParentVariantsContext if variants is
+        let element = // We could omit the SSRParentVariantsContext if variants is
           // the same as parentVariants, but that'd require comparing
           // arrays, so it might not really be an optimization. And
           // since it's just a context, it doesn't affect the size of
           // the generated HTML.
-          /* @__PURE__ */
-          _jsx5(SSRParentVariantsContext.Provider, {
+          /* @__PURE__ */ _jsx5(SSRParentVariantsContext.Provider, {
             value: new Set(variants,),
-            children: cloneChildrenWithProps(child, {
-              ...props,
-              ...propOverrides,
-            },),
+            children: cloneChildrenWithProps(child, { ...props, ...propOverrides, },),
           }, key7,);
         const hiddenClassNames = generateHiddenClassNames(variants, parentVariants, variantClassNames,);
         if (hiddenClassNames.length) {
           assert(branches.length > 1, 'Must branch out when there are hiddenClassNames',);
-          element = /* @__PURE__ */ _jsx5('div', {
-            className: `${SSRVariantClassName} ${hiddenClassNames.join(' ',)}`,
-            children: element,
-          }, key7,);
-        } else {
-          assert(branches.length === 1, 'Cannot branch out when hiddenClassNames is empty',);
-        }
+          element = /* @__PURE__ */ _jsx5(
+            'div',
+            { className: `${SSRVariantClassName} ${hiddenClassNames.join(' ',)}`, children: element, },
+            key7,
+          );
+        } else assert(branches.length === 1, 'Cannot branch out when hiddenClassNames is empty',);
         return element;
       },),
     ],
   },);
 }
-var SSRVariants = /* @__PURE__ */ React__default.forwardRef(function SSRVariants2({
-  id: nodeId,
-  children,
-  ...props
-}, ref,) {
+var SSRVariants = /* @__PURE__ */ React__default.forwardRef(function SSRVariants2({ id: nodeId, children, ...props }, ref,) {
   const cloneWithRefs = useCloneChildrenWithPropsAndRef(ref,);
-  if (isBrowser2()) {
-    return cloneWithRefs(children, props,);
-  }
+  if (isBrowser2()) return cloneWithRefs(children, props,);
   const generatedComponentContext = React__default.useContext(GeneratedComponentContext,);
   if (!generatedComponentContext || !generatedComponentContext.variantProps) {
     console.warn('SSRVariants is missing GeneratedComponentContext',);
     return cloneWithRefs(children, props,);
   }
   const parentVariants = React__default.useContext(SSRParentVariantsContext,);
-  const {
-    primaryVariantId,
-    variantClassNames,
-    variantProps: variantProps2,
-  } = generatedComponentContext;
+  const { primaryVariantId, variantClassNames, variantProps: variantProps2, } = generatedComponentContext;
   const overrides = React__default.useMemo(() => {
     const nextOverrides = {};
-    for (const [variant, values,] of Object.entries(variantProps2,)) {
-      nextOverrides[variant] = values[nodeId];
-    }
+    for (const [variant, values,] of Object.entries(variantProps2,)) nextOverrides[variant] = values[nodeId];
     return nextOverrides;
   }, [nodeId, variantProps2,],);
   return renderBranchedChildrenFromPropertyOverridesOnServer(
@@ -31433,59 +24054,38 @@ function intersection(variants, parentVariants,) {
   return variants.filter((variant) => parentVariants.has(variant,));
 }
 function arePropOverridesEffectivelyDifferent(props, propOverrides,) {
-  for (const key7 of Object.keys(propOverrides,)) {
-    if (!isEqual(props[key7], propOverrides[key7], true,)) {
-      return true;
-    }
-  }
+  for (const key7 of Object.keys(propOverrides,)) if (!isEqual(props[key7], propOverrides[key7], true,)) return true;
   return false;
 }
 function propsForBreakpoint(variant, props, overrides,) {
   if (!overrides || !variant) return props;
-  return {
-    ...props,
-    ...overrides[variant],
-  };
-}
-var PropertyOverrides = /* @__PURE__ */ React__default.forwardRef(function PropertyOverrides2({
-  breakpoint,
-  overrides,
-  children,
-  ...props
-}, ref,) {
-  const cloneWithRefs = useCloneChildrenWithPropsAndRef(ref,);
-  if (isBrowser2()) {
-    return cloneWithRefs(children, propsForBreakpoint(breakpoint, props, overrides,),);
-  }
-  const generatedComponentContext = React__default.useContext(GeneratedComponentContext,);
-  if (!generatedComponentContext) {
-    console.warn('PropertyOverrides is missing GeneratedComponentContext',);
-    return cloneWithRefs(children, props,);
-  }
-  const {
-    primaryVariantId,
-    variantClassNames,
-  } = generatedComponentContext;
-  const parentVariants = React__default.useContext(SSRParentVariantsContext,);
-  return renderBranchedChildrenFromPropertyOverridesOnServer(
-    overrides,
-    children,
-    props,
-    variantClassNames,
-    primaryVariantId,
-    parentVariants,
-    'PropertyOverrides',
-  );
-},);
-var ResolveLinks = /* @__PURE__ */ React.forwardRef(function ResolveLinksInner({
-  links,
-  children,
-  ...rest
-}, ref,) {
+  return { ...props, ...overrides[variant], };
+}
+var PropertyOverrides = /* @__PURE__ */ React__default.forwardRef(
+  function PropertyOverrides2({ breakpoint, overrides, children, ...props }, ref,) {
+    const cloneWithRefs = useCloneChildrenWithPropsAndRef(ref,);
+    if (isBrowser2()) return cloneWithRefs(children, propsForBreakpoint(breakpoint, props, overrides,),);
+    const generatedComponentContext = React__default.useContext(GeneratedComponentContext,);
+    if (!generatedComponentContext) {
+      console.warn('PropertyOverrides is missing GeneratedComponentContext',);
+      return cloneWithRefs(children, props,);
+    }
+    const { primaryVariantId, variantClassNames, } = generatedComponentContext;
+    const parentVariants = React__default.useContext(SSRParentVariantsContext,);
+    return renderBranchedChildrenFromPropertyOverridesOnServer(
+      overrides,
+      children,
+      props,
+      variantClassNames,
+      primaryVariantId,
+      parentVariants,
+      'PropertyOverrides',
+    );
+  },
+);
+var ResolveLinks = /* @__PURE__ */ React.forwardRef(function ResolveLinksInner({ links, children, ...rest }, ref,) {
   const router = useRouter();
-  const {
-    activeLocale,
-  } = useLocaleInfo();
+  const { activeLocale, } = useLocaleInfo();
   const cloneWithPropsAndRef = useCloneChildrenWithPropsAndRef(ref,);
   const promises = [];
   const resolvedLinks = links.map((link) => {
@@ -31498,26 +24098,18 @@ var ResolveLinks = /* @__PURE__ */ React.forwardRef(function ResolveLinksInner({
           assert(unresolvedSlug, 'unresolvedSlug be defined',);
           const lazyValue = resolveSlug(unresolvedSlug, router.collectionUtils, activeLocale,);
           const promise = lazyValue.preload();
-          if (promise) {
-            promises.push(promise,);
-          } else {
+          if (promise) promises.push(promise,);
+          else {
             const resolvedValue = lazyValue.read();
-            if (resolvedValue) {
-              result[slugKey] = resolvedValue;
-            }
+            if (resolvedValue) result[slugKey] = resolvedValue;
           }
         }
         return result;
       }
-      return {
-        path: handleSlugs(unresolvedPathSlugs,),
-        hash: handleSlugs(unresolvedHashslugs,),
-      };
+      return { path: handleSlugs(unresolvedPathSlugs,), hash: handleSlugs(unresolvedHashslugs,), };
     },);
   },);
-  if (promises.length > 0) {
-    throw Promise.allSettled(promises,);
-  }
+  if (promises.length > 0) throw Promise.allSettled(promises,);
   const childrenWithLinks = children(resolvedLinks,);
   return cloneWithPropsAndRef(childrenWithLinks, rest,);
 },);
@@ -31577,19 +24169,11 @@ var CompatibilityDatabaseCollection = class {
     __publicField(this, 'indexes', [],);
     const propertyControls = getPropertyControls(collection,);
     assert(propertyControls, 'Collection does not have properties',);
-    const schema = {
-      id: {
-        type: 'string',
-        isNullable: false,
-      },
-    };
+    const schema = { id: { type: 'string', isNullable: false, }, };
     const controlEntries = Object.entries(propertyControls,);
     for (const [key7, controlDescription,] of controlEntries) {
       if (!controlDescription) continue;
-      schema[key7] = {
-        type: controlDescription.type,
-        isNullable: true,
-      };
+      schema[key7] = { type: controlDescription.type, isNullable: true, };
     }
     this.schema = schema;
   }
@@ -31600,15 +24184,9 @@ var CompatibilityDatabaseCollection = class {
       if (isNullish(value,)) continue;
       const definition = this.schema[key7];
       if (isUndefined(definition,)) continue;
-      data2[key7] = {
-        type: definition.type,
-        value,
-      };
+      data2[key7] = { type: definition.type, value, };
     }
-    return {
-      pointer,
-      data: data2,
-    };
+    return { pointer, data: data2, };
   }
   async resolveRichText(pointer,) {
     if (LazyValue.is(pointer,)) {
@@ -31642,57 +24220,40 @@ var DatabaseValue = {
   /**
    * Checks if the left value is equal to the right value. Returns false if
    * the values are not of the same type.
-   */
-  equal(left, right, collation,) {
-    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
-      return false;
-    }
+   */ equal(left, right, collation,) {
+    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) return false;
     return compare(left, right, collation,) === 0;
-  },
-  /**
+  }, /**
    * Checks if the left value is less than the right value. Returns false if
    * the values are not of the same type.
    */
   lessThan(left, right, collation,) {
-    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
-      return false;
-    }
+    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) return false;
     return compare(left, right, collation,) < 0;
-  },
-  /**
+  }, /**
    * Checks if the left value is less than or equal to the right value.
    * Returns false if the values are not of the same type.
    */
   lessThanOrEqual(left, right, collation,) {
-    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
-      return false;
-    }
+    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) return false;
     return compare(left, right, collation,) <= 0;
-  },
-  /**
+  }, /**
    * Checks if the left value is greater than the right value. Returns false
    * if the values are not of the same type.
    */
   greaterThan(left, right, collation,) {
-    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
-      return false;
-    }
+    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) return false;
     return compare(left, right, collation,) > 0;
-  },
-  /**
+  }, /**
    * Checks if the left value is greater than or equal to the right value.
    * Returns false if the values are not of the same type.
    */
   greaterThanOrEqual(left, right, collation,) {
-    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
-      return false;
-    }
+    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) return false;
     return compare(left, right, collation,) >= 0;
   },
   stringify(value,) {
-    if (value === null) {
-      return 'null';
-    }
+    if (value === null) return 'null';
     switch (value.type) {
       case 'boolean':
       case 'number':
@@ -31815,14 +24376,8 @@ var ScalarIdentifier = class extends ScalarExpression {
     this.schema = schema;
     this.name = name;
     __publicField(this, 'definition',);
-    if (name === INDEX_IDENTIFIER) {
-      this.definition = {
-        type: 'number',
-        isNullable: false,
-      };
-    } else {
-      this.definition = schema[name] ?? null;
-    }
+    if (name === INDEX_IDENTIFIER) this.definition = { type: 'number', isNullable: false, };
+    else this.definition = schema[name] ?? null;
   }
   stringify() {
     return this.name;
@@ -31832,9 +24387,7 @@ var ScalarIdentifier = class extends ScalarExpression {
   }
   evaluate(item,) {
     const name = this.name;
-    if (isUndefined(item,) || name === INDEX_IDENTIFIER) {
-      throw new Error(`Can't evaluate identifier: ${name}`,);
-    }
+    if (isUndefined(item,) || name === INDEX_IDENTIFIER) throw new Error(`Can't evaluate identifier: ${name}`,);
     return item.data[name] ?? null;
   }
   canEvaluate() {
@@ -31854,64 +24407,22 @@ var ScalarLiteralValue = class extends ScalarExpression {
     return new ScalarLiteralValue(null, null,);
   }
   static fromBoolean(value,) {
-    return new ScalarLiteralValue(
-      {
-        type: 'boolean',
-        isNullable: isNull(value,),
-      },
-      isNull(value,) ? null : {
-        type: 'boolean',
-        value,
-      },
-    );
+    return new ScalarLiteralValue({ type: 'boolean', isNullable: isNull(value,), }, isNull(value,) ? null : { type: 'boolean', value, },);
   }
   static fromDate(value,) {
     return new ScalarLiteralValue(
-      {
-        type: 'date',
-        isNullable: isNull(value,),
-      },
-      isNull(value,) ? null : {
-        type: 'date',
-        value: value.toISOString(),
-      },
+      { type: 'date', isNullable: isNull(value,), },
+      isNull(value,) ? null : { type: 'date', value: value.toISOString(), },
     );
   }
   static fromEnum(value,) {
-    return new ScalarLiteralValue(
-      {
-        type: 'enum',
-        isNullable: isNull(value,),
-      },
-      isNull(value,) ? null : {
-        type: 'enum',
-        value,
-      },
-    );
+    return new ScalarLiteralValue({ type: 'enum', isNullable: isNull(value,), }, isNull(value,) ? null : { type: 'enum', value, },);
   }
   static fromNumber(value,) {
-    return new ScalarLiteralValue(
-      {
-        type: 'number',
-        isNullable: isNull(value,),
-      },
-      isNull(value,) ? null : {
-        type: 'number',
-        value,
-      },
-    );
+    return new ScalarLiteralValue({ type: 'number', isNullable: isNull(value,), }, isNull(value,) ? null : { type: 'number', value, },);
   }
   static fromString(value,) {
-    return new ScalarLiteralValue(
-      {
-        type: 'string',
-        isNullable: isNull(value,),
-      },
-      isNull(value,) ? null : {
-        type: 'string',
-        value,
-      },
-    );
+    return new ScalarLiteralValue({ type: 'string', isNullable: isNull(value,), }, isNull(value,) ? null : { type: 'string', value, },);
   }
   equals(other,) {
     return other instanceof ScalarLiteralValue && isEqual(this.definition, other.definition,) && isEqual(other.value, this.value,);
@@ -31927,16 +24438,11 @@ var ScalarFunctionCall = class extends ScalarExpression {
   constructor(argumentExpressions,) {
     super();
     this.argumentExpressions = argumentExpressions;
-    __publicField(this, 'collation', {
-      type: 0,
-      /* CaseInsensitive */
-    },);
+    __publicField(this, 'collation', { type: 0, /* CaseInsensitive */ },);
   }
   getArgumentExpression(index,) {
     const argument = this.argumentExpressions[index];
-    if (isUndefined(argument,)) {
-      throw new Error('Missing argument in function call',);
-    }
+    if (isUndefined(argument,)) throw new Error('Missing argument in function call',);
     return argument;
   }
   equals(other,) {
@@ -31957,10 +24463,7 @@ var ScalarFunctionCallContains = class extends ScalarFunctionCall {
     __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return `CONTAINS(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
@@ -31979,10 +24482,7 @@ var ScalarFunctionCallContains = class extends ScalarFunctionCall {
   evaluate(item,) {
     const source = this.sourceExpression.evaluate(item,);
     const target = this.targetExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: this.getValue(source, target,),
-    };
+    return { type: 'boolean', value: this.getValue(source, target,), };
   }
 };
 var ScalarFunctionCallStartsWith = class extends ScalarFunctionCall {
@@ -31993,10 +24493,7 @@ var ScalarFunctionCallStartsWith = class extends ScalarFunctionCall {
     __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return `STARTS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
@@ -32015,10 +24512,7 @@ var ScalarFunctionCallStartsWith = class extends ScalarFunctionCall {
   evaluate(item,) {
     const source = this.sourceExpression.evaluate(item,);
     const target = this.targetExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: this.getValue(source, target,),
-    };
+    return { type: 'boolean', value: this.getValue(source, target,), };
   }
 };
 var ScalarFunctionCallEndsWith = class extends ScalarFunctionCall {
@@ -32029,10 +24523,7 @@ var ScalarFunctionCallEndsWith = class extends ScalarFunctionCall {
     __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return `ENDS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
@@ -32051,10 +24542,7 @@ var ScalarFunctionCallEndsWith = class extends ScalarFunctionCall {
   evaluate(item,) {
     const source = this.sourceExpression.evaluate(item,);
     const target = this.targetExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: this.getValue(source, target,),
-    };
+    return { type: 'boolean', value: this.getValue(source, target,), };
   }
 };
 var ScalarCase = class extends ScalarExpression {
@@ -32064,21 +24552,10 @@ var ScalarCase = class extends ScalarExpression {
     this.conditions = conditions;
     this.elseExpression = elseExpression;
     __publicField(this, 'definition',);
-    __publicField(this, 'collation', {
-      type: 0,
-      /* CaseInsensitive */
-    },);
+    __publicField(this, 'collation', { type: 0, /* CaseInsensitive */ },);
     const definitions = [];
-    for (
-      const {
-        thenExpression,
-      } of conditions
-    ) {
-      definitions.push(thenExpression.definition,);
-    }
-    if (elseExpression) {
-      definitions.push(elseExpression.definition,);
-    }
+    for (const { thenExpression, } of conditions) definitions.push(thenExpression.definition,);
+    if (elseExpression) definitions.push(elseExpression.definition,);
     this.definition = ScalarCase.getDefinition(definitions,);
   }
   static getDefinition(definitions,) {
@@ -32086,34 +24563,18 @@ var ScalarCase = class extends ScalarExpression {
     let isNullable = false;
     for (const definition of definitions) {
       result ?? (result = definition);
-      if (result && definition && result.type !== definition.type) {
-        throw new Error('Incompatible types in CASE expression',);
-      }
+      if (result && definition && result.type !== definition.type) throw new Error('Incompatible types in CASE expression',);
       isNullable || (isNullable = (definition == null ? void 0 : definition.isNullable) ?? true);
     }
-    return result
-      ? {
-        type: result.type,
-        isNullable,
-      }
-      : null;
+    return result ? { type: result.type, isNullable, } : null;
   }
   stringify() {
     let result = 'CASE';
-    if (this.valueExpression) {
-      result += ` ${this.valueExpression.stringify()}`;
-    }
-    for (
-      const {
-        whenExpression,
-        thenExpression,
-      } of this.conditions
-    ) {
+    if (this.valueExpression) result += ` ${this.valueExpression.stringify()}`;
+    for (const { whenExpression, thenExpression, } of this.conditions) {
       result += ` WHEN ${whenExpression.stringify()} THEN ${thenExpression.stringify()}`;
     }
-    if (this.elseExpression) {
-      result += ` ELSE ${this.elseExpression.stringify()}`;
-    }
+    if (this.elseExpression) result += ` ELSE ${this.elseExpression.stringify()}`;
     result += ' END';
     return result;
   }
@@ -32124,12 +24585,7 @@ var ScalarCase = class extends ScalarExpression {
   evaluate(item,) {
     var _a, _b;
     const value = ((_a = this.valueExpression) == null ? void 0 : _a.evaluate(item,)) ?? null;
-    for (
-      const {
-        whenExpression,
-        thenExpression,
-      } of this.conditions
-    ) {
+    for (const { whenExpression, thenExpression, } of this.conditions) {
       const when = whenExpression.evaluate(item,);
       const isMatching = this.valueExpression ? DatabaseValue.equal(when, value, this.collation,) : convertToBoolean(when,);
       if (isMatching) return thenExpression.evaluate(item,);
@@ -32138,16 +24594,12 @@ var ScalarCase = class extends ScalarExpression {
   }
   canEvaluate() {
     const expressions = [];
-    if (this.valueExpression) {
-      expressions.push(this.valueExpression,);
-    }
+    if (this.valueExpression) expressions.push(this.valueExpression,);
     for (const condition of this.conditions) {
       expressions.push(condition.whenExpression,);
       expressions.push(condition.thenExpression,);
     }
-    if (this.elseExpression) {
-      expressions.push(this.elseExpression,);
-    }
+    if (this.elseExpression) expressions.push(this.elseExpression,);
     return expressions.every((expression) => {
       return expression.canEvaluate();
     },);
@@ -32178,20 +24630,14 @@ var ScalarUnaryOperationNot = class extends ScalarUnaryOperation {
     __publicField(this, 'definition', ScalarUnaryOperationNot.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return `NOT ${this.valueExpression.stringify()}`;
   }
   evaluate(item,) {
     const value = this.valueExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: !convertToBoolean(value,),
-    };
+    return { type: 'boolean', value: !convertToBoolean(value,), };
   }
 };
 var ScalarLogicalOperation = class extends ScalarExpression {
@@ -32201,10 +24647,7 @@ var ScalarLogicalOperation = class extends ScalarExpression {
     __publicField(this, 'definition', ScalarLogicalOperation.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return this.operandExpressions.map((expression) => expression.stringify()).join(' AND ',);
@@ -32229,10 +24672,7 @@ var ScalarLogicalOperationAnd = class extends ScalarLogicalOperation {
       const value = expression.evaluate(item,);
       return convertToBoolean(value,);
     },);
-    return {
-      type: 'boolean',
-      value: result,
-    };
+    return { type: 'boolean', value: result, };
   }
 };
 var ScalarLogicalOperationOr = class extends ScalarLogicalOperation {
@@ -32245,10 +24685,7 @@ var ScalarLogicalOperationOr = class extends ScalarLogicalOperation {
       const value = expression.evaluate(item,);
       return convertToBoolean(value,);
     },);
-    return {
-      type: 'boolean',
-      value: result,
-    };
+    return { type: 'boolean', value: result, };
   }
 };
 var ScalarComparison = class extends ScalarExpression {
@@ -32257,16 +24694,10 @@ var ScalarComparison = class extends ScalarExpression {
     this.leftExpression = leftExpression;
     this.rightExpression = rightExpression;
     __publicField(this, 'definition', ScalarComparison.getDefinition(),);
-    __publicField(this, 'collation', {
-      type: 0,
-      /* CaseInsensitive */
-    },);
+    __publicField(this, 'collation', { type: 0, /* CaseInsensitive */ },);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   stringify() {
     return `${this.leftExpression.stringify()} ${this.operator} ${this.rightExpression.stringify()}`;
@@ -32287,10 +24718,7 @@ var ScalarComparisonEquals = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: DatabaseValue.equal(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: DatabaseValue.equal(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarComparisonNotEquals = class extends ScalarComparison {
@@ -32301,10 +24729,7 @@ var ScalarComparisonNotEquals = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: !DatabaseValue.equal(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: !DatabaseValue.equal(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarComparisonLessThan = class extends ScalarComparison {
@@ -32315,10 +24740,7 @@ var ScalarComparisonLessThan = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: DatabaseValue.lessThan(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: DatabaseValue.lessThan(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarComparisonLessThanOrEqual = class extends ScalarComparison {
@@ -32329,10 +24751,7 @@ var ScalarComparisonLessThanOrEqual = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: DatabaseValue.lessThanOrEqual(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: DatabaseValue.lessThanOrEqual(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarComparisonGreaterThan = class extends ScalarComparison {
@@ -32343,10 +24762,7 @@ var ScalarComparisonGreaterThan = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: DatabaseValue.greaterThan(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: DatabaseValue.greaterThan(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarComparisonGreaterThanOrEqual = class extends ScalarComparison {
@@ -32357,10 +24773,7 @@ var ScalarComparisonGreaterThanOrEqual = class extends ScalarComparison {
   evaluate(item,) {
     const leftValue = this.leftExpression.evaluate(item,);
     const rightValue = this.rightExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: DatabaseValue.greaterThanOrEqual(leftValue, rightValue, this.collation,),
-    };
+    return { type: 'boolean', value: DatabaseValue.greaterThanOrEqual(leftValue, rightValue, this.collation,), };
   }
 };
 var ScalarTypeCast = class extends ScalarExpression {
@@ -32386,17 +24799,11 @@ var ScalarTypeCastBoolean = class extends ScalarTypeCast {
     __publicField(this, 'definition', ScalarTypeCastBoolean.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'boolean',
-      isNullable: false,
-    };
+    return { type: 'boolean', isNullable: false, };
   }
   evaluate(item,) {
     const value = this.valueExpression.evaluate(item,);
-    return {
-      type: 'boolean',
-      value: convertToBoolean(value,),
-    };
+    return { type: 'boolean', value: convertToBoolean(value,), };
   }
 };
 function convertToBoolean(value,) {
@@ -32416,21 +24823,13 @@ var ScalarTypeCastDate = class extends ScalarTypeCast {
     __publicField(this, 'definition', ScalarTypeCastDate.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'date',
-      isNullable: true,
-    };
+    return { type: 'date', isNullable: true, };
   }
   evaluate(item,) {
     const value = this.valueExpression.evaluate(item,);
     const date = convertToDate(value,);
-    if (isNull(date,)) {
-      return null;
-    }
-    return {
-      type: 'date',
-      value: date.toISOString(),
-    };
+    if (isNull(date,)) return null;
+    return { type: 'date', value: date.toISOString(), };
   }
 };
 function convertToDate(value,) {
@@ -32439,9 +24838,7 @@ function convertToDate(value,) {
     case 'number':
     case 'string': {
       const date = new Date(value.value,);
-      if (isValidDate(date,)) {
-        return date;
-      }
+      if (isValidDate(date,)) return date;
       return null;
     }
   }
@@ -32454,21 +24851,13 @@ var ScalarTypeCastNumber = class extends ScalarTypeCast {
     __publicField(this, 'definition', ScalarTypeCastNumber.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'number',
-      isNullable: true,
-    };
+    return { type: 'number', isNullable: true, };
   }
   evaluate(item,) {
     const value = this.valueExpression.evaluate(item,);
     const number2 = convertToNumber(value,);
-    if (isNull(number2,)) {
-      return null;
-    }
-    return {
-      type: 'number',
-      value: number2,
-    };
+    if (isNull(number2,)) return null;
+    return { type: 'number', value: number2, };
   }
 };
 function convertToNumber(value,) {
@@ -32476,9 +24865,7 @@ function convertToNumber(value,) {
     case 'number':
     case 'string': {
       const number2 = Number(value.value,);
-      if (Number.isFinite(number2,)) {
-        return number2;
-      }
+      if (Number.isFinite(number2,)) return number2;
       return null;
     }
   }
@@ -32491,21 +24878,13 @@ var ScalarTypeCastString = class extends ScalarTypeCast {
     __publicField(this, 'definition', ScalarTypeCastString.getDefinition(),);
   }
   static getDefinition() {
-    return {
-      type: 'string',
-      isNullable: true,
-    };
+    return { type: 'string', isNullable: true, };
   }
   evaluate(item,) {
     const value = this.valueExpression.evaluate(item,);
     const string = convertToString(value,);
-    if (isNull(string,)) {
-      return null;
-    }
-    return {
-      type: 'string',
-      value: string,
-    };
+    if (isNull(string,)) return null;
+    return { type: 'string', value: string, };
   }
 };
 function convertToString(value,) {
@@ -32579,18 +24958,10 @@ function convertLiteralValue(expression, typeAffinity,) {
   return scalarExpression;
 }
 function getScalarLiteralValue(value,) {
-  if (isBoolean(value,)) {
-    return ScalarLiteralValue.fromBoolean(value,);
-  }
-  if (isValidDate(value,)) {
-    return ScalarLiteralValue.fromDate(value,);
-  }
-  if (isNumber2(value,)) {
-    return ScalarLiteralValue.fromNumber(value,);
-  }
-  if (isString22(value,)) {
-    return ScalarLiteralValue.fromString(value,);
-  }
+  if (isBoolean(value,)) return ScalarLiteralValue.fromBoolean(value,);
+  if (isValidDate(value,)) return ScalarLiteralValue.fromDate(value,);
+  if (isNumber2(value,)) return ScalarLiteralValue.fromNumber(value,);
+  if (isString22(value,)) return ScalarLiteralValue.fromString(value,);
   return ScalarLiteralValue.fromNull();
 }
 function convertFunctionCall(expression, schema,) {
@@ -32632,64 +25003,40 @@ function getScalarUnaryOperationNot(valueExpression,) {
   var _a;
   if (valueExpression instanceof ScalarUnaryOperationNot) {
     const innerExpression = valueExpression.valueExpression;
-    if (((_a = innerExpression.definition) == null ? void 0 : _a.type) === 'boolean') {
-      return innerExpression;
-    }
+    if (((_a = innerExpression.definition) == null ? void 0 : _a.type) === 'boolean') return innerExpression;
     return new ScalarTypeCastBoolean(innerExpression,);
   }
   if (valueExpression instanceof ScalarComparisonEquals) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonNotEquals(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarComparisonNotEquals) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonEquals(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarComparisonLessThan) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarComparisonLessThanOrEqual) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonGreaterThan(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarComparisonGreaterThan) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonLessThanOrEqual(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarComparisonGreaterThanOrEqual) {
-    const {
-      leftExpression,
-      rightExpression,
-    } = valueExpression;
+    const { leftExpression, rightExpression, } = valueExpression;
     return new ScalarComparisonLessThan(leftExpression, rightExpression,);
   }
   if (valueExpression instanceof ScalarLogicalOperationAnd) {
-    const {
-      operandExpressions,
-    } = valueExpression;
+    const { operandExpressions, } = valueExpression;
     const notExpressions = operandExpressions.map(getScalarUnaryOperationNot,);
     return new ScalarLogicalOperationOr(notExpressions,);
   }
   if (valueExpression instanceof ScalarLogicalOperationAnd) {
-    const {
-      operandExpressions,
-    } = valueExpression;
+    const { operandExpressions, } = valueExpression;
     const notExpressions = operandExpressions.map(getScalarUnaryOperationNot,);
     return new ScalarLogicalOperationAnd(notExpressions,);
   }
@@ -32724,78 +25071,54 @@ function convertBinaryOperation(expression, schema,) {
 }
 function getScalarLogicalOperationAnd(leftExpression, rightExpression,) {
   const operandExpressions = [];
-  if (leftExpression instanceof ScalarLogicalOperationAnd) {
-    operandExpressions.push(...leftExpression.operandExpressions,);
-  } else {
-    operandExpressions.push(leftExpression,);
-  }
-  if (rightExpression instanceof ScalarLogicalOperationAnd) {
-    operandExpressions.push(...rightExpression.operandExpressions,);
-  } else {
-    operandExpressions.push(rightExpression,);
-  }
+  if (leftExpression instanceof ScalarLogicalOperationAnd) operandExpressions.push(...leftExpression.operandExpressions,);
+  else operandExpressions.push(leftExpression,);
+  if (rightExpression instanceof ScalarLogicalOperationAnd) operandExpressions.push(...rightExpression.operandExpressions,);
+  else operandExpressions.push(rightExpression,);
   return new ScalarLogicalOperationAnd(operandExpressions,);
 }
 function getScalarLogicalOperationOr(leftExpression, rightExpression,) {
   const operandExpressions = [];
-  if (leftExpression instanceof ScalarLogicalOperationOr) {
-    operandExpressions.push(...leftExpression.operandExpressions,);
-  } else {
-    operandExpressions.push(leftExpression,);
-  }
-  if (rightExpression instanceof ScalarLogicalOperationOr) {
-    operandExpressions.push(...rightExpression.operandExpressions,);
-  } else {
-    operandExpressions.push(rightExpression,);
-  }
+  if (leftExpression instanceof ScalarLogicalOperationOr) operandExpressions.push(...leftExpression.operandExpressions,);
+  else operandExpressions.push(leftExpression,);
+  if (rightExpression instanceof ScalarLogicalOperationOr) operandExpressions.push(...rightExpression.operandExpressions,);
+  else operandExpressions.push(rightExpression,);
   return new ScalarLogicalOperationOr(operandExpressions,);
 }
 function getScalarComparisonEquals(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonEquals(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonEquals(rightExpression, leftExpression,);
   return new ScalarComparisonEquals(leftExpression, rightExpression,);
 }
 function getScalarComparisonNotEquals(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonNotEquals(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonNotEquals(rightExpression, leftExpression,);
   return new ScalarComparisonNotEquals(leftExpression, rightExpression,);
 }
 function getScalarComparisonLessThan(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonGreaterThan(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonGreaterThan(rightExpression, leftExpression,);
   return new ScalarComparisonLessThan(leftExpression, rightExpression,);
 }
 function getScalarComparisonLessThanOrEqual(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonGreaterThanOrEqual(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonGreaterThanOrEqual(rightExpression, leftExpression,);
   return new ScalarComparisonLessThanOrEqual(leftExpression, rightExpression,);
 }
 function getScalarComparisonGreaterThan(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonLessThan(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonLessThan(rightExpression, leftExpression,);
   return new ScalarComparisonGreaterThan(leftExpression, rightExpression,);
 }
 function getScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,) {
   const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
   const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
-  if (isRightIdentifier && !isLeftIdentifier) {
-    return new ScalarComparisonLessThanOrEqual(rightExpression, leftExpression,);
-  }
+  if (isRightIdentifier && !isLeftIdentifier) return new ScalarComparisonLessThanOrEqual(rightExpression, leftExpression,);
   return new ScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,);
 }
 function convertTypeCast(expression, schema,) {
@@ -32815,30 +25138,22 @@ function convertTypeCast(expression, schema,) {
 }
 function getScalarTypeCastBoolean(valueExpression,) {
   var _a;
-  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'boolean') {
-    return valueExpression;
-  }
+  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'boolean') return valueExpression;
   return new ScalarTypeCastBoolean(valueExpression,);
 }
 function getScalarTypeCastDate(valueExpression,) {
   var _a;
-  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'date') {
-    return valueExpression;
-  }
+  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'date') return valueExpression;
   return new ScalarTypeCastDate(valueExpression,);
 }
 function getScalarTypeCastNumber(valueExpression,) {
   var _a;
-  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'number') {
-    return valueExpression;
-  }
+  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'number') return valueExpression;
   return new ScalarTypeCastNumber(valueExpression,);
 }
 function getScalarTypeCastString(valueExpression,) {
   var _a;
-  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'string') {
-    return valueExpression;
-  }
+  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'string') return valueExpression;
   return new ScalarTypeCastString(valueExpression,);
 }
 function getExpressionType(expression, schema,) {
@@ -32951,9 +25266,7 @@ var ScanCollectionPlan = class extends QueryPlan {
     this.collection = collection;
   }
   inspect() {
-    return {
-      label: `ScanCollectionPlan ${stringifyExecutionTime(this.executionTime,)} ${stringifyItems(this.itemCount,)}`,
-    };
+    return { label: `ScanCollectionPlan ${stringifyExecutionTime(this.executionTime,)} ${stringifyItems(this.itemCount,)}`, };
   }
   async _execute() {
     return this.collection.scanItems();
@@ -33020,11 +25333,8 @@ var UnionPlan = class extends QueryPlan {
     },),);
     let result;
     for (const itemMap of childItemMaps) {
-      if (result) {
-        result = result.union(itemMap,);
-      } else {
-        result = itemMap;
-      }
+      if (result) result = result.union(itemMap,);
+      else result = itemMap;
     }
     return (result == null ? void 0 : result.items()) ?? [];
   }
@@ -33050,11 +25360,8 @@ var IntersectionPlan = class extends QueryPlan {
     },),);
     let result;
     for (const itemMap of childItemMaps) {
-      if (result) {
-        result = result.intersection(itemMap,);
-      } else {
-        result = itemMap;
-      }
+      if (result) result = result.intersection(itemMap,);
+      else result = itemMap;
     }
     return (result == null ? void 0 : result.items()) ?? [];
   }
@@ -33131,13 +25438,7 @@ var SortItemsPlan = class extends QueryPlan {
   async _execute() {
     const childItems = await this.childPlan.execute();
     return childItems.sort((leftItem, rightItem,) => {
-      for (
-        const {
-          expression,
-          direction,
-          collation,
-        } of this.orderExpressions
-      ) {
+      for (const { expression, direction, collation, } of this.orderExpressions) {
         const isAscending = direction === 'asc';
         if (expression instanceof ScalarIdentifier && expression.name === INDEX_IDENTIFIER) {
           const order = this.collection.compareItems(leftItem, rightItem,);
@@ -33145,15 +25446,9 @@ var SortItemsPlan = class extends QueryPlan {
         }
         const left = expression.evaluate(leftItem,);
         const right = expression.evaluate(rightItem,);
-        if (DatabaseValue.equal(left, right, collation,)) {
-          continue;
-        }
-        if (DatabaseValue.lessThan(left, right, collation,) || isNullish(left,)) {
-          return isAscending ? -1 : 1;
-        }
-        if (DatabaseValue.greaterThan(left, right, collation,) || isNullish(right,)) {
-          return isAscending ? 1 : -1;
-        }
+        if (DatabaseValue.equal(left, right, collation,)) continue;
+        if (DatabaseValue.lessThan(left, right, collation,) || isNullish(left,)) return isAscending ? -1 : 1;
+        if (DatabaseValue.greaterThan(left, right, collation,) || isNullish(right,)) return isAscending ? 1 : -1;
         throw new Error('Invalid comparison result.',);
       }
       return this.collection.compareItems(leftItem, rightItem,);
@@ -33207,27 +25502,17 @@ var SliceItemsPlan = class extends QueryPlan {
 var DatabaseItemMap = class extends Map {
   constructor(items = [],) {
     super();
-    for (const item of items) {
-      this.set(item.pointer, item,);
-    }
+    for (const item of items) this.set(item.pointer, item,);
   }
   union(other,) {
     const result = new DatabaseItemMap();
-    for (const [pointer, item,] of this) {
-      result.set(pointer, item,);
-    }
-    for (const [pointer, item,] of other) {
-      result.set(pointer, item,);
-    }
+    for (const [pointer, item,] of this) result.set(pointer, item,);
+    for (const [pointer, item,] of other) result.set(pointer, item,);
     return result;
   }
   intersection(other,) {
     const result = new DatabaseItemMap();
-    for (const [pointer, item,] of this) {
-      if (other.has(pointer,)) {
-        result.set(pointer, item,);
-      }
-    }
+    for (const [pointer, item,] of this) if (other.has(pointer,)) result.set(pointer, item,);
     return result;
   }
   items() {
@@ -33258,9 +25543,7 @@ function stringifyIdentifier(data2, expression,) {
   return `"${expression.name}"`;
 }
 function stringifyLiteralValue(expression,) {
-  if (typeof expression.value === 'string') {
-    return `'${expression.value}'`;
-  }
+  if (typeof expression.value === 'string') return `'${expression.value}'`;
   return expression.value;
 }
 function stringifyFunctionCall(data2, expression,) {
@@ -33268,15 +25551,11 @@ function stringifyFunctionCall(data2, expression,) {
 }
 function stringifyCaseExpression(data2, expression,) {
   let caseString = 'CASE';
-  if (expression.value) {
-    caseString += ` ${stringifyExpression(data2, expression.value,)}`;
-  }
+  if (expression.value) caseString += ` ${stringifyExpression(data2, expression.value,)}`;
   for (const condition of expression.conditions) {
     caseString += ` WHEN ${stringifyExpression(data2, condition.when,)} THEN ${stringifyExpression(data2, condition.then,)}`;
   }
-  if (expression.else) {
-    caseString += ` ELSE ${expression.else}`;
-  }
+  if (expression.else) caseString += ` ELSE ${expression.else}`;
   caseString += ' END';
   return caseString;
 }
@@ -33326,9 +25605,7 @@ ${token}`;
     } else if (['AND', 'OR',].includes(token,)) {
       formattedSql += `
 	${token}`;
-    } else {
-      formattedSql += ` ${token}`;
-    }
+    } else formattedSql += ` ${token}`;
   },);
   return formattedSql.trim();
 }
@@ -33337,20 +25614,13 @@ function stringifyQuery(query,) {
   queryString += `SELECT ${
     query.select.map((selectExpression) => {
       const expressionString = stringifyExpression(query.from.data, selectExpression,);
-      if (selectExpression.alias) {
-        return `${expressionString} AS ${selectExpression.alias}`;
-      }
+      if (selectExpression.alias) return `${expressionString} AS ${selectExpression.alias}`;
       return expressionString;
     },).join(', ',)
   }`;
-  if (isLocalizedDatabaseCollection(query.from.data,)) {
-    queryString += ` FROM ${query.from.data.displayName}`;
-  } else {
-    queryString += ` FROM ${query.from.data.displayName}`;
-  }
-  if (query.where) {
-    queryString += ` WHERE ${stringifyExpression(query.from.data, query.where,)}`;
-  }
+  if (isLocalizedDatabaseCollection(query.from.data,)) queryString += ` FROM ${query.from.data.displayName}`;
+  else queryString += ` FROM ${query.from.data.displayName}`;
+  if (query.where) queryString += ` WHERE ${stringifyExpression(query.from.data, query.where,)}`;
   if (query.orderBy) {
     queryString += ` ORDER BY ${
       query.orderBy.map((orderExpression) => {
@@ -33358,24 +25628,14 @@ function stringifyQuery(query,) {
       },).join(', ',)
     }`;
   }
-  if (query.limit) {
-    queryString += ` LIMIT ${stringifyExpression(query.from.data, query.limit,)}`;
-  }
-  if (query.offset) {
-    queryString += ` OFFSET ${stringifyExpression(query.from.data, query.offset,)}`;
-  }
+  if (query.limit) queryString += ` LIMIT ${stringifyExpression(query.from.data, query.limit,)}`;
+  if (query.offset) queryString += ` OFFSET ${stringifyExpression(query.from.data, query.offset,)}`;
   return autoIndentSql(queryString,);
 }
 var log = getLogger('query-engine',);
-function getDatabaseCollection({
-  data: data2,
-}, locale,) {
-  if (isAnyLegacyCollection(data2,)) {
-    return new CompatibilityDatabaseCollection(data2, locale,);
-  }
-  if (isDatabaseCollection(data2,)) {
-    return data2;
-  }
+function getDatabaseCollection({ data: data2, }, locale,) {
+  if (isAnyLegacyCollection(data2,)) return new CompatibilityDatabaseCollection(data2, locale,);
+  if (isDatabaseCollection(data2,)) return data2;
   if (isLocalizedDatabaseCollection(data2,)) {
     while (locale) {
       const collection = data2.collectionByLocaleId[locale.id];
@@ -33409,25 +25669,16 @@ ${(0, import_archy.default)(plan.inspect(),)}`,);
       ? void 0
       : _a.map((expression) =>
         new ScalarOrderExpression(ScalarExpression.from(expression, collection.schema,), expression.direction ?? 'asc', {
-          type: 0,
-          /* CaseInsensitive */
+          type: 0, /* CaseInsensitive */
         },)
       );
     plan = new SortItemsPlan(plan, sortExpressions ?? [], collection,);
     let offsetExpression;
-    if (query.offset) {
-      offsetExpression = ScalarExpression.from(query.offset, collection.schema,);
-    }
+    if (query.offset) offsetExpression = ScalarExpression.from(query.offset, collection.schema,);
     let limitExpression;
-    if (query.limit) {
-      limitExpression = ScalarExpression.from(query.limit, collection.schema,);
-    }
-    if (offsetExpression || limitExpression) {
-      plan = new SliceItemsPlan(plan, offsetExpression, limitExpression,);
-    }
-    if (query.select.length > 0) {
-      plan = new ResolveItemsPlan(plan, collection, richTextResolver, query.select,);
-    }
+    if (query.limit) limitExpression = ScalarExpression.from(query.limit, collection.schema,);
+    if (offsetExpression || limitExpression) plan = new SliceItemsPlan(plan, offsetExpression, limitExpression,);
+    if (query.select.length > 0) plan = new ResolveItemsPlan(plan, collection, richTextResolver, query.select,);
     return plan;
   }
   async executeQueryPlan(collection, richTextResolver, query, plan,) {
@@ -33445,21 +25696,13 @@ ${(0, import_archy.default)(plan.inspect(),)}`,);
   }
 };
 function getSelectKey(expression,) {
-  if (expression.alias) {
-    return expression.alias;
-  }
-  if (expression.type === 'Identifier') {
-    return expression.name;
-  }
+  if (expression.alias) return expression.alias;
+  if (expression.type === 'Identifier') return expression.name;
   throw new Error('Can\'t serialize expression',);
 }
 async function resolveValue(richTextResolver, value,) {
-  if (isNullish(value,)) {
-    return null;
-  }
-  if (value.type === 'richtext') {
-    return richTextResolver.resolve(value.value,);
-  }
+  if (isNullish(value,)) return null;
+  if (value.type === 'richtext') return richTextResolver.resolve(value.value,);
   return value.value;
 }
 function createPlanForWhereClause(collection, expression,) {
@@ -33475,12 +25718,8 @@ function createPlanForWhereClause(collection, expression,) {
 }
 function findLookupIndexPlan(collection, expression,) {
   var _a, _b;
-  if (expression instanceof ScalarComparison) {
-    return findLookupIndexPlanForComparison(collection, expression,);
-  }
-  if (expression instanceof ScalarFunctionCall) {
-    return findLookupIndexPlanForFunctionCall(collection, expression,);
-  }
+  if (expression instanceof ScalarComparison) return findLookupIndexPlanForComparison(collection, expression,);
+  if (expression instanceof ScalarFunctionCall) return findLookupIndexPlanForFunctionCall(collection, expression,);
   if (expression instanceof ScalarIdentifier && ((_a = expression.definition) == null ? void 0 : _a.type) === 'boolean') {
     const value = ScalarLiteralValue.fromBoolean(true,);
     const comparison = new ScalarComparisonEquals(expression, value,);
@@ -33504,67 +25743,33 @@ function findLookupIndexPlanForComparison(collection, expression,) {
     if (isUndefined(field,)) continue;
     const fieldExpression = ScalarExpression.from(field, collection.schema,);
     if (!leftExpression.equals(fieldExpression,)) continue;
-    const fillerAllQueries = new Array(index.fields.length - 1,).fill({
-      type: 'All',
-      /* All */
-    },);
-    if (
-      expression instanceof ScalarComparisonEquals && index.supportedLookupTypes.includes('Equals',/* Equals */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'Equals',
-        value: rightExpression.evaluate(),
-      }, ...fillerAllQueries,],);
+    const fillerAllQueries = new Array(index.fields.length - 1,).fill({ type: 'All', /* All */ },);
+    if (expression instanceof ScalarComparisonEquals && index.supportedLookupTypes.includes('Equals', /* Equals */)) {
+      return new LookupIndexPlan(index, [{ type: 'Equals', value: rightExpression.evaluate(), }, ...fillerAllQueries,],);
     }
-    if (
-      expression instanceof ScalarComparisonNotEquals && index.supportedLookupTypes.includes('NotEquals',/* NotEquals */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'NotEquals',
-        value: rightExpression.evaluate(),
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarComparisonNotEquals && index.supportedLookupTypes.includes('NotEquals', /* NotEquals */)) {
+      return new LookupIndexPlan(index, [{ type: 'NotEquals', value: rightExpression.evaluate(), }, ...fillerAllQueries,],);
     }
-    if (
-      expression instanceof ScalarComparisonLessThan && index.supportedLookupTypes.includes('LessThan',/* LessThan */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'LessThan',
-        value: rightExpression.evaluate(),
-        inclusive: false,
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarComparisonLessThan && index.supportedLookupTypes.includes('LessThan', /* LessThan */)) {
+      return new LookupIndexPlan(index, [
+        { type: 'LessThan', value: rightExpression.evaluate(), inclusive: false, },
+        ...fillerAllQueries,
+      ],);
     }
-    if (
-      expression instanceof ScalarComparisonLessThanOrEqual && index.supportedLookupTypes.includes('LessThan',/* LessThan */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'LessThan',
-        value: rightExpression.evaluate(),
-        inclusive: true,
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarComparisonLessThanOrEqual && index.supportedLookupTypes.includes('LessThan', /* LessThan */)) {
+      return new LookupIndexPlan(index, [{ type: 'LessThan', value: rightExpression.evaluate(), inclusive: true, }, ...fillerAllQueries,],);
     }
-    if (
-      expression instanceof ScalarComparisonGreaterThan && index.supportedLookupTypes.includes('GreaterThan',/* GreaterThan */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'GreaterThan',
-        value: rightExpression.evaluate(),
-        inclusive: false,
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarComparisonGreaterThan && index.supportedLookupTypes.includes('GreaterThan', /* GreaterThan */)) {
+      return new LookupIndexPlan(index, [
+        { type: 'GreaterThan', value: rightExpression.evaluate(), inclusive: false, },
+        ...fillerAllQueries,
+      ],);
     }
-    if (
-      expression instanceof ScalarComparisonGreaterThanOrEqual && index.supportedLookupTypes.includes('GreaterThan',/* GreaterThan */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'GreaterThan',
-        value: rightExpression.evaluate(),
-        inclusive: true,
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarComparisonGreaterThanOrEqual && index.supportedLookupTypes.includes('GreaterThan', /* GreaterThan */)) {
+      return new LookupIndexPlan(index, [
+        { type: 'GreaterThan', value: rightExpression.evaluate(), inclusive: true, },
+        ...fillerAllQueries,
+      ],);
     }
   }
 }
@@ -33580,36 +25785,15 @@ function findLookupIndexPlanForFunctionCall(collection, expression,) {
     if (isUndefined(field,)) continue;
     const fieldExpression = ScalarExpression.from(field, collection.schema,);
     if (!sourceExpression.equals(fieldExpression,)) continue;
-    const fillerAllQueries = new Array(index.fields.length - 1,).fill({
-      type: 'All',
-      /* All */
-    },);
-    if (
-      expression instanceof ScalarFunctionCallContains && index.supportedLookupTypes.includes('Contains',/* Contains */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'Contains',
-        value: targetExpression.evaluate(),
-      }, ...fillerAllQueries,],);
+    const fillerAllQueries = new Array(index.fields.length - 1,).fill({ type: 'All', /* All */ },);
+    if (expression instanceof ScalarFunctionCallContains && index.supportedLookupTypes.includes('Contains', /* Contains */)) {
+      return new LookupIndexPlan(index, [{ type: 'Contains', value: targetExpression.evaluate(), }, ...fillerAllQueries,],);
     }
-    if (
-      expression instanceof ScalarFunctionCallStartsWith && index.supportedLookupTypes.includes('StartsWith',/* StartsWith */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'StartsWith',
-        value: targetExpression.evaluate(),
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarFunctionCallStartsWith && index.supportedLookupTypes.includes('StartsWith', /* StartsWith */)) {
+      return new LookupIndexPlan(index, [{ type: 'StartsWith', value: targetExpression.evaluate(), }, ...fillerAllQueries,],);
     }
-    if (
-      expression instanceof ScalarFunctionCallEndsWith && index.supportedLookupTypes.includes('EndsWith',/* EndsWith */
-      )
-    ) {
-      return new LookupIndexPlan(index, [{
-        type: 'EndsWith',
-        value: targetExpression.evaluate(),
-      }, ...fillerAllQueries,],);
+    if (expression instanceof ScalarFunctionCallEndsWith && index.supportedLookupTypes.includes('EndsWith', /* EndsWith */)) {
+      return new LookupIndexPlan(index, [{ type: 'EndsWith', value: targetExpression.evaluate(), }, ...fillerAllQueries,],);
     }
   }
 }
@@ -33626,13 +25810,8 @@ var AnimationCollector = class {
     switch (prop) {
       case 'transformTemplate': {
         assert(typeof value === 'string', `transformTemplate must be a string, received: ${value}`,);
-        if (nodeEntry) {
-          nodeEntry.transformTemplate = value;
-        } else {
-          this.entries.set(nodeId, {
-            transformTemplate: value,
-          },);
-        }
+        if (nodeEntry) nodeEntry.transformTemplate = value;
+        else this.entries.set(nodeId, { transformTemplate: value, },);
         break;
       }
       case 'initial':
@@ -33640,15 +25819,8 @@ var AnimationCollector = class {
         assert(typeof value === 'object', `${prop} must be a valid object, received: ${value}`,);
         if (nodeEntry) {
           nodeEntry[prop] = value;
-          if (!nodeEntry.variantHash) {
-            nodeEntry.variantHash = variantHash;
-          }
-        } else {
-          this.entries.set(nodeId, {
-            [prop]: value,
-            variantHash,
-          },);
-        }
+          if (!nodeEntry.variantHash) nodeEntry.variantHash = variantHash;
+        } else this.entries.set(nodeId, { [prop]: value, variantHash, },);
         break;
       }
       default:
@@ -33664,9 +25836,7 @@ var AnimationCollector = class {
 };
 var framerAppearEffects = /* @__PURE__ */ new AnimationCollector();
 var optimizeAppear = (prop, id3, animateTargetAndTransition, variantHash,) => {
-  if (!isBrowser2()) {
-    framerAppearEffects.set(id3, prop, animateTargetAndTransition, variantHash,);
-  }
+  if (!isBrowser2()) framerAppearEffects.set(id3, prop, animateTargetAndTransition, variantHash,);
   return animateTargetAndTransition;
 };
 var framerAppearTransformTemplateToken = '__Appear_Animation_Transform__';
@@ -33704,14 +25874,12 @@ function useActiveVariantCallback(baseVariant,) {
   return React__default.useRef({
     /**
      * Create a callback that can be cancelled if the base variant changes.
-     */
-    activeVariantCallback: (callback) => (...args) => {
+     */ activeVariantCallback: (callback) => (...args) => {
       return new Promise((resolve, reject,) => {
         pendingPromises.add(reject,);
         callback(...args,).then(resolve,);
       },).catch(() => {},);
-    },
-    /**
+    }, /**
      * Execute a callback after a defined period of time. The callback will not
      * be called if pending events are cancelled because the timeout will be
      * cancelled.
@@ -33724,10 +25892,7 @@ function useActiveVariantCallback(baseVariant,) {
 }
 function useActiveTargetCallback() {
   const value = useActiveVariantCallback(void 0,);
-  return React__default.useRef({
-    activeTargetCallback: value.activeVariantCallback,
-    delay: value.delay,
-  },).current;
+  return React__default.useRef({ activeTargetCallback: value.activeVariantCallback, delay: value.delay, },).current;
 }
 function useAddVariantProps(baseVariant, gestureVariant, variantProps2,) {
   return React__default.useCallback((id3) => {
@@ -33747,10 +25912,7 @@ function useAddVariantProps(baseVariant, gestureVariant, variantProps2,) {
 function createMediaQueriesFromBreakpoints(breakpoints,) {
   const mediaQueries = {};
   for (const [variant, query,] of Object.entries(breakpoints,)) {
-    const {
-      min = 0,
-      max,
-    } = query;
+    const { min = 0, max, } = query;
     const mediaQuery = [];
     if (min) mediaQuery.push(`(min-width: ${min}px)`,);
     if (max) mediaQuery.push(`(max-width: ${max}px)`,);
@@ -33799,18 +25961,12 @@ function useHydratedBreakpointVariants(initial, mediaQueries, hydratedWithInitia
   return [baseVariant.current, basePropsVariant.current,];
 }
 function addMQLCallback(mql, callback,) {
-  if (mql.addEventListener) {
-    mql.addEventListener('change', callback,);
-  } else {
-    mql.addListener(callback,);
-  }
+  if (mql.addEventListener) mql.addEventListener('change', callback,);
+  else mql.addListener(callback,);
 }
 function removeMQLCallback(mql, callback,) {
-  if (mql.removeEventListener) {
-    mql.removeEventListener('change', callback,);
-  } else {
-    mql.removeListener(callback,);
-  }
+  if (mql.removeEventListener) mql.removeEventListener('change', callback,);
+  else mql.removeListener(callback,);
 }
 function useBreakpointVariants(initial, _width, breakpoints,) {
   const mediaQueries = useConstant2(() => createMediaQueriesFromBreakpoints(breakpoints,));
@@ -33820,18 +25976,12 @@ function useBreakpointVariants(initial, _width, breakpoints,) {
 function removeHiddenBreakpointLayers(_initial, _mediaQueries, _variantClassNames,) {}
 function useDataRecord(collection, variables,) {
   return useMemo(() => {
-    if (!Array.isArray(collection,)) {
-      return null;
-    }
-    if (!variables) {
-      return null;
-    }
+    if (!Array.isArray(collection,)) return null;
+    if (!variables) return null;
     const pageRecord = collection.find((record2) => {
       return Object.entries(variables,).every(([key7, value,],) => {
         const recordValue = record2[key7];
-        if (value === void 0 || recordValue === void 0 || isObject2(value,) || isObject2(recordValue,)) {
-          return false;
-        }
+        if (value === void 0 || recordValue === void 0 || isObject2(value,) || isObject2(recordValue,)) return false;
         return String(value,) === String(recordValue,);
       },);
     },);
@@ -33864,23 +26014,9 @@ function createGamepadPoller() {
   const startPolling = () => {
     const input = getGamepadInputs();
     if (!input) return;
-    const {
-      gamepad,
-      inputs,
-    } = input;
-    const {
-      mapping,
-      id: id3,
-    } = gamepad;
-    if (gamepadInputsHaveChanged(lastKeys, inputs,)) {
-      handlers.forEach((handler) =>
-        handler({
-          inputs,
-          mapping,
-          id: id3,
-        },)
-      );
-    }
+    const { gamepad, inputs, } = input;
+    const { mapping, id: id3, } = gamepad;
+    if (gamepadInputsHaveChanged(lastKeys, inputs,)) handlers.forEach((handler) => handler({ inputs, mapping, id: id3, },));
     lastKeys = inputs;
     isPolling = safeWindow.requestAnimationFrame(startPolling,);
   };
@@ -33936,19 +26072,9 @@ function getGamepadInputs() {
     if (!gamepad) continue;
     if (!firstConnectedGamepad) firstConnectedGamepad = gamepad;
     const inputs = [...scanPressedAxis(gamepad,), ...scanPressedButtons(gamepad,),];
-    if (inputs.length > 0) {
-      return {
-        gamepad,
-        inputs,
-      };
-    }
-  }
-  if (firstConnectedGamepad) {
-    return {
-      gamepad: firstConnectedGamepad,
-      inputs: [],
-    };
+    if (inputs.length > 0) return { gamepad, inputs, };
   }
+  if (firstConnectedGamepad) return { gamepad: firstConnectedGamepad, inputs: [], };
   return null;
 }
 function scanPressedAxis(gamepad,) {
@@ -33962,32 +26088,18 @@ function scanPressedAxis(gamepad,) {
 }
 function scanPressedButtons(gamepad,) {
   const buttons = [];
-  for (const [idx, button,] of gamepad.buttons.entries()) {
-    if (isButtonPressed(button,)) buttons.push(`Button ${idx}`,);
-  }
+  for (const [idx, button,] of gamepad.buttons.entries()) if (isButtonPressed(button,)) buttons.push(`Button ${idx}`,);
   return buttons;
 }
 function isButtonPressed(button,) {
   return button.pressed === true || button.value > 0;
 }
-function useGamepad(input, callback, {
-  mapping,
-  on,
-} = {},) {
+function useGamepad(input, callback, { mapping, on, } = {},) {
   const context = React__default.useContext(GamepadContext,);
-  const settings = useConstant2(() => ({
-    mapping: mapping ?? 'standard',
-    on: on ?? 'keydown',
-  }));
-  const stateRef = React__default.useRef({
-    pressed: false,
-    handler: callback,
-  },);
+  const settings = useConstant2(() => ({ mapping: mapping ?? 'standard', on: on ?? 'keydown', }));
+  const stateRef = React__default.useRef({ pressed: false, handler: callback, },);
   const cb = React__default.useCallback((gamepad) => {
-    const {
-      pressed,
-      handler,
-    } = stateRef.current;
+    const { pressed, handler, } = stateRef.current;
     if (gamepad.inputs.includes(input,) && settings.mapping === gamepad.mapping) {
       settings.on === 'keydown' && handler();
       stateRef.current.pressed = true;
@@ -33998,11 +26110,8 @@ function useGamepad(input, callback, {
   }, [input, settings,],);
   useOnCurrentTargetChange((isInTarget, isOverlayed,) => {
     const isActive = isInTarget && !isOverlayed;
-    if (isActive) {
-      context.register(cb,);
-    } else {
-      context.unregister(cb,);
-    }
+    if (isActive) context.register(cb,);
+    else context.unregister(cb,);
     return () => context.unregister(cb,);
   }, [],);
   React__default.useEffect(() => {
@@ -34012,25 +26121,14 @@ function useGamepad(input, callback, {
     stateRef.current.handler = callback;
   }, [callback,],);
 }
-var modifierDefaults = {
-  altKey: false,
-  ctrlKey: false,
-  metaKey: false,
-  shiftKey: false,
-};
+var modifierDefaults = { altKey: false, ctrlKey: false, metaKey: false, shiftKey: false, };
 function createShortcutDefinition(shortcut,) {
   const keys3 = shortcut.split('+',);
   const key7 = keys3.pop();
   if (!key7) return void 0;
   const modifiers = {};
-  for (const modifier of keys3) {
-    modifiers[`${modifier}Key`] = true;
-  }
-  return {
-    ...modifierDefaults,
-    ...modifiers,
-    key: key7,
-  };
+  for (const modifier of keys3) modifiers[`${modifier}Key`] = true;
+  return { ...modifierDefaults, ...modifiers, key: key7, };
 }
 function useHotkey(shortcut, callback,) {
   const inTarget = React__default.useRef(true,);
@@ -34055,9 +26153,7 @@ function useIsOnFramerCanvas() {
   return RenderTarget.current() === 'CANVAS';
 }
 function useNavigate() {
-  const {
-    navigate,
-  } = useRouter();
+  const { navigate, } = useRouter();
   const onCanvas = useIsOnFramerCanvas();
   if (!navigate) return () => {};
   return (target) => {
@@ -34092,22 +26188,15 @@ function useOnVariantChange(variant, callbackMap,) {
   }, [variant,],);
 }
 function useOnAppear(callback,) {
-  useOnVariantChange('default', {
-    default: callback,
-  },);
+  useOnVariantChange('default', { default: callback, },);
 }
-function useOverlayState({
-  blockDocumentScrolling = true,
-} = {},) {
+function useOverlayState({ blockDocumentScrolling = true, } = {},) {
   const [showOverlay, setShowOverlay,] = React__default.useState(false,);
   const callback = React__default.useCallback((show) => {
     setShowOverlay(show,);
     if (blockDocumentScrolling === false) return;
-    if (show) {
-      document.documentElement.style.setProperty('overflow', 'hidden',);
-    } else {
-      document.documentElement.style.removeProperty('overflow',);
-    }
+    if (show) document.documentElement.style.setProperty('overflow', 'hidden',);
+    else document.documentElement.style.removeProperty('overflow',);
   }, [blockDocumentScrolling,],);
   React__default.useEffect(() => () => {
     if (blockDocumentScrolling === false) return;
@@ -34117,27 +26206,19 @@ function useOverlayState({
 }
 async function componentForRoute(route,) {
   if (!isRoute(route,)) return;
-  const {
-    page: routeComponent,
-  } = route;
+  const { page: routeComponent, } = route;
   if (!routeComponent) return;
   if (React__default.isValidElement(routeComponent,)) return routeComponent;
   if (withPreload(routeComponent,)) await routeComponent.preload();
-  return React__default.createElement(routeComponent, {
-    key: route.path,
-  },);
+  return React__default.createElement(routeComponent, { key: route.path, },);
 }
 var preloadKey2 = 'preload';
 function withPreload(component,) {
   return !!component && isObject2(component,) && preloadKey2 in component;
 }
-function usePrototypeNavigate({
-  preload,
-} = {},) {
+function usePrototypeNavigate({ preload, } = {},) {
   const navigation = useNavigation();
-  const {
-    getRoute,
-  } = useRouter();
+  const { getRoute, } = useRouter();
   const onCanvas = useIsOnFramerCanvas();
   React__default.useEffect(() => {
     if (!navigation || onCanvas) return;
@@ -34145,12 +26226,8 @@ function usePrototypeNavigate({
       let component;
       if (isString22(componentOrRoute,)) {
         const route = getRoute == null ? void 0 : getRoute(componentOrRoute,);
-        if (isRoute(route,)) {
-          component = route.page;
-        }
-      } else {
-        component = componentOrRoute;
-      }
+        if (isRoute(route,)) component = route.page;
+      } else component = componentOrRoute;
       if (component && withPreload(component,)) void component.preload();
     },);
   }, [],);
@@ -34167,50 +26244,29 @@ function usePrototypeNavigate({
       ? target
       : null;
     if (!Component14) return;
-    const {
-      appearsFrom,
-      backdropColor,
-      animation,
-    } = options;
+    const { appearsFrom, backdropColor, animation, } = options;
     const transitionType = options.transition || 'instant';
     switch (transitionType) {
       case 'instant':
         navigation.instant(Component14,);
         break;
       case 'fade':
-        navigation.fade(Component14, {
-          animation,
-        },);
+        navigation.fade(Component14, { animation, },);
         break;
       case 'push':
-        navigation.push(Component14, {
-          appearsFrom,
-          animation,
-        },);
+        navigation.push(Component14, { appearsFrom, animation, },);
         break;
       case 'flip':
-        navigation.flip(Component14, {
-          appearsFrom,
-          animation,
-        },);
+        navigation.flip(Component14, { appearsFrom, animation, },);
         break;
       case 'magicMotion':
-        navigation.magicMotion(Component14, {
-          animation,
-        },);
+        navigation.magicMotion(Component14, { animation, },);
         break;
       case 'modal':
-        navigation.modal(Component14, {
-          backdropColor,
-          animation,
-        },);
+        navigation.modal(Component14, { backdropColor, animation, },);
         break;
       case 'overlay':
-        navigation.overlay(Component14, {
-          appearsFrom,
-          backdropColor,
-          animation,
-        },);
+        navigation.overlay(Component14, { appearsFrom, backdropColor, animation, },);
         break;
     }
     return false;
@@ -34239,10 +26295,7 @@ function getCollectionId(collection,) {
   collectionIds.set(collection, id3,);
   return id3;
 }
-function getCacheKey({
-  from,
-  ...query
-}, locale,) {
+function getCacheKey({ from, ...query }, locale,) {
   const fromId = getCollectionId(from.data,);
   const localeId = (locale == null ? void 0 : locale.id) ?? 'default';
   return fromId + JSON.stringify(query,) + localeId;
@@ -34253,9 +26306,7 @@ function use(promise,) {
 var queryEngine = /* @__PURE__ */ new QueryEngine();
 var queryCache = /* @__PURE__ */ new QueryCache(queryEngine,);
 function useQueryData(query,) {
-  const {
-    activeLocale,
-  } = useLocaleInfo();
+  const { activeLocale, } = useLocaleInfo();
   const cached = queryCache.get(query, activeLocale,);
   const promise = cached.preload();
   if (promise) use(promise,);
@@ -34274,68 +26325,30 @@ function getWhereExpressionFromPathVariables(pathVariables,) {
   const expressions = entries.map(([name, value,],) => ({
     type: 'BinaryOperation',
     operator: '==',
-    left: {
-      type: 'TypeCast',
-      value: {
-        type: 'Identifier',
-        name,
-      },
-      dataType: 'STRING',
-      /* String */
-    },
-    right: {
-      type: 'LiteralValue',
-      value: String(value,),
-    },
-  }));
-  if (expressions.length === 0) {
-    return {
-      type: 'LiteralValue',
-      value: false,
-    };
-  }
-  return expressions.reduce((result, expression,) => ({
-    type: 'BinaryOperation',
-    operator: 'and',
-    left: result,
-    right: expression,
+    left: { type: 'TypeCast', value: { type: 'Identifier', name, }, dataType: 'STRING', /* String */ },
+    right: { type: 'LiteralValue', value: String(value,), },
   }));
+  if (expressions.length === 0) return { type: 'LiteralValue', value: false, };
+  return expressions.reduce((result, expression,) => ({ type: 'BinaryOperation', operator: 'and', left: result, right: expression, }));
 }
 function useLoadMorePaginatedQuery(query, pageSize,) {
-  const {
-    paginationInfo,
-    setPaginationInfo,
-  } = useCollectionListPaginationInfo();
+  const { paginationInfo, setPaginationInfo, } = useCollectionListPaginationInfo();
   const count = useQueryCount(query,);
   const initialPaginationInfo = useMemo(() => {
     const totalPages = Math.ceil(count / pageSize,);
-    return {
-      currentPage: 1,
-      totalPages,
-      type: 'loadMore',
-    };
+    return { currentPage: 1, totalPages, type: 'loadMore', };
   }, [count, pageSize,],);
   useEffect(() => {
-    if (!paginationInfo) {
-      setPaginationInfo(initialPaginationInfo,);
-    }
+    if (!paginationInfo) setPaginationInfo(initialPaginationInfo,);
   }, [count, initialPaginationInfo, paginationInfo, setPaginationInfo,],);
   const paginatedQuery = useMemo(() => {
     const currentPaginationInfo = paginationInfo ?? initialPaginationInfo;
     let limit = pageSize * currentPaginationInfo.currentPage;
     if (query.limit) {
-      if (query.limit.type !== 'LiteralValue' || typeof query.limit.value !== 'number') {
-        throw new Error('Unexpected type for query limit',);
-      }
+      if (query.limit.type !== 'LiteralValue' || typeof query.limit.value !== 'number') throw new Error('Unexpected type for query limit',);
       limit = Math.min(limit, query.limit.value,);
     }
-    return {
-      ...query,
-      limit: {
-        type: 'LiteralValue',
-        value: limit,
-      },
-    };
+    return { ...query, limit: { type: 'LiteralValue', value: limit, }, };
   }, [initialPaginationInfo, query, pageSize, paginationInfo,],);
   return paginatedQuery;
 }
@@ -34345,9 +26358,7 @@ function createGestureVariant(variant, type,) {
 function nextVariant(allVariants, currentVariant,) {
   const index = allVariants.indexOf(currentVariant,);
   let nextIndex = index + 1;
-  if (nextIndex >= allVariants.length) {
-    nextIndex = 0;
-  }
+  if (nextIndex >= allVariants.length) nextIndex = 0;
   const nextVariant2 = allVariants[nextIndex];
   assert(nextVariant2 !== void 0, 'nextVariant should be defined',);
   return nextVariant2;
@@ -34365,10 +26376,7 @@ var VariantSelector = /* @__PURE__ */ ((VariantSelector2) => {
   return VariantSelector2;
 })(VariantSelector || {},);
 function getGesture(enabledGestures, isHovered, isPressed,) {
-  const {
-    hover,
-    pressed,
-  } = enabledGestures || {};
+  const { hover, pressed, } = enabledGestures || {};
   if (pressed && isPressed) return 'pressed';
   if (hover && isHovered) return 'hover';
 }
@@ -34383,15 +26391,17 @@ function safeBaseVariant(targetVariant, fallbackVariant, validBaseVariants,) {
   return fallbackVariant;
 }
 var CycleVariantState = /* @__PURE__ */ Symbol('cycle',);
-function useVariantState({
-  variant,
-  defaultVariant: externalDefaultVariant,
-  transitions: externalTransitions,
-  enabledGestures: externalEnabledGestures,
-  cycleOrder: externalCycleOrder = [],
-  variantProps: variantProps2 = {},
-  variantClassNames = {},
-},) {
+function useVariantState(
+  {
+    variant,
+    defaultVariant: externalDefaultVariant,
+    transitions: externalTransitions,
+    enabledGestures: externalEnabledGestures,
+    cycleOrder: externalCycleOrder = [],
+    variantProps: variantProps2 = {},
+    variantClassNames = {},
+  },
+) {
   const forceUpdate = useForceUpdate3();
   const validBaseVariants = useConstant2(() => new Set(externalCycleOrder,));
   const internalState = React__default.useRef({
@@ -34399,8 +26409,7 @@ function useVariantState({
     isPressed: false,
     baseVariant: safeBaseVariant(variant, externalDefaultVariant, validBaseVariants,),
     lastVariant: variant,
-    gestureVariant: void 0,
-    // When used in generated components, these are static values defined
+    gestureVariant: void 0, // When used in generated components, these are static values defined
     // outside of the component function that also need to not result in
     // memoized values being recalculated, so we dump them into the ref.
     defaultVariant: externalDefaultVariant,
@@ -34409,28 +26418,17 @@ function useVariantState({
     transitions: externalTransitions,
   },);
   const resolveNextVariant = React__default.useCallback((targetBaseVariant) => {
-    const {
-      isHovered: isHovered2,
-      isPressed: isPressed2,
-      enabledGestures: enabledGestures2,
-      defaultVariant: defaultVariant2,
-    } = internalState.current;
+    const { isHovered: isHovered2, isPressed: isPressed2, enabledGestures: enabledGestures2, defaultVariant: defaultVariant2, } =
+      internalState.current;
     const nextBaseVariant = safeBaseVariant(targetBaseVariant, defaultVariant2, validBaseVariants,);
     const gesture = getGesture(enabledGestures2 == null ? void 0 : enabledGestures2[nextBaseVariant], isHovered2, isPressed2,);
     const nextGestureVariant = gesture ? createGestureVariant(nextBaseVariant, gesture,) : void 0;
     return [nextBaseVariant, nextGestureVariant,];
   }, [validBaseVariants,],);
-  const setGestureState = React__default.useCallback(({
-    isHovered: isHovered2,
-    isPressed: isPressed2,
-  },) => {
+  const setGestureState = React__default.useCallback(({ isHovered: isHovered2, isPressed: isPressed2, },) => {
     if (isHovered2 !== void 0) internalState.current.isHovered = isHovered2;
     if (isPressed2 !== void 0) internalState.current.isPressed = isPressed2;
-    const {
-      baseVariant: baseVariant2,
-      gestureVariant: gestureVariant2,
-      defaultVariant: defaultVariant2,
-    } = internalState.current;
+    const { baseVariant: baseVariant2, gestureVariant: gestureVariant2, defaultVariant: defaultVariant2, } = internalState.current;
     const [nextBase, nextGesture,] = resolveNextVariant(baseVariant2,);
     if (nextBase !== baseVariant2 || nextGesture !== gestureVariant2) {
       internalState.current.baseVariant = nextBase || defaultVariant2;
@@ -34439,12 +26437,8 @@ function useVariantState({
     }
   }, [resolveNextVariant, forceUpdate,],);
   const setVariant = React__default.useCallback((proposedVariant) => {
-    const {
-      defaultVariant: defaultVariant2,
-      cycleOrder,
-      baseVariant: baseVariant2,
-      gestureVariant: gestureVariant2,
-    } = internalState.current;
+    const { defaultVariant: defaultVariant2, cycleOrder, baseVariant: baseVariant2, gestureVariant: gestureVariant2, } =
+      internalState.current;
     const nextBaseVariant = proposedVariant === CycleVariantState
       ? nextVariant(cycleOrder || [], baseVariant2 || defaultVariant2,)
       : proposedVariant;
@@ -34463,14 +26457,7 @@ function useVariantState({
       internalState.current.gestureVariant = nextGesture;
     }
   }
-  const {
-    baseVariant,
-    gestureVariant,
-    defaultVariant,
-    enabledGestures,
-    isHovered,
-    isPressed,
-  } = internalState.current;
+  const { baseVariant, gestureVariant, defaultVariant, enabledGestures, isHovered, isPressed, } = internalState.current;
   const addVariantProps = useAddVariantProps(internalState.current.baseVariant, internalState.current.gestureVariant, variantProps2,);
   return React__default.useMemo(() => {
     const variants = [];
@@ -34516,12 +26503,8 @@ function withMappedReactProps(Component14, info,) {
   return (rawProps) => {
     const props = {};
     const mapping = extractMappingFromInfo(info,);
-    for (const key7 in rawProps) {
-      asRecord(props,)[(mapping == null ? void 0 : mapping[key7]) ?? key7] = rawProps[key7];
-    }
-    return /* @__PURE__ */ _jsx5(Component14, {
-      ...props,
-    },);
+    for (const key7 in rawProps) asRecord(props,)[(mapping == null ? void 0 : mapping[key7]) ?? key7] = rawProps[key7];
+    return /* @__PURE__ */ _jsx5(Component14, { ...props, },);
   };
 }
 var keys2 = /* @__PURE__ */ new Set([
@@ -34534,10 +26517,7 @@ var keys2 = /* @__PURE__ */ new Set([
   'exitTarget',
   'scrollDirection',
 ],);
-var defaultRanges3 = {
-  inputRange: [],
-  outputRange: [],
-};
+var defaultRanges3 = { inputRange: [], outputRange: [], };
 function createInputOutputRanges2(transformTargets, threshold, exitTarget,) {
   const outputRange = [];
   const inputRange = createTransformInputRange(transformTargets, threshold, (index) => outputRange.unshift(index, index,),);
@@ -34549,25 +26529,12 @@ function createInputOutputRanges2(transformTargets, threshold, exitTarget,) {
   }
   const firstItem = inputRange[0];
   if (!isNumber2(firstItem,)) return defaultRanges3;
-  if (firstItem <= 1) {
-    return {
-      inputRange,
-      outputRange,
-    };
-  }
-  return {
-    inputRange: [0, Math.max(firstItem - 1, 0,), ...inputRange,],
-    outputRange: [-1, -1, ...outputRange,],
-  };
+  if (firstItem <= 1) return { inputRange, outputRange, };
+  return { inputRange: [0, Math.max(firstItem - 1, 0,), ...inputRange,], outputRange: [-1, -1, ...outputRange,], };
 }
 var withVariantAppearEffect = (Component14) =>
   React__default.forwardRef((props, forwardedRef,) => {
-    if (RenderTarget.current() === 'CANVAS') {
-      return /* @__PURE__ */ _jsx5(Component14, {
-        ...props,
-        ref: forwardedRef,
-      },);
-    }
+    if (RenderTarget.current() === 'CANVAS') return /* @__PURE__ */ _jsx5(Component14, { ...props, ref: forwardedRef, },);
     const fallbackRef = React__default.useRef(null,);
     const ref = forwardedRef ?? fallbackRef;
     const [options, rest,] = extractPrefixedProps(props, keys2,);
@@ -34589,32 +26556,18 @@ var withVariantAppearEffect = (Component14) =>
       if (animateOnce && animateState.current === true) return;
       if (animateState.current === appears) return;
       animateState.current = appears;
-      if (appears) {
-        setVariant(visibleVariantId,);
-      } else {
-        setVariant(obscuredVariantId,);
-      }
-    }, {
-      enabled: variantAppearEffectEnabled,
-      animateOnce,
-      threshold: {
-        y: threshold,
-      },
-    },);
+      if (appears) setVariant(visibleVariantId,);
+      else setVariant(obscuredVariantId,);
+    }, { enabled: variantAppearEffectEnabled, animateOnce, threshold: { y: threshold, }, },);
     React__default.useEffect(() => {
       if (scrollDirection) return;
       if (!targets) return;
       const playedState = {};
       let currentVariant = void 0;
-      return scrollInfo(({
-        y: scrollY,
-      },) => {
+      return scrollInfo(({ y: scrollY, },) => {
         var _a;
         if (!targets[0] || targets[0].ref && !targets[0].ref.current) return;
-        const {
-          inputRange,
-          outputRange,
-        } = createInputOutputRanges2(targets, (threshold ?? 0) * scrollY.containerLength, exitTarget,);
+        const { inputRange, outputRange, } = createInputOutputRanges2(targets, (threshold ?? 0) * scrollY.containerLength, exitTarget,);
         if (inputRange.length === 0 || inputRange.length !== outputRange.length) return;
         const index = Math.floor(transform(scrollY.current, inputRange, outputRange,),);
         if (animateOnce && playedState[index]) return;
@@ -34625,45 +26578,18 @@ var withVariantAppearEffect = (Component14) =>
         setVariant(variant,);
       },);
     }, [animateOnce, threshold, targets, props.variant,],);
-    useScrollDirectionChange(scrollDirection, setVariant, {
-      enabled: variantAppearEffectEnabled,
-      repeat: !animateOnce,
-    },);
+    useScrollDirectionChange(scrollDirection, setVariant, { enabled: variantAppearEffectEnabled, repeat: !animateOnce, },);
     if (!('variantAppearEffectEnabled' in options) || variantAppearEffectEnabled === true) {
-      return /* @__PURE__ */ _jsx5(Component14, {
-        ...rest,
-        variant: activeVariant ?? props.variant,
-        ref,
-      },);
-    } else {
-      return /* @__PURE__ */ _jsx5(Component14, {
-        ...rest,
-      },);
-    }
+      return /* @__PURE__ */ _jsx5(Component14, { ...rest, variant: activeVariant ?? props.variant, ref, },);
+    } else return /* @__PURE__ */ _jsx5(Component14, { ...rest, },);
   },);
 var withVariantFX = (Component14) =>
-  React__default.forwardRef(({
-    initial,
-    animate: animate3,
-    exit,
-    ...props
-  }, forwardedRef,) => {
+  React__default.forwardRef(({ initial, animate: animate3, exit, ...props }, forwardedRef,) => {
     const ref = useRef();
-    const effect = usePresenceAnimation(
-      {
-        initial,
-        animate: animate3,
-        exit,
-      },
-      forwardedRef ?? ref,
-      true,
-    );
+    const effect = usePresenceAnimation({ initial, animate: animate3, exit, }, forwardedRef ?? ref, true,);
     return /* @__PURE__ */ _jsx5(Component14, {
       ...props,
-      style: {
-        ...(props == null ? void 0 : props.style),
-        ...effect.values,
-      },
+      style: { ...(props == null ? void 0 : props.style), ...effect.values, },
       ref: forwardedRef ?? ref,
     },);
   },);
@@ -34681,511 +26607,144 @@ function isReactDefinition(d,) {
 var localPackageFallbackIdentifier = '|local|';
 var safeFonts = {
   Arial: {
-    Regular: {
-      selector: 'Arial',
-      weight: void 0,
-    },
-    Black: {
-      selector: 'Arial-Black',
-      weight: void 0,
-    },
-    Narrow: {
-      selector: 'Arial Narrow',
-      weight: void 0,
-    },
-    'Rounded Bold': {
-      selector: 'Arial Rounded MT Bold',
-      weight: void 0,
-    },
+    Regular: { selector: 'Arial', weight: void 0, },
+    Black: { selector: 'Arial-Black', weight: void 0, },
+    Narrow: { selector: 'Arial Narrow', weight: void 0, },
+    'Rounded Bold': { selector: 'Arial Rounded MT Bold', weight: void 0, },
   },
   Avenir: {
-    Book: {
-      selector: 'Avenir',
-      weight: void 0,
-    },
-    Light: {
-      selector: 'Avenir-Light',
-      weight: void 0,
-    },
-    Medium: {
-      selector: 'Avenir-Medium',
-      weight: void 0,
-    },
-    Heavy: {
-      selector: 'Avenir-Heavy',
-      weight: void 0,
-    },
-    Black: {
-      selector: 'Avenir-Black',
-      weight: void 0,
-    },
+    Book: { selector: 'Avenir', weight: void 0, },
+    Light: { selector: 'Avenir-Light', weight: void 0, },
+    Medium: { selector: 'Avenir-Medium', weight: void 0, },
+    Heavy: { selector: 'Avenir-Heavy', weight: void 0, },
+    Black: { selector: 'Avenir-Black', weight: void 0, },
   },
   'Avenir Next': {
-    Regular: {
-      selector: 'Avenir Next',
-      weight: void 0,
-    },
-    'Ultra Light': {
-      selector: 'AvenirNext-UltraLight',
-      weight: void 0,
-    },
-    Medium: {
-      selector: 'AvenirNext-Medium',
-      weight: void 0,
-    },
-    'Demi Bold': {
-      selector: 'AvenirNext-DemiBold',
-      weight: void 0,
-    },
-    Heavy: {
-      selector: 'AvenirNext-Heavy',
-      weight: void 0,
-    },
+    Regular: { selector: 'Avenir Next', weight: void 0, },
+    'Ultra Light': { selector: 'AvenirNext-UltraLight', weight: void 0, },
+    Medium: { selector: 'AvenirNext-Medium', weight: void 0, },
+    'Demi Bold': { selector: 'AvenirNext-DemiBold', weight: void 0, },
+    Heavy: { selector: 'AvenirNext-Heavy', weight: void 0, },
   },
   'Avenir Next Condensed': {
-    Regular: {
-      selector: 'Avenir Next Condensed',
-      weight: void 0,
-    },
-    'Ultra Light': {
-      selector: 'AvenirNextCondensed-UltraLight',
-      weight: void 0,
-    },
-    Medium: {
-      selector: 'AvenirNextCondensed-Medium',
-      weight: void 0,
-    },
-    'Demi Bold': {
-      selector: 'AvenirNextCondensed-DemiBold',
-      weight: void 0,
-    },
-    Heavy: {
-      selector: 'AvenirNextCondensed-Heavy',
-      weight: void 0,
-    },
+    Regular: { selector: 'Avenir Next Condensed', weight: void 0, },
+    'Ultra Light': { selector: 'AvenirNextCondensed-UltraLight', weight: void 0, },
+    Medium: { selector: 'AvenirNextCondensed-Medium', weight: void 0, },
+    'Demi Bold': { selector: 'AvenirNextCondensed-DemiBold', weight: void 0, },
+    Heavy: { selector: 'AvenirNextCondensed-Heavy', weight: void 0, },
   },
   Baskerville: {
-    Regular: {
-      selector: 'Baskerville',
-      weight: void 0,
-    },
-    'Semi Bold': {
-      selector: 'Baskerville-SemiBold',
-      weight: void 0,
-    },
+    Regular: { selector: 'Baskerville', weight: void 0, },
+    'Semi Bold': { selector: 'Baskerville-SemiBold', weight: void 0, },
   },
   'Bodoni 72': {
-    Book: {
-      selector: 'Bodoni 72',
-      weight: void 0,
-    },
-    Oldstyle: {
-      selector: 'Bodoni 72 Oldstyle',
-      weight: void 0,
-    },
-    Smallcaps: {
-      selector: 'Bodoni 72 Smallcaps',
-      weight: void 0,
-    },
-  },
-  Courier: {
-    Regular: {
-      selector: 'Courier',
-      weight: void 0,
-    },
-  },
-  'Courier New': {
-    Regular: {
-      selector: 'Courier New',
-      weight: void 0,
-    },
+    Book: { selector: 'Bodoni 72', weight: void 0, },
+    Oldstyle: { selector: 'Bodoni 72 Oldstyle', weight: void 0, },
+    Smallcaps: { selector: 'Bodoni 72 Smallcaps', weight: void 0, },
   },
+  Courier: { Regular: { selector: 'Courier', weight: void 0, }, },
+  'Courier New': { Regular: { selector: 'Courier New', weight: void 0, }, },
   Futura: {
-    Medium: {
-      selector: 'Futura',
-      weight: void 0,
-    },
-    Condensed: {
-      selector: 'Futura-CondensedMedium',
-      weight: void 0,
-    },
-    'Condensed ExtraBold': {
-      selector: 'Futura-CondensedExtraBold',
-      weight: void 0,
-    },
-  },
-  Georgia: {
-    Regular: {
-      selector: 'Georgia',
-      weight: void 0,
-    },
+    Medium: { selector: 'Futura', weight: void 0, },
+    Condensed: { selector: 'Futura-CondensedMedium', weight: void 0, },
+    'Condensed ExtraBold': { selector: 'Futura-CondensedExtraBold', weight: void 0, },
   },
+  Georgia: { Regular: { selector: 'Georgia', weight: void 0, }, },
   'Gill Sans': {
-    Regular: {
-      selector: 'Gill Sans',
-      weight: void 0,
-    },
-    Light: {
-      selector: 'GillSans-Light',
-      weight: void 0,
-    },
-    SemiBold: {
-      selector: 'GillSans-SemiBold',
-      weight: void 0,
-    },
-    UltraBold: {
-      selector: 'GillSans-UltraBold',
-      weight: void 0,
-    },
+    Regular: { selector: 'Gill Sans', weight: void 0, },
+    Light: { selector: 'GillSans-Light', weight: void 0, },
+    SemiBold: { selector: 'GillSans-SemiBold', weight: void 0, },
+    UltraBold: { selector: 'GillSans-UltraBold', weight: void 0, },
   },
   Helvetica: {
-    Regular: {
-      selector: 'Helvetica',
-      weight: void 0,
-    },
-    Light: {
-      selector: 'Helvetica-Light',
-      weight: void 0,
-    },
-    Bold: {
-      selector: 'Helvetica-Bold',
-      weight: void 0,
-    },
-    Oblique: {
-      selector: 'Helvetica-Oblique',
-      weight: void 0,
-    },
-    'Light Oblique': {
-      selector: 'Helvetica-LightOblique',
-      weight: void 0,
-    },
-    'Bold Oblique': {
-      selector: 'Helvetica-BoldOblique',
-      weight: void 0,
-    },
+    Regular: { selector: 'Helvetica', weight: void 0, },
+    Light: { selector: 'Helvetica-Light', weight: void 0, },
+    Bold: { selector: 'Helvetica-Bold', weight: void 0, },
+    Oblique: { selector: 'Helvetica-Oblique', weight: void 0, },
+    'Light Oblique': { selector: 'Helvetica-LightOblique', weight: void 0, },
+    'Bold Oblique': { selector: 'Helvetica-BoldOblique', weight: void 0, },
   },
   'Helvetica Neue': {
-    Regular: {
-      selector: 'Helvetica Neue',
-      weight: void 0,
-    },
-    UltraLight: {
-      selector: 'HelveticaNeue-UltraLight',
-      weight: void 0,
-    },
-    Thin: {
-      selector: 'HelveticaNeue-Thin',
-      weight: void 0,
-    },
-    Light: {
-      selector: 'HelveticaNeue-Light',
-      weight: void 0,
-    },
-    Medium: {
-      selector: 'HelveticaNeue-Medium',
-      weight: void 0,
-    },
-    Bold: {
-      selector: 'HelveticaNeue-Bold',
-      weight: void 0,
-    },
-    Italic: {
-      selector: 'HelveticaNeue-Italic',
-      weight: void 0,
-    },
-    'UltraLight Italic': {
-      selector: 'HelveticaNeue-UltraLightItalic',
-      weight: void 0,
-    },
-    'Thin Italic': {
-      selector: 'HelveticaNeue-ThinItalic',
-      weight: void 0,
-    },
-    'Light Italic': {
-      selector: 'HelveticaNeue-LightItalic',
-      weight: void 0,
-    },
-    'Medium Italic': {
-      selector: 'HelveticaNeue-MediumItalic',
-      weight: void 0,
-    },
-    'Bold Italic': {
-      selector: 'HelveticaNeue-BoldItalic',
-      weight: void 0,
-    },
-    'Condensed Bold': {
-      selector: 'HelveticaNeue-CondensedBold',
-      weight: void 0,
-    },
-    'Condensed Black': {
-      selector: 'HelveticaNeue-CondensedBlack',
-      weight: void 0,
-    },
-  },
-  'Hoefler Text': {
-    Regular: {
-      selector: 'Hoefler Text',
-      weight: void 0,
-    },
-  },
-  Impact: {
-    Regular: {
-      selector: 'Impact',
-      weight: void 0,
-    },
-  },
-  'Lucida Grande': {
-    Regular: {
-      selector: 'Lucida Grande',
-      weight: void 0,
-    },
-  },
-  Menlo: {
-    Regular: {
-      selector: 'Menlo',
-      weight: void 0,
-    },
-  },
-  Monaco: {
-    Regular: {
-      selector: 'Monaco',
-      weight: void 0,
-    },
-  },
-  Optima: {
-    Regular: {
-      selector: 'Optima',
-      weight: void 0,
-    },
-    ExtraBlack: {
-      selector: 'Optima-ExtraBlack',
-      weight: void 0,
-    },
-  },
-  Palatino: {
-    Regular: {
-      selector: 'Palatino',
-      weight: void 0,
-    },
+    Regular: { selector: 'Helvetica Neue', weight: void 0, },
+    UltraLight: { selector: 'HelveticaNeue-UltraLight', weight: void 0, },
+    Thin: { selector: 'HelveticaNeue-Thin', weight: void 0, },
+    Light: { selector: 'HelveticaNeue-Light', weight: void 0, },
+    Medium: { selector: 'HelveticaNeue-Medium', weight: void 0, },
+    Bold: { selector: 'HelveticaNeue-Bold', weight: void 0, },
+    Italic: { selector: 'HelveticaNeue-Italic', weight: void 0, },
+    'UltraLight Italic': { selector: 'HelveticaNeue-UltraLightItalic', weight: void 0, },
+    'Thin Italic': { selector: 'HelveticaNeue-ThinItalic', weight: void 0, },
+    'Light Italic': { selector: 'HelveticaNeue-LightItalic', weight: void 0, },
+    'Medium Italic': { selector: 'HelveticaNeue-MediumItalic', weight: void 0, },
+    'Bold Italic': { selector: 'HelveticaNeue-BoldItalic', weight: void 0, },
+    'Condensed Bold': { selector: 'HelveticaNeue-CondensedBold', weight: void 0, },
+    'Condensed Black': { selector: 'HelveticaNeue-CondensedBlack', weight: void 0, },
   },
+  'Hoefler Text': { Regular: { selector: 'Hoefler Text', weight: void 0, }, },
+  Impact: { Regular: { selector: 'Impact', weight: void 0, }, },
+  'Lucida Grande': { Regular: { selector: 'Lucida Grande', weight: void 0, }, },
+  Menlo: { Regular: { selector: 'Menlo', weight: void 0, }, },
+  Monaco: { Regular: { selector: 'Monaco', weight: void 0, }, },
+  Optima: { Regular: { selector: 'Optima', weight: void 0, }, ExtraBlack: { selector: 'Optima-ExtraBlack', weight: void 0, }, },
+  Palatino: { Regular: { selector: 'Palatino', weight: void 0, }, },
   'SF Pro Display': {
-    Regular: {
-      selector: '__SF-UI-Display-Regular__',
-      weight: 400,
-    },
-    Ultralight: {
-      selector: '__SF-UI-Display-Ultralight__',
-      weight: 100,
-    },
-    Thin: {
-      selector: '__SF-UI-Display-Thin__',
-      weight: 200,
-    },
-    Light: {
-      selector: '__SF-UI-Display-Light__',
-      weight: 300,
-    },
-    Medium: {
-      selector: '__SF-UI-Display-Medium__',
-      weight: 500,
-    },
-    Semibold: {
-      selector: '__SF-UI-Display-Semibold__',
-      weight: 600,
-    },
-    Bold: {
-      selector: '__SF-UI-Display-Bold__',
-      weight: 700,
-    },
-    Heavy: {
-      selector: '__SF-UI-Display-Heavy__',
-      weight: 800,
-    },
-    Black: {
-      selector: '__SF-UI-Display-Black__',
-      weight: 900,
-    },
-    Italic: {
-      selector: '__SF-UI-Display-Italic__',
-      weight: 400,
-    },
-    'Ultralight Italic': {
-      selector: '__SF-UI-Display-Ultralight-Italic__',
-      weight: 100,
-    },
-    'Thin Italic': {
-      selector: '__SF-UI-Display-Thin-Italic__',
-      weight: 200,
-    },
-    'Light Italic': {
-      selector: '__SF-UI-Display-Light-Italic__',
-      weight: 300,
-    },
-    'Medium Italic': {
-      selector: '__SF-UI-Display-Medium-Italic__',
-      weight: 500,
-    },
-    'Semibold Italic': {
-      selector: '__SF-UI-Display-Semibold-Italic__',
-      weight: 600,
-    },
-    'Bold Italic': {
-      selector: '__SF-UI-Display-Bold-Italic__',
-      weight: 700,
-    },
-    'Heavy Italic': {
-      selector: '__SF-UI-Display-Heavy-Italic__',
-      weight: 800,
-    },
-    'Black Italic': {
-      selector: '__SF-UI-Display-Black-Italic__',
-      weight: 900,
-    },
+    Regular: { selector: '__SF-UI-Display-Regular__', weight: 400, },
+    Ultralight: { selector: '__SF-UI-Display-Ultralight__', weight: 100, },
+    Thin: { selector: '__SF-UI-Display-Thin__', weight: 200, },
+    Light: { selector: '__SF-UI-Display-Light__', weight: 300, },
+    Medium: { selector: '__SF-UI-Display-Medium__', weight: 500, },
+    Semibold: { selector: '__SF-UI-Display-Semibold__', weight: 600, },
+    Bold: { selector: '__SF-UI-Display-Bold__', weight: 700, },
+    Heavy: { selector: '__SF-UI-Display-Heavy__', weight: 800, },
+    Black: { selector: '__SF-UI-Display-Black__', weight: 900, },
+    Italic: { selector: '__SF-UI-Display-Italic__', weight: 400, },
+    'Ultralight Italic': { selector: '__SF-UI-Display-Ultralight-Italic__', weight: 100, },
+    'Thin Italic': { selector: '__SF-UI-Display-Thin-Italic__', weight: 200, },
+    'Light Italic': { selector: '__SF-UI-Display-Light-Italic__', weight: 300, },
+    'Medium Italic': { selector: '__SF-UI-Display-Medium-Italic__', weight: 500, },
+    'Semibold Italic': { selector: '__SF-UI-Display-Semibold-Italic__', weight: 600, },
+    'Bold Italic': { selector: '__SF-UI-Display-Bold-Italic__', weight: 700, },
+    'Heavy Italic': { selector: '__SF-UI-Display-Heavy-Italic__', weight: 800, },
+    'Black Italic': { selector: '__SF-UI-Display-Black-Italic__', weight: 900, },
   },
   'SF Pro Display Condensed': {
-    Regular: {
-      selector: '__SF-UI-Display-Condensed-Regular__',
-      weight: 400,
-    },
-    Ultralight: {
-      selector: '__SF-UI-Display-Condensed-Ultralight__',
-      weight: 100,
-    },
-    Thin: {
-      selector: '__SF-UI-Display-Condensed-Thin__',
-      weight: 200,
-    },
-    Light: {
-      selector: '__SF-UI-Display-Condensed-Light__',
-      weight: 300,
-    },
-    Medium: {
-      selector: '__SF-UI-Display-Condensed-Medium__',
-      weight: 500,
-    },
-    Semibold: {
-      selector: '__SF-UI-Display-Condensed-Semibold__',
-      weight: 600,
-    },
-    Bold: {
-      selector: '__SF-UI-Display-Condensed-Bold__',
-      weight: 700,
-    },
-    Heavy: {
-      selector: '__SF-UI-Display-Condensed-Heavy__',
-      weight: 800,
-    },
-    Black: {
-      selector: '__SF-UI-Display-Condensed-Black__',
-      weight: 900,
-    },
+    Regular: { selector: '__SF-UI-Display-Condensed-Regular__', weight: 400, },
+    Ultralight: { selector: '__SF-UI-Display-Condensed-Ultralight__', weight: 100, },
+    Thin: { selector: '__SF-UI-Display-Condensed-Thin__', weight: 200, },
+    Light: { selector: '__SF-UI-Display-Condensed-Light__', weight: 300, },
+    Medium: { selector: '__SF-UI-Display-Condensed-Medium__', weight: 500, },
+    Semibold: { selector: '__SF-UI-Display-Condensed-Semibold__', weight: 600, },
+    Bold: { selector: '__SF-UI-Display-Condensed-Bold__', weight: 700, },
+    Heavy: { selector: '__SF-UI-Display-Condensed-Heavy__', weight: 800, },
+    Black: { selector: '__SF-UI-Display-Condensed-Black__', weight: 900, },
   },
   'SF Pro Text': {
-    Regular: {
-      selector: '__SF-UI-Text-Regular__',
-      weight: 400,
-    },
-    Light: {
-      selector: '__SF-UI-Text-Light__',
-      weight: 200,
-    },
-    Medium: {
-      selector: '__SF-UI-Text-Medium__',
-      weight: 500,
-    },
-    Semibold: {
-      selector: '__SF-UI-Text-Semibold__',
-      weight: 600,
-    },
-    Bold: {
-      selector: '__SF-UI-Text-Bold__',
-      weight: 700,
-    },
-    Heavy: {
-      selector: '__SF-UI-Text-Heavy__',
-      weight: 800,
-    },
-    Italic: {
-      selector: '__SF-UI-Text-Italic__',
-      weight: 400,
-    },
-    'Light Italic': {
-      selector: '__SF-UI-Text-Light-Italic__',
-      weight: 200,
-    },
-    'Medium Italic': {
-      selector: '__SF-UI-Text-Medium-Italic__',
-      weight: 500,
-    },
-    'Semibold Italic': {
-      selector: '__SF-UI-Text-Semibold-Italic__',
-      weight: 600,
-    },
-    'Bold Italic': {
-      selector: '__SF-UI-Text-Bold-Italic__',
-      weight: 700,
-    },
-    'Heavy Italic': {
-      selector: '__SF-UI-Text-Heavy-Italic__',
-      weight: 800,
-    },
+    Regular: { selector: '__SF-UI-Text-Regular__', weight: 400, },
+    Light: { selector: '__SF-UI-Text-Light__', weight: 200, },
+    Medium: { selector: '__SF-UI-Text-Medium__', weight: 500, },
+    Semibold: { selector: '__SF-UI-Text-Semibold__', weight: 600, },
+    Bold: { selector: '__SF-UI-Text-Bold__', weight: 700, },
+    Heavy: { selector: '__SF-UI-Text-Heavy__', weight: 800, },
+    Italic: { selector: '__SF-UI-Text-Italic__', weight: 400, },
+    'Light Italic': { selector: '__SF-UI-Text-Light-Italic__', weight: 200, },
+    'Medium Italic': { selector: '__SF-UI-Text-Medium-Italic__', weight: 500, },
+    'Semibold Italic': { selector: '__SF-UI-Text-Semibold-Italic__', weight: 600, },
+    'Bold Italic': { selector: '__SF-UI-Text-Bold-Italic__', weight: 700, },
+    'Heavy Italic': { selector: '__SF-UI-Text-Heavy-Italic__', weight: 800, },
   },
   'SF Pro Text Condensed': {
-    Regular: {
-      selector: '__SF-UI-Text-Condensed-Regular__',
-      weight: 400,
-    },
-    Light: {
-      selector: '__SF-UI-Text-Condensed-Light__',
-      weight: 200,
-    },
-    Medium: {
-      selector: '__SF-UI-Text-Condensed-Medium__',
-      weight: 500,
-    },
-    Semibold: {
-      selector: '__SF-UI-Text-Condensed-Semibold__',
-      weight: 600,
-    },
-    Bold: {
-      selector: '__SF-UI-Text-Condensed-Bold__',
-      weight: 700,
-    },
-    Heavy: {
-      selector: '__SF-UI-Text-Condensed-Heavy__',
-      weight: 800,
-    },
-  },
-  Tahoma: {
-    Regular: {
-      selector: 'Tahoma',
-      weight: void 0,
-    },
-  },
-  Times: {
-    Regular: {
-      selector: 'Times',
-      weight: void 0,
-    },
-  },
-  'Times New Roman': {
-    Regular: {
-      selector: 'Times New Roman',
-      weight: void 0,
-    },
-  },
-  Trebuchet: {
-    Regular: {
-      selector: 'Trebuchet MS',
-      weight: void 0,
-    },
-  },
-  Verdana: {
-    Regular: {
-      selector: 'Verdana',
-      weight: void 0,
-    },
+    Regular: { selector: '__SF-UI-Text-Condensed-Regular__', weight: 400, },
+    Light: { selector: '__SF-UI-Text-Condensed-Light__', weight: 200, },
+    Medium: { selector: '__SF-UI-Text-Condensed-Medium__', weight: 500, },
+    Semibold: { selector: '__SF-UI-Text-Condensed-Semibold__', weight: 600, },
+    Bold: { selector: '__SF-UI-Text-Condensed-Bold__', weight: 700, },
+    Heavy: { selector: '__SF-UI-Text-Condensed-Heavy__', weight: 800, },
   },
+  Tahoma: { Regular: { selector: 'Tahoma', weight: void 0, }, },
+  Times: { Regular: { selector: 'Times', weight: void 0, }, },
+  'Times New Roman': { Regular: { selector: 'Times New Roman', weight: void 0, }, },
+  Trebuchet: { Regular: { selector: 'Trebuchet MS', weight: void 0, }, },
+  Verdana: { Regular: { selector: 'Verdana', weight: void 0, }, },
 };
 var fontAliases = {
   '__SF-Compact-Display-Regular__': 'SFCompactDisplay-Regular|.SFCompactDisplay-Regular',
@@ -35280,8 +26839,7 @@ var FontSourceNames = /* @__PURE__ */ ((FontSourceNames2) => {
 var systemFontFamilyName = 'System Default';
 var LocalFontSource = class {
   constructor() {
-    __publicField(this, 'name', 'local',/* Local */
-    );
+    __publicField(this, 'name', 'local', /* Local */);
     __publicField(this, 'fontFamilies', [],);
     __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
     __publicField(this, 'fontAliasBySelector', /* @__PURE__ */ new Map(),);
@@ -35289,23 +26847,17 @@ var LocalFontSource = class {
   }
   getFontFamilyByName(family,) {
     return this.byFamilyName.get(family,) ?? null;
-  }
-  // TODO: these are duplicated across implementations of FontSource
+  } // TODO: these are duplicated across implementations of FontSource
   // When adding a third source, we should abstract them
   createFontFamily(family,) {
-    const fontFamily = {
-      name: family,
-      fonts: [],
-      source: this.name,
-    };
+    const fontFamily = { name: family, fonts: [], source: this.name, };
     this.addFontFamily(fontFamily,);
     return fontFamily;
   }
   addFontFamily(fontFamily,) {
     this.fontFamilies.push(fontFamily,);
     this.byFamilyName.set(fontFamily.name, fontFamily,);
-  }
-  // end of duplication
+  } // end of duplication
   importFonts() {
     const fonts = [];
     for (const family of Object.keys(fontFamilies,)) {
@@ -35315,31 +26867,16 @@ var LocalFontSource = class {
       for (const variant of Object.keys(members,)) {
         const member = members[variant];
         if (!member) continue;
-        const {
-          selector,
-          weight,
-        } = member;
-        const font = {
-          variant,
-          selector,
-          weight,
-          family: fontFamily,
-        };
+        const { selector, weight, } = member;
+        const font = { variant, selector, weight, family: fontFamily, };
         fontFamily.fonts.push(font,);
       }
       fonts.push(...fontFamily.fonts,);
     }
-    for (const [key7, value,] of Object.entries(fontAliases,)) {
-      this.addFontAlias(key7, value,);
-    }
-    const {
-      fontFamily: systemFontFamily,
-      aliases,
-    } = this.getSystemFontFamily();
+    for (const [key7, value,] of Object.entries(fontAliases,)) this.addFontAlias(key7, value,);
+    const { fontFamily: systemFontFamily, aliases, } = this.getSystemFontFamily();
     this.addFontFamily(systemFontFamily,);
-    for (const [key7, value,] of aliases) {
-      this.addFontAlias(key7, value,);
-    }
+    for (const [key7, value,] of aliases) this.addFontAlias(key7, value,);
     fonts.push(...systemFontFamily.fonts,);
     return fonts;
   }
@@ -35348,14 +26885,9 @@ var LocalFontSource = class {
     this.fontAliasBySelector.set(value, key7,);
   }
   getSystemFontFamily() {
-    const fontFamilies2 =
-      // System fonts - Taken from https://furbo.org/stuff/systemfonts-new.html - "All Platforms" section
+    const fontFamilies2 = // System fonts - Taken from https://furbo.org/stuff/systemfonts-new.html - "All Platforms" section
       'system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif';
-    const fontFamily = {
-      name: systemFontFamilyName,
-      fonts: [],
-      source: this.name,
-    };
+    const fontFamily = { name: systemFontFamilyName, fonts: [], source: this.name, };
     const aliases = /* @__PURE__ */ new Map();
     const weights = [400, 100, 200, 300, 500, 600, 700, 800, 900,];
     const styles = ['normal', 'italic',];
@@ -35363,29 +26895,19 @@ var LocalFontSource = class {
       for (const weight of weights) {
         const variant = createVariantName(weight, style,);
         const alias = `__SystemDefault-${weight}-${style}__`;
-        const font = {
-          variant,
-          selector: alias,
-          style,
-          weight,
-          family: fontFamily,
-        };
+        const font = { variant, selector: alias, style, weight, family: fontFamily, };
         fontFamily.fonts.push(font,);
         aliases.set(alias, fontFamilies2,);
       }
     }
-    return {
-      fontFamily,
-      aliases,
-    };
+    return { fontFamily, aliases, };
   }
   getFontAliasBySelector(selector,) {
     return this.fontAliasBySelector.get(selector,) || null;
   }
   getFontSelectorByAlias(alias,) {
     return this.fontAliases.get(alias,) || null;
-  }
-  /** Font family aliases are in the format of `__Alias-Name__` */
+  } /** Font family aliases are in the format of `__Alias-Name__` */
   isFontFamilyAlias(value,) {
     if (value && /^__.*__$/u.exec(value,)) return true;
     return false;
@@ -35404,12 +26926,8 @@ var fontWeightNames = {
 };
 function createVariantName(weight, style,) {
   const friendlyStyle = style === 'normal' ? 'Regular' : 'Italic';
-  if (weight === 400) {
-    return friendlyStyle;
-  }
-  if (style !== 'normal') {
-    return `${fontWeightNames[weight]} ${friendlyStyle}`;
-  }
+  if (weight === 400) return friendlyStyle;
+  if (style !== 'normal') return `${fontWeightNames[weight]} ${friendlyStyle}`;
   return `${fontWeightNames[weight]}`;
 }
 var import_process4 = __toESM(require_browser(), 1,);
@@ -35422,8 +26940,7 @@ function getCustomFontName(fileName, properties,) {
 }
 var CustomFontSource = class {
   constructor() {
-    __publicField(this, 'name', 'custom',/* Custom */
-    );
+    __publicField(this, 'name', 'custom', /* Custom */);
     __publicField(this, 'fontFamilies', [],);
     __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
     __publicField(this, 'assetsByFamily', /* @__PURE__ */ new Map(),);
@@ -35435,9 +26952,7 @@ var CustomFontSource = class {
     this.assetsByFamily.clear();
     const fonts = [];
     for (const asset of assets) {
-      if (!this.isValidCustomFontAsset(asset,)) {
-        continue;
-      }
+      if (!this.isValidCustomFontAsset(asset,)) continue;
       const fontName = getCustomFontName(asset.name, asset.properties,);
       const fontFamily = this.createFontFamily(fontName,);
       const font = {
@@ -35473,11 +26988,7 @@ var CustomFontSource = class {
   createFontFamily(family,) {
     const existingFontFamily = this.byFamilyName.get(family,);
     if (existingFontFamily) return existingFontFamily;
-    const fontFamily = {
-      source: this.name,
-      name: family,
-      fonts: [],
-    };
+    const fontFamily = { source: this.name, name: family, fonts: [], };
     this.addFontFamily(fontFamily,);
     return fontFamily;
   }
@@ -35489,10 +27000,7 @@ var CustomFontSource = class {
     if (!selector.startsWith(customFontSelectorPrefix,)) return null;
     const tokens = selector.split(customFontSelectorPrefix,);
     if (tokens[1] === void 0) return null;
-    const locator = {
-      source: 'custom',
-      name: tokens[1],
-    };
+    const locator = { source: 'custom', name: tokens[1], };
     return locator;
   }
   getFontBySelector(selector, createFont = true,) {
@@ -35509,11 +27017,7 @@ var CustomFontSource = class {
   getFontFamilyByName(family,) {
     const foundFontFamily = this.byFamilyName.get(family,);
     if (foundFontFamily) return foundFontFamily;
-    const fontFamily = {
-      source: 'custom',
-      name: family,
-      fonts: [],
-    };
+    const fontFamily = { source: 'custom', name: family, fonts: [], };
     fontFamily.fonts.push({
       selector: `${customFontSelectorPrefix}${family}`,
       variant: this.inferVariantName(family,),
@@ -35526,10 +27030,7 @@ function getFontVariants(currentVariant, variants, parseVariant,) {
   if (variants.length === 0) return {};
   const currentVariantInfo = parseVariant(currentVariant,);
   if (!currentVariantInfo) return {};
-  const {
-    weight: currentWeight,
-    style: currentStyle,
-  } = currentVariantInfo;
+  const { weight: currentWeight, style: currentStyle, } = currentVariantInfo;
   const variantByWeightAndStyle = /* @__PURE__ */ new Map();
   const boldVariantByStyle = /* @__PURE__ */ new Map();
   variants.forEach((variant) => {
@@ -35538,9 +27039,7 @@ function getFontVariants(currentVariant, variants, parseVariant,) {
     if (!variantInfo) return;
     variantByWeightAndStyle.set(`${variantInfo.weight}-${variantInfo.style}`, variantName,);
     if (variantInfo.weight <= currentWeight) return;
-    if (!boldVariantByStyle.has(variantInfo.style,)) {
-      boldVariantByStyle.set(variantInfo.style, variantName,);
-    }
+    if (!boldVariantByStyle.has(variantInfo.style,)) boldVariantByStyle.set(variantInfo.style, variantName,);
   },);
   let variantBold = boldVariantByStyle.get(currentStyle,);
   let variantBoldItalic = boldVariantByStyle.get('italic',) ?? boldVariantByStyle.get('oblique',);
@@ -35555,11 +27054,7 @@ function getFontVariants(currentVariant, variants, parseVariant,) {
     variantBoldItalic = variantByWeightAndStyle.get('900-italic',) ?? variantByWeightAndStyle.get('900-oblique',) ?? variantBoldItalic;
   }
   const variantItalic = variantByWeightAndStyle.get(`${currentWeight}-italic`,) ?? variantByWeightAndStyle.get(`${currentWeight}-oblique`,);
-  return {
-    variantBold,
-    variantItalic,
-    variantBoldItalic,
-  };
+  return { variantBold, variantItalic, variantBoldItalic, };
 }
 var knownFontshareCategories = ['display', 'sans', 'serif', 'slab', 'handwritten', 'script',];
 function parseFontshareCategories(categoriesField,) {
@@ -35571,8 +27066,7 @@ function isKnownFontshareCategory(category,) {
 var fontsharePrefix = 'FS;';
 var weightNameToNumber = {
   thin: 100,
-  hairline: 100,
-  // Alternative name for "thin".
+  hairline: 100, // Alternative name for "thin".
   extralight: 200,
   light: 300,
   regular: 400,
@@ -35580,25 +27074,21 @@ var weightNameToNumber = {
   semibold: 600,
   bold: 700,
   extrabold: 800,
-  ultra: 800,
-  // Alternative name for "extrabold".
+  ultra: 800, // Alternative name for "extrabold".
   black: 900,
-  heavy: 900,
-  // Alternative name for "black".
+  heavy: 900, // Alternative name for "black".
 };
 var weightNames = Object.keys(weightNameToNumber,);
 var allowedVariantsRegex = new RegExp(`^(?:${[...weightNames, 'italic',].join('|',)})`, 'u',);
 var FontshareSource = class {
   constructor() {
-    __publicField(this, 'name', 'fontshare',/* Fontshare */
-    );
+    __publicField(this, 'name', 'fontshare', /* Fontshare */);
     __publicField(this, 'fontFamilies', [],);
     __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
   }
   getFontFamilyByName(family,) {
     return this.byFamilyName.get(family,) ?? null;
-  }
-  /**
+  } /**
    * Parses variant a string into a weight number and style, defaulting to a
    * weight of `400` and/or a style of `"normal"` depending on what isn't
    * present in the variant string.
@@ -35608,6 +27098,7 @@ var FontshareSource = class {
    *   - `"bold italic"` becomes `{ weight: 700, style: "italic" }`
    *   - `"italic"` becomes `{ weight: 400, style: "italic" }`
    */
+
   static parseVariant(variant,) {
     const variantSplit = variant.split(' ',);
     const weightName = weightNames.find((weightName2) => {
@@ -35616,10 +27107,7 @@ var FontshareSource = class {
     const styleName = variant.includes('italic',) ? 'italic' : 'normal';
     const weight = weightName && weightNameToNumber[weightName] || 400;
     const style = styleName === 'italic' ? styleName : 'normal';
-    return {
-      weight,
-      style,
-    };
+    return { weight, style, };
   }
   parseSelector(selector,) {
     if (!selector.startsWith(fontsharePrefix,)) return null;
@@ -35627,11 +27115,7 @@ var FontshareSource = class {
     if (tokens.length !== 2) return null;
     const [family, variant,] = tokens;
     if (!family || !variant) return null;
-    return {
-      name: family.replace(fontsharePrefix, '',),
-      variant,
-      source: this.name,
-    };
+    return { name: family.replace(fontsharePrefix, '',), variant, source: this.name, };
   }
   static createSelector(family, variant,) {
     return `${fontsharePrefix}${family}-${variant}`;
@@ -35648,39 +27132,21 @@ var FontshareSource = class {
       const fontStyles = fontshareFont.font_styles.filter((fontStyle) => {
         const variant = fontStyle.name.toLowerCase();
         const allowedVariantMatch = allowedVariantsRegex.exec(variant,);
-        if (!allowedVariantMatch || variant.endsWith('wide',)) {
-          return false;
-        }
+        if (!allowedVariantMatch || variant.endsWith('wide',)) return false;
         return true;
       },);
       for (const fontStyle of fontStyles) {
-        const {
-          name: family,
-        } = fontshareFont;
+        const { name: family, } = fontshareFont;
         const variant = fontStyle.name.toLowerCase();
         let fontFamily = this.getFontFamilyByName(family,);
         if (!fontFamily) {
-          fontFamily = {
-            name: family,
-            fonts: [],
-            source: this.name,
-          };
+          fontFamily = { name: family, fonts: [], source: this.name, };
           this.addFontFamily(fontFamily,);
         }
         const selector = FontshareSource.createSelector(family, variant,);
-        const variantInfo = FontshareSource.parseVariant(variant,) || {
-          weight: void 0,
-          style: void 0,
-        };
-        const {
-          weight,
-          style,
-        } = variantInfo;
-        const {
-          variantBold,
-          variantBoldItalic,
-          variantItalic,
-        } = getFontVariants(variant, fontStyles, FontshareSource.parseVariant,);
+        const variantInfo = FontshareSource.parseVariant(variant,) || { weight: void 0, style: void 0, };
+        const { weight, style, } = variantInfo;
+        const { variantBold, variantBoldItalic, variantItalic, } = getFontVariants(variant, fontStyles, FontshareSource.parseVariant,);
         const font = {
           family: fontFamily,
           variant,
@@ -35705,8 +27171,7 @@ function mapToKnownCategory(categoryString,) {
     serif: 'serif',
     sans: 'sans-serif',
     slab: 'slab',
-    display: 'display',
-    // As of Nov 2023, these two look similar enough – so we can map them into the same category.
+    display: 'display', // As of Nov 2023, these two look similar enough – so we can map them into the same category.
     handwritten: 'handwriting',
     script: 'handwriting',
   };
@@ -35718,8 +27183,7 @@ var weightNameToNumber2 = {
   Thin: 100,
   ExtraLight: 200,
   Light: 300,
-  '': 400,
-  // Regular weights have a selector like "Inter" or "Inter-Italic", with no mention of weight.
+  '': 400, // Regular weights have a selector like "Inter" or "Inter-Italic", with no mention of weight.
   Medium: 500,
   SemiBold: 600,
   Bold: 700,
@@ -35728,8 +27192,7 @@ var weightNameToNumber2 = {
 };
 var FramerFontSource = class {
   constructor() {
-    __publicField(this, 'name', 'framer',/* Framer */
-    );
+    __publicField(this, 'name', 'framer', /* Framer */);
     __publicField(this, 'fontFamilies', [],);
     __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
   }
@@ -35737,11 +27200,7 @@ var FramerFontSource = class {
     return this.byFamilyName.get(family,) ?? null;
   }
   addFontFamily(familyName,) {
-    const fontFamily = {
-      name: familyName,
-      fonts: [],
-      source: this.name,
-    };
+    const fontFamily = { name: familyName, fonts: [], source: this.name, };
     this.fontFamilies.push(fontFamily,);
     this.byFamilyName.set(fontFamily.name, fontFamily,);
     return fontFamily;
@@ -35754,32 +27213,17 @@ var FramerFontSource = class {
     const style = weightAndStyleInfo.includes('Italic',) ? 'italic' : 'normal';
     const weightName = weightAndStyleInfo.replace('Italic', '',);
     const weight = weightName && weightNameToNumber2[weightName] || 400;
-    return {
-      family,
-      style,
-      weight,
-      source: 'framer',
-      variant: void 0,
-      category: 'sans-serif',
-    };
+    return { family, style, weight, source: 'framer', variant: void 0, category: 'sans-serif', };
   }
   importFonts(framerFonts,) {
     this.fontFamilies.length = 0;
     this.byFamilyName.clear();
     const fonts = [];
     framerFonts.forEach((framerFont) => {
-      const {
-        familyName,
-        ...rest
-      } = framerFont;
+      const { familyName, ...rest } = framerFont;
       let fontFamily = this.getFontFamilyByName(familyName,);
-      if (!fontFamily) {
-        fontFamily = this.addFontFamily(familyName,);
-      }
-      const font = {
-        ...rest,
-        family: fontFamily,
-      };
+      if (!fontFamily) fontFamily = this.addFontFamily(familyName,);
+      const font = { ...rest, family: fontFamily, };
       fontFamily.fonts.push(font,);
       fonts.push(font,);
     },);
@@ -35789,8 +27233,7 @@ var FramerFontSource = class {
 var googleFontSelectorPrefix = 'GF;';
 var GoogleFontSource = class {
   constructor() {
-    __publicField(this, 'name', 'google',/* Google */
-    );
+    __publicField(this, 'name', 'google', /* Google */);
     __publicField(this, 'fontFamilies', [],);
     __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
   }
@@ -35798,20 +27241,12 @@ var GoogleFontSource = class {
     return this.byFamilyName.get(family,) ?? null;
   }
   static parseVariant(variant,) {
-    if (variant === 'regular') {
-      return {
-        style: 'normal',
-        weight: 400,
-      };
-    }
+    if (variant === 'regular') return { style: 'normal', weight: 400, };
     const match = /(\d*)(normal|italic)?/.exec(variant,);
     if (!match) return null;
     const weight = parseInt(match[1] || '400',);
     const style = match[2] === 'italic' ? 'italic' : 'normal';
-    return {
-      weight,
-      style,
-    };
+    return { weight, style, };
   }
   parseSelector(selector,) {
     if (!selector.startsWith(googleFontSelectorPrefix,)) return null;
@@ -35819,21 +27254,13 @@ var GoogleFontSource = class {
     if (tokens.length !== 2) return null;
     const [family, variant,] = tokens;
     if (!family || !variant) return null;
-    return {
-      name: family.replace(googleFontSelectorPrefix, '',),
-      variant,
-      source: this.name,
-    };
+    return { name: family.replace(googleFontSelectorPrefix, '',), variant, source: this.name, };
   }
   static createSelector(family, variant,) {
     return `${googleFontSelectorPrefix}${family}-${variant}`;
   }
   addFontFamily(family,) {
-    const fontFamily = {
-      name: family,
-      fonts: [],
-      source: this.name,
-    };
+    const fontFamily = { name: family, fonts: [], source: this.name, };
     this.fontFamilies.push(fontFamily,);
     this.byFamilyName.set(fontFamily.name, fontFamily,);
     return fontFamily;
@@ -35847,20 +27274,15 @@ var GoogleFontSource = class {
         var _a;
         const family = webFont.family;
         let fontFamily = this.getFontFamilyByName(family,);
-        if (!fontFamily) {
-          fontFamily = this.addFontFamily(family,);
-        }
+        if (!fontFamily) fontFamily = this.addFontFamily(family,);
         const variantInfo = GoogleFontSource.parseVariant(variant,) ?? {};
-        const {
-          weight,
-          style,
-        } = variantInfo;
+        const { weight, style, } = variantInfo;
         const selector = GoogleFontSource.createSelector(family, variant,);
-        const {
-          variantBold,
-          variantItalic,
-          variantBoldItalic,
-        } = getFontVariants(variant, webFont.variants, GoogleFontSource.parseVariant,);
+        const { variantBold, variantItalic, variantBoldItalic, } = getFontVariants(
+          variant,
+          webFont.variants,
+          GoogleFontSource.parseVariant,
+        );
         const font = {
           family: fontFamily,
           variant,
@@ -35904,12 +27326,7 @@ var fontRequests = /* @__PURE__ */ new Map();
 var fontReadyPromises = /* @__PURE__ */ new Map();
 var loadFont = (data2, doc,) => loadFontWithRetries(data2, doc,);
 async function loadFontWithRetries(data2, doc, attempt = 0,) {
-  const {
-    family,
-    url,
-    stretch,
-    unicodeRange,
-  } = data2;
+  const { family, url, stretch, unicodeRange, } = data2;
   const weight = data2.weight || 500;
   const style = data2.style || 'normal';
   const requestId = `${family}-${style}-${weight}-${url}`;
@@ -35924,22 +27341,13 @@ async function loadFontWithRetries(data2, doc, attempt = 0,) {
       doc.fonts.add(fontFace,);
       return isFontReady(family, style, weight,);
     },).catch((e) => {
-      if (e.name !== 'NetworkError') {
-        throw e;
-      }
-      if (attempt < MAX_RETRIES) {
-        return loadFontWithRetries(data2, doc, attempt + 1,);
-      }
-      throw new FontLoadingError(`Font loading failed after ${attempt} retries due to network error: ${
-        JSON.stringify({
-          family,
-          style,
-          weight,
-          url,
-          stretch,
-          unicodeRange,
-        },)
-      }`,);
+      if (e.name !== 'NetworkError') throw e;
+      if (attempt < MAX_RETRIES) return loadFontWithRetries(data2, doc, attempt + 1,);
+      throw new FontLoadingError(
+        `Font loading failed after ${attempt} retries due to network error: ${
+          JSON.stringify({ family, style, weight, url, stretch, unicodeRange, },)
+        }`,
+      );
     },);
     fontRequests.set(requestId, readyPromise,);
   }
@@ -35948,23 +27356,16 @@ async function loadFontWithRetries(data2, doc, attempt = 0,) {
 async function isFontReady(family, style, weight,) {
   const readyPromiseId = `${family}-${style}-${weight}`;
   if (!fontReadyPromises.has(readyPromiseId,)) {
-    const observer2 = new import_fontfaceobserver.default(family, {
-      style,
-      weight,
-    },);
+    const observer2 = new import_fontfaceobserver.default(family, { style, weight, },);
     const readyPromise = observer2.load(null, FONT_LOADING_TIMEOUT,);
     fontReadyPromises.set(readyPromiseId, readyPromise,);
   }
   try {
     await fontReadyPromises.get(readyPromiseId,);
   } catch (e) {
-    throw new FontLoadingError(`Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${
-      JSON.stringify({
-        family,
-        style,
-        weight,
-      },)
-    }`,);
+    throw new FontLoadingError(
+      `Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${JSON.stringify({ family, style, weight, },)}`,
+    );
   }
 }
 var FontStore = class {
@@ -36016,9 +27417,7 @@ var FontStore = class {
       this.getFontshareFontsListPromise = runtime.fetchFontshareFontsList();
       const fontshareFonts = await this.getFontshareFontsListPromise;
       for (const font of this.fontshare.importFonts(fontshareFonts,)) {
-        if (!this.googleFamilyNames.has(font.family.name.toLowerCase(),)) {
-          this.addFont(font,);
-        }
+        if (!this.googleFamilyNames.has(font.family.name.toLowerCase(),)) this.addFont(font,);
       }
     }
     return this.getFontshareFontsListPromise;
@@ -36030,25 +27429,18 @@ var FontStore = class {
   }
   importCustomFonts(assets,) {
     this.bySelector.forEach((_, key7,) => {
-      if (key7.startsWith(customFontSelectorPrefix,)) {
-        this.bySelector.delete(key7,);
-      }
+      if (key7.startsWith(customFontSelectorPrefix,)) this.bySelector.delete(key7,);
     },);
-    for (const font of this.custom.importFonts(assets,)) {
-      this.addFont(font,);
-    }
+    for (const font of this.custom.importFonts(assets,)) this.addFont(font,);
   }
   getFontFamily(info,) {
     const fontFamily = this[info.source].getFontFamilyByName(info.name,);
     return fontFamily;
   }
   getFontBySelector(selector, createFont = true,) {
-    if (selector.startsWith(customFontSelectorPrefix,)) {
-      return this.custom.getFontBySelector(selector, createFont,);
-    }
+    if (selector.startsWith(customFontSelectorPrefix,)) return this.custom.getFontBySelector(selector, createFont,);
     return this.bySelector.get(selector,);
-  }
-  // Function called by draft to get font properties for a selector, before the (google) font is available in the store
+  } // Function called by draft to get font properties for a selector, before the (google) font is available in the store
   // It replaces a previous function that created Font instances and added them to the store
   // on the fly while rendering drafts, which caused issues (overriding real google font info with fake instances with partial data).
   // Ideally this should not happen, but that's a fix for another day
@@ -36093,44 +27485,31 @@ var FontStore = class {
       }
     }
     const framerFontDraftProperties = FramerFontSource.getDraftFontPropertiesBySelector(selector,);
-    if (framerFontDraftProperties) {
-      return framerFontDraftProperties;
-    }
+    if (framerFontDraftProperties) return framerFontDraftProperties;
     return null;
   }
   isSelectorLoaded(selector,) {
     return this.loadedSelectors.has(selector,);
-  }
-  /**
+  } /**
    * Load a single font
    */
+
   async loadFont(font,) {
-    if (this.isSelectorLoaded(font.selector,)) {
-      return 0;
-    }
+    if (this.isSelectorLoaded(font.selector,)) return 0;
     const source = font.family.source;
     switch (source) {
       case 'local':
         this.loadedSelectors.add(font.selector,);
         return 1;
       case 'framer':
-        if (import_process4.default.env.NODE_ENV !== 'test') {
-          await isFontReady(font.family.name, font.style, font.weight,);
-        }
+        if (import_process4.default.env.NODE_ENV !== 'test') await isFontReady(font.family.name, font.style, font.weight,);
         this.loadedSelectors.add(font.selector,);
         return 1;
       case 'google':
       case 'fontshare':
       case 'custom':
-        if (!font.file) {
-          return Promise.reject(`Unable to load font: ${font.selector}`,);
-        }
-        await loadFont({
-          family: font.family.name,
-          url: font.file,
-          weight: font.weight,
-          style: font.style,
-        }, document,);
+        if (!font.file) return Promise.reject(`Unable to load font: ${font.selector}`,);
+        await loadFont({ family: font.family.name, url: font.file, weight: font.weight, style: font.style, }, document,);
         this.loadedSelectors.add(font.selector,);
         return 1;
       default:
@@ -36156,22 +27535,17 @@ var FontStore = class {
     const fonts = selectors.map((s) => this.bySelector.get(s,)).filter((f) => !!f);
     return Promise.allSettled(fonts.map((f) => this.loadFont(f,)),);
   }
-  async loadFonts(fontSelectors,) {
-    const results = await this.loadFontsFromSelectors(fontSelectors,);
-    const newlyLoadedFontCount = results.filter((result) => result.status === 'fulfilled' && result.value === 1/* Loaded */
-    ).length;
-    return {
-      newlyLoadedFontCount,
-    };
-  }
-  // Deprecated methods that are kept for backwards compatibility with any compiled code that might still be using them
+  async loadFonts(fontSelectors,) {
+    const results = await this.loadFontsFromSelectors(fontSelectors,);
+    const newlyLoadedFontCount = results.filter((result) => result.status === 'fulfilled' && result.value === 1 /* Loaded */).length;
+    return { newlyLoadedFontCount, };
+  } // Deprecated methods that are kept for backwards compatibility with any compiled code that might still be using them
   /**
    * @deprecated This method’s API is confusing as 1) it works for all fonts,
    * not just missing ones, 2) it supports both async/await and a callback,
    * but the callback is called only if *all* fonts have been loaded. Use
    * `loadFonts` instead.
-   */
-  async loadMissingFonts(fontSelectors, fontsLoadedCallback,) {
+   */ async loadMissingFonts(fontSelectors, fontsLoadedCallback,) {
     const selectors = fontSelectors.filter((selector) => {
       return !fontStore.isSelectorLoaded(selector,);
     },);
@@ -36181,45 +27555,32 @@ var FontStore = class {
       return fontStore.isSelectorLoaded(selector,);
     },);
     if (isEachFontLoaded && fontsLoadedCallback) fontsLoadedCallback();
-  }
-  /**
+  } /**
    * @deprecated This method is misleading as it works with all fonts, not
    * just web fonts. Use `loadFonts` instead. (In Framer, “web fonts” has a
    * specific meaning: it refers to Google/Fontshare fonts and exludes custom
    * and local fonts. See e.g. `WebFontStore` and the “Web”/“Custom” toggle in
    * the font picker in the UI. More context: https://github.com/framer/FramerStudio/pull/15778#discussion_r1395120760)
    */
+
   async loadWebFontsFromSelectors(selectors,) {
     return this.loadFontsFromSelectors(selectors,);
-  }
-  // defaultFont doesn’t seem to be used anywhere in our code (except tests),
+  } // defaultFont doesn’t seem to be used anywhere in our code (except tests),
   // but keeping it for backwards compatibility with any compiled code.
-  /** @deprecated This will be removed in the future. Don’t use it. */
-  get defaultFont() {
+  /** @deprecated This will be removed in the future. Don’t use it. */ get defaultFont() {
     const defaultFont = this.getFontBySelector('Inter',);
     assert(defaultFont, 'Can\u2019t find Inter font',);
     return defaultFont;
   }
 };
 var fontStore = /* @__PURE__ */ new FontStore();
-Promise.allSettled = Promise.allSettled || ((promises) =>
-  Promise.all(promises.map((p) =>
-    p.then((v) => ({
-      status: 'fulfilled',
-      value: v,
-    })).catch((e) => ({
-      status: 'rejected',
-      reason: e,
-    }))
-  ),));
-function CustomProperties({
-  children,
-  customProperties,
-},) {
-  return /* @__PURE__ */ _jsx5('div', {
-    style: customProperties,
-    children,
-  },);
+Promise.allSettled = Promise.allSettled ||
+  ((promises) =>
+    Promise.all(
+      promises.map((p) => p.then((v) => ({ status: 'fulfilled', value: v, })).catch((e) => ({ status: 'rejected', reason: e, }))),
+    ));
+function CustomProperties({ children, customProperties, },) {
+  return /* @__PURE__ */ _jsx5('div', { style: customProperties, children, },);
 }
 var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
   var _a;
@@ -36228,9 +27589,7 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
       super(...arguments,);
       __publicField(this, 'state', {},);
       __publicField(this, 'setElement', (element) => {
-        if (this.props.innerRef) {
-          this.props.innerRef.current = element;
-        }
+        if (this.props.innerRef) this.props.innerRef.current = element;
         this.setLayerElement(element,);
       },);
     }
@@ -36240,62 +27599,37 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
       let currentIndex = 0;
       if (stack) {
         for (const line of stack) {
-          if (line.startsWith(`    in ${this.constructor.name}`,)) {
-            break;
-          }
+          if (line.startsWith(`    in ${this.constructor.name}`,)) break;
           currentIndex++;
         }
         stack = stack.slice(0, currentIndex,);
       }
-      this.setState({
-        lastError: {
-          children: this.props.children,
-          name: error.name,
-          message: error.message,
-          componentStack: stack,
-        },
-      },);
+      this.setState({ lastError: { children: this.props.children, name: error.name, message: error.message, componentStack: stack, }, },);
     }
     renderErrorPlaceholder(file, error,) {
-      const {
-        RenderPlaceholder,
-      } = runtime;
+      const { RenderPlaceholder, } = runtime;
       return /* @__PURE__ */ _jsx5(FrameWithMotion, {
         ...this.props,
         background: null,
-        children: /* @__PURE__ */ _jsx5(RenderPlaceholder, {
-          error: {
-            error,
-            file,
-          },
-        },),
+        children: /* @__PURE__ */ _jsx5(RenderPlaceholder, { error: { error, file, }, },),
       },);
     }
     render() {
       var _a2, _b;
       countNodeRender();
-      let {
-        children,
-      } = this.props;
-      const {
-        componentIdentifier,
-      } = this.props;
-      const {
-        lastError: error,
-      } = this.state;
+      let { children, } = this.props;
+      const { componentIdentifier, } = this.props;
+      const { lastError: error, } = this.state;
       const noChildren = !children || Array.isArray(children,) && children.filter((c) => c).length === 0;
       if (noChildren) {
         const errorComponent = runtime.componentLoader.errorForIdentifier(componentIdentifier,);
-        if (errorComponent) {
-          return this.renderErrorPlaceholder(errorComponent.file, errorComponent.error,);
-        }
+        if (errorComponent) return this.renderErrorPlaceholder(errorComponent.file, errorComponent.error,);
       }
       if (error && error.children === children) {
         const component = runtime.componentLoader.componentForIdentifier(componentIdentifier,);
         const file = component ? component.file : '???';
         return this.renderErrorPlaceholder(file, error.message,);
       }
-
       (_b = (_a2 = asRecord(safeWindow,))['__checkComponentBudget__']) == null ? void 0 : _b.call(_a2,);
       let frameProps = this.props;
       if (RenderTarget.current() !== 'CANVAS') {
@@ -36321,8 +27655,7 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
           positionStickyTop,
           positionStickyRight,
           positionStickyBottom,
-          positionStickyLeft,
-          // Remove the children and the componentIdentifier from the props passed into the component
+          positionStickyLeft, // Remove the children and the componentIdentifier from the props passed into the component
           componentIdentifier: originalComponentIdentifier,
           children: originalChildren,
           style,
@@ -36332,9 +27665,7 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
           ...childProps
         } = frameProps;
         children = React__default.Children.map(originalChildren, (child) => {
-          if (!isReactChild(child,) || !isReactElement(child,)) {
-            return child;
-          }
+          if (!isReactChild(child,) || !isReactElement(child,)) return child;
           if (!isPageOrScroll(originalComponentIdentifier,)) {
             return /* @__PURE__ */ _jsx5(LayoutGroup, {
               inherit: false,
@@ -36382,9 +27713,7 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
          * but published design components can contain an old version of the presentation tree that expects the background
          * that is passed to be rendered here
          * See the stackBackgroundTest.tsx integration test for an example of such a case
-         */
-        /* @__PURE__ */
-        _jsx5(ComponentContainerContext.Provider, {
+         */ /* @__PURE__ */ _jsx5(ComponentContainerContext.Provider, {
           value: true,
           children: /* @__PURE__ */ _jsx5(FrameWithMotion, {
             'data-framer-component-container': true,
@@ -36399,15 +27728,8 @@ var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
     }
   },
     __publicField(_a, 'supportsConstraints', true,),
-    __publicField(_a, 'defaultComponentContainerProps', {
-      style: {},
-      visible: true,
-      componentIdentifier: '',
-    },),
-    __publicField(_a, 'defaultProps', {
-      ...Layer.defaultProps,
-      ..._a.defaultComponentContainerProps,
-    },),
+    __publicField(_a, 'defaultComponentContainerProps', { style: {}, visible: true, componentIdentifier: '', },),
+    __publicField(_a, 'defaultProps', { ...Layer.defaultProps, ..._a.defaultComponentContainerProps, },),
     __publicField(_a, 'contextType', ComponentContainerContext,),
     _a;
 })();
@@ -36417,21 +27739,10 @@ function isPageOrScroll(identifier,) {
   if (identifier === 'framer/Scroll') return true;
   return false;
 }
-var FormButton = /* @__PURE__ */ React__default.forwardRef(function FormButon({
-  type = 'submit',
-  value = 'Submit',
-  ...props
-}, ref,) {
-  const {
-    style: baseStyle2,
-  } = props;
+var FormButton = /* @__PURE__ */ React__default.forwardRef(function FormButon({ type = 'submit', value = 'Submit', ...props }, ref,) {
+  const { style: baseStyle2, } = props;
   const style = mergeWithDefaultStyle(baseStyle2 ?? {},);
-  return /* @__PURE__ */ _jsx5(motion.input, {
-    type,
-    ref,
-    style,
-    value,
-  },);
+  return /* @__PURE__ */ _jsx5(motion.input, { type, ref, style, value, },);
 },);
 function mergeWithDefaultStyle(style,) {
   return {
@@ -36448,108 +27759,49 @@ function mergeWithDefaultStyle(style,) {
     ...style,
   };
 }
-function formReducer(_state, {
-  type,
-},) {
+function formReducer(_state, { type, },) {
   switch (type) {
     case 'submit':
-      return {
-        state: 'pending',
-      };
+      return { state: 'pending', };
     case 'success':
-      return {
-        state: 'success',
-      };
+      return { state: 'success', };
     case 'error':
-      return {
-        state: 'error',
-      };
+      return { state: 'error', };
     default:
       assertNever(type,);
   }
 }
-var FormContainer = ({
-  action,
-  formId,
-  disabled,
-  children,
-  ...props
-},) => {
-  const [state, dispatch,] = React__default.useReducer(formReducer, {
-    state: disabled ? 'disabled' : void 0,
-  },);
+var FormContainer = ({ action, formId, disabled, children, ...props },) => {
+  const [state, dispatch,] = React__default.useReducer(formReducer, { state: disabled ? 'disabled' : void 0, },);
   const handleSubmit = async (event) => {
     event.preventDefault();
     if (!action) return;
     const data2 = new FormData(event.currentTarget,);
-    for (const [key7, value,] of data2) {
-      if (value instanceof File) data2.delete(key7,);
-    }
+    for (const [key7, value,] of data2) if (value instanceof File) data2.delete(key7,);
     try {
-      dispatch({
-        type: 'submit',
-      },);
-      await fetch(action, {
-        body: data2,
-        method: 'POST',
-      },);
-      dispatch({
-        type: 'success',
-      },);
+      dispatch({ type: 'submit', },);
+      await fetch(action, { body: data2, method: 'POST', },);
+      dispatch({ type: 'success', },);
     } catch (error) {
-      dispatch({
-        type: 'error',
-      },);
+      dispatch({ type: 'error', },);
     }
   };
-  return /* @__PURE__ */ _jsx5(motion.form, {
-    ...props,
-    'data-formid': formId,
-    onSubmit: handleSubmit,
-    children: children(state,),
-  },);
+  return /* @__PURE__ */ _jsx5(motion.form, { ...props, 'data-formid': formId, onSubmit: handleSubmit, children: children(state,), },);
 };
-var passwordManagerIgnoreDataProps = {
-  // 1Password
-  'data-1p-ignore': true,
-  // LastPass
+var passwordManagerIgnoreDataProps = { // 1Password
+  'data-1p-ignore': true, // LastPass
   'data-lpignore': true,
 };
-var sensibleInputDefaults = {
-  autocomplete: 'off',
-};
-var labelStyles = {
-  display: 'flex',
-  flexDirection: 'column',
-  marginBottom: 8,
-};
+var sensibleInputDefaults = { autocomplete: 'off', };
+var labelStyles = { display: 'flex', flexDirection: 'column', marginBottom: 8, };
 var inputClassName = 'framer-form-input';
 var labelClassName = 'framer-form-label';
 var PlainTextInput = /* @__PURE__ */ React__default.forwardRef(function FormPlainTextInput(props, ref,) {
-  const {
-    style,
-    inputName,
-    label,
-    type,
-    required,
-    autoFocus,
-    placeholder,
-    hideInputLabel,
-    ...rest
-  } = props;
-  const dataProps = {
-    ...sensibleInputDefaults,
-    ...passwordManagerIgnoreDataProps,
-  };
-  const baseWrapperStyle = {
-    display: 'flex',
-    flexDirection: 'column',
-  };
+  const { style, inputName, label, type, required, autoFocus, placeholder, hideInputLabel, ...rest } = props;
+  const dataProps = { ...sensibleInputDefaults, ...passwordManagerIgnoreDataProps, };
+  const baseWrapperStyle = { display: 'flex', flexDirection: 'column', };
   const isHiddenInput = type === 'hidden';
-  const baseStyle2 = {
-    width: '100%',
-    flexGrow: 1,
-  };
+  const baseStyle2 = { width: '100%', flexGrow: 1, };
   const input = /* @__PURE__ */ _jsx5(motion.input, {
     id: inputName,
     ...dataProps,
@@ -36561,25 +27813,14 @@ var PlainTextInput = /* @__PURE__ */ React__default.forwardRef(function FormPlai
     placeholder,
     className: inputClassName,
   },);
-  if (isHiddenInput) {
-    return input;
-  }
+  if (isHiddenInput) return input;
   return /* @__PURE__ */ _jsxs(motion.div, {
     ref,
-    style: {
-      ...baseWrapperStyle,
-      ...style,
-    },
+    style: { ...baseWrapperStyle, ...style, },
     ...rest,
     children: [
-      label && !hideInputLabel && /* @__PURE__ */ _jsx5('label', {
-        htmlFor: inputName,
-        style: {
-          ...labelStyles,
-        },
-        className: labelClassName,
-        children: label,
-      },),
+      label && !hideInputLabel && /* @__PURE__ */
+      _jsx5('label', { htmlFor: inputName, style: { ...labelStyles, }, className: labelClassName, children: label, },),
       input,
     ],
   },);
@@ -36609,30 +27850,15 @@ var FormPlainTextInput2 = /* @__PURE__ */ withCSS(PlainTextInput, [
     }`,
 ],);
 var Image2 = /* @__PURE__ */ React__default.forwardRef(function Image3(props, ref,) {
-  const {
-    background,
-    children,
-    alt,
-    ...rest
-  } = props;
-  const style = {
-    ...rest.style,
-  };
-  if (background) {
-    delete style.background;
-  }
+  const { background, children, alt, ...rest } = props;
+  const style = { ...rest.style, };
+  if (background) delete style.background;
   const MotionComponent = htmlElementAsMotionComponent(props.as,);
   return /* @__PURE__ */ _jsxs(MotionComponent, {
     ...rest,
     style,
     ref,
-    children: [
-      background && /* @__PURE__ */ _jsx5(BackgroundImageComponent, {
-        image: background,
-        alt,
-      },),
-      children,
-    ],
+    children: [background && /* @__PURE__ */ _jsx5(BackgroundImageComponent, { image: background, alt, },), children,],
   },);
 },);
 function isShallowEqualArray(a, b,) {
@@ -36660,9 +27886,7 @@ function convertCodeComponentContainer(componentDefinitionProvider, node, conver
   const codeComponentSlots = node.getComponentSlotChildren ? node.getComponentSlotChildren(componentDefinitionProvider,) : {};
   let codeComponentPresentation;
   const props = node.getCodeComponentProps
-    ? node.getCodeComponentProps(componentDefinitionProvider, {
-      skipCache: skipCodeComponentPropsCache,
-    },)
+    ? node.getCodeComponentProps(componentDefinitionProvider, { skipCache: skipCodeComponentPropsCache, },)
     : void 0;
   if (node.cache.codeComponentPresentation) {
     codeComponentPresentation = node.cache.codeComponentPresentation;
@@ -36676,11 +27900,7 @@ function convertCodeComponentContainer(componentDefinitionProvider, node, conver
       codeComponentPresentation.props = props;
     }
   } else {
-    const {
-      id: containerId,
-      codeComponentIdentifier: identifier,
-      codeComponentPackageVersion,
-    } = node;
+    const { id: containerId, codeComponentIdentifier: identifier, codeComponentPackageVersion, } = node;
     node.cache.codeComponentPresentation = codeComponentPresentation = new CodeComponentPresentation(
       containerId + identifier,
       identifier,
@@ -36692,9 +27912,7 @@ function convertCodeComponentContainer(componentDefinitionProvider, node, conver
   codeComponentPresentation.props.placeholders = node.cache.placeholders;
   const slotKeys = Object.keys(codeComponentSlots,);
   if (slotKeys.length) {
-    codeComponentPresentation.props = {
-      ...codeComponentPresentation.props,
-    };
+    codeComponentPresentation.props = { ...codeComponentPresentation.props, };
     codeComponentPresentation.props.__slotKeys = slotKeys;
     for (const slotKey of slotKeys) {
       const slotChildren = (_a = codeComponentSlots[slotKey]) == null
@@ -36725,31 +27943,15 @@ var CodeComponentPresentation = class {
     __publicField(this, 'cache', {},);
   }
   getProps() {
-    return {
-      ...this.props,
-      id: this.id,
-      key: this.id,
-    };
+    return { ...this.props, id: this.id, key: this.id, };
   }
   rect(_parentSizeInfo,) {
-    return {
-      x: 0,
-      y: 0,
-      width: 0,
-      height: 0,
-    };
+    return { x: 0, y: 0, width: 0, height: 0, };
   }
 };
 var htmlRegExp = /[&<>'"]/g;
 var escapeHTML = (str) =>
-  str.replace(htmlRegExp, (tag) =>
-    ({
-      '&': '&amp;',
-      '<': '&lt;',
-      '>': '&gt;',
-      '\'': '&#39;',
-      '"': '&quot;',
-    })[tag] || tag,);
+  str.replace(htmlRegExp, (tag) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\'': '&#39;', '"': '&quot;', })[tag] || tag,);
 var regex =
   /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
 function replaceFramerPageLinks(rawHTML, getRoute, currentRoute, implicitPathVariables,) {
@@ -36766,18 +27968,15 @@ function replaceFramerPageLinks(rawHTML, getRoute, currentRoute, implicitPathVar
     if (!targetPath || !currentPath) return original;
     let attributes = ` ${'data-framer-page-link-target'}="${pageLink.target}"`;
     const elementId = getRouteElementId(targetRoute, pageLink.element ?? void 0,);
-    if (elementId) {
-      attributes += ` ${'data-framer-page-link-element'}="${pageLink.element}"`;
-    }
+    if (elementId) attributes += ` ${'data-framer-page-link-element'}="${pageLink.element}"`;
     const link = linkFromFramerPageLink(href,);
     if (!link || isString22(link,)) return original;
-    if (linkMatchesRoute(currentRoute, link, implicitPathVariables,)) {
-      attributes += ` ${'data-framer-page-link-current'}`;
-    }
+    if (linkMatchesRoute(currentRoute, link, implicitPathVariables,)) attributes += ` ${'data-framer-page-link-current'}`;
     let relativePath = targetPath;
     const pathVariables = Object.assign({}, implicitPathVariables, (_a = pageLink.collectionItem) == null ? void 0 : _a.pathVariables,);
     if (Object.keys(pathVariables,).length > 0) {
-      relativePath = relativePath.replace(pathVariablesRegExp2, (_, key7,) => '' + pathVariables[key7],);
+      relativePath = relativePath.replace(pathVariablesRegExp2, (_, key7,) =>
+        '' + pathVariables[key7],);
     }
     if ((_b = pageLink.collectionItem) == null ? void 0 : _b.pathVariables) {
       const params = new URLSearchParams(pageLink.collectionItem.pathVariables,);
@@ -36787,13 +27986,7 @@ function replaceFramerPageLinks(rawHTML, getRoute, currentRoute, implicitPathVar
     return pre1 + pre2 + `"${escapeHTML(relativePath + (elementId ? `#${elementId}` : ''),)}"` + attributes + post;
   },);
 }
-var htmlEscapes = {
-  '&': '&amp;',
-  '<': '&lt;',
-  '>': '&gt;',
-  '"': '&quot;',
-  '\'': '&#39;',
-};
+var htmlEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', };
 var reUnescapedHtml = /[&<>"']/gu;
 var reHasUnescapedHtml = RegExp(reUnescapedHtml.source,);
 function escapeHTML2(str,) {
@@ -36844,10 +28037,7 @@ var DeprecatedRichText = /* @__PURE__ */ React.forwardRef(function Text(props, f
   const layoutId = useLayoutId2(props,);
   const fallbackLayoutRef = useRef(null,);
   const layoutRef = forwardedRef ?? fallbackLayoutRef;
-  const {
-    navigate,
-    getRoute,
-  } = useRouter();
+  const { navigate, getRoute, } = useRouter();
   const currentRoute = useCurrentRoute();
   useRoutePreloader(props.preload ?? [],);
   useMeasureLayout(props, layoutRef,);
@@ -36857,22 +28047,17 @@ var DeprecatedRichText = /* @__PURE__ */ React.forwardRef(function Text(props, f
   const forwardedOverrideId = _forwardedOverrideId ?? id3;
   if (forwardedOverrideId && _forwardedOverrides) {
     const override = _forwardedOverrides[forwardedOverrideId];
-    if (typeof override === 'string') {
-      textOrOverride = override;
-    }
+    if (typeof override === 'string') textOrOverride = override;
   }
   let innerHTML = '';
   if (textOrOverride) {
     const escapedText = escapeHTML2(textOrOverride,);
     innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText,) : `<p>${escapedText}</p>`;
-  } else if (html) {
-    innerHTML = html;
-  } else if (textFromDesign) {
+  } else if (html) innerHTML = html;
+  else if (textFromDesign) {
     const escapedText = escapeHTML2(textFromDesign,);
     innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText,) : `<p>${escapedText}</p>`;
-  } else if (htmlFromDesign) {
-    innerHTML = htmlFromDesign;
-  }
+  } else if (htmlFromDesign) innerHTML = htmlFromDesign;
   const implicitPathVariables = useImplicitPathVariables();
   const innerHTMLWithReplacedFramerPageLinks = React.useMemo(() => {
     if (isOnCanvas || !getRoute || !currentRoute) return innerHTML;
@@ -36885,9 +28070,7 @@ var DeprecatedRichText = /* @__PURE__ */ React.forwardRef(function Text(props, f
       const anchorElement = findAnchorElement(event.target, layoutRef.current,);
       if (event.metaKey || !navigate || !anchorElement || anchorElement.getAttribute('target',) === '_blank') return;
       const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables,);
-      if (didNavigate) {
-        event.preventDefault();
-      }
+      if (didNavigate) event.preventDefault();
     }
     container.addEventListener('click', interceptPageLinks,);
     return () => {
@@ -36939,15 +28122,11 @@ var DeprecatedRichText = /* @__PURE__ */ React.forwardRef(function Text(props, f
         style.bottom = positionStickyBottom;
         style.left = positionStickyLeft;
       }
-    } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
-      style.position = 'absolute';
-    }
+    } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) style.position = 'absolute';
   }
   collectFiltersFromProps(props, style,);
   collectTextShadowsForProps(props, style,);
-  if (willChangeTransform) {
-    forceLayerBackingWithCSSProperties(style,);
-  }
+  if (willChangeTransform) forceLayerBackingWithCSSProperties(style,);
   Object.assign(style, props.style,);
   return /* @__PURE__ */ _jsx5(motion.div, {
     id: id3,
@@ -36960,9 +28139,7 @@ var DeprecatedRichText = /* @__PURE__ */ React.forwardRef(function Text(props, f
     'data-center': center,
     className: cx(className, stylesPresetsClassName, richTextWrapperClassName,),
     transformTemplate: template,
-    dangerouslySetInnerHTML: {
-      __html: innerHTMLWithReplacedFramerPageLinks,
-    },
+    dangerouslySetInnerHTML: { __html: innerHTMLWithReplacedFramerPageLinks, },
   },);
 },);
 function convertVerticalAlignment(verticalAlignment,) {
@@ -36979,22 +28156,13 @@ function useLoadFonts(fonts, fromCanvasComponent, containerRef,) {
   const prevFontsRef = useRef([],);
   if (!isShallowEqualArray(prevFontsRef.current, fonts,)) {
     prevFontsRef.current = fonts;
-    void fontStore.loadFonts(fonts,).then(({
-      newlyLoadedFontCount,
-    },) => {
+    void fontStore.loadFonts(fonts,).then(({ newlyLoadedFontCount, },) => {
       if (!fromCanvasComponent || !containerRef.current || RenderTarget.current() !== 'CANVAS') return;
-      if (newlyLoadedFontCount > 0) {
-        measureClosestComponentContainer(containerRef.current,);
-      }
+      if (newlyLoadedFontCount > 0) measureClosestComponentContainer(containerRef.current,);
     },);
   }
 }
-var FitText = /* @__PURE__ */ forwardRef(({
-  viewBoxScale,
-  viewBox,
-  children,
-  ...props
-}, ref,) => {
+var FitText = /* @__PURE__ */ forwardRef(({ viewBoxScale, viewBox, children, ...props }, ref,) => {
   return /* @__PURE__ */ _jsx5(motion.svg, {
     ref,
     ...props,
@@ -37004,10 +28172,7 @@ var FitText = /* @__PURE__ */ forwardRef(({
       height: '100%',
       className: 'framer-fit-text',
       transform: `scale(${viewBoxScale})`,
-      style: {
-        overflow: 'visible',
-        transformOrigin: 'center center',
-      },
+      style: { overflow: 'visible', transformOrigin: 'center center', },
       children,
     },),
   },);
@@ -37103,19 +28268,13 @@ var RichTextContainer = /* @__PURE__ */ forwardRef((props, ref,) => {
         containerStyle.bottom = positionStickyBottom;
         containerStyle.left = positionStickyLeft;
       }
-    } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
-      containerStyle.position = 'absolute';
-    }
+    } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) containerStyle.position = 'absolute';
   }
   collectFiltersFromProps(props, containerStyle,);
   collectTextShadowsForProps(props, containerStyle,);
-  if (willChangeTransform) {
-    forceLayerBackingWithCSSProperties(containerStyle,);
-  }
+  if (willChangeTransform) forceLayerBackingWithCSSProperties(containerStyle,);
   Object.assign(containerStyle, _initialStyle, style,);
-  if (layoutId) {
-    rest.layout = 'preserve-aspect';
-  }
+  if (layoutId) rest.layout = 'preserve-aspect';
   const Component14 = htmlElementAsMotionComponent(props.as,);
   if (isString22(props.viewBox,)) {
     if (props.as !== void 0) {
@@ -37130,15 +28289,11 @@ var RichTextContainer = /* @__PURE__ */ forwardRef((props, ref,) => {
         children: /* @__PURE__ */ _jsx5(FitText, {
           viewBox,
           viewBoxScale,
-          style: {
-            width: '100%',
-            height: '100%',
-          },
+          style: { width: '100%', height: '100%', },
           children: children && styleRichTextChildren(children, stylesPresetsClassNames, plainText,),
         },),
       },);
-    } else {
-      return /* @__PURE__ */ _jsx5(FitText, {
+    } else {return /* @__PURE__ */ _jsx5(FitText, {
         ...rest,
         ref: containerRef,
         style: containerStyle,
@@ -37149,8 +28304,7 @@ var RichTextContainer = /* @__PURE__ */ forwardRef((props, ref,) => {
         'data-framer-name': name,
         'data-framer-component-type': 'RichTextContainer',
         children: children && styleRichTextChildren(children, stylesPresetsClassNames, plainText,),
-      },);
-    }
+      },);}
   }
   return /* @__PURE__ */ _jsx5(Component14, {
     ...rest,
@@ -37165,22 +28319,13 @@ var RichTextContainer = /* @__PURE__ */ forwardRef((props, ref,) => {
 },);
 function styleRichTextChildren(element, stylesPresetsClassNames, plainText,) {
   let children = Children.toArray(element.props.children,);
-  if (isString22(plainText,)) {
-    children = children.slice(0, 1,);
-  }
+  if (isString22(plainText,)) children = children.slice(0, 1,);
   children = children.map((child) => {
-    if (isValidElement(child,)) {
-      return styleRichTextChildren(child, stylesPresetsClassNames, plainText,);
-    }
-    if (isString22(plainText,)) {
-      return plainText;
-    }
+    if (isValidElement(child,)) return styleRichTextChildren(child, stylesPresetsClassNames, plainText,);
+    if (isString22(plainText,)) return plainText;
     return child;
   },);
-  const {
-    ['data-preset-tag']: dataPresetTag,
-    ...props
-  } = element.props;
+  const { ['data-preset-tag']: dataPresetTag, ...props } = element.props;
   if (isString22(element.type,) || isMotionComponent(element.type,)) {
     const tag = dataPresetTag || unwrapMotionComponent(element.type,) || element.type;
     const stylesPresetClassName = isString22(tag,) ? stylesPresetsClassNames == null ? void 0 : stylesPresetsClassNames[tag] : void 0;
@@ -37188,66 +28333,35 @@ function styleRichTextChildren(element, stylesPresetsClassNames, plainText,) {
   }
   return cloneElement2(element, props, ...children,);
 }
-var RichText = /* @__PURE__ */ forwardRef(({
-  children,
-  html,
-  htmlFromDesign,
-  ...props
-}, ref,) => {
+var RichText = /* @__PURE__ */ forwardRef(({ children, html, htmlFromDesign, ...props }, ref,) => {
   const content = html || children || htmlFromDesign;
   if (isString22(content,)) {
     if (!props.stylesPresetsClassName && isObject2(props.stylesPresetsClassNames,)) {
       props.stylesPresetsClassName = Object.values(props.stylesPresetsClassNames,).join(' ',);
     }
-    const contentProp = {
-      // We need to use the original prop name.
+    const contentProp = { // We need to use the original prop name.
       [isString22(html,) ? 'html' : 'htmlFromDesign']: content,
     };
-    return /* @__PURE__ */ _jsx5(DeprecatedRichText, {
-      ...props,
-      ...contentProp,
-      ref,
-    },);
+    return /* @__PURE__ */ _jsx5(DeprecatedRichText, { ...props, ...contentProp, ref, },);
   }
   if (!props.stylesPresetsClassNames && isString22(props.stylesPresetsClassName,)) {
     const [h1, h2, h3, p, a,] = props.stylesPresetsClassName.split(' ',);
     if (h1 === void 0 || h2 === void 0 || h3 === void 0 || p === void 0 || a === void 0) {
       console.warn(`Encountered invalid stylesPresetsClassNames: ${props.stylesPresetsClassNames}`,);
-    } else {
-      props.stylesPresetsClassNames = {
-        h1,
-        h2,
-        h3,
-        p,
-        a,
-      };
-    }
+    } else props.stylesPresetsClassNames = { h1, h2, h3, p, a, };
   }
-  return /* @__PURE__ */ _jsx5(RichTextContainer, {
-    ...props,
-    ref,
-    children: isValidElement(content,) ? content : void 0,
-  },);
+  return /* @__PURE__ */ _jsx5(RichTextContainer, { ...props, ref, children: isValidElement(content,) ? content : void 0, },);
 },);
 function linearGradientLine(angle,) {
   var _a, _b;
   const rad = angle * Math.PI / 180;
-  const offset = {
-    x: -Math.sin(rad,) * 100,
-    y: Math.cos(rad,) * 100,
-  };
+  const offset = { x: -Math.sin(rad,) * 100, y: Math.cos(rad,) * 100, };
   const anglePoint = Point(offset.x, offset.y,);
   const angleLine = Line(Point(0.5, 0.5,), anglePoint,);
-  const points = Rect.points({
-    x: 0,
-    y: 0,
-    width: 1,
-    height: 1,
-  },);
-  const sortedPoints = points.map((point2) => ({
-    point: point2,
-    distance: Point.distance(anglePoint, point2,),
-  })).sort((a2, b2,) => a2.distance - b2.distance);
+  const points = Rect.points({ x: 0, y: 0, width: 1, height: 1, },);
+  const sortedPoints = points.map((point2) => ({ point: point2, distance: Point.distance(anglePoint, point2,), })).sort((a2, b2,) =>
+    a2.distance - b2.distance
+  );
   const a = (_a = sortedPoints[0]) == null ? void 0 : _a.point;
   const b = (_b = sortedPoints[1]) == null ? void 0 : _b.point;
   assert(a && b, 'linearGradientLine: Must have 2 closest points.',);
@@ -37326,11 +28440,8 @@ function imagePatternPropsForFill(fill, frame2, id3, includeTransform,) {
   const imageWidth = fill.pixelWidth;
   const imageHeight = fill.pixelHeight;
   let transform2;
-  const {
-    fit,
-  } = fill;
-  let width = 1,
-    height = 1;
+  const { fit, } = fill;
+  let width = 1, height = 1;
   let offsetX = 0;
   let offsetY = 0;
   if (fit === 'fill' || fit === 'fit' || fit === 'tile' || !fit) {
@@ -37368,15 +28479,7 @@ function imagePatternPropsForFill(fill, frame2, id3, includeTransform,) {
     }
   }
   const imageId = `id${id3}g${'-fillImage'}`;
-  return {
-    id: imageId,
-    path: fill.src ?? '',
-    transform: transform2,
-    width,
-    height,
-    offsetX,
-    offsetY,
-  };
+  return { id: imageId, path: fill.src ?? '', transform: transform2, width, height, offsetX, offsetY, };
 }
 var mediaType2 = 'framer/asset-reference,';
 function isAssetReference(value,) {
@@ -37390,21 +28493,9 @@ function imageUrlForAsset(asset, pixelSize,) {
   else if (pixelSize <= 2048) pixelSize = 2048;
   else pixelSize = 4096;
   const isExport = RenderTarget.current() === 'EXPORT';
-  return runtime.assetResolver(asset, {
-    pixelSize,
-    isExport,
-  },) ?? '';
+  return runtime.assetResolver(asset, { pixelSize, isExport, },) ?? '';
 }
-var ImagePatternElement = ({
-  id: id3,
-  path,
-  transform: transform2,
-  repeat,
-  width,
-  height,
-  offsetX,
-  offsetY,
-},) => {
+var ImagePatternElement = ({ id: id3, path, transform: transform2, repeat, width, height, offsetX, offsetY, },) => {
   const href = imageUrlForAsset(path,);
   return /* @__PURE__ */ _jsx5('pattern', {
     id: id3,
@@ -37441,25 +28532,21 @@ var SharedSVGManager = class {
   }
   debugGetEntries() {
     return this.entries;
-  }
-  /** Request to render a svg, this will ensure there is a global instance and will return a
+  } /** Request to render a svg, this will ensure there is a global instance and will return a
    * template referencing the image. Must be balanced with `unsubscribe()` calls using the same
    * svg. If called multiple times while the shared SVG exists, the generateUniqueIds and
    * contentId parameters are ignored. */
+
   subscribe(svg, generateUniqueIds, contentId,) {
     if (!svg || svg === '') return '';
     let entry = this.entries.get(svg,);
     if (!entry) {
-      if (!contentId) {
-        contentId = 'svg' + String(hash(svg,),) + '_' + String(svg.length,);
-      }
+      if (!contentId) contentId = 'svg' + String(hash(svg,),) + '_' + String(svg.length,);
       let uniqueSVG = svg;
       let svgSize;
       const svgDom = parseSVG(svg,);
       if (svgDom) {
-        if (generateUniqueIds) {
-          prefixIdsInSVG(svgDom, contentId,);
-        }
+        if (generateUniqueIds) prefixIdsInSVG(svgDom, contentId,);
         svgDom.id = contentId;
         svgSize = getSVGSize(svgDom,);
         uniqueSVG = svgDom.outerHTML;
@@ -37469,14 +28556,12 @@ var SharedSVGManager = class {
     }
     entry.count += 1;
     return entry.innerHTML;
-  }
-  /** Returns the viewBox for the svg, or undefined if there is no viewBox. */
+  } /** Returns the viewBox for the svg, or undefined if there is no viewBox. */
   getViewBox(svg,) {
     if (!svg || svg === '') return;
     const entry = this.entries.get(svg,);
     return entry == null ? void 0 : entry.viewBox;
-  }
-  /** When no longer rendering an svg it must be unsubscribed from so resources can be cleaned up.
+  } /** When no longer rendering an svg it must be unsubscribed from so resources can be cleaned up.
    * Pass in the same svg as used with `subscribe()`. */
   unsubscribe(svg,) {
     if (!svg || svg === '') return;
@@ -37519,9 +28604,7 @@ var SharedSVGManager = class {
         const container = document.createElement('div',);
         container.id = containerId;
         container.innerHTML = svg;
-        if (container.firstElementChild) {
-          container.firstElementChild.id = id3;
-        }
+        if (container.firstElementChild) container.firstElementChild.id = id3;
         svgTemplates.appendChild(container,);
       }
     }
@@ -37533,8 +28616,7 @@ var SharedSVGManager = class {
   }
   clear() {
     this.entries.clear();
-  }
-  /** Returns a string containing a div#svg-templates and all the current svg templates. Can be
+  } /** Returns a string containing a div#svg-templates and all the current svg templates. Can be
    * used after running `ReactDOMServer.renderToString()` */
   generateTemplates() {
     const output = [];
@@ -37585,9 +28667,7 @@ function prefixId(el, prefix2,) {
   attributes.forEach((attr) => {
     const value = el.getAttribute(attr,);
     if (!value) return;
-    if (attr === 'id') {
-      el.setAttribute(attr, `${prefix2}_${value}`,);
-    }
+    if (attr === 'id') el.setAttribute(attr, `${prefix2}_${value}`,);
     if (attr === 'href' || attr === 'xlink:href') {
       const [base, fragmentIdentifier,] = value.split('#',);
       if (base) return;
@@ -37608,8 +28688,7 @@ var unitsToPixels = {
   in: 96,
   pc: 96 / 6,
   pt: 96 / 72,
-  px: 1,
-  // A few assumptions about relative units.
+  px: 1, // A few assumptions about relative units.
   em: 16,
   ex: 8,
   ch: 8,
@@ -37628,10 +28707,7 @@ function getSVGSize(svg,) {
   const height = parseLength(svg.getAttribute('height',),);
   if (typeof width !== 'number' || typeof height !== 'number') return;
   if (width <= 0 || height <= 0) return;
-  return {
-    width,
-    height,
-  };
+  return { width, height, };
 }
 function SVG(props,) {
   const parentSize = useParentSize();
@@ -37639,13 +28715,7 @@ function SVG(props,) {
   const layoutRef = React__default.useRef(null,);
   const providedWindow = useProvidedWindow();
   useMeasureLayout(props, layoutRef,);
-  return /* @__PURE__ */ _jsx5(SVGComponent, {
-    ...props,
-    innerRef: layoutRef,
-    parentSize,
-    layoutId,
-    providedWindow,
-  },);
+  return /* @__PURE__ */ _jsx5(SVGComponent, { ...props, innerRef: layoutRef, parentSize, layoutId, providedWindow, },);
 }
 var MAX_BACKGROUND_SVG_TEXT_LENGTH = 5e4;
 function containsImageReference(svg,) {
@@ -37667,32 +28737,18 @@ function sizeSVG(container, props,) {
   if (!svg || !(svg instanceof localWindow.SVGSVGElement)) return;
   if (!svg.getAttribute('viewBox',)) {
     const viewBox = sharedSVGManager.getViewBox(props.svg,);
-    if (viewBox) {
-      svg.setAttribute('viewBox', viewBox,);
-    }
+    if (viewBox) svg.setAttribute('viewBox', viewBox,);
   }
-  const {
-    withExternalLayout,
-    parentSize,
-  } = props;
+  const { withExternalLayout, parentSize, } = props;
   const canUseCalculatedOnCanvasSize = !withExternalLayout && constraintsEnabled(props,) && parentSize !== 1 && parentSize !== 2;
   if (canUseCalculatedOnCanvasSize) return;
-  const {
-    intrinsicWidth,
-    intrinsicHeight,
-    _constraints,
-  } = props;
+  const { intrinsicWidth, intrinsicHeight, _constraints, } = props;
   if (
     ((_a = svg.viewBox.baseVal) == null ? void 0 : _a.width) === 0 && ((_b = svg.viewBox.baseVal) == null ? void 0 : _b.height) === 0 &&
     isFiniteNumber(intrinsicWidth,) && isFiniteNumber(intrinsicHeight,)
-  ) {
-    svg.setAttribute('viewBox', `0 0 ${intrinsicWidth} ${intrinsicHeight}`,);
-  }
-  if (_constraints && _constraints.aspectRatio) {
-    svg.setAttribute('preserveAspectRatio', '',);
-  } else {
-    svg.setAttribute('preserveAspectRatio', 'none',);
-  }
+  ) svg.setAttribute('viewBox', `0 0 ${intrinsicWidth} ${intrinsicHeight}`,);
+  if (_constraints && _constraints.aspectRatio) svg.setAttribute('preserveAspectRatio', '',);
+  else svg.setAttribute('preserveAspectRatio', 'none',);
   svg.setAttribute('width', '100%',);
   svg.setAttribute('height', '100%',);
 }
@@ -37717,18 +28773,14 @@ var SVGComponent = /* @__PURE__ */ (() => {
       __publicField(this, 'unmountedSVG', '',);
     }
     static frame(props,) {
-      return calculateRect(props, props.parentSize || 0,/* Unknown */
-      );
+      return calculateRect(props, props.parentSize || 0, /* Unknown */);
     }
     get frame() {
-      return calculateRect(this.props, this.props.parentSize || 0,/* Unknown */
-      );
+      return calculateRect(this.props, this.props.parentSize || 0, /* Unknown */);
     }
     componentDidMount() {
       if (this.unmountedSVG) {
-        const {
-          svgContentId,
-        } = this.props;
+        const { svgContentId, } = this.props;
         const contentid = svgContentId ? 'svg' + svgContentId : null;
         sharedSVGManager.subscribe(this.unmountedSVG, !svgContentId, contentid,);
         this.previouslyRenderedSVG = this.unmountedSVG;
@@ -37744,9 +28796,7 @@ var SVGComponent = /* @__PURE__ */ (() => {
     componentDidUpdate(prevProps,) {
       super.componentDidUpdate(prevProps,);
       if (this.props.svgContentId) return;
-      const {
-        fill,
-      } = this.props;
+      const { fill, } = this.props;
       if (BackgroundImage.isImageObject(fill,) && BackgroundImage.isImageObject(prevProps.fill,) && fill.src !== prevProps.fill.src) {
         resetSetStyle(this.svgElement, 'fill', null, false,);
       }
@@ -37760,13 +28810,7 @@ var SVGComponent = /* @__PURE__ */ (() => {
         return;
       }
       const frame2 = this.frame;
-      const {
-        rotation,
-        intrinsicWidth,
-        intrinsicHeight,
-        width,
-        height,
-      } = this.props;
+      const { rotation, intrinsicWidth, intrinsicHeight, width, height, } = this.props;
       const rotate = Animatable.getNumber(rotation,);
       style.opacity = isFiniteNumber(this.props.opacity,) ? this.props.opacity : 1;
       if (RenderTarget.hasRestrictions() && frame2) {
@@ -37775,50 +28819,24 @@ var SVGComponent = /* @__PURE__ */ (() => {
           width: `${frame2.width}px`,
           height: `${frame2.height}px`,
         },);
-        if (constraintsEnabled(this.props,)) {
-          style.position = 'absolute';
-        }
+        if (constraintsEnabled(this.props,)) style.position = 'absolute';
         const xFactor = frame2.width / (intrinsicWidth || 1);
         const yFactor = frame2.height / (intrinsicHeight || 1);
         innerStyle.transformOrigin = 'top left';
-        const {
-          zoom,
-          target,
-        } = RenderEnvironment;
+        const { zoom, target, } = RenderEnvironment;
         if (target === 'EXPORT') {
           const zoomFactor = zoom > 1 ? zoom : 1;
           innerStyle.transform = `scale(${xFactor * zoomFactor}, ${yFactor * zoomFactor})`;
           innerStyle.zoom = 1 / zoomFactor;
-        } else {
-          innerStyle.transform = `scale(${xFactor}, ${yFactor})`;
-        }
+        } else innerStyle.transform = `scale(${xFactor}, ${yFactor})`;
         if (intrinsicWidth && intrinsicHeight) {
           innerStyle.width = intrinsicWidth;
           innerStyle.height = intrinsicHeight;
         }
       } else {
-        const {
-          left,
-          right,
-          top,
-          bottom,
-        } = this.props;
-        Object.assign(style, {
-          left,
-          right,
-          top,
-          bottom,
-          width,
-          height,
-          rotate,
-        },);
-        Object.assign(innerStyle, {
-          left: 0,
-          top: 0,
-          bottom: 0,
-          right: 0,
-          position: 'absolute',
-        },);
+        const { left, right, top, bottom, } = this.props;
+        Object.assign(style, { left, right, top, bottom, width, height, rotate, },);
+        Object.assign(innerStyle, { left: 0, top: 0, bottom: 0, right: 0, position: 'absolute', },);
       }
     }
     render() {
@@ -37847,15 +28865,8 @@ var SVGComponent = /* @__PURE__ */ (() => {
       if (!withExternalLayout && (!visible || !id3)) return null;
       const identifier = id3 ?? layoutId ?? 'svg';
       const frame2 = this.frame;
-      const size2 = frame2 || {
-        width: intrinsicWidth || 100,
-        height: intrinsicHeight || 100,
-      };
-      const outerStyle = {
-        ...style,
-        imageRendering: 'pixelated',
-        flexShrink: 0,
-      };
+      const size2 = frame2 || { width: intrinsicWidth || 100, height: intrinsicHeight || 100, };
+      const outerStyle = { ...style, imageRendering: 'pixelated', flexShrink: 0, };
       const innerStyle = {};
       this.collectLayout(outerStyle, innerStyle,);
       collectOpacityFromProps(this.props, outerStyle,);
@@ -37870,21 +28881,13 @@ var SVGComponent = /* @__PURE__ */ (() => {
         const gradient = fill;
         const gradientId = `${encodeURI(id3 || '',)}g${LinearGradient.hash(gradient,)}`;
         outerStyle.fill = `url(#${gradientId})`;
-        const {
-          stops,
-          x1,
-          x2,
-          y1,
-          y2,
-        } = elementPropertiesForLinearGradient(gradient, identifier,);
+        const { stops, x1, x2, y1, y2, } = elementPropertiesForLinearGradient(gradient, identifier,);
         fillElement = /* @__PURE__ */ _jsx5('svg', {
           ref: this.setSVGElement,
           xmlns: 'http://www.w3.org/2000/svg',
           width: '100%',
           height: '100%',
-          style: {
-            position: 'absolute',
-          },
+          style: { position: 'absolute', },
           children: /* @__PURE__ */ _jsx5('linearGradient', {
             id: gradientId,
             x1,
@@ -37892,11 +28895,7 @@ var SVGComponent = /* @__PURE__ */ (() => {
             y1,
             y2,
             children: stops.map((stop, idx,) => {
-              return /* @__PURE__ */ _jsx5('stop', {
-                offset: stop.position,
-                stopColor: stop.color,
-                stopOpacity: stop.alpha,
-              }, idx,);
+              return /* @__PURE__ */ _jsx5('stop', { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha, }, idx,);
             },),
           },),
         },);
@@ -37910,20 +28909,14 @@ var SVGComponent = /* @__PURE__ */ (() => {
           xmlns: 'http://www.w3.org/2000/svg',
           width: '100%',
           height: '100%',
-          style: {
-            position: 'absolute',
-          },
+          style: { position: 'absolute', },
           children: /* @__PURE__ */ _jsx5('radialGradient', {
             id: gradientId,
             cy: gradient.centerAnchorY,
             cx: gradient.centerAnchorX,
             r: gradient.widthFactor,
             children: elementProperties.stops.map((stop, idx,) => {
-              return /* @__PURE__ */ _jsx5('stop', {
-                offset: stop.position,
-                stopColor: stop.color,
-                stopOpacity: stop.alpha,
-              }, idx,);
+              return /* @__PURE__ */ _jsx5('stop', { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha, }, idx,);
             },),
           },),
         },);
@@ -37937,24 +28930,14 @@ var SVGComponent = /* @__PURE__ */ (() => {
             xmlnsXlink: 'http://www.w3.org/1999/xlink',
             width: '100%',
             height: '100%',
-            style: {
-              position: 'absolute',
-            },
-            children: /* @__PURE__ */ _jsx5('defs', {
-              children: /* @__PURE__ */ _jsx5(ImagePatternElement, {
-                ...imagePattern,
-              },),
-            },),
+            style: { position: 'absolute', },
+            children: /* @__PURE__ */ _jsx5('defs', { children: /* @__PURE__ */ _jsx5(ImagePatternElement, { ...imagePattern, },), },),
           },);
         }
       }
-      const dataProps = {
-        'data-framer-component-type': 'SVG',
-      };
+      const dataProps = { 'data-framer-component-type': 'SVG', };
       const hasTransformTemplate = !frame2;
-      if (hasTransformTemplate) {
-        Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center,),);
-      }
+      if (hasTransformTemplate) Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center,),);
       const svgAsBackgroundImage = !fillElement && !outerStyle.fill && !outerStyle.background && !outerStyle.backgroundImage &&
         svg.length < MAX_BACKGROUND_SVG_TEXT_LENGTH && !containsImageReference(svg,) && !containsCustomPropertyReference(svg,);
       let content = null;
@@ -37968,9 +28951,7 @@ var SVGComponent = /* @__PURE__ */ (() => {
         const __html = sharedSVGManager.subscribe(svg, !svgContentId, contentid,);
         sharedSVGManager.unsubscribe(this.previouslyRenderedSVG,);
         this.previouslyRenderedSVG = svg;
-        if (hasBorderRadius(outerStyle,)) {
-          outerStyle.overflow = 'hidden';
-        }
+        if (hasBorderRadius(outerStyle,)) outerStyle.overflow = 'hidden';
         content = /* @__PURE__ */ _jsxs(Fragment, {
           children: [
             fillElement,
@@ -37978,20 +28959,13 @@ var SVGComponent = /* @__PURE__ */ (() => {
               className: 'svgContainer',
               style: innerStyle,
               ref: this.container,
-              dangerouslySetInnerHTML: {
-                __html,
-              },
+              dangerouslySetInnerHTML: { __html, },
             }, BackgroundImage.isImageObject(fill,) ? fill.src : '',),
           ],
         },);
       }
       const MotionComponent = htmlElementAsMotionComponent(this.props.as,);
-      const {
-        href,
-        target,
-        rel,
-        onClick,
-      } = this.props;
+      const { href, target, rel, onClick, } = this.props;
       return /* @__PURE__ */ _jsxs(MotionComponent, {
         ...dataProps,
         ...rest,
@@ -38006,12 +28980,7 @@ var SVGComponent = /* @__PURE__ */ (() => {
         role: title || description ? 'img' : void 0,
         'aria-label': title,
         'aria-description': description,
-        ...{
-          href,
-          target,
-          rel,
-          onClick,
-        },
+        ...{ href, target, rel, onClick, },
         children: [content, /* @__PURE__ */ _jsx5(SVGStyleSheet, {},),],
       },);
     }
@@ -38023,20 +28992,14 @@ var SVGComponent = /* @__PURE__ */ (() => {
       top: void 0,
       bottom: void 0,
       style: void 0,
-      _constraints: {
-        enabled: true,
-        aspectRatio: null,
-      },
+      _constraints: { enabled: true, aspectRatio: null, },
       parentSize: 0,
       rotation: 0,
       visible: true,
       svg: '',
       shadows: [],
     },),
-    __publicField(_a, 'defaultProps', {
-      ...Layer.defaultProps,
-      ..._a.defaultSVGProps,
-    },),
+    __publicField(_a, 'defaultProps', { ...Layer.defaultProps, ..._a.defaultSVGProps, },),
     _a;
 })();
 function useFontLoadStatus(fontSelectors = [], timeout = 5e3,) {
@@ -38066,28 +29029,20 @@ var Text2 = /* @__PURE__ */ React__default.forwardRef(function Text3(props, forw
   const layoutId = useLayoutId2(props,);
   const fallbackLayoutRef = useRef(null,);
   const layoutRef = forwardedRef ?? fallbackLayoutRef;
-  const {
-    navigate,
-    getRoute,
-  } = useRouter();
+  const { navigate, getRoute, } = useRouter();
   const currentRoute = useCurrentRoute();
   useRoutePreloader(props.preload ?? [],);
   const onCanvas = useIsOnFramerCanvas();
   const matchesCurrentRoute = useLinkMatchesRoute(props.__link,);
   const fontLoadStatus = useFontLoadStatus(props.fonts,);
   useMeasureLayout(props, layoutRef,);
-  const {
-    fonts,
-    __fromCanvasComponent,
-  } = props;
+  const { fonts, __fromCanvasComponent, } = props;
   const prevFontsRef = useRef([],);
   const fontsDidChange = !isShallowEqualArray(prevFontsRef.current ?? [], fonts ?? [],);
   prevFontsRef.current = fonts;
   useEffect(() => {
     if (!fontsDidChange || !fonts) return;
-    void fontStore.loadFonts(fonts,).then(({
-      newlyLoadedFontCount,
-    },) => {
+    void fontStore.loadFonts(fonts,).then(({ newlyLoadedFontCount, },) => {
       if (!__fromCanvasComponent || !layoutRef.current || RenderTarget.current() !== 'CANVAS') return;
       if (newlyLoadedFontCount === 0) return;
       measureClosestComponentContainer(layoutRef.current,);
@@ -38098,9 +29053,7 @@ var Text2 = /* @__PURE__ */ React__default.forwardRef(function Text3(props, forw
     const anchorElement = findAnchorElement(event.target, layoutRef.current,);
     if (event.metaKey || !navigate || !anchorElement) return;
     const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables,);
-    if (didNavigate) {
-      event.preventDefault();
-    }
+    if (didNavigate) event.preventDefault();
   }, [navigate, implicitPathVariables,],);
   useEffect(() => {
     var _a;
@@ -38129,9 +29082,7 @@ var TextComponent = /* @__PURE__ */ (() => {
       super(...arguments,);
       __publicField(this, 'editorText',);
       __publicField(this, 'setElement', (element) => {
-        if (this.props.innerRef) {
-          this.props.innerRef.current = element;
-        }
+        if (this.props.innerRef) this.props.innerRef.current = element;
         this.setLayerElement(element,);
       },);
       __publicField(this, 'renderMain', (inCodeComponent) => {
@@ -38161,9 +29112,7 @@ var TextComponent = /* @__PURE__ */ (() => {
           tabIndex,
           ...rest
         } = this.props;
-        if (!visible) {
-          return null;
-        }
+        if (!visible) return null;
         const isHidden2 = this.props.isEditable && this.props.environment() === 'CANVAS';
         const justifyContent = convertVerticalAlignment2(this.props.verticalAlignment,);
         const style = {
@@ -38175,51 +29124,29 @@ var TextComponent = /* @__PURE__ */ (() => {
           flexShrink: 0,
         };
         if (_initialStyle) {
-          for (const key7 in _initialStyle) {
-            if (key7.startsWith('--framer',)) {
-              asRecord(style,)[key7] = asRecord(_initialStyle,)[key7];
-            }
-          }
-        }
-        const dataProps = {
-          'data-framer-component-type': 'Text',
-          'data-framer-name': name,
-        };
-        if (autoSize) {
-          asRecord(dataProps,)['data-framer-component-text-autosized'] = 'true';
+          for (const key7 in _initialStyle) if (key7.startsWith('--framer',)) asRecord(style,)[key7] = asRecord(_initialStyle,)[key7];
         }
+        const dataProps = { 'data-framer-component-type': 'Text', 'data-framer-name': name, };
+        if (autoSize) asRecord(dataProps,)['data-framer-component-text-autosized'] = 'true';
         this.collectLayout(style, inCodeComponent,);
         collectFiltersFromProps(this.props, style,);
         collectTextShadowsForProps(this.props, style,);
-        if (style.opacity === 1 || style.opacity === void 0) {
-          delete style.opacity;
-        }
-        if (willChangeTransform) {
-          forceLayerBackingWithCSSProperties(style,);
-        }
+        if (style.opacity === 1 || style.opacity === void 0) delete style.opacity;
+        if (willChangeTransform) forceLayerBackingWithCSSProperties(style,);
         let rawHTML = this.props.rawHTML;
         const text = this.getOverrideText() || this.props.text;
-        if (isString22(text,)) {
-          if (rawHTML) {
-            rawHTML = replaceDraftHTMLWithText(rawHTML, text,);
-          } else {
-            rawHTML = `<p style="font: ${font}">${text}</p>`;
-          }
-        }
-        if (this.props.style) {
-          Object.assign(style, this.props.style,);
+        if (isString22(text,)) {
+          if (rawHTML) rawHTML = replaceDraftHTMLWithText(rawHTML, text,);
+          else rawHTML = `<p style="font: ${font}">${text}</p>`;
         }
+        if (this.props.style) Object.assign(style, this.props.style,);
         const centeringTransformTemplate = this.transformTemplate;
         if (centeringTransformTemplate) Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center,),);
         if (rawHTML) {
           style.lineHeight = '1px';
           style.fontSize = '0px';
-          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'loading') {
-            style.visibility = 'hidden';
-          }
-          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'timeout') {
-            style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
-          }
+          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'loading') style.visibility = 'hidden';
+          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'timeout') style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
           Object.assign(style, styleProp,);
           if (alignment) asRecord(style,)['--framer-text-alignment'] = alignment;
           const tabIndexProps = getTabIndexProps(tabIndex,);
@@ -38231,9 +29158,7 @@ var TextComponent = /* @__PURE__ */ (() => {
             ...rest,
             style,
             transformTemplate: centeringTransformTemplate,
-            dangerouslySetInnerHTML: {
-              __html: rawHTML,
-            },
+            dangerouslySetInnerHTML: { __html: rawHTML, },
             'data-center': this.props.center,
             className: cx(className, matchesCurrentRoute && 'isCurrent',),
             transition,
@@ -38247,25 +29172,17 @@ var TextComponent = /* @__PURE__ */ (() => {
       return calculateRect(this.props, this.props.parentSize || 0, false,);
     }
     getOverrideText() {
-      const {
-        _forwardedOverrideId,
-        _forwardedOverrides,
-        id: id3,
-      } = this.props;
+      const { _forwardedOverrideId, _forwardedOverrides, id: id3, } = this.props;
       const forwardedOverrideId = _forwardedOverrideId ?? id3;
       if (forwardedOverrideId && _forwardedOverrides) {
         const text = _forwardedOverrides[forwardedOverrideId];
-        if (isString22(text,)) {
-          return text;
-        }
+        if (isString22(text,)) return text;
       }
     }
     render() {
       return /* @__PURE__ */ _jsxs(Fragment, {
         children: [
-          /* @__PURE__ */ _jsx5(ComponentContainerContext.Consumer, {
-            children: this.renderMain,
-          },),
+          /* @__PURE__ */ _jsx5(ComponentContainerContext.Consumer, { children: this.renderMain, },),
           /* @__PURE__ */ _jsx5(TextStyleSheet, {},),
         ],
       },);
@@ -38291,8 +29208,7 @@ var TextComponent = /* @__PURE__ */ (() => {
       const isDOMLayoutAutoSized = _usesDOMRect && (externalWidth === 'auto' || externalHeight === 'auto');
       if (frame2 && !isDOMLayoutAutoSized && RenderTarget.hasRestrictions()) {
         Object.assign(style, {
-          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4,)}deg)`,
-          // Using “auto” fixes wrapping problems where our size calculation does not work out well when zooming the
+          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4,)}deg)`, // Using “auto” fixes wrapping problems where our size calculation does not work out well when zooming the
           // text (due to rendering differences).
           // TODO: When the `autoSize` prop is removed, it's safe to leave
           // this at `${frame.width}px`, because all auto cases will be
@@ -38302,34 +29218,17 @@ var TextComponent = /* @__PURE__ */ (() => {
           height: `${frame2.height}px`,
         },);
       } else {
-        const {
-          left,
-          right,
-          top,
-          bottom,
-        } = this.props;
+        const { left, right, top, bottom, } = this.props;
         let width;
         let height;
         if (autoSize) {
           width = 'auto';
           height = 'auto';
         } else {
-          if (!isFiniteNumber(left,) || !isFiniteNumber(right,)) {
-            width = externalWidth;
-          }
-          if (!isFiniteNumber(top,) || !isFiniteNumber(bottom,)) {
-            height = externalHeight;
-          }
+          if (!isFiniteNumber(left,) || !isFiniteNumber(right,)) width = externalWidth;
+          if (!isFiniteNumber(top,) || !isFiniteNumber(bottom,)) height = externalHeight;
         }
-        Object.assign(style, {
-          left,
-          right,
-          top,
-          bottom,
-          width,
-          height,
-          rotate,
-        },);
+        Object.assign(style, { left, right, top, bottom, width, height, rotate, },);
       }
       const onCanvas = RenderTarget.current() === 'CANVAS';
       if (positionSticky) {
@@ -38342,17 +29241,10 @@ var TextComponent = /* @__PURE__ */ (() => {
           style.bottom = positionStickyBottom;
           style.left = positionStickyLeft;
         }
-      } else if (onCanvas && (positionFixed || positionAbsolute)) {
-        style.position = 'absolute';
-      }
+      } else if (onCanvas && (positionFixed || positionAbsolute)) style.position = 'absolute';
     }
     get transformTemplate() {
-      const {
-        _usesDOMRect,
-        widthType,
-        heightType,
-        __fromCanvasComponent,
-      } = this.props;
+      const { _usesDOMRect, widthType, heightType, __fromCanvasComponent, } = this.props;
       if (this.props.transformTemplate) return this.props.transformTemplate;
       const frame2 = this.frame;
       const isDOMLayoutAutoSized = _usesDOMRect && (widthType === 2 || heightType === 2);
@@ -38367,10 +29259,7 @@ var TextComponent = /* @__PURE__ */ (() => {
       right: void 0,
       top: void 0,
       bottom: void 0,
-      _constraints: {
-        enabled: true,
-        aspectRatio: null,
-      },
+      _constraints: { enabled: true, aspectRatio: null, },
       rotation: 0,
       visible: true,
       alignment: void 0,
@@ -38397,11 +29286,9 @@ var blockClosingTag = '</(?:div|span)>';
 var inlineTag = '<[^>]+>';
 var inlineClosingTag = '</[^>]+>';
 var textContentRegex = new RegExp(
-  `^(${linkTag}${outerTag}${blockTag}${inlineTag}).*?(${inlineClosingTag}).*?(${blockClosingTag}${outerClosingTag}${linkClosingTag})$`,
-  //                                              ^^^ this is the content we want to replace
+  `^(${linkTag}${outerTag}${blockTag}${inlineTag}).*?(${inlineClosingTag}).*?(${blockClosingTag}${outerClosingTag}${linkClosingTag})$`, //                                              ^^^ this is the content we want to replace
   //                                                                      ^^^ this is the content we want to discard
-  's',
-  // let the "." also match newlines
+  's', // let the "." also match newlines
 );
 function replaceDraftHTMLWithText(rawHTML, text,) {
   return rawHTML.replace(
@@ -38421,9 +29308,7 @@ function convertVerticalAlignment2(verticalAlignment,) {
 }
 function getTabIndexProps(tabIndex,) {
   if (tabIndex === void 0) return {};
-  return {
-    tabIndex,
-  };
+  return { tabIndex, };
 }
 var keys22 = /* @__PURE__ */ new Map();
 var InternalID = class {
@@ -38467,9 +29352,7 @@ var PathSegment = class {
     __publicField(this, 'handleInX', 0,);
     __publicField(this, 'handleInY', 0,);
     __publicField(this, 'radius', 0,);
-    if (value) {
-      Object.assign(this, value,);
-    }
+    if (value) Object.assign(this, value,);
   }
   merge(value,) {
     return Object.assign(Object.create(Object.getPrototypeOf(this,),), this, value,);
@@ -38479,22 +29362,13 @@ __publicField(PathSegment, 'displayName', 'WithClassDiscriminatorMixin(PathSegme
 PathSegment.prototype.__class = 'PathSegment';
 ((PathSegment2) => {
   PathSegment2.point = (pathSegment) => {
-    return {
-      x: pathSegment.x,
-      y: pathSegment.y,
-    };
+    return { x: pathSegment.x, y: pathSegment.y, };
   };
   PathSegment2.handleOut = (pathSegment) => {
-    return {
-      x: pathSegment.handleOutX,
-      y: pathSegment.handleOutY,
-    };
+    return { x: pathSegment.handleOutX, y: pathSegment.handleOutY, };
   };
   PathSegment2.handleIn = (pathSegment) => {
-    return {
-      x: pathSegment.handleInX,
-      y: pathSegment.handleInY,
-    };
+    return { x: pathSegment.handleInX, y: pathSegment.handleInY, };
   };
   PathSegment2.calculatedHandleOut = (pathSegment) => {
     switch (pathSegment.handleMirroring) {
@@ -38503,10 +29377,7 @@ PathSegment.prototype.__class = 'PathSegment';
       case 'asymmetric':
         return Point.add((0, PathSegment2.point)(pathSegment,), (0, PathSegment2.handleOut)(pathSegment,),);
       default:
-        return {
-          x: pathSegment.x,
-          y: pathSegment.y,
-        };
+        return { x: pathSegment.x, y: pathSegment.y, };
     }
   };
   PathSegment2.calculatedHandleIn = (pathSegment) => {
@@ -38524,54 +29395,30 @@ PathSegment.prototype.__class = 'PathSegment';
     if (points.length > 2) {
       let pointBefore;
       let pointAfter;
-      if (index === 0) {
-        pointBefore = points[points.length - 1];
-      } else {
-        pointBefore = points[index - 1];
-      }
-      if (index === points.length - 1) {
-        pointAfter = points[0];
-      } else {
-        pointAfter = points[index + 1];
-      }
+      if (index === 0) pointBefore = points[points.length - 1];
+      else pointBefore = points[index - 1];
+      if (index === points.length - 1) pointAfter = points[0];
+      else pointAfter = points[index + 1];
       assert(pointBefore, 'pointBefore should be defined',);
       assert(pointAfter, 'pointAfter should be defined',);
       const delta = Point.subtract((0, PathSegment2.point)(pointAfter,), (0, PathSegment2.point)(pointBefore,),);
-      return {
-        x: delta.x / 4,
-        y: delta.y / 4,
-      };
+      return { x: delta.x / 4, y: delta.y / 4, };
     }
-    return {
-      x: 10,
-      y: 10,
-    };
+    return { x: 10, y: 10, };
   };
 })(PathSegment || (PathSegment = {}),);
 var key5 = 'pathSegments';
 function withPath(target,) {
   return key5 in target;
 }
-var pathDefaults = {
-  pathSegments: [],
-  pathClosed: false,
-};
-function toSVGPath(withPaths, translate = {
-  x: 0,
-  y: 0,
-}, canvasMode = 'CANVAS',) {
+var pathDefaults = { pathSegments: [], pathClosed: false, };
+function toSVGPath(withPaths, translate = { x: 0, y: 0, }, canvasMode = 'CANVAS',) {
   let pathElements = [];
   let paths = [];
-  if (Array.isArray(withPaths,)) {
-    paths = withPaths;
-  } else {
-    paths = [withPaths,];
-  }
+  if (Array.isArray(withPaths,)) paths = withPaths;
+  else paths = [withPaths,];
   paths.forEach((path) => {
-    const {
-      pathClosed,
-      pathSegments,
-    } = path;
+    const { pathClosed, pathSegments, } = path;
     const segmentCount = pathSegments.length;
     if (segmentCount === 0) return '';
     for (let i = 0; i < segmentCount; i++) {
@@ -38581,21 +29428,12 @@ function toSVGPath(withPaths, translate = {
       let prevSegment;
       const isFirstSegment = i === 0;
       const isLastSegment = i === segmentCount - 1;
-      if (!isLastSegment) {
-        nextSegment = pathSegments[i + 1];
-      } else if (pathClosed) {
-        nextSegment = pathSegments[0];
-      }
-      if (!isFirstSegment) {
-        prevSegment = pathSegments[i - 1];
-      } else if (pathClosed) {
-        prevSegment = pathSegments[segmentCount - 1];
-      }
-      if (i === 0) {
-        pathElements.push('M',);
-      } else if (prevSegment && isStraightCurve(prevSegment, segment,)) {
-        pathElements.push('L',);
-      }
+      if (!isLastSegment) nextSegment = pathSegments[i + 1];
+      else if (pathClosed) nextSegment = pathSegments[0];
+      if (!isFirstSegment) prevSegment = pathSegments[i - 1];
+      else if (pathClosed) prevSegment = pathSegments[segmentCount - 1];
+      if (i === 0) pathElements.push('M',);
+      else if (prevSegment && isStraightCurve(prevSegment, segment,)) pathElements.push('L',);
       pathElements.push(segment.x + translate.x, segment.y + translate.y,);
       if (nextSegment && !isStraightCurve(segment, nextSegment,)) {
         const handleOut = PathSegment.calculatedHandleOut(segment,);
@@ -38603,11 +29441,8 @@ function toSVGPath(withPaths, translate = {
         pathElements.push('C', handleOut.x + translate.x, handleOut.y + translate.y, handleIn.x + translate.x, handleIn.y + translate.y,);
       }
       if (isLastSegment && nextSegment) {
-        if (isStraightCurve(segment, nextSegment,)) {
-          pathElements.push('Z',);
-        } else {
-          pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, 'Z',);
-        }
+        if (isStraightCurve(segment, nextSegment,)) pathElements.push('Z',);
+        else pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, 'Z',);
       }
     }
   },);
@@ -38635,15 +29470,8 @@ var svgElementAttributeDefaults = {
   fillOpacity: 1,
 };
 function createTransformValues(baseTransform, mode,) {
-  let {
-    x,
-    y,
-  } = baseTransform;
-  const {
-    width,
-    height,
-    rotation,
-  } = baseTransform;
+  let { x, y, } = baseTransform;
+  const { width, height, rotation, } = baseTransform;
   if (mode === 'resetXYKeepFraction') {
     x = x - Math.floor(x,);
     y = y - Math.floor(y,);
@@ -38651,54 +29479,25 @@ function createTransformValues(baseTransform, mode,) {
     x = 0;
     y = 0;
   }
-  return {
-    x,
-    y,
-    width,
-    height,
-    rotation,
-  };
+  return { x, y, width, height, rotation, };
 }
 function getTransformMode(isRootVectorNode, includeTransform,) {
-  if (includeTransform !== void 0) {
-    if (includeTransform) {
-      return 'asIs';
-    }
-  } else {
-    if (!isRootVectorNode) {
-      return 'asIs';
-    }
-  }
-  if (isRootVectorNode) {
-    return 'resetXYKeepFraction';
-  } else {
-    return 'resetXY';
-  }
+  if (includeTransform !== void 0) if (includeTransform) return 'asIs';
+  else if (!isRootVectorNode) return 'asIs';
+  if (isRootVectorNode) return 'resetXYKeepFraction';
+  else return 'resetXY';
 }
 function transformValues(rect, rotation, isRootVectorNode, includeTransform,) {
   const transformMode = getTransformMode(isRootVectorNode, includeTransform,);
-  const baseTransform = {
-    ...rect,
-    rotation,
-  };
+  const baseTransform = { ...rect, rotation, };
   const transform2 = createTransformValues(baseTransform, transformMode,);
   return transform2;
 }
 function transformString(transform2,) {
-  if (transform2 === void 0) {
-    return void 0;
-  }
-  const {
-    x,
-    y,
-    rotation,
-    width,
-    height,
-  } = transform2;
+  if (transform2 === void 0) return void 0;
+  const { x, y, rotation, width, height, } = transform2;
   let result;
-  if (x !== 0 || y !== 0) {
-    result = `translate(${roundedNumberString(x, 3,)} ${roundedNumberString(y, 3,)})`;
-  }
+  if (x !== 0 || y !== 0) result = `translate(${roundedNumberString(x, 3,)} ${roundedNumberString(y, 3,)})`;
   if (rotation !== 0) {
     const roundedRotation = roundedNumberString(rotation, 4,);
     const roundedWidth = roundedNumberString(width / 2, 3,);
@@ -38710,14 +29509,7 @@ function transformString(transform2,) {
 }
 var LinearGradientElement = class extends Component2 {
   render() {
-    const {
-      id: id3,
-      stops,
-      x1,
-      x2,
-      y1,
-      y2,
-    } = this.props;
+    const { id: id3, stops, x1, x2, y1, y2, } = this.props;
     return /* @__PURE__ */ _jsx5('linearGradient', {
       id: id3,
       x1,
@@ -38725,25 +29517,14 @@ var LinearGradientElement = class extends Component2 {
       y1,
       y2,
       children: stops.map((stop, idx,) => {
-        return /* @__PURE__ */ _jsx5('stop', {
-          offset: stop.position,
-          stopColor: stop.color,
-          stopOpacity: stop.alpha,
-        }, idx,);
+        return /* @__PURE__ */ _jsx5('stop', { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha, }, idx,);
       },),
     },);
   }
 };
 var RadialGradientElement = class extends Component2 {
   render() {
-    const {
-      centerAnchorX,
-      centerAnchorY,
-      id: id3,
-      widthFactor,
-      heightFactor,
-      stops,
-    } = this.props;
+    const { centerAnchorX, centerAnchorY, id: id3, widthFactor, heightFactor, stops, } = this.props;
     return /* @__PURE__ */ _jsx5('radialGradient', {
       id: id3,
       cy: centerAnchorY,
@@ -38753,26 +29534,15 @@ var RadialGradientElement = class extends Component2 {
         heightFactor / widthFactor
       }) translate(-${centerAnchorX}, -${centerAnchorY})`,
       children: stops.map((stop, idx,) => {
-        return /* @__PURE__ */ _jsx5('stop', {
-          offset: stop.position,
-          stopColor: stop.color,
-          stopOpacity: stop.alpha,
-        }, idx,);
+        return /* @__PURE__ */ _jsx5('stop', { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha, }, idx,);
       },),
     },);
   }
 };
 var SVGRoot = class extends Component2 {
   render() {
-    const {
-      children,
-      frame: frame2,
-      innerRef,
-    } = this.props;
-    const {
-      width,
-      height,
-    } = frame2;
+    const { children, frame: frame2, innerRef, } = this.props;
+    const { width, height, } = frame2;
     const fx = Math.floor(frame2.x,);
     const fy = Math.floor(frame2.y,);
     const svgStyle = {
@@ -38830,9 +29600,7 @@ var Vector = /* @__PURE__ */ (() => {
       } = this.props;
       if (!id3 || !shapeId || !strokeClipId) return null;
       const rotate = this.props.rotate ?? rotation ?? 0;
-      const {
-        target,
-      } = RenderEnvironment;
+      const { target, } = RenderEnvironment;
       const transform2 = transformValues(rect, rotate, isRootVectorNode, includeTransform,);
       let vectorFill;
       let fillAlpha = 0;
@@ -38860,16 +29628,10 @@ var Vector = /* @__PURE__ */ (() => {
           fillAlpha = 1;
         }
       }
-      if (vectorFill === svgElementAttributeDefaults.fill) {
-        vectorFill = void 0;
-      }
-      if (vectorFill === void 0) {
-        vectorFill = 'transparent';
-      }
+      if (vectorFill === svgElementAttributeDefaults.fill) vectorFill = void 0;
+      if (vectorFill === void 0) vectorFill = 'transparent';
       const fillEnabled = vectorFill !== void 0 && vectorFill !== 'transparent' && fillAlpha !== 0;
-      if (!fillEnabled && !strokeEnabled) {
-        fillAlpha = 1;
-      }
+      if (!fillEnabled && !strokeEnabled) fillAlpha = 1;
       let mainElement;
       let strokeClipPath = null;
       let shapeReference = null;
@@ -38877,32 +29639,21 @@ var Vector = /* @__PURE__ */ (() => {
       let pathTranslate;
       let elementTransform;
       const translatePaths = target === 'EXPORT';
-      if (transform2.rotation === 0 && translatePaths) {
-        pathTranslate = transform2;
-      } else {
-        pathTranslate = {
-          x: 0,
-          y: 0,
-        };
+      if (transform2.rotation === 0 && translatePaths) pathTranslate = transform2;
+      else {
+        pathTranslate = { x: 0, y: 0, };
         elementTransform = transformString(transform2,);
       }
-      const pathAttributes = {
-        d: d ?? toSVGPath(calculatedPath, pathTranslate, target,),
-        transform: elementTransform,
-      };
+      const pathAttributes = { d: d ?? toSVGPath(calculatedPath, pathTranslate, target,), transform: elementTransform, };
       const svgStrokeAttributes = {};
       if (strokeEnabled && strokeWidth !== 0) {
         svgStrokeAttributes.strokeWidth = strokeWidth;
         svgStrokeAttributes.stroke = strokeColor;
         svgStrokeAttributes.strokeLinecap = lineCap;
         svgStrokeAttributes.strokeLinejoin = lineJoin;
-        if (lineJoin === 'miter') {
-          svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;
-        }
+        if (lineJoin === 'miter') svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;
         svgStrokeAttributes.strokeDasharray = strokeDashArray;
-        if (strokeDashOffset !== 0) {
-          svgStrokeAttributes.strokeDashoffset = strokeDashOffset;
-        }
+        if (strokeDashOffset !== 0) svgStrokeAttributes.strokeDashoffset = strokeDashOffset;
       }
       for (const key7 in svgElementAttributeDefaults) {
         if (asRecord(svgStrokeAttributes,)[key7] === asRecord(svgElementAttributeDefaults,)[key7]) {
@@ -38924,19 +29675,11 @@ var Vector = /* @__PURE__ */ (() => {
       const currentName = target === 'PREVIEW' ? name || void 0 : void 0;
       if (shadow.insetElement !== null || shadow.outsetElement !== null || insideStroke) {
         pathAttributes.id = internalShapeId.id;
-        shapeReference = /* @__PURE__ */ _jsx5(motion.path, {
-          ...{
-            ...pathAttributes,
-          },
-          variants,
-          transition,
-        },);
+        shapeReference = /* @__PURE__ */ _jsx5(motion.path, { ...{ ...pathAttributes, }, variants, transition, },);
         if (shadow.needsStrokeClip || insideStroke) {
           strokeClipPath = /* @__PURE__ */ _jsx5('clipPath', {
             id: internalStrokeClipId.id,
-            children: /* @__PURE__ */ _jsx5('use', {
-              xlinkHref: internalShapeId.link,
-            },),
+            children: /* @__PURE__ */ _jsx5('use', { xlinkHref: internalShapeId.link, },),
           },);
         }
         if (shadow.insetElement !== null && strokeEnabled && strokeWidth && strokeWidth > 0) {
@@ -38953,24 +29696,18 @@ var Vector = /* @__PURE__ */ (() => {
             ...svgStrokeAttributes,
             strokeWidth,
           },);
-        } else {
-          mainElement = /* @__PURE__ */ _jsx5('use', {
+        } else {mainElement = /* @__PURE__ */ _jsx5('use', {
             xlinkHref: internalShapeId.link,
             fill: vectorFill,
             clipPath: internalStrokeClipId.urlLink,
             ...svgStrokeAttributes,
             strokeWidth,
             name: currentName,
-          },);
-        }
+          },);}
       } else {
         pathAttributes.id = idAttribute;
         mainElement = /* @__PURE__ */ _jsx5(motion.path, {
-          ...{
-            ...pathAttributes,
-            fill: vectorFill,
-            ...svgStrokeAttributes,
-          },
+          ...{ ...pathAttributes, fill: vectorFill, ...svgStrokeAttributes, },
           name: currentName,
           variants,
           transition,
@@ -38983,15 +29720,8 @@ var Vector = /* @__PURE__ */ (() => {
         },)
         : void 0;
       let gradient;
-      if (linearGradient) {
-        gradient = /* @__PURE__ */ _jsx5(LinearGradientElement, {
-          ...linearGradient,
-        },);
-      } else if (radialGradient) {
-        gradient = /* @__PURE__ */ _jsx5(RadialGradientElement, {
-          ...radialGradient,
-        },);
-      }
+      if (linearGradient) gradient = /* @__PURE__ */ _jsx5(LinearGradientElement, { ...linearGradient, },);
+      else if (radialGradient) gradient = /* @__PURE__ */ _jsx5(RadialGradientElement, { ...radialGradient, },);
       let defs = null;
       if (shapeReference || strokeClipPath || shadow.definition && shadow.definition.length || gradient || imagePatternElement) {
         defs = /* @__PURE__ */ _jsxs('defs', {
@@ -39001,11 +29731,7 @@ var Vector = /* @__PURE__ */ (() => {
       const opacityValue = opacity ?? (variants ? 1 : void 0);
       if (defs === null && shadow.outsetElement === null && shadow.insetElement === null && strokeElement === null) {
         mainElement = /* @__PURE__ */ _jsx5(motion.path, {
-          ...{
-            ...pathAttributes,
-            fill: vectorFill,
-            ...svgStrokeAttributes,
-          },
+          ...{ ...pathAttributes, fill: vectorFill, ...svgStrokeAttributes, },
           opacity: opacityValue,
           variants,
           transition,
@@ -39013,28 +29739,18 @@ var Vector = /* @__PURE__ */ (() => {
         },);
         return this.renderElement(mainElement,);
       }
-      return this.renderElement(/* @__PURE__ */ _jsxs(motion.g, {
-        opacity: opacityValue,
-        variants,
-        transition,
-        children: [defs, shadow.outsetElement, mainElement, shadow.insetElement, strokeElement,],
-      },),);
+      return this.renderElement(
+        /* @__PURE__ */ _jsxs(motion.g, {
+          opacity: opacityValue,
+          variants,
+          transition,
+          children: [defs, shadow.outsetElement, mainElement, shadow.insetElement, strokeElement,],
+        },),
+      );
     }
     renderElement(element,) {
-      const {
-        isRootVectorNode,
-        width,
-        height,
-        rect,
-        willChangeTransform,
-        includeTransform,
-      } = this.props;
-      const frame2 = this.props.frame ?? rect ?? {
-        x: 0,
-        y: 0,
-        width: 100,
-        height: 100,
-      };
+      const { isRootVectorNode, width, height, rect, willChangeTransform, includeTransform, } = this.props;
+      const frame2 = this.props.frame ?? rect ?? { x: 0, y: 0, width: 100, height: 100, };
       if (!isRootVectorNode) return element;
       if (includeTransform) return element;
       return /* @__PURE__ */ _jsx5(SVGRoot, {
@@ -39072,12 +29788,7 @@ var Vector = /* @__PURE__ */ (() => {
       transition: void 0,
       shadows: [],
       strokeAlpha: 1,
-      rect: {
-        x: 0,
-        y: 0,
-        width: 0,
-        height: 0,
-      },
+      rect: { x: 0, y: 0, width: 0, height: 0, },
       lineCap: 'butt',
       strokeColor: '#0AF',
       lineJoin: 'miter',
@@ -39086,10 +29797,7 @@ var Vector = /* @__PURE__ */ (() => {
       strokeDashOffset: 0,
       fill: 'rgba(0,170,255,0.5)',
     },),
-    __publicField(_a, 'defaultProps', {
-      ...Layer.defaultProps,
-      ..._a.defaultVectorProps,
-    },),
+    __publicField(_a, 'defaultProps', { ...Layer.defaultProps, ..._a.defaultVectorProps, },),
     _a;
 })();
 var VectorGroup = /* @__PURE__ */ (() => {
@@ -39114,46 +29822,22 @@ var VectorGroup = /* @__PURE__ */ (() => {
         isRootVectorNode,
       } = this.props;
       if (!visible) return null;
-      const {
-        target,
-      } = RenderEnvironment;
-      const rect = {
-        x,
-        y,
-        width,
-        height,
-      };
+      const { target, } = RenderEnvironment;
+      const rect = { x, y, width, height, };
       const transform2 = transformValues(rect, rotation, isRootVectorNode, includeTransform,);
       const addNames = target === 'PREVIEW';
       let name = void 0;
       if (addNames) {
-        if (targetName) {
-          name = targetName;
-        } else if (nameProp) {
-          name = nameProp;
-        } else {
-          name = defaultName;
-        }
+        if (targetName) name = targetName;
+        else if (nameProp) name = nameProp;
+        else name = defaultName;
       }
-      return this.renderElement(/* @__PURE__ */ _jsx5('g', {
-        transform: transformString(transform2,),
-        ...{
-          id: id3,
-          name,
-          opacity,
-        },
-        children,
-      },),);
+      return this.renderElement(
+        /* @__PURE__ */ _jsx5('g', { transform: transformString(transform2,), ...{ id: id3, name, opacity, }, children, },),
+      );
     }
     renderElement(element,) {
-      const {
-        isRootVectorNode,
-        width,
-        height,
-        frame: frame2,
-        willChangeTransform,
-        includeTransform,
-      } = this.props;
+      const { isRootVectorNode, width, height, frame: frame2, willChangeTransform, includeTransform, } = this.props;
       if (!isRootVectorNode) return element;
       if (includeTransform) return element;
       return /* @__PURE__ */ _jsx5(SVGRoot, {
@@ -39179,17 +29863,9 @@ var VectorGroup = /* @__PURE__ */ (() => {
       defaultName: '',
       isRootVectorNode: false,
       includeTransform: void 0,
-      frame: {
-        x: 0,
-        y: 0,
-        width: 100,
-        height: 100,
-      },
-    },),
-    __publicField(_a, 'defaultProps', {
-      ...Layer.defaultProps,
-      ..._a.defaultVectorGroupProps,
+      frame: { x: 0, y: 0, width: 100, height: 100, },
     },),
+    __publicField(_a, 'defaultProps', { ...Layer.defaultProps, ..._a.defaultVectorGroupProps, },),
     _a;
 })();
 var key6 = 'calculatedPaths';
@@ -39198,10 +29874,7 @@ function withShape(target,) {
 }
 var Size = /* @__PURE__ */ (() => {
   function Size2(width, height,) {
-    return {
-      width,
-      height,
-    };
+    return { width, height, };
   }
   Size2.equals = (sizeA, sizeB,) => {
     if (sizeA === sizeB) return true;
@@ -39209,40 +29882,25 @@ var Size = /* @__PURE__ */ (() => {
     return sizeA.width === sizeB.width && sizeA.height === sizeB.height;
   };
   Size2.update = (fromSize, toSize, keepAspectRatio = false,) => {
-    let {
-      width,
-      height,
-    } = fromSize;
+    let { width, height, } = fromSize;
     const sizeRatio = width / height;
     width = toSize.width !== void 0 ? toSize.width : width;
     height = toSize.height !== void 0 ? toSize.height : height;
     if (keepAspectRatio) {
-      if (toSize.width === void 0 && toSize.height !== void 0) {
-        width = toSize.height * sizeRatio;
-      }
-      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) {
-        height = toSize.width / sizeRatio;
-      }
+      if (toSize.width === void 0 && toSize.height !== void 0) width = toSize.height * sizeRatio;
+      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) height = toSize.width / sizeRatio;
     }
-    return {
-      width,
-      height,
-    };
+    return { width, height, };
   };
   Size2.subtract = (sizeA, sizeB,) => {
-    return {
-      width: Math.max(0, sizeA.width - sizeB.width,),
-      height: Math.max(0, sizeA.height - sizeB.height,),
-    };
+    return { width: Math.max(0, sizeA.width - sizeB.width,), height: Math.max(0, sizeA.height - sizeB.height,), };
   };
   Size2.zero = Size2(0, 0,);
   Size2.isZero = function (size2,) {
     return size2 === Size2.zero || size2.width === 0 && size2.height === 0;
   };
   Size2.defaultIfZero = function (width, height, size2,) {
-    if (Size2.isZero(size2,)) {
-      return Size2(width, height,);
-    }
+    if (Size2.isZero(size2,)) return Size2(width, height,);
     return size2;
   };
   return Size2;
@@ -39251,9 +29909,7 @@ function annotateTypeOnStringify(ctor, typeName,) {
   const existingToJSON = ctor.prototype.toJSON;
   ctor.prototype.toJSON = function () {
     const base = existingToJSON ? existingToJSON.apply(this,) : this;
-    return Object.assign({}, base, {
-      __type__: typeName,
-    },);
+    return Object.assign({}, base, { __type__: typeName, },);
   };
   return ctor;
 }
@@ -39271,67 +29927,34 @@ var frameFromElements = (elements) => {
 };
 var convertToPageFrame = (frame2, element,) => {
   const point2 = convertToPagePoint(frame2, element,);
-  return {
-    x: point2.x,
-    y: point2.y,
-    width: frame2.width,
-    height: frame2.height,
-  };
+  return { x: point2.x, y: point2.y, width: frame2.width, height: frame2.height, };
 };
 var convertFromPageFrame = (frame2, element,) => {
   const point2 = convertFromPagePoint(frame2, element,);
-  return {
-    x: point2.x,
-    y: point2.y,
-    width: frame2.width,
-    height: frame2.height,
-  };
+  return { x: point2.x, y: point2.y, width: frame2.width, height: frame2.height, };
 };
 var getPageFrame = (element) => {
   const rect = element.getBoundingClientRect();
-  return {
-    x: rect.left + safeWindow.scrollX,
-    y: rect.top + safeWindow.scrollY,
-    width: rect.width,
-    height: rect.height,
-  };
+  return { x: rect.left + safeWindow.scrollX, y: rect.top + safeWindow.scrollY, width: rect.width, height: rect.height, };
 };
 var fromEventForPage = (event) => {
-  return {
-    x: event.pageX,
-    y: event.pageY,
-  };
+  return { x: event.pageX, y: event.pageY, };
 };
 var fromEventForClient = (event) => {
-  return {
-    x: event.clientX,
-    y: event.clientY,
-  };
+  return { x: event.clientX, y: event.clientY, };
 };
 var convertToPagePoint = (point2, element,) => {
   const frame2 = getPageFrame(element,);
-  return {
-    x: point2.x + frame2.x,
-    y: point2.y + frame2.y,
-  };
+  return { x: point2.x + frame2.x, y: point2.y + frame2.y, };
 };
 var convertFromPagePoint = (point2, element,) => {
   const frame2 = getPageFrame(element,);
-  return {
-    x: point2.x - frame2.x,
-    y: point2.y - frame2.y,
-  };
+  return { x: point2.x - frame2.x, y: point2.y - frame2.y, };
 };
 var dispatchKeyDownEvent = (keyCode, options = {},) => {
-  const keyboardEvent = new KeyboardEvent('keydown', {
-    bubbles: true,
-    keyCode,
-    ...options,
-  },);
+  const keyboardEvent = new KeyboardEvent('keydown', { bubbles: true, keyCode, ...options, },);
   const activeElement = document.activeElement;
-  if (activeElement) {
-    activeElement.dispatchEvent(keyboardEvent,);
-  }
+  if (activeElement) activeElement.dispatchEvent(keyboardEvent,);
 };
 var DOM = {
   frameFromElement,
@@ -39345,12 +29968,8 @@ var DOM = {
   convertFromPagePoint,
 };
 function gradientForShape(nodeId, node,) {
-  if (LinearGradient.isLinearGradient(node.fill,)) {
-    return elementPropertiesForLinearGradient(node.fill, nodeId,);
-  }
-  if (RadialGradient.isRadialGradient(node.fill,)) {
-    return elementPropertiesForRadialGradient(node.fill, nodeId,);
-  }
+  if (LinearGradient.isLinearGradient(node.fill,)) return elementPropertiesForLinearGradient(node.fill, nodeId,);
+  if (RadialGradient.isRadialGradient(node.fill,)) return elementPropertiesForRadialGradient(node.fill, nodeId,);
   return void 0;
 }
 function throttle(fn, time22,) {
@@ -39371,9 +29990,7 @@ function throttle(fn, time22,) {
       }
       previous = now2;
       fn(...args,);
-    } else if (!timeout) {
-      timeout = safeWindow.setTimeout(later, remaining, ...args,);
-    }
+    } else if (!timeout) timeout = safeWindow.setTimeout(later, remaining, ...args,);
   };
 }
 function addActionControls(action, title, controls,) {
@@ -39382,53 +29999,29 @@ function addActionControls(action, title, controls,) {
 function addFonts(component, passedFonts, flags,) {
   const fonts = convertMixedFontArrayToFontBundles(passedFonts,);
   if (
-    !(flags == null ? void 0 : flags.supportsExplicitInterCodegen) &&
-    // Only emit an `explicitInter: false` bundle if we don’t already have one.
+    !(flags == null ? void 0 : flags.supportsExplicitInterCodegen) && // Only emit an `explicitInter: false` bundle if we don’t already have one.
     !fonts.some((font) => font.explicitInter === false)
-  ) {
-    fonts.push({
-      explicitInter: false,
-      fonts: [],
-    },);
-  }
-  Object.assign(component, {
-    fonts,
-  },);
+  ) fonts.push({ explicitInter: false, fonts: [], },);
+  Object.assign(component, { fonts, },);
 }
 function getFonts(component,) {
   const fonts = component.fonts;
   return fonts ?? [];
 }
 function getFontsFromSharedStyle(fonts,) {
-  if (fonts.length === 0) {
-    return [{
-      explicitInter: false,
-      fonts: [],
-    },];
-  }
+  if (fonts.length === 0) return [{ explicitInter: false, fonts: [], },];
   return convertMixedFontArrayToFontBundles(fonts,);
 }
 function getFontsFromComponentPreset(fonts,) {
-  if (fonts.length === 0) {
-    return [{
-      explicitInter: false,
-      fonts: [],
-    },];
-  }
+  if (fonts.length === 0) return [{ explicitInter: false, fonts: [], },];
   return convertMixedFontArrayToFontBundles(fonts,);
 }
 function convertMixedFontArrayToFontBundles(fonts,) {
-  const oldFontBundle = {
-    explicitInter: false,
-    fonts: [],
-  };
+  const oldFontBundle = { explicitInter: false, fonts: [], };
   const fontBundles = [];
   for (const fontOrBundle of fonts) {
-    if (isComponentFontBundle(fontOrBundle,)) {
-      fontBundles.push(fontOrBundle,);
-    } else {
-      oldFontBundle.fonts.push(upgradeComponentFontV1(fontOrBundle,),);
-    }
+    if (isComponentFontBundle(fontOrBundle,)) fontBundles.push(fontOrBundle,);
+    else oldFontBundle.fonts.push(upgradeComponentFontV1(fontOrBundle,),);
   }
   if (oldFontBundle.fonts.length > 0) fontBundles.push(oldFontBundle,);
   return fontBundles;
@@ -39439,107 +30032,65 @@ function isComponentFontBundle(font,) {
 }
 function upgradeComponentFontV1(font,) {
   let source;
-  if (font.url.startsWith('https://fonts.gstatic.com/s/',)) {
-    source = 'google';
-  } else if (font.url.startsWith('https://framerusercontent.com/third-party-assets/fontshare/',)) {
-    source = 'fontshare';
-  } else {
-    source = 'custom';
-  }
-  return {
-    ...font,
-    source,
-  };
+  if (font.url.startsWith('https://fonts.gstatic.com/s/',)) source = 'google';
+  else if (font.url.startsWith('https://framerusercontent.com/third-party-assets/fontshare/',)) source = 'fontshare';
+  else source = 'custom';
+  return { ...font, source, };
 }
 function loadJSON(url,) {
-  return fetch(url, {
-    mode: 'cors',
-  },).then((res) => res.json());
+  return fetch(url, { mode: 'cors', },).then((res) => res.json());
 }
 function inspectObjectType(item,) {
   let className;
   if (
     (item.constructor !== null ? item.constructor.name : void 0) !== null &&
     (item.constructor !== null ? item.constructor.name : void 0) !== 'Object'
-  ) {
-    return item.constructor.name;
-  }
+  ) return item.constructor.name;
   const extract = function (str,) {
-    if (!str) {
-      return null;
-    }
+    if (!str) return null;
     const regex2 = /\[object (\w+)\]/;
     const match = regex2.exec(str,);
-    if (match) {
-      return match[1];
-    }
+    if (match) return match[1];
     return null;
   };
   if (item.toString) {
     className = extract(item.toString(),);
-    if (className) {
-      return className;
-    }
+    if (className) return className;
   }
   if (item.constructor !== null ? item.constructor.toString : void 0) {
     className = extract(item.constructor !== null ? item.constructor.toString() : void 0,);
-    if (className) {
-      return className.replace('Constructor', '',);
-    }
+    if (className) return className.replace('Constructor', '',);
   }
   return 'Object';
 }
 function inspect(item, max, l,) {
-  if (max === void 0) {
-    max = 5;
-  }
-  if (l === void 0) {
-    l = 0;
-  }
-  if (item === null) {
-    return 'null';
-  }
-  if (item === void 0) {
-    return 'undefined';
-  }
-  if (isObject2(item,) && isFunction(item.toInspect,)) {
-    return item.toInspect();
-  }
-  if (isString22(item,)) {
-    return `"${item}"`;
-  }
-  if (isNumber2(item,)) {
-    return `${item}`;
-  }
+  if (max === void 0) max = 5;
+  if (l === void 0) l = 0;
+  if (item === null) return 'null';
+  if (item === void 0) return 'undefined';
+  if (isObject2(item,) && isFunction(item.toInspect,)) return item.toInspect();
+  if (isString22(item,)) return `"${item}"`;
+  if (isNumber2(item,)) return `${item}`;
   if (isFunction(item,)) {
     let code = item.toString().slice('function '.length,).replace(/\n/g, '',).replace(/\s+/g, ' ',);
     const limit = 50;
-    if (code.length > limit && l > 0) {
-      code = `${code.slice(0, +limit + 1 || void 0,).trim()}\u2026 }`;
-    }
+    if (code.length > limit && l > 0) code = `${code.slice(0, +limit + 1 || void 0,).trim()}\u2026 }`;
     return `<Function ${code}>`;
   }
   if (isArray(item,)) {
-    if (l > max) {
-      return '[...]';
-    }
+    if (l > max) return '[...]';
     return `[${item.map((i) => inspect(i, max, (l || 0) + 1,)).join(', ',)}]`;
   }
   if (isObject2(item,)) {
     let objectInfo;
     const objectType = inspectObjectType(item,);
-    if (/HTML\w+?Element/.test(objectType,)) {
-      return `<${objectType}>`;
-    }
-    if (l > max) {
-      objectInfo = '{...}';
-    } else {
+    if (/HTML\w+?Element/.test(objectType,)) return `<${objectType}>`;
+    if (l > max) objectInfo = '{...}';
+    else {
       const itemKeys = Object.keys(item,);
       objectInfo = `{${itemKeys.map((k) => `${k}:${inspect(item[k], max, (l || 0) + 1,)}`).join(', ',)}}`;
     }
-    if (objectType === 'Object') {
-      return objectInfo;
-    }
+    if (objectType === 'Object') return objectInfo;
     return `<${objectType} ${objectInfo}>`;
   }
   return `${item}`;
@@ -39560,9 +30111,7 @@ function useInitialRouteComponent(routes, homeNodeId,) {
   const InitialRouteComponent = (_a = routes[homeNodeId]) == null ? void 0 : _a.page;
   const [RouteComponent, setRouteComponent,] = useState(initialRouteComponent(InitialRouteComponent,),);
   useEffect(() => {
-    if (withPreload(InitialRouteComponent,)) {
-      void InitialRouteComponent.preload().then(setRouteComponent,);
-    }
+    if (withPreload(InitialRouteComponent,)) void InitialRouteComponent.preload().then(setRouteComponent,);
   }, [],);
   return RouteComponent;
 }
@@ -39571,11 +30120,7 @@ var package_default = {
   version: '2.4.1',
   main: 'build/index.js',
   type: 'module',
-  exports: {
-    '.': './build/index.js',
-    './package.json': './package.json',
-    './*': './build/*',
-  },
+  exports: { '.': './build/index.js', './package.json': './package.json', './*': './build/*', },
   files: ['build', 'CHANGELOG.md', 'README.md', 'LICENSE.md', 'postinstall.cjs',],
   types: './build/index.d.ts',
   author: 'Framer',
@@ -39623,42 +30168,23 @@ var package_default = {
     typescript: '^5.3.3',
     yargs: '^17.6.2',
   },
-  peerDependencies: {
-    'framer-motion': '11.0.11-sync.5',
-    react: '^18.2.0',
-    'react-dom': '^18.2.0',
-  },
-  tsdoc: {
-    tsdocFlavor: 'AEDoc',
-  },
+  peerDependencies: { 'framer-motion': '11.0.11-sync.5', react: '^18.2.0', 'react-dom': '^18.2.0', },
+  tsdoc: { tsdocFlavor: 'AEDoc', },
   framer: {
     components: [{
       name: 'Scroll',
       children: true,
-      properties: [{
-        key: 'direction',
-        title: 'Direction',
-        kind: 'enum',
-        options: ['horizontal', 'vertical', 'both',],
-      },],
-    }, {
-      name: 'Page',
-    },],
+      properties: [{ key: 'direction', title: 'Direction', kind: 'enum', options: ['horizontal', 'vertical', 'both',], },],
+    }, { name: 'Page', },],
   },
 };
-var {
-  version,
-} = package_default;
-MotionValue.prototype.addChild = function ({
-  transformer = (v) => v,
-},) {
+var { version, } = package_default;
+MotionValue.prototype.addChild = function ({ transformer = (v) => v, },) {
   const child = motionValue(transformer(this.get(),),);
   this.onChange((v) => child.set(transformer(v,),));
   return child;
 };
-if (false) {
-  MainLoop.start();
-}
+if (false) MainLoop.start();
 export {
   _injectRuntime,
   addActionControls,
@@ -40031,8 +30557,7 @@ export {
   withVariantAppearEffect,
   withVariantFX,
   wrap,
-};
-/**
+}; /**
  * @license Emotion v11.0.0
  * MIT License
  *
@@ -40056,6 +30581,7 @@ export {
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */
+
 /*! Bundled license information:
 
 react-is/cjs/react-is.production.min.js:
