// @ts-nocheck
// https:https://app.framerstatic.com/chunk-4NJGI344.js
import { createContext, } from 'react';
import { createContext as createContext2, } from 'react';
import { createContext as createContext3, } from 'react';
import { useEffect, useLayoutEffect, } from 'react';
import { createContext as createContext4, } from 'react';
import { createContext as createContext5, } from 'react';
import * as React from 'react';
import { forwardRef, useContext as useContext3, } from 'react';
import { useContext, useEffect as useEffect2, useInsertionEffect, useRef, } from 'react';
import { createContext as createContext6, } from 'react';
import { useCallback, } from 'react';
import { useContext as useContext2, useMemo, } from 'react';
import { useContext as useContext4, } from 'react';
import { useRef as useRef2, } from 'react';
import { useContext as useContext5, useEffect as useEffect3, useId, } from 'react';
import { createElement as createElement2, Fragment, useMemo as useMemo4, } from 'react';
import { useMemo as useMemo2, } from 'react';
import { useMemo as useMemo3, } from 'react';
import React__default, { useContext as useContext6, } from 'react';
import { useCallback as useCallback2, useState, } from 'react';
import { useRef as useRef3, } from 'react';
import { useEffect as useEffect4, } from 'react';
import * as React4 from 'react';
import { Children, cloneElement as cloneElement2, isValidElement, useContext as useContext7, useRef as useRef5, } from 'react';
import * as React3 from 'react';
import { useId as useId3, useMemo as useMemo5, } from 'react';
import * as React2 from 'react';
import { useId as useId2, useInsertionEffect as useInsertionEffect2, useRef as useRef4, } from 'react';
import * as React5 from 'react';
import { useContext as useContext8, useMemo as useMemo6, } from 'react';
import * as React6 from 'react';
import { useEffect as useEffect6, useRef as useRef6, useState as useState2, } from 'react';
import { createContext as createContext7, } from 'react';
import * as React7 from 'react';
import { useContext as useContext9, useMemo as useMemo7, useRef as useRef7, } from 'react';
import { useContext as useContext10, useEffect as useEffect7, useState as useState3, } from 'react';
import * as React8 from 'react';
import { forwardRef as forwardRef2, useEffect as useEffect8, useRef as useRef8, } from 'react';
import { createContext as createContext8, } from 'react';
import * as React9 from 'react';
import { forwardRef as forwardRef3, useContext as useContext11, } from 'react';
import { useContext as useContext12, useInsertionEffect as useInsertionEffect3, useRef as useRef9, } from 'react';
import { useInsertionEffect as useInsertionEffect4, } from 'react';
import { useEffect as useEffect9, } from 'react';
import { useContext as useContext13, useEffect as useEffect10, useRef as useRef10, } from 'react';
import { useState as useState4, } from 'react';
import { useContext as useContext14, } from 'react';
import { useCallback as useCallback3, useRef as useRef11, useState as useState5, } from 'react';
import { useEffect as useEffect11, useState as useState6, } from 'react';
import { useEffect as useEffect12, } from 'react';
import { useEffect as useEffect13, useRef as useRef12, } from 'react';
import * as React10 from 'react';
import { useEffect as useEffect14, useState as useState7, } from 'react';
import { useContext as useContext15, } from 'react';
import * as React11 from 'react';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key7, value,) =>
  key7 in obj ? __defProp(obj, key7, { enumerable: true, configurable: true, writable: true, value, },) : obj[key7] = value;
var __commonJS = (cb, mod,) =>
  function __require() {
    return mod || (0, cb[__getOwnPropNames(cb,)[0]])((mod = { exports: {}, }).exports, mod,), mod.exports;
  };
var __copyProps = (to, from, except, desc,) => {
  if (from && typeof from === 'object' || typeof from === 'function') {
    for (let key7 of __getOwnPropNames(from,)) {
      if (!__hasOwnProp.call(to, key7,) && key7 !== except) {
        __defProp(to, key7, { get: () => from[key7], enumerable: !(desc = __getOwnPropDesc(from, key7,)) || desc.enumerable, },);
      }
    }
  }
  return to;
};
var __toESM = (mod, isNodeMode, target,) => (target = mod != null ? __create(__getProtoOf(mod,),) : {},
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, 'default', { value: mod, enumerable: true, },) : target,
    mod,
  ));
var __publicField = (obj, key7, value,) => {
  __defNormalProp(obj, typeof key7 !== 'symbol' ? key7 + '' : key7, value,);
  return value;
};
var __accessCheck = (obj, member, msg2,) => {
  if (!member.has(obj,)) {
    throw TypeError('Cannot ' + msg2,);
  }
};
var __privateGet = (obj, member, getter,) => {
  __accessCheck(obj, member, 'read from private field',);
  return getter ? getter.call(obj,) : member.get(obj,);
};
var __privateAdd = (obj, member, value,) => {
  if (member.has(obj,)) {
    throw TypeError('Cannot add the same private member more than once',);
  }
  member instanceof WeakSet ? member.add(obj,) : member.set(obj, value,);
};
var __privateSet = (obj, member, value, setter,) => {
  __accessCheck(obj, member, 'write to private field',);
  setter ? setter.call(obj, value,) : member.set(obj, value,);
  return value;
};
var require_memoize_browser_cjs = __commonJS({
  '../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js'(exports,) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true, },);
    function memoize3(fn,) {
      var cache3 = {};
      return function (arg,) {
        if (cache3[arg] === void 0) {
          cache3[arg] = fn(arg,);
        }
        return cache3[arg];
      };
    }
    exports.default = memoize3;
  },
},);
var require_is_prop_valid_browser_cjs = __commonJS({
  '../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js'(exports,) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true, },);
    function _interopDefault(ex,) {
      return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
    }
    var memoize3 = _interopDefault(require_memoize_browser_cjs(),);
    var reactPropsRegex2 =
      /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var index = memoize3(
      function (prop,) {
        return reactPropsRegex2.test(prop,) || prop.charCodeAt(0,) === 111 && prop.charCodeAt(1,) === 110 && prop.charCodeAt(2,) < 91;
      },
      /* Z+1 */
    );
    exports.default = index;
  },
},);
var MotionConfigContext = createContext({
  transformPagePoint: (p,) => p,
  isStatic: false,
  reducedMotion: 'never',
},);
var MotionContext = createContext2({},);
var PresenceContext = createContext3(null,);
var isBrowser = typeof document !== 'undefined';
var useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;
var camelToDash = (str,) => str.replace(/([a-z])([A-Z])/g, '$1-$2',).toLowerCase();
var optimizedAppearDataId = 'framerAppearId';
var optimizedAppearDataAttribute = 'data-' + camelToDash(optimizedAppearDataId,);
var MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false,
};
var LayoutGroupContext = createContext4({},);
var SwitchLayoutGroupContext = createContext5({},);
var LazyContext = createContext6({ strict: false, },);
var Queue = class {
  constructor() {
    this.order = [];
    this.scheduled = /* @__PURE__ */ new Set();
  }
  add(process2,) {
    if (!this.scheduled.has(process2,)) {
      this.scheduled.add(process2,);
      this.order.push(process2,);
      return true;
    }
  }
  remove(process2,) {
    const index = this.order.indexOf(process2,);
    if (index !== -1) {
      this.order.splice(index, 1,);
      this.scheduled.delete(process2,);
    }
  }
  clear() {
    this.order.length = 0;
    this.scheduled.clear();
  }
};
function createRenderStep(runNextFrame,) {
  let thisFrame = new Queue();
  let nextFrame = new Queue();
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step2 = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false,) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive) {
        toKeepAlive.add(callback,);
      }
      if (queue.add(callback,) && addToCurrentFrame && isProcessing) {
        numToRun = thisFrame.order.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback,) => {
      nextFrame.remove(callback,);
      toKeepAlive.delete(callback,);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2,) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame,] = [nextFrame, thisFrame,];
      nextFrame.clear();
      numToRun = thisFrame.order.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = thisFrame.order[i];
          if (toKeepAlive.has(callback,)) {
            step2.schedule(callback,);
            runNextFrame();
          }
          callback(frameData2,);
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step2.process(frameData2,);
      }
    },
  };
  return step2;
}
var stepsOrder = [
  'prepare',
  'read',
  'update',
  'preRender',
  'render',
  'postRender',
];
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive,) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false,
  };
  const steps2 = stepsOrder.reduce((acc, key7,) => {
    acc[key7] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {},);
  const processStep = (stepId,) => {
    steps2[stepId].process(state,);
  };
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed,), 1,);
    state.timestamp = timestamp;
    state.isProcessing = true;
    stepsOrder.forEach(processStep,);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch,);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch,);
    }
  };
  const schedule = stepsOrder.reduce((acc, key7,) => {
    const step2 = steps2[key7];
    acc[key7] = (process2, keepAlive = false, immediate = false,) => {
      if (!runNextFrame) {
        wake();
      }
      return step2.schedule(process2, keepAlive, immediate,);
    };
    return acc;
  }, {},);
  const cancel = (process2,) => stepsOrder.forEach((key7,) => steps2[key7].cancel(process2,));
  return { schedule, cancel, state, steps: steps2, };
}
var { schedule: microtask, cancel: cancelMicrotask, } = createRenderBatcher(queueMicrotask, false,);
function useVisualElement(Component23, visualState, props, createVisualElement2,) {
  const { visualElement: parent, } = useContext(MotionContext,);
  const lazyContext = useContext(LazyContext,);
  const presenceContext = useContext(PresenceContext,);
  const reducedMotionConfig = useContext(MotionConfigContext,).reducedMotion;
  const visualElementRef = useRef();
  createVisualElement2 = createVisualElement2 || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement2) {
    visualElementRef.current = createVisualElement2(Component23, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig,
    },);
  }
  const visualElement = visualElementRef.current;
  useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext,);
  },);
  const wantsHandoff = useRef(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete,),);
  useIsomorphicLayoutEffect(() => {
    if (!visualElement) {
      return;
    }
    microtask.postRender(visualElement.render,);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  },);
  useEffect2(() => {
    if (!visualElement) {
      return;
    }
    visualElement.updateFeatures();
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      wantsHandoff.current = false;
      window.HandoffComplete = true;
    }
  },);
  return visualElement;
}
function isRefObject(ref,) {
  return ref && typeof ref === 'object' && Object.prototype.hasOwnProperty.call(ref, 'current',);
}
function useMotionRef(visualState, visualElement, externalRef,) {
  return useCallback(
    (instance,) => {
      instance && visualState.mount && visualState.mount(instance,);
      if (visualElement) {
        instance ? visualElement.mount(instance,) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === 'function') {
          externalRef(instance,);
        } else if (isRefObject(externalRef,)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement,],
  );
}
function isVariantLabel(v,) {
  return typeof v === 'string' || Array.isArray(v,);
}
function isAnimationControls(v,) {
  return v !== null && typeof v === 'object' && typeof v.start === 'function';
}
var variantPriorityOrder = [
  'animate',
  'whileInView',
  'whileFocus',
  'whileHover',
  'whileTap',
  'whileDrag',
  'exit',
];
var variantProps = ['initial', ...variantPriorityOrder,];
function isControllingVariants(props,) {
  return isAnimationControls(props.animate,) || variantProps.some((name,) => isVariantLabel(props[name],));
}
function isVariantNode(props,) {
  return Boolean(isControllingVariants(props,) || props.variants,);
}
function getCurrentTreeVariants(props, context,) {
  if (isControllingVariants(props,)) {
    const { initial, animate: animate22, } = props;
    return {
      initial: initial === false || isVariantLabel(initial,) ? initial : void 0,
      animate: isVariantLabel(animate22,) ? animate22 : void 0,
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props,) {
  const { initial, animate: animate22, } = getCurrentTreeVariants(props, useContext2(MotionContext,),);
  return useMemo(() => ({ initial, animate: animate22, }), [variantLabelsAsDependency(initial,), variantLabelsAsDependency(animate22,),],);
}
function variantLabelsAsDependency(prop,) {
  return Array.isArray(prop,) ? prop.join(' ',) : prop;
}
var featureProps = {
  animation: [
    'animate',
    'variants',
    'whileHover',
    'whileTap',
    'exit',
    'whileInView',
    'whileFocus',
    'whileDrag',
  ],
  exit: ['exit',],
  drag: ['drag', 'dragControls',],
  focus: ['whileFocus',],
  hover: ['whileHover', 'onHoverStart', 'onHoverEnd',],
  tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel',],
  pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd',],
  inView: ['whileInView', 'onViewportEnter', 'onViewportLeave',],
  layout: ['layout', 'layoutId',],
};
var featureDefinitions = {};
for (const key7 in featureProps) {
  featureDefinitions[key7] = {
    isEnabled: (props,) => featureProps[key7].some((name,) => !!props[name]),
  };
}
function loadFeatures(features,) {
  for (const key7 in features) {
    featureDefinitions[key7] = {
      ...featureDefinitions[key7],
      ...features[key7],
    };
  }
}
var motionComponentSymbol = Symbol.for('motionComponentSymbol',);
function createMotionComponent(
  {
    preloadedFeatures: preloadedFeatures2,
    createVisualElement: createVisualElement2,
    useRender,
    useVisualState: useVisualState2,
    Component: Component23,
  },
) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2,);
  function MotionComponent(props, externalRef,) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext3(MotionConfigContext,),
      ...props,
      layoutId: useLayoutId(props,),
    };
    const { isStatic, } = configAndProps;
    const context = useCreateMotionContext(props,);
    const visualState = useVisualState2(props, isStatic,);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component23, visualState, configAndProps, createVisualElement2,);
      const initialLayoutGroupConfig = useContext3(SwitchLayoutGroupContext,);
      const isStrict = useContext3(LazyContext,).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig,
        );
      }
    }
    return React.createElement(
      MotionContext.Provider,
      { value: context, },
      MeasureLayout2 && context.visualElement
        ? React.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps, },)
        : null,
      useRender(
        Component23,
        props,
        useMotionRef(visualState, context.visualElement, externalRef,),
        visualState,
        isStatic,
        context.visualElement,
      ),
    );
  }
  const ForwardRefComponent = forwardRef(MotionComponent,);
  ForwardRefComponent[motionComponentSymbol] = Component23;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId, },) {
  const layoutGroupId = useContext3(LayoutGroupContext,).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + '-' + layoutId : layoutId;
}
var scaleCorrectors = {};
function addScaleCorrector(correctors,) {
  Object.assign(scaleCorrectors, correctors,);
}
var isMotionValue = (value,) => Boolean(value && value.getVelocity,);
var transformPropOrder = [
  'transformPerspective',
  'x',
  'y',
  'z',
  'translateX',
  'translateY',
  'translateZ',
  'scale',
  'scaleX',
  'scaleY',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'skew',
  'skewX',
  'skewY',
];
var transformProps = new Set(transformPropOrder,);
var translateAlias = {
  x: 'translateX',
  y: 'translateY',
  z: 'translateZ',
  transformPerspective: 'perspective',
};
var numTransforms = transformPropOrder.length;
function buildTransform(
  transform2,
  { enableHardwareAcceleration = true, allowTransformNone = true, },
  transformIsDefault,
  transformTemplate2,
) {
  let transformString2 = '';
  for (let i = 0; i < numTransforms; i++) {
    const key7 = transformPropOrder[i];
    if (transform2[key7] !== void 0) {
      const transformName = translateAlias[key7] || key7;
      transformString2 += `${transformName}(${transform2[key7]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform2.z) {
    transformString2 += 'translateZ(0)';
  }
  transformString2 = transformString2.trim();
  if (transformTemplate2) {
    transformString2 = transformTemplate2(transform2, transformIsDefault ? '' : transformString2,);
  } else if (allowTransformNone && transformIsDefault) {
    transformString2 = 'none';
  }
  return transformString2;
}
var clamp = (min, max, v,) => {
  if (v > max) {
    return max;
  }
  if (v < min) {
    return min;
  }
  return v;
};
var sanitize = (v,) => Math.round(v * 1e5,) / 1e5;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v,) {
  return typeof v === 'string';
}
var createUnitType = (unit,) => ({
  test: (v,) => isString(v,) && v.endsWith(unit,) && v.split(' ',).length === 1,
  parse: parseFloat,
  transform: (v,) => `${v}${unit}`,
});
var degrees = createUnitType('deg',);
var percent = createUnitType('%',);
var px = createUnitType('px',);
var vh = createUnitType('vh',);
var vw = createUnitType('vw',);
var progressPercentage = {
  ...percent,
  parse: (v,) => percent.parse(v,) / 100,
  transform: (v,) => percent.transform(v * 100,),
};
var validMotionProps = /* @__PURE__ */ new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
],);
function isValidMotionProp(key7,) {
  return key7.startsWith('while',) || key7.startsWith('drag',) && key7 !== 'draggable' || key7.startsWith('layout',) ||
    key7.startsWith('onTap',) || key7.startsWith('onPan',) || key7.startsWith('onLayout',) || validMotionProps.has(key7,);
}
var shouldForward = (key7,) => !isValidMotionProp(key7,);
function loadExternalIsValidProp(isValidProp,) {
  if (!isValidProp) {
    return;
  }
  shouldForward = (key7,) => key7.startsWith('on',) ? !isValidMotionProp(key7,) : isValidProp(key7,);
}
try {
  loadExternalIsValidProp(require_is_prop_valid_browser_cjs().default,);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps,) {
  const filteredProps2 = {};
  for (const key7 in props) {
    if (key7 === 'values' && typeof props.values === 'object') {
      continue;
    }
    if (
      shouldForward(key7,) || forwardMotionProps === true && isValidMotionProp(key7,) || !isDom && !isValidMotionProp(key7,) || // If trying to use native HTML drag events, forward drag listeners
      props['draggable'] && key7.startsWith('onDrag',)
    ) {
      filteredProps2[key7] = props[key7];
    }
  }
  return filteredProps2;
}
var isKeyframesTarget = (v,) => {
  return Array.isArray(v,);
};
var isCustomValue = (v,) => {
  return Boolean(v && typeof v === 'object' && v.mix && v.toValue,);
};
var resolveFinalValueInKeyframes = (v,) => {
  return isKeyframesTarget(v,) ? v[v.length - 1] || 0 : v;
};
function resolveMotionValue(value,) {
  const unwrappedValue = isMotionValue(value,) ? value.get() : value;
  return isCustomValue(unwrappedValue,) ? unwrappedValue.toValue() : unwrappedValue;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {},) {
  if (typeof definition === 'function') {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
  }
  if (typeof definition === 'string') {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === 'function') {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity,);
  }
  return definition;
}
function useConstant(init,) {
  const ref = useRef2(null,);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
function makeState(
  { scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount, },
  props,
  context,
  presenceContext,
) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3,),
    renderState: createRenderState(),
  };
  if (onMount) {
    state.mount = (instance,) => onMount(props, instance, state,);
  }
  return state;
}
var makeUseVisualState = (config,) => (props, isStatic,) => {
  const context = useContext4(MotionContext,);
  const presenceContext = useContext4(PresenceContext,);
  const make = () => makeState(config, props, context, presenceContext,);
  return isStatic ? make() : useConstant(make,);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues,) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {},);
  for (const key7 in motionValues) {
    values[key7] = resolveMotionValue(motionValues[key7],);
  }
  let { initial, animate: animate22, } = props;
  const isControllingVariants$1 = isControllingVariants(props,);
  const isVariantNode$1 = isVariantNode(props,);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0) {
      initial = context.initial;
    }
    if (animate22 === void 0) {
      animate22 = context.animate;
    }
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate22 : initial;
  if (variantToSet && typeof variantToSet !== 'boolean' && !isAnimationControls(variantToSet,)) {
    const list = Array.isArray(variantToSet,) ? variantToSet : [variantToSet,];
    list.forEach((definition,) => {
      const resolved = resolveVariantFromProps(props, definition,);
      if (!resolved) {
        return;
      }
      const { transitionEnd, transition, ...target } = resolved;
      for (const key7 in target) {
        let valueTarget = target[key7];
        if (Array.isArray(valueTarget,)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values[key7] = valueTarget;
        }
      }
      for (const key7 in transitionEnd) {
        values[key7] = transitionEnd[key7];
      }
    },);
  }
  return values;
}
var noop = (any,) => any;
var { schedule: frame, cancel: cancelFrame, state: frameData, steps, } = createRenderBatcher(
  typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : noop,
  true,
);
var isPrimaryPointer = (event,) => {
  if (event.pointerType === 'mouse') {
    return typeof event.button !== 'number' || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = 'page',) {
  return {
    point: {
      x: event[pointType + 'X'],
      y: event[pointType + 'Y'],
    },
  };
}
var addPointerInfo = (handler,) => {
  return (event,) => isPrimaryPointer(event,) && handler(event, extractEventInfo(event,),);
};
function addDomEvent(target, eventName, handler, options = { passive: true, },) {
  target.addEventListener(eventName, handler, options,);
  return () => target.removeEventListener(eventName, handler,);
}
function addPointerEvent(target, eventName, handler, options,) {
  return addDomEvent(target, eventName, addPointerInfo(handler,), options,);
}
var combineFunctions = (a, b,) => (v,) => b(a(v,),);
var pipe = (...transformers) => transformers.reduce(combineFunctions,);
function createLock(name,) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock('dragHorizontal',);
var globalVerticalLock = createLock('dragVertical',);
function getGlobalLock(drag2,) {
  let lock = false;
  if (drag2 === 'y') {
    lock = globalVerticalLock();
  } else if (drag2 === 'x') {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal) {
        openHorizontal();
      }
      if (openVertical) {
        openVertical();
      }
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true,);
  if (!openGestureLock) {
    return true;
  }
  openGestureLock();
  return false;
}
var warning = noop;
var invariant = noop;
if (false) {
  warning = (check, message,) => {
    if (!check && typeof console !== 'undefined') {
      console.warn(message,);
    }
  };
  invariant = (check, message,) => {
    if (!check) {
      throw new Error(message,);
    }
  };
}
var calcBezier = (t, a1, a2,) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2,) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2,) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX,) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2,) {
  if (mX1 === mY1 && mX2 === mY2) {
    return noop;
  }
  const getTForX = (aX,) => binarySubdivide(aX, 0, 1, mX1, mX2,);
  return (t,) => t === 0 || t === 1 ? t : calcBezier(getTForX(t,), mY1, mY2,);
}
var easeIn = cubicBezier(0.42, 0, 1, 1,);
var easeOut = cubicBezier(0, 0, 0.58, 1,);
var easeInOut = cubicBezier(0.42, 0, 0.58, 1,);
var mirrorEasing = (easing,) => (p,) => p <= 0.5 ? easing(2 * p,) / 2 : (2 - easing(2 * (1 - p),)) / 2;
var reverseEasing = (easing,) => (p,) => 1 - easing(1 - p,);
var circIn = (p,) => 1 - Math.sin(Math.acos(p,),);
var circOut = reverseEasing(circIn,);
var circInOut = mirrorEasing(circIn,);
var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99,);
var backIn = reverseEasing(backOut,);
var backInOut = mirrorEasing(backIn,);
var anticipate = (p,) => (p *= 2) < 1 ? 0.5 * backIn(p,) : 0.5 * (2 - Math.pow(2, -10 * (p - 1),));
var progress = (from, to, value,) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
var number = {
  test: (v,) => typeof v === 'number',
  parse: parseFloat,
  transform: (v,) => v,
};
var alpha = {
  ...number,
  transform: (v,) => clamp(0, 1, v,),
};
var scale = {
  ...number,
  default: 1,
};
var isColorString = (type, testProp,) => (v,) => {
  return Boolean(
    isString(v,) && singleColorRegex.test(v,) && v.startsWith(type,) || testProp && Object.prototype.hasOwnProperty.call(v, testProp,),
  );
};
var splitColor = (aName, bName, cName,) => (v,) => {
  if (!isString(v,)) {
    return v;
  }
  const [a, b, c, alpha2,] = v.match(floatRegex,);
  return {
    [aName]: parseFloat(a,),
    [bName]: parseFloat(b,),
    [cName]: parseFloat(c,),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2,) : 1,
  };
};
var clampRgbUnit = (v,) => clamp(0, 255, v,);
var rgbUnit = {
  ...number,
  transform: (v,) => Math.round(clampRgbUnit(v,),),
};
var rgba = {
  test: isColorString('rgb', 'red',),
  parse: splitColor('red', 'green', 'blue',),
  transform: ({ red, green, blue, alpha: alpha$1 = 1, },) =>
    'rgba(' + rgbUnit.transform(red,) + ', ' + rgbUnit.transform(green,) + ', ' + rgbUnit.transform(blue,) + ', ' +
    sanitize(alpha.transform(alpha$1,),) + ')',
};
function parseHex(v,) {
  let r = '';
  let g = '';
  let b = '';
  let a = '';
  if (v.length > 5) {
    r = v.substring(1, 3,);
    g = v.substring(3, 5,);
    b = v.substring(5, 7,);
    a = v.substring(7, 9,);
  } else {
    r = v.substring(1, 2,);
    g = v.substring(2, 3,);
    b = v.substring(3, 4,);
    a = v.substring(4, 5,);
    r += r;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16,),
    green: parseInt(g, 16,),
    blue: parseInt(b, 16,),
    alpha: a ? parseInt(a, 16,) / 255 : 1,
  };
}
var hex = {
  test: isColorString('#',),
  parse: parseHex,
  transform: rgba.transform,
};
var hsla = {
  test: isColorString('hsl', 'hue',),
  parse: splitColor('hue', 'saturation', 'lightness',),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1, },) => {
    return 'hsla(' + Math.round(hue,) + ', ' + percent.transform(sanitize(saturation,),) + ', ' + percent.transform(sanitize(lightness,),) +
      ', ' + sanitize(alpha.transform(alpha$1,),) + ')';
  },
};
var color = {
  test: (v,) => rgba.test(v,) || hex.test(v,) || hsla.test(v,),
  parse: (v,) => {
    if (rgba.test(v,)) {
      return rgba.parse(v,);
    } else if (hsla.test(v,)) {
      return hsla.parse(v,);
    } else {
      return hex.parse(v,);
    }
  },
  transform: (v,) => {
    return isString(v,) ? v : v.hasOwnProperty('red',) ? rgba.transform(v,) : hsla.transform(v,);
  },
};
function test(v,) {
  var _a, _b;
  return isNaN(v,) && isString(v,) &&
    (((_a = v.match(floatRegex,)) === null || _a === void 0 ? void 0 : _a.length) || 0) +
          (((_b = v.match(colorRegex,)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
var NUMBER_TOKEN = 'number';
var COLOR_TOKEN = 'color';
var VAR_TOKEN = 'var';
var VAR_FUNCTION_TOKEN = 'var(';
var SPLIT_TOKEN = '${}';
var complexRegex =
  /(var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))|((-)?([\d]*\.?[\d])+)/gi;
function analyseComplexValue(value,) {
  const originalValue = value.toString();
  const matchedValues = originalValue.match(complexRegex,) || [];
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: [],
  };
  const types2 = [];
  for (let i = 0; i < matchedValues.length; i++) {
    const parsedValue = matchedValues[i];
    if (color.test(parsedValue,)) {
      indexes.color.push(i,);
      types2.push(COLOR_TOKEN,);
      values.push(color.parse(parsedValue,),);
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN,)) {
      indexes.var.push(i,);
      types2.push(VAR_TOKEN,);
      values.push(parsedValue,);
    } else {
      indexes.number.push(i,);
      types2.push(NUMBER_TOKEN,);
      values.push(parseFloat(parsedValue,),);
    }
  }
  const tokenised = originalValue.replace(complexRegex, SPLIT_TOKEN,);
  const split = tokenised.split(SPLIT_TOKEN,);
  return { values, split, indexes, types: types2, };
}
function parseComplexValue(v,) {
  return analyseComplexValue(v,).values;
}
function createTransformer(source,) {
  const { split, types: types2, } = analyseComplexValue(source,);
  const numSections = split.length;
  return (v,) => {
    let output = '';
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== void 0) {
        const type = types2[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i],);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i],);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
var convertNumbersToZero = (v,) => typeof v === 'number' ? 0 : v;
function getAnimatableNone(v,) {
  const parsed = parseComplexValue(v,);
  const transformer = createTransformer(v,);
  return transformer(parsed.map(convertNumbersToZero,),);
}
var complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone,
};
var mixNumber = (from, to, progress2,) => {
  return from + (to - from) * progress2;
};
function hueToRgb(p, q, t,) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2, },) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3,);
    green = hueToRgb(p, q, hue,);
    blue = hueToRgb(p, q, hue - 1 / 3,);
  }
  return {
    red: Math.round(red * 255,),
    green: Math.round(green * 255,),
    blue: Math.round(blue * 255,),
    alpha: alpha2,
  };
}
var mixLinearColor = (from, to, v,) => {
  const fromExpo = from * from;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo,);
};
var colorTypes = [hex, rgba, hsla,];
var getColorType = (v,) => colorTypes.find((type,) => type.test(v,));
function asRGBA(color2,) {
  const type = getColorType(color2,);
  invariant(Boolean(type,), `'${color2}' is not an animatable color. Use the equivalent color code instead.`,);
  let model = type.parse(color2,);
  if (type === hsla) {
    model = hslaToRgba(model,);
  }
  return model;
}
var mixColor = (from, to,) => {
  const fromRGBA = asRGBA(from,);
  const toRGBA = asRGBA(to,);
  const blended = { ...fromRGBA, };
  return (v,) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v,);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v,);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v,);
    blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v,);
    return rgba.transform(blended,);
  };
};
var checkStringStartsWith = (token,) => (key7,) => typeof key7 === 'string' && key7.startsWith(token,);
var isCSSVariableName = checkStringStartsWith('--',);
var startsAsVariableToken = checkStringStartsWith('var(--',);
var isCSSVariableToken = (value,) => {
  const startsWithToken = startsAsVariableToken(value,);
  if (!startsWithToken) {
    return false;
  }
  return singleCssVariableRegex.test(value.split('/*',)[0].trim(),);
};
var singleCssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)$/i;
function mixImmediate(a, b,) {
  return (p,) => p > 0 ? b : a;
}
function mixNumber2(a, b,) {
  return (p,) => mixNumber(a, b, p,);
}
function getMixer(a,) {
  if (typeof a === 'number') {
    return mixNumber2;
  } else if (typeof a === 'string') {
    return isCSSVariableToken(a,) ? mixImmediate : color.test(a,) ? mixColor : mixComplex;
  } else if (Array.isArray(a,)) {
    return mixArray;
  } else if (typeof a === 'object') {
    return color.test(a,) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b,) {
  const output = [...a,];
  const numValues = output.length;
  const blendValue = a.map((v, i,) => getMixer(v,)(v, b[i],));
  return (p,) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p,);
    }
    return output;
  };
}
function mixObject(a, b,) {
  const output = { ...a, ...b, };
  const blendValue = {};
  for (const key7 in output) {
    if (a[key7] !== void 0 && b[key7] !== void 0) {
      blendValue[key7] = getMixer(a[key7],)(a[key7], b[key7],);
    }
  }
  return (v,) => {
    for (const key7 in blendValue) {
      output[key7] = blendValue[key7](v,);
    }
    return output;
  };
}
function matchOrder(origin, target,) {
  var _a;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0, };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
var mixComplex = (origin, target,) => {
  const template = complex.createTransformer(target,);
  const originStats = analyseComplexValue(origin,);
  const targetStats = analyseComplexValue(target,);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&
    originStats.indexes.color.length === targetStats.indexes.color.length &&
    originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    return pipe(mixArray(matchOrder(originStats, targetStats,), targetStats.values,), template,);
  } else {
    warning(
      true,
      `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,
    );
    return mixImmediate(origin, target,);
  }
};
function mix(from, to, p,) {
  if (typeof from === 'number' && typeof to === 'number' && typeof p === 'number') {
    return mixNumber(from, to, p,);
  }
  const mixer = getMixer(from,);
  return mixer(from, to,);
}
function createMixers(output, ease2, customMixer,) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1],);
    if (ease2) {
      const easingFunction = Array.isArray(ease2,) ? ease2[i] || noop : ease2;
      mixer = pipe(easingFunction, mixer,);
    }
    mixers.push(mixer,);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer, } = {},) {
  const inputLength = input.length;
  invariant(inputLength === output.length, 'Both input and output ranges must be the same length',);
  if (inputLength === 1) {
    return () => output[0];
  }
  if (input[0] > input[inputLength - 1]) {
    input = [...input,].reverse();
    output = [...output,].reverse();
  }
  const mixers = createMixers(output, ease2, mixer,);
  const numMixers = mixers.length;
  const interpolator = (v,) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1]) {
          break;
        }
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v,);
    return mixers[i](progressInRange,);
  };
  return isClamp ? (v,) => interpolator(clamp(input[0], input[inputLength - 1], v,),) : interpolator;
}
var secondsToMilliseconds = (seconds,) => seconds * 1e3;
var millisecondsToSeconds = (milliseconds,) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration,) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue2, t, current,) {
  const prevT = Math.max(t - velocitySampleDuration, 0,);
  return velocityPerSecond(current - resolveValue2(prevT,), t - prevT,);
}
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, },) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration,), 'Spring duration must be 10 seconds or less',);
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio,);
  duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration,),);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2,) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio,);
      const c = Math.exp(-delta,);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2,) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2,) * Math.pow(undampedFreq2, 2,) * duration;
      const f = Math.exp(-delta,);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2,), dampingRatio,);
      const factor = -envelope(undampedFreq2,) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2,) => {
      const a = Math.exp(-undampedFreq2 * duration,);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2,) => {
      const a = Math.exp(-undampedFreq2 * duration,);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess,);
  duration = secondsToMilliseconds(duration,);
  if (isNaN(undampedFreq,)) {
    return {
      stiffness: 100,
      damping: 10,
      duration,
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2,) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness,),
      duration,
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess,) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result,) / derivative(result,);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio,) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio,);
}
var durationKeys = ['duration', 'bounce',];
var physicsKeys = ['stiffness', 'damping', 'mass',];
function isSpringType(options, keys23,) {
  return keys23.some((key7,) => options[key7] !== void 0);
}
function getSpringOptions(options,) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options,
  };
  if (!isSpringType(options, physicsKeys,) && isSpringType(options, durationKeys,)) {
    const derived = findSpring(options,);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1,
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options },) {
  const origin = keyframes2[0];
  const target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin, };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0,),
  },);
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass,));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass,),);
  const isGranularScale = Math.abs(initialDelta,) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio,);
    resolveSpring = (t,) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t,);
      return target -
        envelope *
          ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t,) +
            initialDelta * Math.cos(angularFreq * t,));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t,) =>
      target - Math.exp(-undampedAngularFreq * t,) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1,);
    resolveSpring = (t,) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t,);
      const freqForT = Math.min(dampedAngularFreq * t, 300,);
      return target -
        envelope *
          ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT,) +
            dampedAngularFreq * initialDelta * Math.cosh(freqForT,)) /
          dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t,) => {
      const current = resolveSpring(t,);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current,);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity,) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current,) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
  };
}
var isEasingArray = (ease2,) => {
  return Array.isArray(ease2,) && typeof ease2[0] !== 'number';
};
var easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
};
var easingDefinitionToFunction = (definition,) => {
  if (Array.isArray(definition,)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`,);
    const [x1, y1, x2, y2,] = definition;
    return cubicBezier(x1, y1, x2, y2,);
  } else if (typeof definition === 'string') {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`,);
    return easingLookup[definition];
  }
  return definition;
};
function fillOffset(offset, remaining,) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i,);
    offset.push(mixNumber(min, 1, offsetProgress,),);
  }
}
function defaultOffset(arr,) {
  const offset = [0,];
  fillOffset(offset, arr.length - 1,);
  return offset;
}
function convertOffsetToTimes(offset, duration,) {
  return offset.map((o,) => o * duration);
}
function defaultEasing(values, easing,) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1,);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = 'easeInOut', },) {
  const easingFunctions = isEasingArray(ease2,) ? ease2.map(easingDefinitionToFunction,) : easingDefinitionToFunction(ease2,);
  const state = {
    done: false,
    value: keyframeValues[0],
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues,),
    duration,
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions,) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions,),
  },);
  return {
    calculatedDuration: duration,
    next: (t,) => {
      state.value = mapTimeToKeyframe(t,);
      state.done = t >= duration;
      return state;
    },
  };
}
function inertia(
  {
    keyframes: keyframes2,
    velocity = 0,
    power = 0.8,
    timeConstant: timeConstant2 = 325,
    bounceDamping = 10,
    bounceStiffness = 500,
    modifyTarget,
    min,
    max,
    restDelta = 0.5,
    restSpeed,
  },
) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin,
  };
  const isOutOfBounds = (v,) => min !== void 0 && v < min || max !== void 0 && v > max;
  const nearestBoundary = (v,) => {
    if (min === void 0) {
      return max;
    }
    if (max === void 0) {
      return min;
    }
    return Math.abs(min - v,) < Math.abs(max - v,) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal,);
  if (target !== ideal) {
    amplitude = target - origin;
  }
  const calcDelta = (t,) => -amplitude * Math.exp(-t / timeConstant2,);
  const calcLatest = (t,) => target + calcDelta(t,);
  const applyFriction = (t,) => {
    const delta = calcDelta(t,);
    const latest = calcLatest(t,);
    state.done = Math.abs(delta,) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t,) => {
    if (!isOutOfBounds(state.value,)) {
      return;
    }
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value,),],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value,),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed,
    },);
  };
  checkCatchBoundary(0,);
  return {
    calculatedDuration: null,
    next: (t,) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t,);
        checkCatchBoundary(t,);
      }
      if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary,);
      } else {
        !hasUpdatedFrame && applyFriction(t,);
        return state;
      }
    },
  };
}
var now;
function clearTime() {
  now = void 0;
}
var time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now(),);
    }
    return now;
  },
  set: (newTime,) => {
    now = newTime;
    queueMicrotask(clearTime,);
  },
};
var frameloopDriver = (update,) => {
  const passTimestamp = ({ timestamp, },) => update(timestamp,);
  return {
    start: () => frame.update(passTimestamp, true,),
    stop: () => cancelFrame(passTimestamp,),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now(),
  };
};
var maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator,) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration,);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration,);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
var types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring,
};
var percentToProgress = (percent2,) => percent2 / 100;
function animateValue(
  {
    autoplay = true,
    delay: delay2 = 0,
    driver = frameloopDriver,
    keyframes: keyframes$1,
    type = 'keyframes',
    repeat = 0,
    repeatDelay = 0,
    repeatType = 'loop',
    onPlay,
    onStop,
    onComplete,
    onUpdate,
    ...options
  },
) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve,) => {
      resolveFinishedPromise = resolve;
    },);
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== 'number') {
    if (false) {
      invariant(
        keyframes$1.length === 2,
        `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`,
      );
    }
    mapNumbersToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1],),);
    keyframes$1 = [0, 100,];
  }
  const generator = generatorFactory({ ...options, keyframes: keyframes$1, },);
  let mirroredGenerator;
  if (repeatType === 'mirror') {
    mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1,].reverse(),
      velocity: -(options.velocity || 0),
    },);
  }
  let playState = 'idle';
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator,);
  }
  const { calculatedDuration, } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp,) => {
    if (startTime === null) {
      return;
    }
    if (speed > 0) {
      startTime = Math.min(startTime, timestamp,);
    }
    if (speed < 0) {
      startTime = Math.min(timestamp - totalDuration / speed, startTime,);
    }
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = Math.round(timestamp - startTime,) * speed;
    }
    const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0,);
    if (playState === 'finished' && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(currentTime, totalDuration,) / resolvedDuration;
      let currentIteration = Math.floor(progress2,);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1,);
      const isOddIteration = Boolean(currentIteration % 2,);
      if (isOddIteration) {
        if (repeatType === 'reverse') {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === 'mirror') {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress,) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes$1[0], } : frameGenerator.next(elapsed,);
    if (mapNumbersToKeyframes) {
      state.value = mapNumbersToKeyframes(state.value,);
    }
    let { done, } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
    }
    const isAnimationFinished = holdTime === null && (playState === 'finished' || playState === 'running' && done);
    if (onUpdate) {
      onUpdate(state.value,);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = 'idle';
    stopAnimationDriver();
    resolveFinishedPromise();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = 'finished';
    onComplete && onComplete();
    stopAnimationDriver();
    resolveFinishedPromise();
  };
  const play = () => {
    if (hasStopped) {
      return;
    }
    if (!animationDriver) {
      animationDriver = driver(tick,);
    }
    const now2 = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now2 - holdTime;
    } else if (!startTime || playState === 'finished') {
      startTime = now2;
    }
    if (playState === 'finished') {
      updateFinishedPromise();
    }
    cancelTime = startTime;
    holdTime = null;
    playState = 'running';
    animationDriver.start();
  };
  if (autoplay) {
    play();
  }
  const controls = {
    then(resolve, reject,) {
      return currentFinishedPromise.then(resolve, reject,);
    },
    get time() {
      return millisecondsToSeconds(currentTime,);
    },
    set time(newTime,) {
      newTime = secondsToMilliseconds(newTime,);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator,) : generator.calculatedDuration;
      return millisecondsToSeconds(duration,);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed,) {
      if (newSpeed === speed || !animationDriver) {
        return;
      }
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime,);
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = 'paused';
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === 'idle') {
        return;
      }
      playState = 'idle';
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null) {
        tick(cancelTime,);
      }
      cancel();
    },
    complete: () => {
      playState = 'finished';
    },
    sample: (elapsed,) => {
      startTime = 0;
      return tick(elapsed,);
    },
  };
  return controls;
}
function addUniqueItem(arr, item,) {
  if (arr.indexOf(item,) === -1) {
    arr.push(item,);
  }
}
function removeItem(arr, item,) {
  const index = arr.indexOf(item,);
  if (index > -1) {
    arr.splice(index, 1,);
  }
}
function moveItem([...arr], fromIndex, toIndex,) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item,] = arr.splice(fromIndex, 1,);
    arr.splice(endIndex, 0, item,);
  }
  return arr;
}
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler,) {
    addUniqueItem(this.subscriptions, handler,);
    return () => removeItem(this.subscriptions, handler,);
  }
  notify(a, b, c,) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions) {
      return;
    }
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c,);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c,);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
var MAX_VELOCITY_DELTA = 30;
var isFloat = (value,) => {
  return !isNaN(parseFloat(value,),);
};
var collectMotionValues = {
  current: void 0,
};
var MotionValue = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {},) {
    this.version = '11.0.7';
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v, render = true,) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v,);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current,);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current,);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init,);
    this.canTrackVelocity = isFloat(this.current,);
    this.owner = options.owner;
  }
  setCurrent(current,) {
    this.current = current;
    this.updatedAt = time.now();
  }
  setPrevFrameValue(prevFrameValue = this.current,) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription,) {
    if (false) {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`,);
    }
    return this.on('change', subscription,);
  }
  on(eventName, callback,) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback,);
    if (eventName === 'change') {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        },);
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect,) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true,) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render,);
    } else {
      this.passiveEffect(v, this.updateAndNotify,);
    }
  }
  setWithVelocity(prev, current, delta,) {
    this.set(current,);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v,) {
    this.updateAndNotify(v,);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this,);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA,);
    return velocityPerSecond(parseFloat(this.current,) - parseFloat(this.prevFrameValue,), delta,);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation2,) {
    this.stop();
    return new Promise((resolve,) => {
      this.hasAnimated = true;
      this.animation = startAnimation2(resolve,);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    },).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    },);
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
function motionValue(init, options,) {
  return new MotionValue(init, options,);
}
var isNumericalString = (v,) => /^\-?\d*\.?\d+$/.test(v,);
var isZeroValueString = (v,) => /^0[^.\s]+$/.test(v,);
var maxDefaults = /* @__PURE__ */ new Set(['brightness', 'contrast', 'saturate', 'opacity',],);
function applyDefaultFilter(v,) {
  const [name, value,] = v.slice(0, -1,).split('(',);
  if (name === 'drop-shadow') {
    return v;
  }
  const [number2,] = value.match(floatRegex,) || [];
  if (!number2) {
    return v;
  }
  const unit = value.replace(number2, '',);
  let defaultValue = maxDefaults.has(name,) ? 1 : 0;
  if (number2 !== value) {
    defaultValue *= 100;
  }
  return name + '(' + defaultValue + unit + ')';
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = {
  ...complex,
  getAnimatableNone: (v,) => {
    const functions = v.match(functionRegex,);
    return functions ? functions.map(applyDefaultFilter,).join(' ',) : v;
  },
};
var int = {
  ...number,
  transform: Math.round,
};
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int,
};
var defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter,
};
var getDefaultValueType = (key7,) => defaultValueTypes[key7];
function getAnimatableNone2(key7, value,) {
  let defaultValueType = getDefaultValueType(key7,);
  if (defaultValueType !== filter) {
    defaultValueType = complex;
  }
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value,) : void 0;
}
var testValueType = (v,) => (type,) => type.test(v,);
var auto = {
  test: (v,) => v === 'auto',
  parse: (v,) => v,
};
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto,];
var findDimensionValueType = (v,) => dimensionValueTypes.find(testValueType(v,),);
var valueTypes = [...dimensionValueTypes, color, complex,];
var findValueType = (v,) => valueTypes.find(testValueType(v,),);
function getCurrent(visualElement,) {
  const current = {};
  visualElement.values.forEach((value, key7,) => current[key7] = value.get());
  return current;
}
function getVelocity(visualElement,) {
  const velocity = {};
  visualElement.values.forEach((value, key7,) => velocity[key7] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom,) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(
    props,
    definition,
    custom !== void 0 ? custom : props.custom,
    getCurrent(visualElement,),
    getVelocity(visualElement,),
  );
}
function setMotionValue(visualElement, key7, value,) {
  if (visualElement.hasValue(key7,)) {
    visualElement.getValue(key7,).set(value,);
  } else {
    visualElement.addValue(key7, motionValue(value,),);
  }
}
function setTarget(visualElement, definition,) {
  const resolved = resolveVariant(visualElement, definition,);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false,) : {};
  target = { ...target, ...transitionEnd, };
  for (const key7 in target) {
    const value = resolveFinalValueInKeyframes(target[key7],);
    setMotionValue(visualElement, key7, value,);
  }
}
function setVariants(visualElement, variantLabels,) {
  const reversedLabels = [...variantLabels,].reverse();
  reversedLabels.forEach((key7,) => {
    const variant = visualElement.getVariant(key7,);
    variant && setTarget(visualElement, variant,);
    if (visualElement.variantChildren) {
      visualElement.variantChildren.forEach((child,) => {
        setVariants(child, variantLabels,);
      },);
    }
  },);
}
function setValues(visualElement, definition,) {
  if (Array.isArray(definition,)) {
    return setVariants(visualElement, definition,);
  } else if (typeof definition === 'string') {
    return setVariants(visualElement, [definition,],);
  } else {
    setTarget(visualElement, definition,);
  }
}
function checkTargetForNewValues(visualElement, target, origin,) {
  var _a, _b;
  const newValueKeys = Object.keys(target,).filter((key7,) => !visualElement.hasValue(key7,));
  const numNewValues = newValueKeys.length;
  if (!numNewValues) {
    return;
  }
  for (let i = 0; i < numNewValues; i++) {
    const key7 = newValueKeys[i];
    const targetValue = target[key7];
    let value = null;
    if (Array.isArray(targetValue,)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key7]) !== null && _a !== void 0 ? _a : visualElement.readValue(key7,)) !== null && _b !== void 0
        ? _b
        : target[key7];
    }
    if (value === void 0 || value === null) {
      continue;
    }
    if (typeof value === 'string' && (isNumericalString(value,) || isZeroValueString(value,))) {
      value = parseFloat(value,);
    } else if (!findValueType(value,) && complex.test(targetValue,)) {
      value = getAnimatableNone2(key7, targetValue,);
    }
    visualElement.addValue(key7, motionValue(value, { owner: visualElement, },),);
    if (origin[key7] === void 0) {
      origin[key7] = value;
    }
    if (value !== null) {
      visualElement.setBaseTarget(key7, value,);
    }
  }
}
function getOriginFromTransition(key7, transition,) {
  if (!transition) {
    return;
  }
  const valueTransition = transition[key7] || transition['default'] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement,) {
  const origin = {};
  for (const key7 in target) {
    const transitionOrigin = getOriginFromTransition(key7, transition,);
    if (transitionOrigin !== void 0) {
      origin[key7] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key7,);
      if (value) {
        origin[key7] = value.get();
      }
    }
  }
  return origin;
}
var instantAnimationState = {
  current: false,
};
var isBezierDefinition = (easing,) => Array.isArray(easing,) && typeof easing[0] === 'number';
function isWaapiSupportedEasing(easing,) {
  return Boolean(
    !easing || typeof easing === 'string' && supportedWaapiEasing[easing] || isBezierDefinition(easing,) ||
      Array.isArray(easing,) && easing.every(isWaapiSupportedEasing,),
  );
}
var cubicBezierAsString = ([a, b, c, d,],) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
var supportedWaapiEasing = {
  linear: 'linear',
  ease: 'ease',
  easeIn: 'ease-in',
  easeOut: 'ease-out',
  easeInOut: 'ease-in-out',
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1,],),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45,],),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59,],),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99,],),
};
function mapEasingToNativeEasing(easing,) {
  if (!easing) {
    return void 0;
  }
  return isBezierDefinition(easing,)
    ? cubicBezierAsString(easing,)
    : Array.isArray(easing,)
    ? easing.map(mapEasingToNativeEasing,)
    : supportedWaapiEasing[easing];
}
function animateStyle(
  element,
  valueName,
  keyframes2,
  { delay: delay2 = 0, duration, repeat = 0, repeatType = 'loop', ease: ease2, times, } = {},
) {
  const keyframeOptions = { [valueName]: keyframes2, };
  if (times) {
    keyframeOptions.offset = times;
  }
  const easing = mapEasingToNativeEasing(ease2,);
  if (Array.isArray(easing,)) {
    keyframeOptions.easing = easing;
  }
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing,) ? easing : 'linear',
    fill: 'both',
    iterations: repeat + 1,
    direction: repeatType === 'reverse' ? 'alternate' : 'normal',
  },);
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = 'loop', },) {
  const index = repeat && repeatType !== 'loop' && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index];
}
function memo(callback,) {
  let result;
  return () => {
    if (result === void 0) {
      result = callback();
    }
    return result;
  };
}
var supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, 'animate',));
var acceleratedValues = /* @__PURE__ */ new Set([
  'opacity',
  'clipPath',
  'filter',
  'transform',
],);
var sampleDelta = 10;
var maxDuration2 = 2e4;
var requiresPregeneratedKeyframes = (valueName, options,) =>
  options.type === 'spring' || valueName === 'backgroundColor' || !isWaapiSupportedEasing(options.ease,);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options },) {
  const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName,) && !options.repeatDelay &&
    options.repeatType !== 'mirror' && options.damping !== 0 && options.type !== 'inertia';
  if (!canAccelerateAnimation) {
    return false;
  }
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  let pendingCancel = false;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve,) => {
      resolveFinishedPromise = resolve;
    },);
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times, } = options;
  if (requiresPregeneratedKeyframes(valueName, options,)) {
    const sampleAnimation = animateValue({
      ...options,
      repeat: 0,
      delay: 0,
    },);
    let state = { done: false, value: keyframes2[0], };
    const pregeneratedKeyframes = [];
    let t = 0;
    while (!state.done && t < maxDuration2) {
      state = sampleAnimation.sample(t,);
      pregeneratedKeyframes.push(state.value,);
      t += sampleDelta;
    }
    times = void 0;
    keyframes2 = pregeneratedKeyframes;
    duration = t - sampleDelta;
    ease2 = 'linear';
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times,
  },);
  const cancelAnimation = () => {
    pendingCancel = false;
    animation.cancel();
  };
  const safeCancel = () => {
    pendingCancel = true;
    frame.update(cancelAnimation,);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation.onfinish = () => {
    if (pendingCancel) {
      return;
    }
    value.set(getFinalKeyframe(keyframes2, options,),);
    onComplete && onComplete();
    safeCancel();
  };
  const controls = {
    then(resolve, reject,) {
      return currentFinishedPromise.then(resolve, reject,);
    },
    attachTimeline(timeline,) {
      animation.timeline = timeline;
      animation.onfinish = null;
      return noop;
    },
    get time() {
      return millisecondsToSeconds(animation.currentTime || 0,);
    },
    set time(newTime,) {
      animation.currentTime = secondsToMilliseconds(newTime,);
    },
    get speed() {
      return animation.playbackRate;
    },
    set speed(newSpeed,) {
      animation.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration,);
    },
    play: () => {
      if (hasStopped) {
        return;
      }
      animation.play();
      cancelFrame(cancelAnimation,);
    },
    pause: () => animation.pause(),
    stop: () => {
      hasStopped = true;
      if (animation.playState === 'idle') {
        return;
      }
      const { currentTime, } = animation;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options,
          autoplay: false,
        },);
        value.setWithVelocity(
          sampleAnimation.sample(currentTime - sampleDelta,).value,
          sampleAnimation.sample(currentTime,).value,
          sampleDelta,
        );
      }
      safeCancel();
    },
    complete: () => {
      if (pendingCancel) {
        return;
      }
      animation.finish();
    },
    cancel: safeCancel,
  };
  return controls;
}
function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete, },) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1],);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop,
      pause: noop,
      stop: noop,
      then: (resolve,) => {
        resolve();
        return Promise.resolve();
      },
      cancel: noop,
      complete: noop,
    };
  };
  return delay2
    ? animateValue({
      keyframes: [0, 1,],
      duration: 0,
      delay: delay2,
      onComplete: setValue,
    },)
    : setValue();
}
var underDampedSpring = {
  type: 'spring',
  stiffness: 500,
  damping: 25,
  restSpeed: 10,
};
var criticallyDampedSpring = (target,) => ({
  type: 'spring',
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550,) : 30,
  restSpeed: 10,
});
var keyframesTransition = {
  type: 'keyframes',
  duration: 0.8,
};
var ease = {
  type: 'keyframes',
  ease: [0.25, 0.1, 0.35, 1,],
  duration: 0.3,
};
var getDefaultTransition = (valueKey, { keyframes: keyframes2, },) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey,)) {
    return valueKey.startsWith('scale',) ? criticallyDampedSpring(keyframes2[1],) : underDampedSpring;
  }
  return ease;
};
var isAnimatable = (key7, value,) => {
  if (key7 === 'zIndex') {
    return false;
  }
  if (typeof value === 'number' || Array.isArray(value,)) {
    return true;
  }
  if (
    typeof value === 'string' && // It's animatable if we have a string
    (complex.test(value,) || value === '0') && // And it contains numbers and/or colors
    !value.startsWith('url(',)
  ) {
    return true;
  }
  return false;
};
function isNone(value,) {
  if (typeof value === 'number') {
    return value === 0;
  } else if (value !== null) {
    return value === 'none' || value === '0' || isZeroValueString(value,);
  }
}
function getKeyframes(value, valueName, target, transition,) {
  const isTargetAnimatable = isAnimatable(valueName, target,);
  let keyframes2;
  if (Array.isArray(target,)) {
    keyframes2 = [...target,];
  } else {
    keyframes2 = [null, target,];
  }
  const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] === null) {
      keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1];
    }
    if (isNone(keyframes2[i],)) {
      noneKeyframeIndexes.push(i,);
    }
    if (typeof keyframes2[i] === 'string' && keyframes2[i] !== 'none' && keyframes2[i] !== '0') {
      animatableTemplateValue = keyframes2[i];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i = 0; i < noneKeyframeIndexes.length; i++) {
      const index = noneKeyframeIndexes[i];
      keyframes2[index] = getAnimatableNone2(valueName, animatableTemplateValue,);
    }
  }
  return keyframes2;
}
function isTransitionDefined(
  { when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition },
) {
  return !!Object.keys(transition,).length;
}
function getValueTransition(transition, key7,) {
  return transition[key7] || transition['default'] || transition;
}
var animateMotionValue = (valueName, value, target, transition = {},) => {
  return (onComplete,) => {
    const valueTransition = getValueTransition(transition, valueName,) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0, } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2,);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition,);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe,);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe,);
    warning(
      isOriginAnimatable === isTargetAnimatable,
      `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`,
    );
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ease: 'easeOut',
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v,) => {
        value.set(v,);
        valueTransition.onUpdate && valueTransition.onUpdate(v,);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
    };
    if (!isTransitionDefined(valueTransition,)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options,),
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration,);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay,);
    }
    if (
      !isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false ||
      MotionGlobalConfig.skipAnimations
    ) {
      return createInstantAnimation(instantAnimationState.current ? { ...options, delay: 0, } : options,);
    }
    if (
      /**
       * If this is a handoff animation, the optimised animation will be running via
       * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
       * optimised animation.
       */
      !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
       * If we're outputting values to onUpdate then we can't use WAAPI as there's
       * no way to read the value from WAAPI every frame.
       */
      !value.owner.getProps().onUpdate
    ) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options,);
      if (acceleratedAnimation) {
        return acceleratedAnimation;
      }
    }
    return animateValue(options,);
  };
};
function isWillChangeMotionValue(value,) {
  return Boolean(isMotionValue(value,) && value.add,);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating, }, key7,) {
  const shouldBlock = protectedKeys.hasOwnProperty(key7,) && needsAnimating[key7] !== true;
  needsAnimating[key7] = false;
  return shouldBlock;
}
function hasKeyframesChanged(value, target,) {
  const current = value.get();
  if (Array.isArray(target,)) {
    for (let i = 0; i < target.length; i++) {
      if (target[i] !== current) {
        return true;
      }
    }
  } else {
    return current !== target;
  }
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type, } = {},) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition,);
  const willChange = visualElement.getValue('willChange',);
  if (transitionOverride) {
    transition = transitionOverride;
  }
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key7 in target) {
    const value = visualElement.getValue(key7,);
    const valueTarget = target[key7];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key7,)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      elapsed: 0,
      ...getValueTransition(transition || {}, key7,),
    };
    if (window.HandoffAppearAnimations) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        const elapsed = window.HandoffAppearAnimations(appearId, key7, value, frame,);
        if (elapsed !== null) {
          valueTransition.elapsed = elapsed;
          valueTransition.isHandoff = true;
        }
      }
    }
    let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget,);
    if (valueTransition.type === 'spring' && (value.getVelocity() || valueTransition.velocity)) {
      canSkip = false;
    }
    if (value.animation) {
      canSkip = false;
    }
    if (canSkip) {
      continue;
    }
    value.start(
      animateMotionValue(
        key7,
        value,
        valueTarget,
        visualElement.shouldReduceMotion && transformProps.has(key7,) ? { type: false, } : valueTransition,
      ),
    );
    const animation = value.animation;
    if (isWillChangeMotionValue(willChange,)) {
      willChange.add(key7,);
      animation.then(() => willChange.remove(key7,));
    }
    animations2.push(animation,);
  }
  if (transitionEnd) {
    Promise.all(animations2,).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd,);
    },);
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {},) {
  const resolved = resolveVariant(visualElement, variant, options.custom,);
  let { transition = visualElement.getDefaultTransition() || {}, } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options,),) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size
    ? (forwardDelay = 0,) => {
      const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;
      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options,);
    }
    : () => Promise.resolve();
  const { when, } = transition;
  if (when) {
    const [first, last,] = when === 'beforeChildren' ? [getAnimation, getChildAnimations,] : [getChildAnimations, getAnimation,];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay,),],);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options,) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1
    ? (i = 0,) => i * staggerChildren
    : (i = 0,) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren,).sort(sortByTreeOrder,).forEach((child, i,) => {
    child.notify('AnimationStart', variant,);
    animations2.push(
      animateVariant(child, variant, {
        ...options,
        delay: delayChildren + generateStaggerDuration(i,),
      },).then(() => child.notify('AnimationComplete', variant,)),
    );
  },);
  return Promise.all(animations2,);
}
function sortByTreeOrder(a, b,) {
  return a.sortNodePosition(b,);
}
function animateVisualElement(visualElement, definition, options = {},) {
  visualElement.notify('AnimationStart', definition,);
  let animation;
  if (Array.isArray(definition,)) {
    const animations2 = definition.map((variant,) => animateVariant(visualElement, variant, options,));
    animation = Promise.all(animations2,);
  } else if (typeof definition === 'string') {
    animation = animateVariant(visualElement, definition, options,);
  } else {
    const resolvedDefinition = typeof definition === 'function' ? resolveVariant(visualElement, definition, options.custom,) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options,),);
  }
  return animation.then(() => visualElement.notify('AnimationComplete', definition,));
}
function shallowCompare(next, prev,) {
  if (!Array.isArray(prev,)) {
    return false;
  }
  const prevLength = prev.length;
  if (prevLength !== next.length) {
    return false;
  }
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i]) {
      return false;
    }
  }
  return true;
}
var reversePriorityOrder = [...variantPriorityOrder,].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement,) {
  return (animations2,) =>
    Promise.all(animations2.map(({ animation, options, },) => animateVisualElement(visualElement, animation, options,)),);
}
function createAnimationState(visualElement,) {
  let animate22 = animateList(visualElement,);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition,) => {
    const resolved = resolveVariant(visualElement, definition,);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd, };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator,) {
    animate22 = makeAnimator(visualElement,);
  }
  function animateChanges(options, changedActiveType,) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true,) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop,);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false) {
        removedVariantIndex = i;
      }
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys, };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop,) || typeof prop === 'boolean'
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop,);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop,) ? prop : [prop,];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {},);
      if (activeDelta === false) {
        resolvedValues = {};
      }
      const { prevResolvedValues = {}, } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues,
      };
      const markToAnimate = (key7,) => {
        shouldAnimateType = true;
        if (removedKeys.has(key7,)) {
          handledRemovedValues = true;
          removedKeys.delete(key7,);
        }
        typeState.needsAnimating[key7] = true;
      };
      for (const key7 in allKeys) {
        const next = resolvedValues[key7];
        const prev = prevResolvedValues[key7];
        if (encounteredKeys.hasOwnProperty(key7,)) {
          continue;
        }
        let valueHasChanged = false;
        if (isKeyframesTarget(next,) && isKeyframesTarget(prev,)) {
          valueHasChanged = !shallowCompare(next, prev,);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0) {
            markToAnimate(key7,);
          } else {
            removedKeys.add(key7,);
          }
        } else if (next !== void 0 && removedKeys.has(key7,)) {
          markToAnimate(key7,);
        } else {
          typeState.protectedKeys[key7] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues, };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
        animations2.push(...definitionList.map((animation,) => ({
          animation,
          options: { type, ...options, },
        })),);
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key7,) => {
        const fallbackTarget = visualElement.getBaseTarget(key7,);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key7] = fallbackTarget;
        }
      },);
      animations2.push({ animation: fallbackAnimation, },);
    }
    let shouldAnimate = Boolean(animations2.length,);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate22(animations2,) : Promise.resolve();
  }
  function setActive(type, isActive, options,) {
    var _a;
    if (state[type].isActive === isActive) {
      return Promise.resolve();
    }
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child,) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive,);
    },);
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type,);
    for (const key7 in state) {
      state[key7].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
  };
}
function checkVariantsDidChange(prev, next,) {
  if (typeof next === 'string') {
    return next !== prev;
  } else if (Array.isArray(next,)) {
    return !shallowCompare(next, prev,);
  }
  return false;
}
function createTypeState(isActive = false,) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function createState() {
  return {
    animate: createTypeState(true,),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState(),
  };
}
var Feature = class {
  constructor(node,) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
};
var AnimationFeature = class extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node,) {
    super(node,);
    node.animationState || (node.animationState = createAnimationState(node,));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate22, } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate22,)) {
      this.unmount = animate22.subscribe(this.node,);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate22, } = this.node.getProps();
    const { animate: prevAnimate, } = this.node.prevProps || {};
    if (animate22 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
};
var id = 0;
var ExitAnimationFeature = class extends Feature {
  constructor() {
    super(...arguments,);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext) {
      return;
    }
    const { isPresent: isPresent2, onExitComplete, custom, } = this.node.presenceContext;
    const { isPresent: prevIsPresent, } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent2 === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive('exit', !isPresent2, {
      custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom,
    },);
    if (onExitComplete && !isPresent2) {
      exitAnimation.then(() => onExitComplete(this.id,));
    }
  }
  mount() {
    const { register, } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id,);
    }
  }
  unmount() {
  }
};
var animations = {
  animation: {
    Feature: AnimationFeature,
  },
  exit: {
    Feature: ExitAnimationFeature,
  },
};
var distance = (a, b,) => Math.abs(a - b,);
function distance2D(a, b,) {
  const xDelta = distance(a.x, b.x,);
  const yDelta = distance(a.y, b.y,);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2,);
}
function calcLength(axis,) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01,) {
  return Math.abs(value - target,) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5,) {
  delta.origin = origin;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin,);
  delta.scale = calcLength(target,) / calcLength(source,);
  if (isNear(delta.scale, 1, 1e-4,) || isNaN(delta.scale,)) {
    delta.scale = 1;
  }
  delta.translate = mixNumber(target.min, target.max, delta.origin,) - delta.originPoint;
  if (isNear(delta.translate,) || isNaN(delta.translate,)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin,) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0,);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0,);
}
function calcRelativeAxis(target, relative2, parent,) {
  target.min = parent.min + relative2.min;
  target.max = target.min + calcLength(relative2,);
}
function calcRelativeBox(target, relative2, parent,) {
  calcRelativeAxis(target.x, relative2.x, parent.x,);
  calcRelativeAxis(target.y, relative2.y, parent.y,);
}
function calcRelativeAxisPosition(target, layout2, parent,) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2,);
}
function calcRelativePosition(target, layout2, parent,) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x,);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y,);
}
var createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0,
});
var createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta(),
});
var createAxis = () => ({ min: 0, max: 0, });
var createBox = () => ({
  x: createAxis(),
  y: createAxis(),
});
function usePresence() {
  const context = useContext5(PresenceContext,);
  if (context === null) {
    return [true, null,];
  }
  const { isPresent: isPresent2, onExitComplete, register, } = context;
  const id4 = useId();
  useEffect3(() => register(id4,), [],);
  const safeToRemove = () => onExitComplete && onExitComplete(id4,);
  return !isPresent2 && onExitComplete ? [false, safeToRemove,] : [true,];
}
function useIsPresent() {
  return isPresent(useContext5(PresenceContext,),);
}
function isPresent(context,) {
  return context === null ? true : context.isPresent;
}
var compareByDepth = (a, b,) => a.depth - b.depth;
var FlatTree = class {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child,) {
    addUniqueItem(this.children, child,);
    this.isDirty = true;
  }
  remove(child,) {
    removeItem(this.children, child,);
    this.isDirty = true;
  }
  forEach(callback,) {
    this.isDirty && this.children.sort(compareByDepth,);
    this.isDirty = false;
    this.children.forEach(callback,);
  }
};
function delay(callback, timeout,) {
  const start = time.now();
  const checkElapsed = ({ timestamp, },) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed,);
      callback(elapsed - timeout,);
    }
  };
  frame.read(checkElapsed, true,);
  return () => cancelFrame(checkElapsed,);
}
var visualElementStore = /* @__PURE__ */ new WeakMap();
var prefersReducedMotion = { current: null, };
var hasReducedMotionListener = { current: false, };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser) {
    return;
  }
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia('(prefers-reduced-motion)',);
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences,);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next, prev,) {
  const { willChange, } = next;
  for (const key7 in next) {
    const nextValue = next[key7];
    const prevValue = prev[key7];
    if (isMotionValue(nextValue,)) {
      element.addValue(key7, nextValue,);
      if (isWillChangeMotionValue(willChange,)) {
        willChange.add(key7,);
      }
      if (false) {
        warnOnce(
          nextValue.version === '11.0.7',
          `Attempting to mix Framer Motion versions ${nextValue.version} with 11.0.7 may not work as expected.`,
        );
      }
    } else if (isMotionValue(prevValue,)) {
      element.addValue(key7, motionValue(nextValue, { owner: element, },),);
      if (isWillChangeMotionValue(willChange,)) {
        willChange.remove(key7,);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key7,)) {
        const existingValue = element.getValue(key7,);
        !existingValue.hasAnimated && existingValue.set(nextValue,);
      } else {
        const latestValue = element.getStaticValue(key7,);
        element.addValue(key7, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element, },),);
      }
    }
  }
  for (const key7 in prev) {
    if (next[key7] === void 0) {
      element.removeValue(key7,);
    }
  }
  return next;
}
var featureNames = Object.keys(featureDefinitions,);
var numFeatures = featureNames.length;
var propEventHandlers = [
  'AnimationStart',
  'AnimationComplete',
  'Update',
  'BeforeLayoutMeasure',
  'LayoutMeasure',
  'LayoutAnimationStart',
  'LayoutAnimationComplete',
];
var numVariantProps = variantProps.length;
var VisualElement = class {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState, }, options = {},) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify('Update', this.latestValues,);
    this.render = () => {
      if (!this.current) {
        return;
      }
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection,);
    };
    this.scheduleRender = () => frame.render(this.render, false, true,);
    const { latestValues, renderState, } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues, };
    this.initialValues = props.initial ? { ...latestValues, } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props,);
    this.isVariantNode = isVariantNode(props,);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current,);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {},);
    for (const key7 in initialMotionValues) {
      const value = initialMotionValues[key7];
      if (latestValues[key7] !== void 0 && isMotionValue(value,)) {
        value.set(latestValues[key7], false,);
        if (isWillChangeMotionValue(willChange,)) {
          willChange.add(key7,);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps,) {
    return {};
  }
  mount(instance,) {
    this.current = instance;
    visualElementStore.set(instance, this,);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance,);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this,);
    }
    this.values.forEach((value, key7,) => this.bindToMotionValue(key7, value,));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === 'never'
      ? false
      : this.reducedMotionConfig === 'always'
      ? true
      : prefersReducedMotion.current;
    if (false) {
      warnOnce(this.shouldReduceMotion !== true, 'You have Reduced Motion enabled on your device. Animations may not appear as expected.',);
    }
    if (this.parent) {
      this.parent.children.add(this,);
    }
    this.update(this.props, this.presenceContext,);
  }
  unmount() {
    visualElementStore.delete(this.current,);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate,);
    cancelFrame(this.render,);
    this.valueSubscriptions.forEach((remove2,) => remove2());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this,);
    for (const key7 in this.events) {
      this.events[key7].clear();
    }
    for (const key7 in this.features) {
      this.features[key7].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key7, value,) {
    const valueIsTransform = transformProps.has(key7,);
    const removeOnChange = value.on('change', (latestValue,) => {
      this.latestValues[key7] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true,);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    },);
    const removeOnRenderRequest = value.on('renderRequest', this.scheduleRender,);
    this.valueSubscriptions.set(key7, () => {
      removeOnChange();
      removeOnRenderRequest();
    },);
  }
  sortNodePosition(other,) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current,);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig,) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    if (false) {
      const strictMessage =
        'You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.';
      renderedProps.ignoreStrict ? warning(false, strictMessage,) : invariant(false, strictMessage,);
    }
    for (let i = 0; i < numFeatures; i++) {
      const name = featureNames[i];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent, } = featureDefinitions[name];
      if (ProjectionNode) {
        ProjectionNodeConstructor = ProjectionNode;
      }
      if (isEnabled(renderedProps,)) {
        if (!this.features[name] && FeatureConstructor) {
          this.features[name] = new FeatureConstructor(this,);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if ((this.type === 'html' || this.type === 'svg') && !this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection,);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2,) || dragConstraints && isRefObject(dragConstraints,),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         */
        animationType: typeof layout2 === 'string' ? layout2 : 'both',
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot,
      },);
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key7 in this.features) {
      const feature = this.features[key7];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props,);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props,) : createBox();
  }
  getStaticValue(key7,) {
    return this.latestValues[key7];
  }
  setStaticValue(key7, value,) {
    this.latestValues[key7] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true,) {
    return this.makeTargetAnimatableFromInstance(target, canMutate,);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext,) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key7 = propEventHandlers[i];
      if (this.propEventSubscriptions[key7]) {
        this.propEventSubscriptions[key7]();
        delete this.propEventSubscriptions[key7];
      }
      const listener = props['on' + key7];
      if (listener) {
        this.propEventSubscriptions[key7] = this.on(key7, listener,);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(
      this,
      this.scrapeMotionValuesFromProps(props, this.prevProps,),
      this.prevMotionValues,
    );
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name,) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false,) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = this.props[name];
      if (isVariantLabel(prop,) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child,) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child,);
      return () => closestVariantNode.variantChildren.delete(child,);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key7, value,) {
    if (value !== this.values.get(key7,)) {
      this.removeValue(key7,);
      this.bindToMotionValue(key7, value,);
    }
    this.values.set(key7, value,);
    this.latestValues[key7] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key7,) {
    this.values.delete(key7,);
    const unsubscribe = this.valueSubscriptions.get(key7,);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key7,);
    }
    delete this.latestValues[key7];
    this.removeValueFromRenderState(key7, this.renderState,);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key7,) {
    return this.values.has(key7,);
  }
  getValue(key7, defaultValue,) {
    if (this.props.values && this.props.values[key7]) {
      return this.props.values[key7];
    }
    let value = this.values.get(key7,);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this, },);
      this.addValue(key7, value,);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key7,) {
    var _a;
    return this.latestValues[key7] !== void 0 || !this.current
      ? this.latestValues[key7]
      : (_a = this.getBaseTargetFromProps(this.props, key7,)) !== null && _a !== void 0
      ? _a
      : this.readValueFromInstance(this.current, key7, this.options,);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key7, value,) {
    this.baseTarget[key7] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key7,) {
    var _a;
    const { initial, } = this.props;
    const valueFromInitial = typeof initial === 'string' || typeof initial === 'object'
      ? (_a = resolveVariantFromProps(this.props, initial,)) === null || _a === void 0 ? void 0 : _a[key7]
      : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key7,);
    if (target !== void 0 && !isMotionValue(target,)) {
      return target;
    }
    return this.initialValues[key7] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key7];
  }
  on(eventName, callback,) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback,);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args,);
    }
  }
};
function createMotionProxy(createConfig,) {
  function custom(Component23, customMotionComponentConfig = {},) {
    return createMotionComponent(createConfig(Component23, customMotionComponentConfig,),);
  }
  if (typeof Proxy === 'undefined') {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key7,) => {
      if (!componentCache.has(key7,)) {
        componentCache.set(key7, custom(key7,),);
      }
      return componentCache.get(key7,);
    },
  },);
}
var lowercaseSVGElements = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
];
function isSVGComponent(Component23,) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component23 !== 'string' || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component23.includes('-',)
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component23,) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component23,)
  ) {
    return true;
  }
  return false;
}
function isForcedMotionValue(key7, { layout: layout2, layoutId, },) {
  return transformProps.has(key7,) || key7.startsWith('origin',) ||
    (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key7] || key7 === 'opacity');
}
var getValueAsType = (value, type,) => {
  return type && typeof value === 'number' ? type.transform(value,) : value;
};
function buildHTMLStyles(state, latestValues, options, transformTemplate2,) {
  const { style, vars, transform: transform2, transformOrigin, } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key7 in latestValues) {
    const value = latestValues[key7];
    if (isCSSVariableName(key7,)) {
      vars[key7] = value;
      continue;
    }
    const valueType = numberValueTypes[key7];
    const valueAsType = getValueAsType(value, valueType,);
    if (transformProps.has(key7,)) {
      hasTransform2 = true;
      transform2[key7] = valueAsType;
      if (!transformIsNone) {
        continue;
      }
      if (value !== (valueType.default || 0)) {
        transformIsNone = false;
      }
    } else if (key7.startsWith('origin',)) {
      hasTransformOrigin = true;
      transformOrigin[key7] = valueAsType;
    } else {
      style[key7] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate2) {
      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate2,);
    } else if (style.transform) {
      style.transform = 'none';
    }
  }
  if (hasTransformOrigin) {
    const { originX = '50%', originY = '50%', originZ = 0, } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {},
});
function copyRawValuesOnly(target, source, props,) {
  for (const key7 in source) {
    if (!isMotionValue(source[key7],) && !isForcedMotionValue(key7, props,)) {
      target[key7] = source[key7];
    }
  }
}
function useInitialMotionValues({ transformTemplate: transformTemplate2, }, visualState, isStatic,) {
  return useMemo2(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic, }, transformTemplate2,);
    return Object.assign({}, state.vars, state.style,);
  }, [visualState,],);
}
function useStyle(props, visualState, isStatic,) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props,);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic,),);
  return style;
}
function useHTMLProps(props, visualState, isStatic,) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic,);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = 'none';
    style.touchAction = props.drag === true ? 'none' : `pan-${props.drag === 'x' ? 'y' : 'x'}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
function calcOrigin(origin, offset, size2,) {
  return typeof origin === 'string' ? origin : px.transform(offset + size2 * origin,);
}
function calcSVGTransformOrigin(dimensions, originX, originY,) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width,);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height,);
  return `${pxOriginX} ${pxOriginY}`;
}
var dashKeys = {
  offset: 'stroke-dashoffset',
  array: 'stroke-dasharray',
};
var camelKeys = {
  offset: 'strokeDashoffset',
  array: 'strokeDasharray',
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true,) {
  attrs.pathLength = 1;
  const keys23 = useDashCase ? dashKeys : camelKeys;
  attrs[keys23.offset] = px.transform(-offset,);
  const pathLength = px.transform(length,);
  const pathSpacing = px.transform(spacing,);
  attrs[keys23.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(
  state,
  {
    attrX,
    attrY,
    attrScale,
    originX,
    originY,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  },
  options,
  isSVGTag2,
  transformTemplate2,
) {
  buildHTMLStyles(state, latest, options, transformTemplate2,);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions, } = state;
  if (attrs.transform) {
    if (dimensions) {
      style.transform = attrs.transform;
    }
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5,);
  }
  if (attrX !== void 0) {
    attrs.x = attrX;
  }
  if (attrY !== void 0) {
    attrs.y = attrY;
  }
  if (attrScale !== void 0) {
    attrs.scale = attrScale;
  }
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false,);
  }
}
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {},
});
var isSVGTag = (tag,) => typeof tag === 'string' && tag.toLowerCase() === 'svg';
function useSVGProps(props, visualState, _isStatic, Component23,) {
  const visualProps = useMemo3(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false, }, isSVGTag(Component23,), props.transformTemplate,);
    return {
      ...state.attrs,
      style: { ...state.style, },
    };
  }, [visualState,],);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props,);
    visualProps.style = { ...rawStyles, ...visualProps.style, };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false,) {
  const useRender = (Component23, props, ref, { latestValues, }, isStatic,) => {
    const useVisualProps = isSVGComponent(Component23,) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component23,);
    const filteredProps2 = filterProps(props, typeof Component23 === 'string', forwardMotionProps,);
    const elementProps = Component23 !== Fragment ? { ...filteredProps2, ...visualProps, ref, } : {};
    const { children, } = props;
    const renderedChildren = useMemo4(() => isMotionValue(children,) ? children.get() : children, [children,],);
    return createElement2(Component23, {
      ...elementProps,
      children: renderedChildren,
    },);
  };
  return useRender;
}
function renderHTML(element, { style, vars, }, styleProp, projection,) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp,),);
  for (const key7 in vars) {
    element.style.setProperty(key7, vars[key7],);
  }
}
var camelCaseAttributes = /* @__PURE__ */ new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
],);
function renderSVG(element, renderState, _styleProp, projection,) {
  renderHTML(element, renderState, void 0, projection,);
  for (const key7 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key7,) ? camelToDash(key7,) : key7, renderState.attrs[key7],);
  }
}
function scrapeMotionValuesFromProps(props, prevProps,) {
  const { style, } = props;
  const newValues = {};
  for (const key7 in style) {
    if (isMotionValue(style[key7],) || prevProps.style && isMotionValue(prevProps.style[key7],) || isForcedMotionValue(key7, props,)) {
      newValues[key7] = style[key7];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps2(props, prevProps,) {
  const newValues = scrapeMotionValuesFromProps(props, prevProps,);
  for (const key7 in props) {
    if (isMotionValue(props[key7],) || isMotionValue(prevProps[key7],)) {
      const targetKey = transformPropOrder.indexOf(key7,) !== -1 ? 'attr' + key7.charAt(0,).toUpperCase() + key7.substring(1,) : key7;
      newValues[targetKey] = props[key7];
    }
  }
  return newValues;
}
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues, },) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === 'function' ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
          };
        }
      },);
      frame.render(() => {
        buildSVGAttrs(
          renderState,
          latestValues,
          { enableHardwareAcceleration: false, },
          isSVGTag(instance.tagName,),
          props.transformTemplate,
        );
        renderSVG(instance, renderState,);
      },);
    },
  },),
};
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState,
  },),
};
function createDomMotionConfig(Component23, { forwardMotionProps = false, }, preloadedFeatures2, createVisualElement2,) {
  const baseConfig = isSVGComponent(Component23,) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps,),
    createVisualElement: createVisualElement2,
    Component: Component23,
  };
}
function addHoverEvent(node, isActive,) {
  const eventName = 'pointer' + (isActive ? 'enter' : 'leave');
  const callbackName = 'onHover' + (isActive ? 'Start' : 'End');
  const handleEvent = (event, info,) => {
    if (event.pointerType === 'touch' || isDragActive()) {
      return;
    }
    const props = node.getProps();
    if (node.animationState && props.whileHover) {
      node.animationState.setActive('whileHover', isActive,);
    }
    if (props[callbackName]) {
      frame.update(() => props[callbackName](event, info,));
    }
  };
  return addPointerEvent(node.current, eventName, handleEvent, {
    passive: !node.getProps()[callbackName],
  },);
}
var HoverGesture = class extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true,), addHoverEvent(this.node, false,),);
  }
  unmount() {
  }
};
var FocusGesture = class extends Feature {
  constructor() {
    super(...arguments,);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(':focus-visible',);
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState) {
      return;
    }
    this.node.animationState.setActive('whileFocus', true,);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState) {
      return;
    }
    this.node.animationState.setActive('whileFocus', false,);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(
      addDomEvent(this.node.current, 'focus', () => this.onFocus(),),
      addDomEvent(this.node.current, 'blur', () => this.onBlur(),),
    );
  }
  unmount() {
  }
};
var isNodeOrChild = (parent, child,) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement,);
  }
};
function fireSyntheticPointerEvent(name, handler,) {
  if (!handler) {
    return;
  }
  const syntheticPointerEvent = new PointerEvent('pointer' + name,);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent,),);
}
var PressGesture = class extends Feature {
  constructor() {
    super(...arguments,);
    this.removeStartListeners = noop;
    this.removeEndListeners = noop;
    this.removeAccessibleListeners = noop;
    this.startPointerPress = (startEvent, startInfo,) => {
      if (this.isPressing) {
        return;
      }
      this.removeEndListeners();
      const props = this.node.getProps();
      const endPointerPress = (endEvent, endInfo,) => {
        if (!this.checkPressEnd()) {
          return;
        }
        const { onTap, onTapCancel, globalTapTarget, } = this.node.getProps();
        frame.update(() => {
          !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target,)
            ? onTapCancel && onTapCancel(endEvent, endInfo,)
            : onTap && onTap(endEvent, endInfo,);
        },);
      };
      const removePointerUpListener = addPointerEvent(window, 'pointerup', endPointerPress, {
        passive: !(props.onTap || props['onPointerUp']),
      },);
      const removePointerCancelListener = addPointerEvent(
        window,
        'pointercancel',
        (cancelEvent, cancelInfo,) => this.cancelPress(cancelEvent, cancelInfo,),
        { passive: !(props.onTapCancel || props['onPointerCancel']), },
      );
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener,);
      this.startPress(startEvent, startInfo,);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent,) => {
        if (keydownEvent.key !== 'Enter' || this.isPressing) {
          return;
        }
        const handleKeyup = (keyupEvent,) => {
          if (keyupEvent.key !== 'Enter' || !this.checkPressEnd()) {
            return;
          }
          fireSyntheticPointerEvent('up', (event, info,) => {
            const { onTap, } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info,));
            }
          },);
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, 'keyup', handleKeyup,);
        fireSyntheticPointerEvent('down', (event, info,) => {
          this.startPress(event, info,);
        },);
      };
      const removeKeydownListener = addDomEvent(this.node.current, 'keydown', handleKeydown,);
      const handleBlur = () => {
        if (!this.isPressing) {
          return;
        }
        fireSyntheticPointerEvent('cancel', (cancelEvent, cancelInfo,) => this.cancelPress(cancelEvent, cancelInfo,),);
      };
      const removeBlurListener = addDomEvent(this.node.current, 'blur', handleBlur,);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener,);
    };
  }
  startPress(event, info,) {
    this.isPressing = true;
    const { onTapStart, whileTap, } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive('whileTap', true,);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info,));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive('whileTap', false,);
    }
    return !isDragActive();
  }
  cancelPress(event, info,) {
    if (!this.checkPressEnd()) {
      return;
    }
    const { onTapCancel, } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info,));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(
      props.globalTapTarget ? window : this.node.current,
      'pointerdown',
      this.startPointerPress,
      { passive: !(props.onTapStart || props['onPointerStart']), },
    );
    const removeFocusListener = addDomEvent(this.node.current, 'focus', this.startAccessiblePress,);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener,);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
};
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = (entry,) => {
  const callback = observerCallbacks.get(entry.target,);
  callback && callback(entry,);
};
var fireAllObserverCallbacks = (entries,) => {
  entries.forEach(fireObserverCallback,);
};
function initIntersectionObserver({ root, ...options },) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot,)) {
    observers.set(lookupRoot, {},);
  }
  const rootObservers = observers.get(lookupRoot,);
  const key7 = JSON.stringify(options,);
  if (!rootObservers[key7]) {
    rootObservers[key7] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options, },);
  }
  return rootObservers[key7];
}
function observeIntersection(element, options, callback,) {
  const rootInteresectionObserver = initIntersectionObserver(options,);
  observerCallbacks.set(element, callback,);
  rootInteresectionObserver.observe(element,);
  return () => {
    observerCallbacks.delete(element,);
    rootInteresectionObserver.unobserve(element,);
  };
}
var thresholdNames = {
  some: 0,
  all: 1,
};
var InViewFeature = class extends Feature {
  constructor() {
    super(...arguments,);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {}, } = this.node.getProps();
    const { root, margin: rootMargin, amount = 'some', once, } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === 'number' ? amount : thresholdNames[amount],
    };
    const onIntersectionUpdate = (entry,) => {
      const { isIntersecting, } = entry;
      if (this.isInView === isIntersecting) {
        return;
      }
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive('whileInView', isIntersecting,);
      }
      const { onViewportEnter, onViewportLeave, } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry,);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate,);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === 'undefined') {
      return;
    }
    const { props, prevProps, } = this.node;
    const hasOptionsChanged = ['amount', 'margin', 'root',].some(hasViewportOptionChanged(props, prevProps,),);
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
function hasViewportOptionChanged({ viewport = {}, }, { viewport: prevViewport = {}, } = {},) {
  return (name,) => viewport[name] !== prevViewport[name];
}
var gestureAnimations = {
  inView: {
    Feature: InViewFeature,
  },
  tap: {
    Feature: PressGesture,
  },
  focus: {
    Feature: FocusGesture,
  },
  hover: {
    Feature: HoverGesture,
  },
};
var PanSession = class {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {},) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) {
        return;
      }
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history,);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0, },) >= 3;
      if (!isPanStarted && !isDistancePastThreshold) {
        return;
      }
      const { point: point3, } = info2;
      const { timestamp: timestamp2, } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2, },);
      const { onStart, onMove, } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2,);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2,);
    };
    this.handlePointerMove = (event2, info2,) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint,);
      frame.update(this.updatePoint, true,);
    };
    this.handlePointerUp = (event2, info2,) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation, } = this.handlers;
      if (this.dragSnapToOrigin) {
        resumeAnimation && resumeAnimation();
      }
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) {
        return;
      }
      const panInfo = getPanInfo(
        event2.type === 'pointercancel' ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint,),
        this.history,
      );
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo,);
      }
      onSessionEnd && onSessionEnd(event2, panInfo,);
    };
    if (!isPrimaryPointer(event,)) {
      return;
    }
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event,);
    const initialInfo = transformPoint(info, this.transformPagePoint,);
    const { point: point2, } = initialInfo;
    const { timestamp, } = frameData;
    this.history = [{ ...point2, timestamp, },];
    const { onSessionStart, } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history,),);
    this.removeListeners = pipe(
      addPointerEvent(this.contextWindow, 'pointermove', this.handlePointerMove,),
      addPointerEvent(this.contextWindow, 'pointerup', this.handlePointerUp,),
      addPointerEvent(this.contextWindow, 'pointercancel', this.handlePointerUp,),
    );
  }
  updateHandlers(handlers,) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint,);
  }
};
function transformPoint(info, transformPagePoint,) {
  return transformPagePoint ? { point: transformPagePoint(info.point,), } : info;
}
function subtractPoint(a, b,) {
  return { x: a.x - b.x, y: a.y - b.y, };
}
function getPanInfo({ point: point2, }, history,) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history,),),
    offset: subtractPoint(point2, startDevicePoint(history,),),
    velocity: getVelocity2(history, 0.1,),
  };
}
function startDevicePoint(history,) {
  return history[0];
}
function lastDevicePoint(history,) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta2,) {
  if (history.length < 2) {
    return { x: 0, y: 0, };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history,);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta2,)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0, };
  }
  const time22 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp,);
  if (time22 === 0) {
    return { x: 0, y: 0, };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time22,
    y: (lastPoint.y - timestampedPoint.y) / time22,
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point2, { min, max, }, elastic,) {
  if (min !== void 0 && point2 < min) {
    point2 = elastic ? mixNumber(min, point2, elastic.min,) : Math.max(point2, min,);
  } else if (max !== void 0 && point2 > max) {
    point2 = elastic ? mixNumber(max, point2, elastic.max,) : Math.min(point2, max,);
  }
  return point2;
}
function calcRelativeAxisConstraints(axis, min, max,) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0,
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right, },) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right,),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom,),
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis,) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max,] = [max, min,];
  }
  return { min, max, };
}
function calcViewportConstraints(layoutBox, constraintsBox,) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x,),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y,),
  };
}
function calcOrigin2(source, target,) {
  let origin = 0.5;
  const sourceLength = calcLength(source,);
  const targetLength = calcLength(target,);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min,);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min,);
  }
  return clamp(0, 1, origin,);
}
function rebaseAxisConstraints(layout2, constraints,) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic,) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, 'left', 'right',),
    y: resolveAxisElastic(dragElastic, 'top', 'bottom',),
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel,) {
  return {
    min: resolvePointElastic(dragElastic, minLabel,),
    max: resolvePointElastic(dragElastic, maxLabel,),
  };
}
function resolvePointElastic(dragElastic, label,) {
  return typeof dragElastic === 'number' ? dragElastic : dragElastic[label] || 0;
}
function eachAxis(callback,) {
  return [callback('x',), callback('y',),];
}
function convertBoundingBoxToBox({ top, left, right, bottom, },) {
  return {
    x: { min: left, max: right, },
    y: { min: top, max: bottom, },
  };
}
function convertBoxToBoundingBox({ x, y, },) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min, };
}
function transformBoxPoints(point2, transformPoint2,) {
  if (!transformPoint2) {
    return point2;
  }
  const topLeft = transformPoint2({ x: point2.left, y: point2.top, },);
  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom, },);
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x,
  };
}
function isIdentityScale(scale2,) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY, },) {
  return !isIdentityScale(scale2,) || !isIdentityScale(scaleX,) || !isIdentityScale(scaleY,);
}
function hasTransform(values,) {
  return hasScale(values,) || has2DTranslate(values,) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values,) {
  return is2DTranslate(values.x,) || is2DTranslate(values.y,);
}
function is2DTranslate(value,) {
  return value && value !== '0%';
}
function scalePoint(point2, scale2, originPoint,) {
  const distanceFromOrigin = point2 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale,) {
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, boxScale, originPoint,);
  }
  return scalePoint(point2, scale2, originPoint,) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale,) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale,);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale,);
}
function applyBoxDelta(box, { x, y, },) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint,);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint,);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false,) {
  const treeLength = treePath.length;
  if (!treeLength) {
    return;
  }
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const instance = node.instance;
    if (instance && instance.style && instance.style.display === 'contents') {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y,
      },);
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta,);
    }
    if (isSharedTransition && hasTransform(node.latestValues,)) {
      transformBox(box, node.latestValues,);
    }
  }
  treeScale.x = snapToDefault(treeScale.x,);
  treeScale.y = snapToDefault(treeScale.y,);
}
function snapToDefault(scale2,) {
  if (Number.isInteger(scale2,)) {
    return scale2;
  }
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2,) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key7, scaleKey, originKey,],) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin,);
  applyAxisDelta(axis, transforms[key7], transforms[scaleKey], originPoint, transforms.scale,);
}
var xKeys = ['x', 'scaleX', 'originX',];
var yKeys = ['y', 'scaleY', 'originY',];
function transformBox(box, transform2,) {
  transformAxis(box.x, transform2, xKeys,);
  transformAxis(box.y, transform2, yKeys,);
}
function measureViewportBox(instance, transformPoint2,) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2,),);
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint,) {
  const viewportBox = measureViewportBox(element, transformPagePoint,);
  const { scroll: scroll2, } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x,);
    translateAxis(viewportBox.y, scroll2.offset.y,);
  }
  return viewportBox;
}
var getContextWindow = ({ current, },) => {
  return current ? current.ownerDocument.defaultView : null;
};
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = class {
  constructor(visualElement,) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0, };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false, } = {},) {
    const { presenceContext, } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false) {
      return;
    }
    const onSessionStart = (event,) => {
      const { dragSnapToOrigin: dragSnapToOrigin2, } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, 'page',).point,);
      }
    };
    const onStart = (event, info,) => {
      const { drag: drag2, dragPropagation, onDragStart, } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock) {
          this.openGlobalLock();
        }
        this.openGlobalLock = getGlobalLock(drag2,);
        if (!this.openGlobalLock) {
          return;
        }
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis,) => {
        let current = this.getAxisMotionValue(axis,).get() || 0;
        if (percent.test(current,)) {
          const { projection, } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis,);
              current = length * (parseFloat(current,) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      },);
      if (onDragStart) {
        frame.update(() => onDragStart(event, info,), false, true,);
      }
      const { animationState, } = this.visualElement;
      animationState && animationState.setActive('whileDrag', true,);
    };
    const onMove = (event, info,) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock) {
        return;
      }
      const { offset, } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset,);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection,);
        }
        return;
      }
      this.updateAxis('x', info.point, offset,);
      this.updateAxis('y', info.point, offset,);
      this.visualElement.render();
      onDrag && onDrag(event, info,);
    };
    const onSessionEnd = (event, info,) => this.stop(event, info,);
    const resumeAnimation = () =>
      eachAxis((axis,) => {
        var _a;
        return this.getAnimationState(axis,) === 'paused' &&
          ((_a = this.getAxisMotionValue(axis,).animation) === null || _a === void 0 ? void 0 : _a.play());
      },);
    const { dragSnapToOrigin, } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation,
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement,),
    },);
  }
  stop(event, info,) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging) {
      return;
    }
    const { velocity, } = info;
    this.startAnimation(velocity,);
    const { onDragEnd, } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info,));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState, } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation, } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive('whileDrag', false,);
  }
  updateAxis(axis, _point, offset,) {
    const { drag: drag2, } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection,)) {
      return;
    }
    const axisValue = this.getAxisMotionValue(axis,);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis],);
    }
    axisValue.set(next,);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic, } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout
      ? this.visualElement.projection.measure(false,)
      : (_a = this.visualElement.projection) === null || _a === void 0
      ? void 0
      : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints,)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints,);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic,);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis,) => {
        if (this.getAxisMotionValue(axis,)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis],);
        }
      },);
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints, } = this.getProps();
    if (!constraints || !isRefObject(constraints,)) {
      return false;
    }
    const constraintsElement = constraints.current;
    invariant(
      constraintsElement !== null,
      'If `dragConstraints` is set as a React ref, that ref must be passed to another component\'s `ref` prop.',
    );
    const { projection, } = this.visualElement;
    if (!projection || !projection.layout) {
      return false;
    }
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint(),);
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox,);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints,),);
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints,);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity,) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis,) => {
      if (!shouldDrag(axis, drag2, this.currentDirection,)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin) {
        transition = { min: 0, max: 0, };
      }
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: 'inertia',
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition,
      };
      return this.startAxisValueAnimation(axis, inertia2,);
    },);
    return Promise.all(momentumAnimations,).then(onDragTransitionEnd,);
  }
  startAxisValueAnimation(axis, transition,) {
    const axisValue = this.getAxisMotionValue(axis,);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition,),);
  }
  stopAnimation() {
    eachAxis((axis,) => this.getAxisMotionValue(axis,).stop());
  }
  pauseAnimation() {
    eachAxis((axis,) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis,).animation) === null || _a === void 0 ? void 0 : _a.pause();
    },);
  }
  getAnimationState(axis,) {
    var _a;
    return (_a = this.getAxisMotionValue(axis,).animation) === null || _a === void 0 ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis,) {
    const dragKey = '_drag' + axis.toUpperCase();
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue
      ? externalMotionValue
      : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0,);
  }
  snapToCursor(point2,) {
    eachAxis((axis,) => {
      const { drag: drag2, } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection,)) {
        return;
      }
      const { projection, } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis,);
      if (projection && projection.layout) {
        const { min, max, } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber(min, max, 0.5,),);
      }
    },);
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) {
      return;
    }
    const { drag: drag2, dragConstraints, } = this.getProps();
    const { projection, } = this.visualElement;
    if (!isRefObject(dragConstraints,) || !projection || !this.constraints) {
      return;
    }
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0, };
    eachAxis((axis,) => {
      const axisValue = this.getAxisMotionValue(axis,);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest, }, this.constraints[axis],);
      }
    },);
    const { transformTemplate: transformTemplate2, } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, '',) : 'none';
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis,) => {
      if (!shouldDrag(axis, drag2, null,)) {
        return;
      }
      const axisValue = this.getAxisMotionValue(axis,);
      const { min, max, } = this.constraints[axis];
      axisValue.set(mixNumber(min, max, boxProgress[axis],),);
    },);
  }
  addListeners() {
    if (!this.visualElement.current) {
      return;
    }
    elementDragControls.set(this.visualElement, this,);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, 'pointerdown', (event,) => {
      const { drag: drag2, dragListener = true, } = this.getProps();
      drag2 && dragListener && this.start(event,);
    },);
    const measureDragConstraints = () => {
      const { dragConstraints, } = this.getProps();
      if (isRefObject(dragConstraints,)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection, } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener('measure', measureDragConstraints,);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, 'resize', () => this.scalePositionWithinConstraints(),);
    const stopLayoutUpdateListener = projection.addEventListener('didUpdate', ({ delta, hasLayoutChanged, },) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis,) => {
          const motionValue2 = this.getAxisMotionValue(axis,);
          if (!motionValue2) {
            return;
          }
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate,);
        },);
        this.visualElement.render();
      }
    },);
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const {
      drag: drag2 = false,
      dragDirectionLock = false,
      dragPropagation = false,
      dragConstraints = false,
      dragElastic = defaultElastic,
      dragMomentum = true,
    } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum,
    };
  }
};
function shouldDrag(direction, drag2, currentDirection,) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10,) {
  let direction = null;
  if (Math.abs(offset.y,) > lockThreshold) {
    direction = 'y';
  } else if (Math.abs(offset.x,) > lockThreshold) {
    direction = 'x';
  }
  return direction;
}
var DragGesture = class extends Feature {
  constructor(node,) {
    super(node,);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node,);
  }
  mount() {
    const { dragControls, } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls,);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};
var asyncHandler = (handler,) => (event, info,) => {
  if (handler) {
    frame.update(() => handler(event, info,));
  }
};
var PanGesture = class extends Feature {
  constructor() {
    super(...arguments,);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent,) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node,),
    },);
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd, } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart,),
      onStart: asyncHandler(onPanStart,),
      onMove: onPan,
      onEnd: (event, info,) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info,));
        }
      },
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, 'pointerdown', (event,) => this.onPointerDown(event,),);
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers(),);
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false,
};
function pixelsToPercent(pixels, axis,) {
  if (axis.max === axis.min) {
    return 0;
  }
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: (latest, node,) => {
    if (!node.target) {
      return latest;
    }
    if (typeof latest === 'string') {
      if (px.test(latest,)) {
        latest = parseFloat(latest,);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x,);
    const y = pixelsToPercent(latest, node.target.y,);
    return `${x}% ${y}%`;
  },
};
var correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta, },) => {
    const original = latest;
    const shadow = complex.parse(latest,);
    if (shadow.length > 5) {
      return original;
    }
    const template = complex.createTransformer(latest,);
    const offset = typeof shadow[0] !== 'number' ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber(xScale, yScale, 0.5,);
    if (typeof shadow[2 + offset] === 'number') {
      shadow[2 + offset] /= averageScale;
    }
    if (typeof shadow[3 + offset] === 'number') {
      shadow[3 + offset] /= averageScale;
    }
    return template(shadow,);
  },
};
var MeasureLayoutWithContext = class extends React__default.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId, } = this.props;
    const { projection, } = visualElement;
    addScaleCorrector(defaultScaleCorrectors,);
    if (projection) {
      if (layoutGroup.group) {
        layoutGroup.group.add(projection,);
      }
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection,);
      }
      projection.root.didUpdate();
      projection.addEventListener('animationComplete', () => {
        this.safeToRemove();
      },);
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove(),
      },);
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps,) {
    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2, } = this.props;
    const projection = visualElement.projection;
    if (!projection) {
      return null;
    }
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        },);
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection, } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      },);
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;
    const { projection, } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group) {
        layoutGroup.group.remove(projection,);
      }
      if (promoteContext && promoteContext.deregister) {
        promoteContext.deregister(projection,);
      }
    }
  }
  safeToRemove() {
    const { safeToRemove, } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
function MeasureLayout(props,) {
  const [isPresent2, safeToRemove,] = usePresence();
  const layoutGroup = useContext6(LayoutGroupContext,);
  return React__default.createElement(MeasureLayoutWithContext, {
    ...props,
    layoutGroup,
    switchLayoutGroup: useContext6(SwitchLayoutGroupContext,),
    isPresent: isPresent2,
    safeToRemove,
  },);
}
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow,
};
var borders = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',];
var numBorders = borders.length;
var asNumber = (value,) => typeof value === 'string' ? parseFloat(value,) : value;
var isPx = (value,) => typeof value === 'number' || px.test(value,);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember,) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2,),
    );
    target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2,),);
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2,);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel,);
    let leadRadius = getRadius(lead, borderLabel,);
    if (followRadius === void 0 && leadRadius === void 0) {
      continue;
    }
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius,) === isPx(leadRadius,);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius,), asNumber(leadRadius,), progress2,), 0,);
      if (percent.test(leadRadius,) || percent.test(followRadius,)) {
        target[borderLabel] += '%';
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2,);
  }
}
function getRadius(values, radiusName,) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut,);
var easeCrossfadeOut = compress(0.5, 0.95, noop,);
function compress(min, max, easing,) {
  return (p,) => {
    if (p < min) {
      return 0;
    }
    if (p > max) {
      return 1;
    }
    return easing(progress(min, max, p,),);
  };
}
function copyAxisInto(axis, originAxis,) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox,) {
  copyAxisInto(box.x, originBox.x,);
  copyAxisInto(box.y, originBox.y,);
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale,) {
  point2 -= translate;
  point2 = scalePoint(point2, 1 / scale2, originPoint,);
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, 1 / boxScale, originPoint,);
  }
  return point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis,) {
  if (percent.test(translate,)) {
    translate = parseFloat(translate,);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100,);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== 'number') {
    return;
  }
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin,);
  if (axis === originAxis) {
    originPoint -= translate;
  }
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale,);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale,);
}
function removeAxisTransforms(axis, transforms, [key7, scaleKey, originKey,], origin, sourceAxis,) {
  removeAxisDelta(axis, transforms[key7], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis,);
}
var xKeys2 = ['x', 'scaleX', 'originX',];
var yKeys2 = ['y', 'scaleY', 'originY',];
function removeBoxTransforms(box, transforms, originBox, sourceBox,) {
  removeAxisTransforms(box.x, transforms, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0,);
  removeAxisTransforms(box.y, transforms, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0,);
}
function isAxisDeltaZero(delta,) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta,) {
  return isAxisDeltaZero(delta.x,) && isAxisDeltaZero(delta.y,);
}
function boxEquals(a, b,) {
  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
}
function boxEqualsRounded(a, b,) {
  return Math.round(a.x.min,) === Math.round(b.x.min,) && Math.round(a.x.max,) === Math.round(b.x.max,) &&
    Math.round(a.y.min,) === Math.round(b.y.min,) && Math.round(a.y.max,) === Math.round(b.y.max,);
}
function aspectRatio(box,) {
  return calcLength(box.x,) / calcLength(box.y,);
}
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node,) {
    addUniqueItem(this.members, node,);
    node.scheduleRender();
  }
  remove(node,) {
    removeItem(this.members, node,);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead,);
      }
    }
  }
  relegate(node,) {
    const indexOfNode = this.members.findIndex((member,) => node === member);
    if (indexOfNode === 0) {
      return false;
    }
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead,);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity,) {
    const prevLead = this.lead;
    if (node === prevLead) {
      return;
    }
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade, } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node,) => {
      const { options, resumingFrom, } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    },);
  }
  scheduleRender() {
    this.members.forEach((node,) => {
      node.instance && node.scheduleRender(false,);
    },);
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};
function buildProjectionTransform(delta, treeScale, latestTransform,) {
  let transform2 = '';
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY, } = latestTransform;
    if (rotate) {
      transform2 += `rotate(${rotate}deg) `;
    }
    if (rotateX) {
      transform2 += `rotateX(${rotateX}deg) `;
    }
    if (rotateY) {
      transform2 += `rotateY(${rotateY}deg) `;
    }
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || 'none';
}
function record(data2,) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data2,);
  }
}
function isSVGElement(element,) {
  return element instanceof SVGElement && element.tagName !== 'svg';
}
function animateSingleValue(value, keyframes2, options,) {
  const motionValue$1 = isMotionValue(value,) ? value : motionValue(value,);
  motionValue$1.start(animateMotionValue('', motionValue$1, keyframes2, options,),);
  return motionValue$1.animation;
}
var transformAxes = ['', 'X', 'Y', 'Z',];
var hiddenVisibility = { visibility: 'hidden', };
var animationTarget = 1e3;
var id2 = 0;
var projectionFrameData = {
  type: 'projectionFrame',
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, },) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent(),) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1, };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes,);
        this.nodes.forEach(resolveTargetDelta,);
        this.nodes.forEach(calcProjection,);
        this.nodes.forEach(cleanDirtyNodes,);
        record(projectionFrameData,);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent,] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this) {
        this.nodes = new FlatTree();
      }
    }
    addEventListener(name, handler,) {
      if (!this.eventHandlers.has(name,)) {
        this.eventHandlers.set(name, new SubscriptionManager(),);
      }
      return this.eventHandlers.get(name,).add(handler,);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name,);
      subscriptionManager && subscriptionManager.notify(...args,);
    }
    hasListeners(name,) {
      return this.eventHandlers.has(name,);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated,) {
      if (this.instance) {
        return;
      }
      this.isSVG = isSVGElement(instance,);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement, } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance,);
      }
      this.root.nodes.add(this,);
      this.parent && this.parent.children.add(this,);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250,);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation,);
          }
        },);
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this,);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener('didUpdate', ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, },) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout,) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (
            this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged ||
            hasLayoutChanged && (targetChanged || !this.currentAnimation)
          ) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged,);
            const animationOptions = {
              ...getValueTransition(layoutTransition, 'layout',),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete,
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions,);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this,);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        },);
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this,);
      const stack = this.getStack();
      stack && stack.remove(this,);
      this.parent && this.parent.children.delete(this,);
      this.instance = void 0;
      cancelFrame(this.updateProjection,);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked()) {
        return;
      }
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation,);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement, } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true,) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty) {
        return;
      }
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll('snapshot',);
        if (node.options.layoutRoot) {
          node.willUpdate(false,);
        }
      }
      const { layoutId, layout: layout2, } = this.options;
      if (layoutId === void 0 && !layout2) {
        return;
      }
      const transformTemplate2 = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, '',) : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners('willUpdate',);
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements,);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty,);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle,);
      this.nodes.forEach(updateLayout,);
      this.nodes.forEach(notifyLayoutUpdate,);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp,);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      steps.update.process(frameData,);
      steps.preRender.process(frameData,);
      steps.render.process(frameData,);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot,);
      this.sharedNodes.forEach(removeLeadSnapshots,);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true,);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      },);
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance) {
        return;
      }
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance) {
        return;
      }
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false,);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners('measure', this.layout.layoutBox,);
      const { visualElement, } = this.options;
      visualElement && visualElement.notify('LayoutMeasure', this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0,);
    }
    updateScroll(phase = 'measure',) {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance,);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance,),
          offset: measureScroll(this.instance,),
        };
      }
    }
    resetTransform() {
      if (!resetTransform) {
        return;
      }
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta,);
      const transformTemplate2 = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, '',) : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues,) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue,);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true,) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox,);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox,);
      }
      roundBox(layoutBox,);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id,
      };
    }
    measurePageBox() {
      const { visualElement, } = this.options;
      if (!visualElement) {
        return createBox();
      }
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2, } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x,);
        translateAxis(box.y, scroll2.offset.y,);
      }
      return box;
    }
    removeElementScroll(box,) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box,);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll: scroll2, options, } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box,);
            const { scroll: rootScroll, } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x,);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y,);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x,);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y,);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false,) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box,);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y,
          },);
        }
        if (!hasTransform(node.latestValues,)) {
          continue;
        }
        transformBox(withTransforms, node.latestValues,);
      }
      if (hasTransform(this.latestValues,)) {
        transformBox(withTransforms, this.latestValues,);
      }
      return withTransforms;
    }
    removeTransform(box,) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box,);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance) {
          continue;
        }
        if (!hasTransform(node.latestValues,)) {
          continue;
        }
        hasScale(node.latestValues,) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox,);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox,);
      }
      if (hasTransform(this.latestValues,)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues,);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta,) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options,) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true,
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent) {
        return;
      }
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true,);
      }
    }
    resolveTargetDelta(forceRecalculation = false,) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom,) || this !== lead;
      const canSkip =
        !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty ||
          ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip) {
        return;
      }
      const { layout: layout2, layoutId, } = this.options;
      if (!this.layout || !(layout2 || layoutId)) {
        return;
      }
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox,);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin,);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta) {
        return;
      }
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target,);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom,)) {
          this.target = this.applyTransform(this.layout.layoutBox,);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox,);
        }
        applyBoxDelta(this.target, this.targetDelta,);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox,);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (
          relativeParent && Boolean(relativeParent.resumingFrom,) === Boolean(this.resumingFrom,) && !relativeParent.options.layoutScroll &&
          relativeParent.target && this.animationProgress !== 1
        ) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target,);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin,);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues,) || has2DTranslate(this.parent.latestValues,)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout,);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom,) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip) {
        return;
      }
      const { layout: layout2, layoutId, } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation,);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId)) {
        return;
      }
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox,);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared,);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target, } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = 'none';
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues,);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale,);
      if (
        this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY
      ) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners('projectionUpdate', target,);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll2 = true,) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll2) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false,) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues, };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(
        isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade,),
      );
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest,) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2,);
        mixAxisDelta(targetDelta.y, delta.y, progress2,);
        this.setTargetDelta(targetDelta,);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox,);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2,);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget,)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget) {
            prevRelativeTarget = createBox();
          }
          copyBoxInto(prevRelativeTarget, this.relativeTarget,);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember,);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0,);
    }
    startAnimation(options,) {
      this.notifyListeners('animationStart',);
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation,);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest,) => {
            this.mixTargetDelta(latest,);
            options.onUpdate && options.onUpdate(latest,);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          },
        },);
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      },);
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners('animationComplete',);
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget,);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues, } = lead;
      if (!targetWithTransforms || !target || !layout2) {
        return;
      }
      if (
        this !== lead && this.layout && layout2 &&
        shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox,)
      ) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x,);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y,);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target,);
      transformBox(targetWithTransforms, latestValues,);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues,);
    }
    registerSharedNode(layoutId, node,) {
      if (!this.sharedNodes.has(layoutId,)) {
        this.sharedNodes.set(layoutId, new NodeStack(),);
      }
      const stack = this.sharedNodes.get(layoutId,);
      stack.add(node,);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node,) : void 0,
      },);
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId, } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId, } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId, } = this.options;
      if (layoutId) {
        return this.root.sharedNodes.get(layoutId,);
      }
    }
    promote({ needsReset, transition, preserveFollowOpacity, } = {},) {
      const stack = this.getStack();
      if (stack) {
        stack.promote(this, preserveFollowOpacity,);
      }
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition) {
        this.setOptions({ transition, },);
      }
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this,);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement, } = this.options;
      if (!visualElement) {
        return;
      }
      let hasRotate = false;
      const { latestValues, } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate) {
        return;
      }
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key7 = 'rotate' + transformAxes[i];
        if (latestValues[key7]) {
          resetValues[key7] = latestValues[key7];
          visualElement.setStaticValue(key7, 0,);
        }
      }
      visualElement.render();
      for (const key7 in resetValues) {
        visualElement.setStaticValue(key7, resetValues[key7],);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp,) {
      var _a, _b;
      if (!this.instance || this.isSVG) {
        return void 0;
      }
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: '',
      };
      const transformTemplate2 = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = '';
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents,) || '';
        styles.transform = transformTemplate2 ? transformTemplate2(this.latestValues, '',) : 'none';
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents,) ||
            '';
        }
        if (this.hasProjected && !hasTransform(this.latestValues,)) {
          emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, '',) : 'none';
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender,);
      if (transformTemplate2) {
        styles.transform = transformTemplate2(valuesToRender, styles.transform,);
      }
      const { x, y, } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this
          ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0
            ? _b
            : 1
          : this.preserveOpacity
          ? this.latestValues.opacity
          : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this
          ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : ''
          : valuesToRender.opacityExit !== void 0
          ? valuesToRender.opacityExit
          : 0;
      }
      for (const key7 in scaleCorrectors) {
        if (valuesToRender[key7] === void 0) {
          continue;
        }
        const { correct, applyTo, } = scaleCorrectors[key7];
        const corrected = styles.transform === 'none' ? valuesToRender[key7] : correct(valuesToRender[key7], lead,);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key7] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this
          ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents,) || ''
          : 'none';
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node,) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      },);
      this.root.nodes.forEach(clearMeasurements,);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node,) {
  node.updateLayout();
}
function notifyLayoutUpdate(node,) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners('didUpdate',)) {
    const { layoutBox: layout2, measuredBox: measuredLayout, } = node.layout;
    const { animationType, } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === 'size') {
      eachAxis((axis,) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot,);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      },);
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2,)) {
      eachAxis((axis,) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis],);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      },);
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox,);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true,), snapshot.measuredBox,);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox,);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta,);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout, } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox,);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox,);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout,)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners('didUpdate', {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged,
    },);
  } else if (node.isLead()) {
    const { onExitComplete, } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node,) {
  projectionFrameData.totalNodes++;
  if (!node.parent) {
    return;
  }
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty ||
    (node.isSharedProjectionDirty = Boolean(
      node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty,
    ));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node,) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node,) {
  node.clearSnapshot();
}
function clearMeasurements(node,) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node,) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node,) {
  const { visualElement, } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify('BeforeLayoutMeasure',);
  }
  node.resetTransform();
}
function finishAnimation(node,) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node,) {
  node.resolveTargetDelta();
}
function calcProjection(node,) {
  node.calcProjection();
}
function resetRotation(node,) {
  node.resetRotation();
}
function removeLeadSnapshots(stack,) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p,) {
  output.translate = mixNumber(delta.translate, 0, p,);
  output.scale = mixNumber(delta.scale, 1, p,);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p,) {
  output.min = mixNumber(from.min, to.min, p,);
  output.max = mixNumber(from.max, to.max, p,);
}
function mixBox(output, from, to, p,) {
  mixAxis(output.x, from.x, to.x, p,);
  mixAxis(output.y, from.y, to.y, p,);
}
function hasOpacityCrossfade(node,) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1,],
};
var userAgentContains = (string,) =>
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string,);
var roundPoint = userAgentContains('applewebkit/',) && !userAgentContains('chrome/',) ? Math.round : noop;
function roundAxis(axis,) {
  axis.min = roundPoint(axis.min,);
  axis.max = roundPoint(axis.max,);
}
function roundBox(box,) {
  roundAxis(box.x,);
  roundAxis(box.y,);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2,) {
  return animationType === 'position' ||
    animationType === 'preserve-aspect' && !isNear(aspectRatio(snapshot,), aspectRatio(layout2,), 0.2,);
}
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify22,) => addDomEvent(ref, 'resize', notify22,),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop,
  }),
  checkIsScrollRoot: () => true,
},);
var rootProjectionNode = {
  current: void 0,
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance,) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop,
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({},);
      documentNode.mount(window,);
      documentNode.setOptions({ layoutScroll: true, },);
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value,) => {
    instance.style.transform = value !== void 0 ? value : 'none';
  },
  checkIsScrollRoot: (instance,) => Boolean(window.getComputedStyle(instance,).position === 'fixed',),
},);
var drag = {
  pan: {
    Feature: PanGesture,
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout,
  },
};
var splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current,) {
  const match = splitCSSVariableRegex.exec(current,);
  if (!match) {
    return [,];
  }
  const [, token, fallback,] = match;
  return [token, fallback,];
}
var maxDepth = 4;
function getVariableValue(current, element, depth = 1,) {
  invariant(
    depth <= maxDepth,
    `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`,
  );
  const [token, fallback,] = parseCSSVariable(current,);
  if (!token) {
    return;
  }
  const resolved = window.getComputedStyle(element,).getPropertyValue(token,);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed,) ? parseFloat(trimmed,) : trimmed;
  } else if (isCSSVariableToken(fallback,)) {
    return getVariableValue(fallback, element, depth + 1,);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd,) {
  const element = visualElement.current;
  if (!(element instanceof Element)) {
    return { target, transitionEnd, };
  }
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd, };
  }
  visualElement.values.forEach((value,) => {
    const current = value.get();
    if (!isCSSVariableToken(current,)) {
      return;
    }
    const resolved = getVariableValue(current, element,);
    if (resolved) {
      value.set(resolved,);
    }
  },);
  for (const key7 in target) {
    const current = target[key7];
    if (!isCSSVariableToken(current,)) {
      continue;
    }
    const resolved = getVariableValue(current, element,);
    if (!resolved) {
      continue;
    }
    target[key7] = resolved;
    if (!transitionEnd) {
      transitionEnd = {};
    }
    if (transitionEnd[key7] === void 0) {
      transitionEnd[key7] = current;
    }
  }
  return { target, transitionEnd, };
}
var positionalKeys = /* @__PURE__ */ new Set([
  'width',
  'height',
  'top',
  'left',
  'right',
  'bottom',
  'x',
  'y',
  'translateX',
  'translateY',
],);
var isPositionalKey = (key7,) => positionalKeys.has(key7,);
var hasPositionalKey = (target,) => {
  return Object.keys(target,).some(isPositionalKey,);
};
var isNumOrPxType = (v,) => v === number || v === px;
var getPosFromMatrix = (matrix, pos,) => parseFloat(matrix.split(', ',)[pos],);
var getTranslateFromMatrix = (pos2, pos3,) => (_bbox, { transform: transform2, },) => {
  if (transform2 === 'none' || !transform2) {
    return 0;
  }
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/,);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3,);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/,);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2,);
    } else {
      return 0;
    }
  }
};
var transformKeys = /* @__PURE__ */ new Set(['x', 'y', 'z',],);
var nonTranslationalTransformKeys = transformPropOrder.filter((key7,) => !transformKeys.has(key7,));
function removeNonTranslationalTransform(visualElement,) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key7,) => {
    const value = visualElement.getValue(key7,);
    if (value !== void 0) {
      removedTransforms.push([key7, value.get(),],);
      value.set(key7.startsWith('scale',) ? 1 : 0,);
    }
  },);
  if (removedTransforms.length) {
    visualElement.render();
  }
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: ({ x, }, { paddingLeft = '0', paddingRight = '0', },) => x.max - x.min - parseFloat(paddingLeft,) - parseFloat(paddingRight,),
  height: ({ y, }, { paddingTop = '0', paddingBottom = '0', },) => y.max - y.min - parseFloat(paddingTop,) - parseFloat(paddingBottom,),
  top: (_bbox, { top, },) => parseFloat(top,),
  left: (_bbox, { left, },) => parseFloat(left,),
  bottom: ({ y, }, { top, },) => parseFloat(top,) + (y.max - y.min),
  right: ({ x, }, { left, },) => parseFloat(left,) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13,),
  y: getTranslateFromMatrix(5, 14,),
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
var convertChangedValueTypes = (target, visualElement, changedKeys,) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element,);
  const { display, } = elementComputedStyle;
  const origin = {};
  if (display === 'none') {
    visualElement.setStaticValue('display', target.display || 'block',);
  }
  changedKeys.forEach((key7,) => {
    origin[key7] = positionalValues[key7](originBbox, elementComputedStyle,);
  },);
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key7,) => {
    const value = visualElement.getValue(key7,);
    value && value.jump(origin[key7],);
    target[key7] = positionalValues[key7](targetBbox, elementComputedStyle,);
  },);
  return target;
};
var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {},) => {
  target = { ...target, };
  transitionEnd = { ...transitionEnd, };
  const targetPositionalKeys = Object.keys(target,).filter(isPositionalKey,);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key7,) => {
    const value = visualElement.getValue(key7,);
    if (!visualElement.hasValue(key7,)) {
      return;
    }
    let from = origin[key7];
    let fromType = findDimensionValueType(from,);
    const to = target[key7];
    let toType;
    if (isKeyframesTarget(to,)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from,);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (to[i] === null) {
          break;
        }
        if (!toType) {
          toType = findDimensionValueType(to[i],);
          invariant(
            toType === fromType || isNumOrPxType(fromType,) && isNumOrPxType(toType,),
            'Keyframes must be of the same dimension as the current value',
          );
        } else {
          invariant(findDimensionValueType(to[i],) === toType, 'All keyframes must be of the same type',);
        }
      }
    } else {
      toType = findDimensionValueType(to,);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType,) && isNumOrPxType(toType,)) {
        const current = value.get();
        if (typeof current === 'string') {
          value.set(parseFloat(current,),);
        }
        if (typeof to === 'string') {
          target[key7] = parseFloat(to,);
        } else if (Array.isArray(to,) && toType === px) {
          target[key7] = to.map(parseFloat,);
        }
      } else if (
        (fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&
        (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)
      ) {
        if (from === 0) {
          value.set(toType.transform(from,),);
        } else {
          target[key7] = fromType.transform(to,);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement,);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key7,);
        transitionEnd[key7] = transitionEnd[key7] !== void 0 ? transitionEnd[key7] : target[key7];
        value.jump(to,);
      }
    }
  },);
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf('height',) >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys,);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key7, value,],) => {
        visualElement.getValue(key7,).set(value,);
      },);
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY, },);
    }
    return { target: convertedTarget, transitionEnd, };
  } else {
    return { target, transitionEnd, };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd,) {
  return hasPositionalKey(target,)
    ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd,)
    : { target, transitionEnd, };
}
var parseDomVariant = (visualElement, target, origin, transitionEnd,) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd,);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd,);
};
var DOMVisualElement = class extends VisualElement {
  sortInstanceNodePosition(a, b,) {
    return a.compareDocumentPosition(b,) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key7,) {
    return props.style ? props.style[key7] : void 0;
  }
  removeValueFromRenderState(key7, { vars, style, },) {
    delete vars[key7];
    delete style[key7];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, isMounted,) {
    const origin = getOrigin(target, transition || {}, this,);
    if (isMounted) {
      checkTargetForNewValues(this, target, origin,);
      const parsed = parseDomVariant(this, target, origin, transitionEnd,);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target,
    };
  }
};
function getComputedStyle2(element,) {
  return window.getComputedStyle(element,);
}
var HTMLVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments,);
    this.type = 'html';
  }
  readValueFromInstance(instance, key7,) {
    if (transformProps.has(key7,)) {
      const defaultType = getDefaultValueType(key7,);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle2(instance,);
      const value = (isCSSVariableName(key7,) ? computedStyle.getPropertyValue(key7,) : computedStyle[key7]) || 0;
      return typeof value === 'string' ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint, },) {
    return measureViewportBox(instance, transformPagePoint,);
  }
  build(renderState, latestValues, options, props,) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate,);
  }
  scrapeMotionValuesFromProps(props, prevProps,) {
    return scrapeMotionValuesFromProps(props, prevProps,);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children, } = this.props;
    if (isMotionValue(children,)) {
      this.childSubscription = children.on('change', (latest,) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      },);
    }
  }
  renderInstance(instance, renderState, styleProp, projection,) {
    renderHTML(instance, renderState, styleProp, projection,);
  }
};
var SVGVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments,);
    this.type = 'svg';
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key7,) {
    return props[key7];
  }
  readValueFromInstance(instance, key7,) {
    if (transformProps.has(key7,)) {
      const defaultType = getDefaultValueType(key7,);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key7 = !camelCaseAttributes.has(key7,) ? camelToDash(key7,) : key7;
    return instance.getAttribute(key7,);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps,) {
    return scrapeMotionValuesFromProps2(props, prevProps,);
  }
  build(renderState, latestValues, options, props,) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate,);
  }
  renderInstance(instance, renderState, styleProp, projection,) {
    renderSVG(instance, renderState, styleProp, projection,);
  }
  mount(instance,) {
    this.isSVGTag = isSVGTag(instance.tagName,);
    super.mount(instance,);
  }
};
var createDomVisualElement = (Component23, options,) => {
  return isSVGComponent(Component23,)
    ? new SVGVisualElement(options, { enableHardwareAcceleration: false, },)
    : new HTMLVisualElement(options, { enableHardwareAcceleration: true, },);
};
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout,
  },
};
var preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout,
};
var motion = /* @__PURE__ */ createMotionProxy((Component23, config,) =>
  createDomMotionConfig(Component23, config, preloadedFeatures, createDomVisualElement,)
);
function createDomMotionComponent(key7,) {
  return createMotionComponent(createDomMotionConfig(key7, { forwardMotionProps: false, }, preloadedFeatures, createDomVisualElement,),);
}
var m = createMotionProxy(createDomMotionConfig,);
function useIsMounted() {
  const isMounted = useRef3(false,);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, [],);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount,] = useState(0,);
  const forceRender = useCallback2(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1,);
  }, [forcedRenderCount,],);
  const deferredForceRender = useCallback2(() => frame.postRender(forceRender,), [forceRender,],);
  return [deferredForceRender, forcedRenderCount,];
}
function useUnmountEffect(callback,) {
  return useEffect4(() => () => callback(), [],);
}
var PopChildMeasure = class extends React2.Component {
  getSnapshotBeforeUpdate(prevProps,) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function PopChild({ children, isPresent: isPresent2, },) {
  const id4 = useId2();
  const ref = useRef4(null,);
  const size2 = useRef4({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
  },);
  useInsertionEffect2(() => {
    const { width, height, top, left, } = size2.current;
    if (isPresent2 || !ref.current || !width || !height) {
      return;
    }
    ref.current.dataset.motionPopId = id4;
    const style = document.createElement('style',);
    document.head.appendChild(style,);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id4}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `,);
    }
    return () => {
      document.head.removeChild(style,);
    };
  }, [isPresent2,],);
  return React2.createElement(
    PopChildMeasure,
    { isPresent: isPresent2, childRef: ref, sizeRef: size2, },
    React2.cloneElement(children, { ref, },),
  );
}
var PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode, },) => {
  const presenceChildren = useConstant(newChildrenMap,);
  const id4 = useId3();
  const context = useMemo5(
    () => ({
      id: id4,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId,) => {
        presenceChildren.set(childId, true,);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete) {
            return;
          }
        }
        onExitComplete && onExitComplete();
      },
      register: (childId,) => {
        presenceChildren.set(childId, false,);
        return () => presenceChildren.delete(childId,);
      },
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2,],
  );
  useMemo5(() => {
    presenceChildren.forEach((_, key7,) => presenceChildren.set(key7, false,));
  }, [isPresent2,],);
  React3.useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2,],);
  if (mode === 'popLayout') {
    children = React3.createElement(PopChild, { isPresent: isPresent2, }, children,);
  }
  return React3.createElement(PresenceContext.Provider, { value: context, }, children,);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
var getChildKey = (child,) => child.key || '';
function updateChildLookup(children, allChildren,) {
  children.forEach((child,) => {
    const key7 = getChildKey(child,);
    allChildren.set(key7, child,);
  },);
}
function onlyElements(children,) {
  const filtered = [];
  Children.forEach(children, (child,) => {
    if (isValidElement(child,)) {
      filtered.push(child,);
    }
  },);
  return filtered;
}
var AnimatePresence = (
  { children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = 'sync', },
) => {
  invariant(!exitBeforeEnter, 'Replace exitBeforeEnter with mode=\'wait\'',);
  const forceRender = useContext7(LayoutGroupContext,).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children,);
  let childrenToRender = filteredChildren;
  const exitingChildren = useRef5(/* @__PURE__ */ new Map(),).current;
  const presentChildren = useRef5(childrenToRender,);
  const allChildren = useRef5(/* @__PURE__ */ new Map(),).current;
  const isInitialRender = useRef5(true,);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren,);
    presentChildren.current = childrenToRender;
  },);
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  },);
  if (isInitialRender.current) {
    return React4.createElement(
      React4.Fragment,
      null,
      childrenToRender.map((child,) =>
        React4.createElement(PresenceChild, {
          key: getChildKey(child,),
          isPresent: true,
          initial: initial ? void 0 : false,
          presenceAffectsLayout,
          mode,
        }, child,)
      ),
    );
  }
  childrenToRender = [...childrenToRender,];
  const presentKeys = presentChildren.current.map(getChildKey,);
  const targetKeys = filteredChildren.map(getChildKey,);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key7 = presentKeys[i];
    if (targetKeys.indexOf(key7,) === -1 && !exitingChildren.has(key7,)) {
      exitingChildren.set(key7, void 0,);
    }
  }
  if (mode === 'wait' && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key7,) => {
    if (targetKeys.indexOf(key7,) !== -1) {
      return;
    }
    const child = allChildren.get(key7,);
    if (!child) {
      return;
    }
    const insertionIndex = presentKeys.indexOf(key7,);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        exitingChildren.delete(key7,);
        const leftOverKeys = Array.from(allChildren.keys(),).filter((childKey,) => !targetKeys.includes(childKey,));
        leftOverKeys.forEach((leftOverKey,) => allChildren.delete(leftOverKey,));
        presentChildren.current = filteredChildren.filter((presentChild,) => {
          const presentChildKey = getChildKey(presentChild,);
          return (
            // filter out the node exiting
            presentChildKey === key7 || // filter out the leftover children
            leftOverKeys.includes(presentChildKey,)
          );
        },);
        if (!exitingChildren.size) {
          if (isMounted.current === false) {
            return;
          }
          forceRender();
          onExitComplete && onExitComplete();
        }
      };
      exitingComponent = React4.createElement(PresenceChild, {
        key: getChildKey(child,),
        isPresent: false,
        onExitComplete: onExit,
        custom,
        presenceAffectsLayout,
        mode,
      }, child,);
      exitingChildren.set(key7, exitingComponent,);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent,);
  },);
  childrenToRender = childrenToRender.map((child,) => {
    const key7 = child.key;
    return exitingChildren.has(key7,)
      ? child
      : React4.createElement(PresenceChild, { key: getChildKey(child,), isPresent: true, presenceAffectsLayout, mode, }, child,);
  },);
  if (false) {
    console.warn(
      `You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`,
    );
  }
  return React4.createElement(
    React4.Fragment,
    null,
    exitingChildren.size ? childrenToRender : childrenToRender.map((child,) => cloneElement2(child,)),
  );
};
function MotionConfig({ children, isValidProp, ...config },) {
  isValidProp && loadExternalIsValidProp(isValidProp,);
  config = { ...useContext8(MotionConfigContext,), ...config, };
  config.isStatic = useConstant(() => config.isStatic);
  const context = useMemo6(() => config, [JSON.stringify(config.transition,), config.transformPagePoint, config.reducedMotion,],);
  return React5.createElement(MotionConfigContext.Provider, { value: context, }, children,);
}
function LazyMotion({ children, features, strict = false, },) {
  const [, setIsLoaded,] = useState2(!isLazyBundle(features,),);
  const loadedRenderer = useRef6(void 0,);
  if (!isLazyBundle(features,)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures,);
  }
  useEffect6(() => {
    if (isLazyBundle(features,)) {
      features().then(({ renderer, ...loadedFeatures },) => {
        loadFeatures(loadedFeatures,);
        loadedRenderer.current = renderer;
        setIsLoaded(true,);
      },);
    }
  }, [],);
  return React6.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict, }, }, children,);
}
function isLazyBundle(features,) {
  return typeof features === 'function';
}
var DeprecatedLayoutGroupContext = createContext7(null,);
var notify = (node,) => !node.isLayoutDirty && node.willUpdate(false,);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new WeakMap();
  const dirtyAll = () => nodes.forEach(notify,);
  return {
    add: (node,) => {
      nodes.add(node,);
      subscriptions.set(node, node.addEventListener('willUpdate', dirtyAll,),);
    },
    remove: (node,) => {
      nodes.delete(node,);
      const unsubscribe = subscriptions.get(node,);
      if (unsubscribe) {
        unsubscribe();
        subscriptions.delete(node,);
      }
      dirtyAll();
    },
    dirty: dirtyAll,
  };
}
var shouldInheritGroup = (inherit,) => inherit === true;
var shouldInheritId = (inherit,) => shouldInheritGroup(inherit === true,) || inherit === 'id';
var LayoutGroup = ({ children, id: id4, inherit = true, },) => {
  const layoutGroupContext = useContext9(LayoutGroupContext,);
  const deprecatedLayoutGroupContext = useContext9(DeprecatedLayoutGroupContext,);
  const [forceRender, key7,] = useForceUpdate();
  const context = useRef7(null,);
  const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  if (context.current === null) {
    if (shouldInheritId(inherit,) && upstreamId) {
      id4 = id4 ? upstreamId + '-' + id4 : upstreamId;
    }
    context.current = {
      id: id4,
      group: shouldInheritGroup(inherit,) ? layoutGroupContext.group || nodeGroup() : nodeGroup(),
    };
  }
  const memoizedContext = useMemo7(() => ({ ...context.current, forceRender, }), [key7,],);
  return React7.createElement(LayoutGroupContext.Provider, { value: memoizedContext, }, children,);
};
function useMotionValue(initial,) {
  const value = useConstant(() => motionValue(initial,));
  const { isStatic, } = useContext10(MotionConfigContext,);
  if (isStatic) {
    const [, setLatest,] = useState3(initial,);
    useEffect7(() => value.on('change', setLatest,), [],);
  }
  return value;
}
var isCustomValueType = (v,) => {
  return v && typeof v === 'object' && v.mix;
};
var getMixer2 = (v,) => isCustomValueType(v,) ? v.mix : void 0;
function transform(...args) {
  const useImmediate = !Array.isArray(args[0],);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, {
    mixer: getMixer2(outputRange[0],),
    ...options,
  },);
  return useImmediate ? interpolator(inputValue,) : interpolator;
}
function useCombineMotionValues(values, combineValues,) {
  const value = useMotionValue(combineValues(),);
  const updateValue = () => value.set(combineValues(),);
  updateValue();
  useIsomorphicLayoutEffect(() => {
    const scheduleUpdate = () => frame.update(updateValue, false, true,);
    const subscriptions = values.map((v,) => v.on('change', scheduleUpdate,));
    return () => {
      subscriptions.forEach((unsubscribe,) => unsubscribe());
      cancelFrame(updateValue,);
    };
  },);
  return value;
}
function useComputed(compute,) {
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute,);
  collectMotionValues.current = void 0;
  return value;
}
function useTransform(input, inputRangeOrTransformer, outputRange, options,) {
  if (typeof input === 'function') {
    return useComputed(input,);
  }
  const transformer = typeof inputRangeOrTransformer === 'function'
    ? inputRangeOrTransformer
    : transform(inputRangeOrTransformer, outputRange, options,);
  return Array.isArray(input,) ? useListTransform(input, transformer,) : useListTransform([input,], ([latest,],) => transformer(latest,),);
}
function useListTransform(values, transformer,) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values, () => {
    latest.length = 0;
    const numValues = values.length;
    for (let i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest,);
  },);
}
var ReorderContext = createContext8(null,);
function checkReorder(order, value, offset, velocity,) {
  if (!velocity) {
    return order;
  }
  const index = order.findIndex((item2,) => item2.value === value);
  if (index === -1) {
    return order;
  }
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem = order[index + nextOffset];
  if (!nextItem) {
    return order;
  }
  const item = order[index];
  const nextLayout = nextItem.layout;
  const nextItemCenter = mixNumber(nextLayout.min, nextLayout.max, 0.5,);
  if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
    return moveItem(order, index, index + nextOffset,);
  }
  return order;
}
function ReorderGroup({ children, as = 'ul', axis = 'y', onReorder, values, ...props }, externalRef,) {
  const Component23 = useConstant(() => motion(as,));
  const order = [];
  const isReordering = useRef8(false,);
  invariant(Boolean(values,), 'Reorder.Group must be provided a values prop',);
  const context = {
    axis,
    registerItem: (value, layout2,) => {
      const idx = order.findIndex((entry,) => value === entry.value);
      if (idx !== -1) {
        order[idx].layout = layout2[axis];
      } else {
        order.push({ value, layout: layout2[axis], },);
      }
      order.sort(compareMin,);
    },
    updateOrder: (item, offset, velocity,) => {
      if (isReordering.current) {
        return;
      }
      const newOrder = checkReorder(order, item, offset, velocity,);
      if (order !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue,).filter((value,) => values.indexOf(value,) !== -1),);
      }
    },
  };
  useEffect8(() => {
    isReordering.current = false;
  },);
  return React8.createElement(
    Component23,
    { ...props, ref: externalRef, ignoreStrict: true, },
    React8.createElement(ReorderContext.Provider, { value: context, }, children,),
  );
}
var Group = forwardRef2(ReorderGroup,);
function getValue(item,) {
  return item.value;
}
function compareMin(a, b,) {
  return a.layout.min - b.layout.min;
}
function useDefaultMotionValue(value, defaultValue = 0,) {
  return isMotionValue(value,) ? value : useMotionValue(defaultValue,);
}
function ReorderItem({ children, style = {}, value, as = 'li', onDrag, layout: layout2 = true, ...props }, externalRef,) {
  const Component23 = useConstant(() => motion(as,));
  const context = useContext11(ReorderContext,);
  const point2 = {
    x: useDefaultMotionValue(style.x,),
    y: useDefaultMotionValue(style.y,),
  };
  const zIndex = useTransform([point2.x, point2.y,], ([latestX, latestY,],) => latestX || latestY ? 1 : 'unset',);
  invariant(Boolean(context,), 'Reorder.Item must be a child of Reorder.Group',);
  const { axis, registerItem, updateOrder, } = context;
  return React9.createElement(Component23, {
    drag: axis,
    ...props,
    dragSnapToOrigin: true,
    style: { ...style, x: point2.x, y: point2.y, zIndex, },
    layout: layout2,
    onDrag: (event, gesturePoint,) => {
      const { velocity, } = gesturePoint;
      velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis],);
      onDrag && onDrag(event, gesturePoint,);
    },
    onLayoutMeasure: (measured,) => registerItem(value, measured,),
    ref: externalRef,
    ignoreStrict: true,
  }, children,);
}
var Item = forwardRef3(ReorderItem,);
var Reorder = {
  Group,
  Item,
};
var domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations,
};
var domMax = {
  ...domAnimation,
  ...drag,
  ...layout,
};
function useMotionTemplate(fragments, ...values) {
  const numFragments = fragments.length;
  function buildValue() {
    let output = ``;
    for (let i = 0; i < numFragments; i++) {
      output += fragments[i];
      const value = values[i];
      if (value) {
        output += isMotionValue(value,) ? value.get() : value;
      }
    }
    return output;
  }
  return useCombineMotionValues(values.filter(isMotionValue,), buildValue,);
}
function useSpring(source, config = {},) {
  const { isStatic, } = useContext12(MotionConfigContext,);
  const activeSpringAnimation = useRef9(null,);
  const value = useMotionValue(isMotionValue(source,) ? source.get() : source,);
  const stopAnimation2 = () => {
    if (activeSpringAnimation.current) {
      activeSpringAnimation.current.stop();
    }
  };
  useInsertionEffect3(() => {
    return value.attach((v, set,) => {
      if (isStatic) {
        return set(v,);
      }
      const animation = activeSpringAnimation.current;
      if (animation && animation.time === 0) {
        animation.sample(frameData.delta,);
      }
      stopAnimation2();
      activeSpringAnimation.current = animateValue({
        keyframes: [value.get(), v,],
        velocity: value.getVelocity(),
        type: 'spring',
        restDelta: 1e-3,
        restSpeed: 0.01,
        ...config,
        onUpdate: set,
      },);
      return value.get();
    }, stopAnimation2,);
  }, [JSON.stringify(config,),],);
  useIsomorphicLayoutEffect(() => {
    if (isMotionValue(source,)) {
      return source.on('change', (v,) => value.set(parseFloat(v,),),);
    }
  }, [value,],);
  return value;
}
function useMotionValueEvent(value, event, callback,) {
  useInsertionEffect4(() => value.on(event, callback,), [value, event, callback,],);
}
function useVelocity(value,) {
  const velocity = useMotionValue(value.getVelocity(),);
  const updateVelocity = () => {
    const latest = value.getVelocity();
    velocity.set(latest,);
    if (latest) {
      frame.update(updateVelocity,);
    }
  };
  useMotionValueEvent(value, 'change', () => {
    frame.update(updateVelocity, false, true,);
  },);
  return velocity;
}
function resolveElements(elements, scope, selectorCache,) {
  var _a;
  if (typeof elements === 'string') {
    let root = document;
    if (scope) {
      invariant(Boolean(scope.current,), 'Scope provided, but no element detected.',);
      root = scope.current;
    }
    if (selectorCache) {
      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements,);
      elements = selectorCache[elements];
    } else {
      elements = root.querySelectorAll(elements,);
    }
  } else if (elements instanceof Element) {
    elements = [elements,];
  }
  return Array.from(elements || [],);
}
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var observer;
function getElementSize(target, borderBoxSize,) {
  if (borderBoxSize) {
    const { inlineSize, blockSize, } = borderBoxSize[0];
    return { width: inlineSize, height: blockSize, };
  } else if (target instanceof SVGElement && 'getBBox' in target) {
    return target.getBBox();
  } else {
    return {
      width: target.offsetWidth,
      height: target.offsetHeight,
    };
  }
}
function notifyTarget({ target, contentRect, borderBoxSize, },) {
  var _a;
  (_a = resizeHandlers.get(target,)) === null || _a === void 0 ? void 0 : _a.forEach((handler,) => {
    handler({
      target,
      contentSize: contentRect,
      get size() {
        return getElementSize(target, borderBoxSize,);
      },
    },);
  },);
}
function notifyAll(entries,) {
  entries.forEach(notifyTarget,);
}
function createResizeObserver() {
  if (typeof ResizeObserver === 'undefined') {
    return;
  }
  observer = new ResizeObserver(notifyAll,);
}
function resizeElement(target, handler,) {
  if (!observer) {
    createResizeObserver();
  }
  const elements = resolveElements(target,);
  elements.forEach((element,) => {
    let elementHandlers = resizeHandlers.get(element,);
    if (!elementHandlers) {
      elementHandlers = /* @__PURE__ */ new Set();
      resizeHandlers.set(element, elementHandlers,);
    }
    elementHandlers.add(handler,);
    observer === null || observer === void 0 ? void 0 : observer.observe(element,);
  },);
  return () => {
    elements.forEach((element,) => {
      const elementHandlers = resizeHandlers.get(element,);
      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler,);
      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
        observer === null || observer === void 0 ? void 0 : observer.unobserve(element,);
      }
    },);
  };
}
var windowCallbacks = /* @__PURE__ */ new Set();
var windowResizeHandler;
function createWindowResizeHandler() {
  windowResizeHandler = () => {
    const size2 = {
      width: window.innerWidth,
      height: window.innerHeight,
    };
    const info = {
      target: window,
      size: size2,
      contentSize: size2,
    };
    windowCallbacks.forEach((callback,) => callback(info,));
  };
  window.addEventListener('resize', windowResizeHandler,);
}
function resizeWindow(callback,) {
  windowCallbacks.add(callback,);
  if (!windowResizeHandler) {
    createWindowResizeHandler();
  }
  return () => {
    windowCallbacks.delete(callback,);
    if (!windowCallbacks.size && windowResizeHandler) {
      windowResizeHandler = void 0;
    }
  };
}
function resize(a, b,) {
  return typeof a === 'function' ? resizeWindow(a,) : resizeElement(a, b,);
}
var maxElapsed2 = 50;
var createAxisInfo = () => ({
  current: 0,
  offset: [],
  progress: 0,
  scrollLength: 0,
  targetOffset: 0,
  targetLength: 0,
  containerLength: 0,
  velocity: 0,
});
var createScrollInfo = () => ({
  time: 0,
  x: createAxisInfo(),
  y: createAxisInfo(),
});
var keys = {
  x: {
    length: 'Width',
    position: 'Left',
  },
  y: {
    length: 'Height',
    position: 'Top',
  },
};
function updateAxisInfo(element, axisName, info, time22,) {
  const axis = info[axisName];
  const { length, position, } = keys[axisName];
  const prev = axis.current;
  const prevTime = info.time;
  axis.current = element['scroll' + position];
  axis.scrollLength = element['scroll' + length] - element['client' + length];
  axis.offset.length = 0;
  axis.offset[0] = 0;
  axis.offset[1] = axis.scrollLength;
  axis.progress = progress(0, axis.scrollLength, axis.current,);
  const elapsed = time22 - prevTime;
  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond(axis.current - prev, elapsed,);
}
function updateScrollInfo(element, info, time22,) {
  updateAxisInfo(element, 'x', info, time22,);
  updateAxisInfo(element, 'y', info, time22,);
  info.time = time22;
}
function calcInset(element, container,) {
  const inset2 = { x: 0, y: 0, };
  let current = element;
  while (current && current !== container) {
    if (current instanceof HTMLElement) {
      inset2.x += current.offsetLeft;
      inset2.y += current.offsetTop;
      current = current.offsetParent;
    } else if (current.tagName === 'svg') {
      const svgBoundingBox = current.getBoundingClientRect();
      current = current.parentElement;
      const parentBoundingBox = current.getBoundingClientRect();
      inset2.x += svgBoundingBox.left - parentBoundingBox.left;
      inset2.y += svgBoundingBox.top - parentBoundingBox.top;
    } else if (current instanceof SVGGraphicsElement) {
      const { x, y, } = current.getBBox();
      inset2.x += x;
      inset2.y += y;
      let svg = null;
      let parent = current.parentNode;
      while (!svg) {
        if (parent.tagName === 'svg') {
          svg = parent;
        }
        parent = current.parentNode;
      }
      current = svg;
    } else {
      break;
    }
  }
  return inset2;
}
var ScrollOffset = {
  Enter: [
    [0, 1,],
    [1, 1,],
  ],
  Exit: [
    [0, 0,],
    [1, 0,],
  ],
  Any: [
    [1, 0,],
    [0, 1,],
  ],
  All: [
    [0, 0,],
    [1, 1,],
  ],
};
var namedEdges = {
  start: 0,
  center: 0.5,
  end: 1,
};
function resolveEdge(edge, length, inset2 = 0,) {
  let delta = 0;
  if (namedEdges[edge] !== void 0) {
    edge = namedEdges[edge];
  }
  if (typeof edge === 'string') {
    const asNumber2 = parseFloat(edge,);
    if (edge.endsWith('px',)) {
      delta = asNumber2;
    } else if (edge.endsWith('%',)) {
      edge = asNumber2 / 100;
    } else if (edge.endsWith('vw',)) {
      delta = asNumber2 / 100 * document.documentElement.clientWidth;
    } else if (edge.endsWith('vh',)) {
      delta = asNumber2 / 100 * document.documentElement.clientHeight;
    } else {
      edge = asNumber2;
    }
  }
  if (typeof edge === 'number') {
    delta = length * edge;
  }
  return inset2 + delta;
}
var defaultOffset2 = [0, 0,];
function resolveOffset(offset, containerLength, targetLength, targetInset,) {
  let offsetDefinition = Array.isArray(offset,) ? offset : defaultOffset2;
  let targetPoint = 0;
  let containerPoint = 0;
  if (typeof offset === 'number') {
    offsetDefinition = [offset, offset,];
  } else if (typeof offset === 'string') {
    offset = offset.trim();
    if (offset.includes(' ',)) {
      offsetDefinition = offset.split(' ',);
    } else {
      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`,];
    }
  }
  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset,);
  containerPoint = resolveEdge(offsetDefinition[1], containerLength,);
  return targetPoint - containerPoint;
}
var point = { x: 0, y: 0, };
function getTargetSize(target,) {
  return 'getBBox' in target && target.tagName !== 'svg' ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight, };
}
function resolveOffsets(container, info, options,) {
  let { offset: offsetDefinition = ScrollOffset.All, } = options;
  const { target = container, axis = 'y', } = options;
  const lengthLabel = axis === 'y' ? 'height' : 'width';
  const inset2 = target !== container ? calcInset(target, container,) : point;
  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight, } : getTargetSize(target,);
  const containerSize = {
    width: container.clientWidth,
    height: container.clientHeight,
  };
  info[axis].offset.length = 0;
  let hasChanged = !info[axis].interpolate;
  const numOffsets = offsetDefinition.length;
  for (let i = 0; i < numOffsets; i++) {
    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset2[axis],);
    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
      hasChanged = true;
    }
    info[axis].offset[i] = offset;
  }
  if (hasChanged) {
    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition,),);
    info[axis].interpolatorOffsets = [...info[axis].offset,];
  }
  info[axis].progress = info[axis].interpolate(info[axis].current,);
}
function measure(container, target = container, info,) {
  info.x.targetOffset = 0;
  info.y.targetOffset = 0;
  if (target !== container) {
    let node = target;
    while (node && node !== container) {
      info.x.targetOffset += node.offsetLeft;
      info.y.targetOffset += node.offsetTop;
      node = node.offsetParent;
    }
  }
  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
  info.x.containerLength = container.clientWidth;
  info.y.containerLength = container.clientHeight;
  if (false) {
    if (container && target && target !== container) {
      warnOnce(
        getComputedStyle(container,).position !== 'static',
        'Please ensure that the container has a non-static position, like \'relative\', \'fixed\', or \'absolute\' to ensure scroll offset is calculated correctly.',
      );
    }
  }
}
function createOnScrollHandler(element, onScroll, info, options = {},) {
  return {
    measure: () => measure(element, options.target, info,),
    update: (time22,) => {
      updateScrollInfo(element, info, time22,);
      if (options.offset || options.target) {
        resolveOffsets(element, info, options,);
      }
    },
    notify: () => onScroll(info,),
  };
}
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getEventTarget = (element,) => element === document.documentElement ? window : element;
function scrollInfo(onScroll, { container = document.documentElement, ...options } = {},) {
  let containerHandlers = onScrollHandlers.get(container,);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers,);
  }
  const info = createScrollInfo();
  const containerHandler = createOnScrollHandler(container, onScroll, info, options,);
  containerHandlers.add(containerHandler,);
  if (!scrollListeners.has(container,)) {
    const measureAll = () => {
      for (const handler of containerHandlers) {
        handler.measure();
      }
    };
    const updateAll = () => {
      for (const handler of containerHandlers) {
        handler.update(frameData.timestamp,);
      }
    };
    const notifyAll2 = () => {
      for (const handler of containerHandlers) {
        handler.notify();
      }
    };
    const listener2 = () => {
      frame.read(measureAll, false, true,);
      frame.read(updateAll, false, true,);
      frame.update(notifyAll2, false, true,);
    };
    scrollListeners.set(container, listener2,);
    const target = getEventTarget(container,);
    window.addEventListener('resize', listener2, { passive: true, },);
    if (container !== document.documentElement) {
      resizeListeners.set(container, resize(container, listener2,),);
    }
    target.addEventListener('scroll', listener2, { passive: true, },);
  }
  const listener = scrollListeners.get(container,);
  frame.read(listener, false, true,);
  return () => {
    var _a;
    cancelFrame(listener,);
    const currentHandlers = onScrollHandlers.get(container,);
    if (!currentHandlers) {
      return;
    }
    currentHandlers.delete(containerHandler,);
    if (currentHandlers.size) {
      return;
    }
    const scrollListener = scrollListeners.get(container,);
    scrollListeners.delete(container,);
    if (scrollListener) {
      getEventTarget(container,).removeEventListener('scroll', scrollListener,);
      (_a = resizeListeners.get(container,)) === null || _a === void 0 ? void 0 : _a();
      window.removeEventListener('resize', scrollListener,);
    }
  };
}
function refWarning(name, ref,) {
  warning(
    Boolean(!ref || ref.current,),
    `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`,
  );
}
var createScrollMotionValues = () => ({
  scrollX: motionValue(0,),
  scrollY: motionValue(0,),
  scrollXProgress: motionValue(0,),
  scrollYProgress: motionValue(0,),
});
function useScroll({ container, target, layoutEffect = true, ...options } = {},) {
  const values = useConstant(createScrollMotionValues,);
  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : useEffect9;
  useLifecycleEffect(() => {
    refWarning('target', target,);
    refWarning('container', container,);
    return scrollInfo(({ x, y, },) => {
      values.scrollX.set(x.current,);
      values.scrollXProgress.set(x.progress,);
      values.scrollY.set(y.current,);
      values.scrollYProgress.set(y.progress,);
    }, {
      ...options,
      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,
      target: (target === null || target === void 0 ? void 0 : target.current) || void 0,
    },);
  }, [container, target, JSON.stringify(options.offset,),],);
  return values;
}
function useElementScroll(ref,) {
  if (false) {
    warnOnce(false, 'useElementScroll is deprecated. Convert to useScroll({ container: ref }).',);
  }
  return useScroll({ container: ref, },);
}
function useViewportScroll() {
  if (false) {
    warnOnce(false, 'useViewportScroll is deprecated. Convert to useScroll().',);
  }
  return useScroll();
}
function useAnimationFrame(callback,) {
  const initialTimestamp = useRef10(0,);
  const { isStatic, } = useContext13(MotionConfigContext,);
  useEffect10(() => {
    if (isStatic) {
      return;
    }
    const provideTimeSinceStart = ({ timestamp, delta, },) => {
      if (!initialTimestamp.current) {
        initialTimestamp.current = timestamp;
      }
      callback(timestamp - initialTimestamp.current, delta,);
    };
    frame.update(provideTimeSinceStart, true,);
    return () => cancelFrame(provideTimeSinceStart,);
  }, [callback,],);
}
function useTime() {
  const time22 = useMotionValue(0,);
  useAnimationFrame((t,) => time22.set(t,));
  return time22;
}
var WillChangeMotionValue = class extends MotionValue {
  constructor() {
    super(...arguments,);
    this.members = [];
    this.transforms = /* @__PURE__ */ new Set();
  }
  add(name,) {
    let memberName;
    if (transformProps.has(name,)) {
      this.transforms.add(name,);
      memberName = 'transform';
    } else if (!name.startsWith('origin',) && !isCSSVariableName(name,) && name !== 'willChange') {
      memberName = camelToDash(name,);
    }
    if (memberName) {
      addUniqueItem(this.members, memberName,);
      this.update();
    }
  }
  remove(name,) {
    if (transformProps.has(name,)) {
      this.transforms.delete(name,);
      if (!this.transforms.size) {
        removeItem(this.members, 'transform',);
      }
    } else {
      removeItem(this.members, camelToDash(name,),);
    }
    this.update();
  }
  update() {
    this.set(this.members.length ? this.members.join(', ',) : 'auto',);
  }
};
function useWillChange() {
  return useConstant(() => new WillChangeMotionValue('auto',));
}
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion,] = useState4(prefersReducedMotion.current,);
  if (false) {
    warnOnce(shouldReduceMotion !== true, 'You have Reduced Motion enabled on your device. Animations may not appear as expected.',);
  }
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion();
  const { reducedMotion, } = useContext14(MotionConfigContext,);
  if (reducedMotion === 'never') {
    return false;
  } else if (reducedMotion === 'always') {
    return true;
  } else {
    return reducedMotionPreference;
  }
}
function stopAnimation(visualElement,) {
  visualElement.values.forEach((value,) => value.stop());
}
function animationControls() {
  let hasMounted = false;
  const subscribers = /* @__PURE__ */ new Set();
  const controls = {
    subscribe(visualElement,) {
      subscribers.add(visualElement,);
      return () => void subscribers.delete(visualElement,);
    },
    start(definition, transitionOverride,) {
      invariant(
        hasMounted,
        'controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.',
      );
      const animations2 = [];
      subscribers.forEach((visualElement,) => {
        animations2.push(animateVisualElement(visualElement, definition, {
          transitionOverride,
        },),);
      },);
      return Promise.all(animations2,);
    },
    set(definition,) {
      invariant(
        hasMounted,
        'controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.',
      );
      return subscribers.forEach((visualElement,) => {
        setValues(visualElement, definition,);
      },);
    },
    stop() {
      subscribers.forEach((visualElement,) => {
        stopAnimation(visualElement,);
      },);
    },
    mount() {
      hasMounted = true;
      return () => {
        hasMounted = false;
        controls.stop();
      };
    },
  };
  return controls;
}
var wrap = (min, max, v,) => {
  const rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};
function observeTimeline(update, timeline,) {
  let prevProgress;
  const onFrame = () => {
    const { currentTime, } = timeline;
    const percentage = currentTime === null ? 0 : currentTime.value;
    const progress2 = percentage / 100;
    if (prevProgress !== progress2) {
      update(progress2,);
    }
    prevProgress = progress2;
  };
  frame.update(onFrame, true,);
  return () => cancelFrame(onFrame,);
}
var supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
var GroupPlaybackControls = class {
  constructor(animations2,) {
    this.animations = animations2.filter(Boolean,);
  }
  then(onResolve, onReject,) {
    return Promise.all(this.animations,).then(onResolve,).catch(onReject,);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName,) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue,) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline,) {
    const cancelAll = this.animations.map((animation,) => {
      if (supportsScrollTimeline() && animation.attachTimeline) {
        animation.attachTimeline(timeline,);
      } else {
        animation.pause();
        return observeTimeline((progress2,) => {
          animation.time = animation.duration * progress2;
        }, timeline,);
      }
    },);
    return () => {
      cancelAll.forEach((cancelTimeline, i,) => {
        if (cancelTimeline) {
          cancelTimeline();
        }
        this.animations[i].stop();
      },);
    };
  }
  get time() {
    return this.getAll('time',);
  }
  set time(time22,) {
    this.setAll('time', time22,);
  }
  get speed() {
    return this.getAll('speed',);
  }
  set speed(speed,) {
    this.setAll('speed', speed,);
  }
  get duration() {
    let max = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max = Math.max(max, this.animations[i].duration,);
    }
    return max;
  }
  runAll(methodName,) {
    this.animations.forEach((controls,) => controls[methodName]());
  }
  play() {
    this.runAll('play',);
  }
  pause() {
    this.runAll('pause',);
  }
  stop() {
    this.runAll('stop',);
  }
  cancel() {
    this.runAll('cancel',);
  }
  complete() {
    this.runAll('complete',);
  }
};
function isDOMKeyframes(keyframes2,) {
  return typeof keyframes2 === 'object' && !Array.isArray(keyframes2,);
}
function createVisualElement(element,) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {},
      },
      latestValues: {},
    },
  };
  const node = isSVGElement(element,)
    ? new SVGVisualElement(options, {
      enableHardwareAcceleration: false,
    },)
    : new HTMLVisualElement(options, {
      enableHardwareAcceleration: true,
    },);
  node.mount(element,);
  visualElementStore.set(element, node,);
}
function createGeneratorEasing(options, scale2 = 100,) {
  const generator = spring({ keyframes: [0, scale2,], ...options, },);
  const duration = Math.min(calcGeneratorDuration(generator,), maxGeneratorDuration,);
  return {
    type: 'keyframes',
    ease: (progress2,) => generator.next(duration * progress2,).value / scale2,
    duration: millisecondsToSeconds(duration,),
  };
}
function calcNextTime(current, next, prev, labels,) {
  var _a;
  if (typeof next === 'number') {
    return next;
  } else if (next.startsWith('-',) || next.startsWith('+',)) {
    return Math.max(0, current + parseFloat(next,),);
  } else if (next === '<') {
    return prev;
  } else {
    return (_a = labels.get(next,)) !== null && _a !== void 0 ? _a : current;
  }
}
function getEasingForSegment(easing, i,) {
  return isEasingArray(easing,) ? easing[wrap(0, easing.length, i,)] : easing;
}
function eraseKeyframes(sequence2, startTime, endTime,) {
  for (let i = 0; i < sequence2.length; i++) {
    const keyframe = sequence2[i];
    if (keyframe.at > startTime && keyframe.at < endTime) {
      removeItem(sequence2, keyframe,);
      i--;
    }
  }
}
function addKeyframes(sequence2, keyframes2, easing, offset, startTime, endTime,) {
  eraseKeyframes(sequence2, startTime, endTime,);
  for (let i = 0; i < keyframes2.length; i++) {
    sequence2.push({
      value: keyframes2[i],
      at: mixNumber(startTime, endTime, offset[i],),
      easing: getEasingForSegment(easing, i,),
    },);
  }
}
function compareByTime(a, b,) {
  if (a.at === b.at) {
    if (a.value === null) {
      return 1;
    }
    if (b.value === null) {
      return -1;
    }
    return 0;
  } else {
    return a.at - b.at;
  }
}
var defaultSegmentEasing = 'easeInOut';
function createAnimationsFromSequence(sequence2, { defaultTransition = {}, ...sequenceTransition } = {}, scope,) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = /* @__PURE__ */ new Map();
  const sequences = /* @__PURE__ */ new Map();
  const elementCache = {};
  const timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  for (let i = 0; i < sequence2.length; i++) {
    const segment = sequence2[i];
    if (typeof segment === 'string') {
      timeLabels.set(segment, currentTime,);
      continue;
    } else if (!Array.isArray(segment,)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels,),);
      continue;
    }
    let [subject, keyframes2, transition = {},] = segment;
    if (transition.at !== void 0) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels,);
    }
    let maxDuration32 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0,) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes,);
      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList,), type = 'keyframes', ...remainingTransition } =
        valueTransition;
      let { ease: ease2 = defaultTransition.ease || 'easeOut', duration, } = valueTransition;
      const calculatedDelay = typeof delay2 === 'function' ? delay2(elementIndex, numElements,) : delay2;
      const numKeyframes = valueKeyframesAsList.length;
      if (numKeyframes <= 2 && type === 'spring') {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList,)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta,);
        }
        const springTransition = { ...remainingTransition, };
        if (duration !== void 0) {
          springTransition.duration = secondsToMilliseconds(duration,);
        }
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta,);
        ease2 = springEasing.ease;
        duration = springEasing.duration;
      }
      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
      const startTime = currentTime + calculatedDelay;
      const targetTime = startTime + duration;
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder,);
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null,);
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime,);
      maxDuration32 = Math.max(calculatedDelay + duration, maxDuration32,);
      totalDuration = Math.max(targetTime, totalDuration,);
    };
    if (isMotionValue(subject,)) {
      const subjectSequence = getSubjectSequence(subject, sequences,);
      resolveValueSequence(keyframes2, transition, getValueSequence('default', subjectSequence,),);
    } else {
      const elements = resolveElements(subject, scope, elementCache,);
      const numElements = elements.length;
      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
        keyframes2 = keyframes2;
        transition = transition;
        const element = elements[elementIndex];
        const subjectSequence = getSubjectSequence(element, sequences,);
        for (const key7 in keyframes2) {
          resolveValueSequence(
            keyframes2[key7],
            getValueTransition2(transition, key7,),
            getValueSequence(key7, subjectSequence,),
            elementIndex,
            numElements,
          );
        }
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration32;
  }
  sequences.forEach((valueSequences, element,) => {
    for (const key7 in valueSequences) {
      const valueSequence = valueSequences[key7];
      valueSequence.sort(compareByTime,);
      const keyframes2 = [];
      const valueOffset = [];
      const valueEasing = [];
      for (let i = 0; i < valueSequence.length; i++) {
        const { at, value, easing, } = valueSequence[i];
        keyframes2.push(value,);
        valueOffset.push(progress(0, totalDuration, at,),);
        valueEasing.push(easing || 'easeOut',);
      }
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0,);
        keyframes2.unshift(keyframes2[0],);
        valueEasing.unshift(defaultSegmentEasing,);
      }
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1,);
        keyframes2.push(null,);
      }
      if (!animationDefinitions.has(element,)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {},
        },);
      }
      const definition = animationDefinitions.get(element,);
      definition.keyframes[key7] = keyframes2;
      definition.transition[key7] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition,
      };
    }
  },);
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences,) {
  !sequences.has(subject,) && sequences.set(subject, {},);
  return sequences.get(subject,);
}
function getValueSequence(name, sequences,) {
  if (!sequences[name]) {
    sequences[name] = [];
  }
  return sequences[name];
}
function keyframesAsList(keyframes2,) {
  return Array.isArray(keyframes2,) ? keyframes2 : [keyframes2,];
}
function getValueTransition2(transition, key7,) {
  return transition[key7] ? { ...transition, ...transition[key7], } : { ...transition, };
}
var isNumber = (keyframe,) => typeof keyframe === 'number';
var isNumberKeyframesArray = (keyframes2,) => keyframes2.every(isNumber,);
function animateElements(elementOrSelector, keyframes2, options, scope,) {
  const elements = resolveElements(elementOrSelector, scope,);
  const numElements = elements.length;
  invariant(Boolean(numElements,), 'No valid element provided.',);
  const animations2 = [];
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    if (!visualElementStore.has(element,)) {
      createVisualElement(element,);
    }
    const visualElement = visualElementStore.get(element,);
    const transition = { ...options, };
    if (typeof transition.delay === 'function') {
      transition.delay = transition.delay(i, numElements,);
    }
    animations2.push(...animateTarget(visualElement, { ...keyframes2, transition, }, {},),);
  }
  return new GroupPlaybackControls(animations2,);
}
var isSequence = (value,) => Array.isArray(value,) && Array.isArray(value[0],);
function animateSequence(sequence2, options, scope,) {
  const animations2 = [];
  const animationDefinitions = createAnimationsFromSequence(sequence2, options, scope,);
  animationDefinitions.forEach(({ keyframes: keyframes2, transition, }, subject,) => {
    let animation;
    if (isMotionValue(subject,)) {
      animation = animateSingleValue(subject, keyframes2.default, transition.default,);
    } else {
      animation = animateElements(subject, keyframes2, transition,);
    }
    animations2.push(animation,);
  },);
  return new GroupPlaybackControls(animations2,);
}
var createScopedAnimate = (scope,) => {
  function scopedAnimate(valueOrElementOrSequence, keyframes2, options,) {
    let animation;
    if (isSequence(valueOrElementOrSequence,)) {
      animation = animateSequence(valueOrElementOrSequence, keyframes2, scope,);
    } else if (isDOMKeyframes(keyframes2,)) {
      animation = animateElements(valueOrElementOrSequence, keyframes2, options, scope,);
    } else {
      animation = animateSingleValue(valueOrElementOrSequence, keyframes2, options,);
    }
    if (scope) {
      scope.animations.push(animation,);
    }
    return animation;
  }
  return scopedAnimate;
};
var animate = createScopedAnimate();
function useAnimate() {
  const scope = useConstant(() => ({
    current: null,
    animations: [],
  }));
  const animate22 = useConstant(() => createScopedAnimate(scope,));
  useUnmountEffect(() => {
    scope.animations.forEach((animation,) => animation.stop());
  },);
  return [scope, animate22,];
}
function useAnimationControls() {
  const controls = useConstant(animationControls,);
  useIsomorphicLayoutEffect(controls.mount, [],);
  return controls;
}
var useAnimation = useAnimationControls;
function useCycle(...items) {
  const index = useRef11(0,);
  const [item, setItem,] = useState5(items[index.current],);
  const runCycle = useCallback3(
    (next,) => {
      index.current = typeof next !== 'number' ? wrap(0, items.length, index.current + 1,) : next;
      setItem(items[index.current],);
    },
    // The array will change on each call, but by putting items.length at
    // the front of this array, we guarantee the dependency comparison will match up
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [items.length, ...items,],
  );
  return [item, runCycle,];
}
var thresholds = {
  some: 0,
  all: 1,
};
function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = 'some', } = {},) {
  const elements = resolveElements(elementOrSelector,);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = (entries,) => {
    entries.forEach((entry,) => {
      const onEnd = activeIntersections.get(entry.target,);
      if (entry.isIntersecting === Boolean(onEnd,)) {
        return;
      }
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry,);
        if (typeof newOnEnd === 'function') {
          activeIntersections.set(entry.target, newOnEnd,);
        } else {
          observer2.unobserve(entry.target,);
        }
      } else if (onEnd) {
        onEnd(entry,);
        activeIntersections.delete(entry.target,);
      }
    },);
  };
  const observer2 = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === 'number' ? amount : thresholds[amount],
  },);
  elements.forEach((element,) => observer2.observe(element,));
  return () => observer2.disconnect();
}
function useInView(ref, { root, margin, amount, once = false, } = {},) {
  const [isInView, setInView,] = useState6(false,);
  useEffect11(() => {
    if (!ref.current || once && isInView) {
      return;
    }
    const onEnter = () => {
      setInView(true,);
      return once ? void 0 : () => setInView(false,);
    };
    const options = {
      root: root && root.current || void 0,
      margin,
      amount,
    };
    return inView(ref.current, onEnter, options,);
  }, [root, ref, margin, once, amount,],);
  return isInView;
}
var DragControls = class {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls,) {
    this.componentControls.add(controls,);
    return () => this.componentControls.delete(controls,);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options,) {
    this.componentControls.forEach((controls,) => {
      controls.start(event.nativeEvent || event, options,);
    },);
  }
};
var createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls,);
}
function useDomEvent(ref, eventName, handler, options,) {
  useEffect12(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options,);
    }
  }, [ref, eventName, handler, options,],);
}
function isMotionComponent(component,) {
  return component !== null && typeof component === 'object' && motionComponentSymbol in component;
}
function unwrapMotionComponent(component,) {
  if (isMotionComponent(component,)) {
    return component[motionComponentSymbol];
  }
  return void 0;
}
function useInstantLayoutTransition() {
  return startTransition;
}
function startTransition(callback,) {
  if (!rootProjectionNode.current) {
    return;
  }
  rootProjectionNode.current.isUpdating = false;
  rootProjectionNode.current.blockUpdate();
  callback && callback();
}
function useInstantTransition() {
  const [forceUpdate, forcedRenderCount,] = useForceUpdate();
  const startInstantLayoutTransition = useInstantLayoutTransition();
  const unlockOnFrameRef = useRef12();
  useEffect13(() => {
    frame.postRender(() =>
      frame.postRender(() => {
        if (forcedRenderCount !== unlockOnFrameRef.current) {
          return;
        }
        instantAnimationState.current = false;
      },)
    );
  }, [forcedRenderCount,],);
  return (callback,) => {
    startInstantLayoutTransition(() => {
      instantAnimationState.current = true;
      forceUpdate();
      callback();
      unlockOnFrameRef.current = forcedRenderCount + 1;
    },);
  };
}
function disableInstantTransitions() {
  instantAnimationState.current = false;
}
function useResetProjection() {
  const reset = React10.useCallback(() => {
    const root = rootProjectionNode.current;
    if (!root) {
      return;
    }
    root.resetTree();
  }, [],);
  return reset;
}
var appearStoreId = (id4, value,) => `${id4}: ${value}`;
var appearAnimationStore = /* @__PURE__ */ new Map();
var handoffFrameTime;
function handoffOptimizedAppearAnimation(elementId, valueName, _value, _frame,) {
  const optimisedValueName = transformProps.has(valueName,) ? 'transform' : valueName;
  const storeId = appearStoreId(elementId, optimisedValueName,);
  const optimisedAnimation = appearAnimationStore.get(storeId,);
  if (!optimisedAnimation) {
    return null;
  }
  const { animation, startTime, } = optimisedAnimation;
  const cancelAnimation = () => {
    appearAnimationStore.delete(storeId,);
    try {
      animation.cancel();
    } catch (error) {
    }
  };
  if (startTime === null || window.HandoffComplete) {
    cancelAnimation();
    return null;
  } else {
    if (handoffFrameTime === void 0) {
      handoffFrameTime = performance.now();
    }
    return handoffFrameTime - startTime || 0;
  }
}
var startFrameTime;
var readyAnimation;
function startOptimizedAppearAnimation(element, name, keyframes2, options, onReady,) {
  if (window.HandoffComplete) {
    window.HandoffAppearAnimations = void 0;
    return;
  }
  const id4 = element.dataset[optimizedAppearDataId];
  if (!id4) {
    return;
  }
  window.HandoffAppearAnimations = handoffOptimizedAppearAnimation;
  const storeId = appearStoreId(id4, name,);
  if (!readyAnimation) {
    readyAnimation = animateStyle(
      element,
      name,
      [keyframes2[0], keyframes2[0],],
      /**
       * 10 secs is basically just a super-safe duration to give Chrome
       * long enough to get the animation ready.
       */
      { duration: 1e4, ease: 'linear', },
    );
    appearAnimationStore.set(storeId, {
      animation: readyAnimation,
      startTime: null,
    },);
  }
  const startAnimation2 = () => {
    readyAnimation.cancel();
    const appearAnimation = animateStyle(element, name, keyframes2, options,);
    if (startFrameTime === void 0) {
      startFrameTime = performance.now();
    }
    appearAnimation.startTime = startFrameTime;
    appearAnimationStore.set(storeId, {
      animation: appearAnimation,
      startTime: startFrameTime,
    },);
    if (onReady) {
      onReady(appearAnimation,);
    }
  };
  if (readyAnimation.ready) {
    readyAnimation.ready.then(startAnimation2,).catch(noop,);
  } else {
    startAnimation2();
  }
}
var createObject = () => ({});
var StateVisualElement = class extends VisualElement {
  build() {
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  resetTransform() {
  }
  restoreTransform() {
  }
  removeValueFromRenderState() {
  }
  renderInstance() {
  }
  scrapeMotionValuesFromProps() {
    return createObject();
  }
  getBaseTargetFromProps() {
    return void 0;
  }
  readValueFromInstance(_state, key7, options,) {
    return options.initialState[key7] || 0;
  }
  sortInstanceNodePosition() {
    return 0;
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target },) {
    const origin = getOrigin(target, transition || {}, this,);
    checkTargetForNewValues(this, target, origin,);
    return { transition, transitionEnd, ...target, };
  }
};
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject,
},);
function useAnimatedState(initialState2,) {
  const [animationState, setAnimationState,] = useState7(initialState2,);
  const visualState = useVisualState({}, false,);
  const element = useConstant(() => {
    return new StateVisualElement({ props: {}, visualState, presenceContext: null, }, { initialState: initialState2, },);
  },);
  useEffect14(() => {
    element.mount({},);
    return () => element.unmount();
  }, [element,],);
  useEffect14(() => {
    element.update({
      onUpdate: (v,) => {
        setAnimationState({ ...v, },);
      },
    }, null,);
  }, [setAnimationState, element,],);
  const startAnimation2 = useConstant(() => (animationDefinition,) => {
    return animateVisualElement(element, animationDefinition,);
  });
  return [animationState, startAnimation2,];
}
var maxScale = 1e5;
var invertScale = (scale2,) => scale2 > 1e-3 ? 1 / scale2 : maxScale;
var hasWarned = false;
function useInvertedScale(scale2,) {
  let parentScaleX = useMotionValue(1,);
  let parentScaleY = useMotionValue(1,);
  const { visualElement, } = useContext15(MotionContext,);
  invariant(
    !!(scale2 || visualElement),
    'If no scale values are provided, useInvertedScale must be used within a child of another motion component.',
  );
  warning(hasWarned, 'useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.',);
  hasWarned = true;
  if (scale2) {
    parentScaleX = scale2.scaleX || parentScaleX;
    parentScaleY = scale2.scaleY || parentScaleY;
  } else if (visualElement) {
    parentScaleX = visualElement.getValue('scaleX', 1,);
    parentScaleY = visualElement.getValue('scaleY', 1,);
  }
  const scaleX = useTransform(parentScaleX, invertScale,);
  const scaleY = useTransform(parentScaleY, invertScale,);
  return { scaleX, scaleY, };
}
function scrollTimelineFallback({ source, axis = 'y', },) {
  const currentTime = { value: 0, };
  const cancel = scrollInfo((info,) => {
    currentTime.value = info[axis].progress * 100;
  }, { container: source, axis, },);
  return { currentTime, cancel, };
}
var timelineCache = /* @__PURE__ */ new Map();
function getTimeline({ source = document.documentElement, axis = 'y', } = {},) {
  if (!timelineCache.has(source,)) {
    timelineCache.set(source, {},);
  }
  const elementCache = timelineCache.get(source,);
  if (!elementCache[axis]) {
    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({ source, axis, },) : scrollTimelineFallback({ source, axis, },);
  }
  return elementCache[axis];
}
function scroll(onScroll, options,) {
  const timeline = getTimeline(options,);
  if (typeof onScroll === 'function') {
    return observeTimeline(onScroll, timeline,);
  } else {
    return onScroll.attachTimeline(timeline,);
  }
}
function getOriginIndex(from, total,) {
  if (from === 'first') {
    return 0;
  } else {
    const lastIndex = total - 1;
    return from === 'last' ? lastIndex : lastIndex / 2;
  }
}
function stagger(duration = 0.1, { startDelay = 0, from = 0, ease: ease2, } = {},) {
  return (i, total,) => {
    const fromIndex = typeof from === 'number' ? from : getOriginIndex(from, total,);
    const distance2 = Math.abs(fromIndex - i,);
    let delay2 = duration * distance2;
    if (ease2) {
      const maxDelay = total * duration;
      const easingFunction = easingDefinitionToFunction(ease2,);
      delay2 = easingFunction(delay2 / maxDelay,) * maxDelay;
    }
    return startDelay + delay2;
  };
}
var sync = frame;
var cancelSync = stepsOrder.reduce((acc, key7,) => {
  acc[key7] = (process2,) => cancelFrame(process2,);
  return acc;
}, {},);

// https:https://app.framerstatic.com/framer.LKURAB5Q.js
import { Component as Component2, } from 'react';
import React12 from 'react';
import React112, { startTransition as startTransition2, } from 'react';
import React42, { useCallback as useCallback22, } from 'react';
import React22 from 'react';
import { useCallback as useCallback5, useEffect as useEffect16, useRef as useRef13, } from 'react';
import React32 from 'react';
import React62 from 'react';
import React52 from 'react';
import React82, { Suspense as Suspense2, } from 'react';
import React72, { Component as Component22, Suspense, } from 'react';
import React92 from 'react';
import React102 from 'react';
import React122, { useContext as useContext16, } from 'react';
import React14 from 'react';
import React13 from 'react';
import React15 from 'react';
import React16 from 'react';
import React17 from 'react';
import React18, { useCallback as useCallback32, useContext as useContext22, useMemo as useMemo8, useRef as useRef22, } from 'react';
import React20, { Component as Component3, } from 'react';
import { useRef as useRef32, } from 'react';
import React19 from 'react';
import React23 from 'react';
import React21 from 'react';
import React222 from 'react';
import React322 from 'react';
import React31, { forwardRef as forwardRef4, useContext as useContext52, useRef as useRef52, } from 'react';
import React25 from 'react';
import React24 from 'react';
import React26 from 'react';
import React27 from 'react';
import { useContext as useContext32, useMemo as useMemo22, } from 'react';
import { useContext as useContext42, } from 'react';
import { useEffect as useEffect22, useLayoutEffect as useLayoutEffect2, } from 'react';
import React28 from 'react';
import React30, { useEffect as useEffect32, } from 'react';
import React29 from 'react';
import { Component as Component4, } from 'react';
import { useEffect as useEffect42, useRef as useRef42, } from 'react';
import React45, { Component as Component7, } from 'react';
import React33, { Component as Component5, } from 'react';
import React34 from 'react';
import React44, { useContext as useContext82, useEffect as useEffect62, useRef as useRef72, } from 'react';
import React35 from 'react';
import React40, { forwardRef as forwardRef22, } from 'react';
import React37 from 'react';
import React36 from 'react';
import React39 from 'react';
import React38 from 'react';
import React41, { Component as Component6, } from 'react';
import React422, { useContext as useContext62, } from 'react';
import React43, {
  createContext as createContext9,
  useCallback as useCallback42,
  useContext as useContext72,
  useEffect as useEffect52,
  useRef as useRef62,
} from 'react';
import { createContext as createContext22, } from 'react';
import React46 from 'react';
import React50 from 'react';
import { useCallback as useCallback52, useRef as useRef82, } from 'react';
import React49 from 'react';
import React48 from 'react';
import React47 from 'react';
import React51, { Component as Component10, } from 'react';
import { Component as Component8, } from 'react';
import { Component as Component9, } from 'react';
import React55 from 'react';
import React522, {
  useCallback as useCallback6,
  useInsertionEffect as useInsertionEffect5,
  useMemo as useMemo32,
  useRef as useRef92,
} from 'react';
import React54, { useInsertionEffect as useInsertionEffect22, } from 'react';
import React53, { useEffect as useEffect72, } from 'react';
import { useContext as useContext92, } from 'react';
import {
  createContext as createContext32,
  useContext as useContext102,
  useEffect as useEffect82,
  useMemo as useMemo42,
  useState as useState8,
} from 'react';
import React56, { Component as Component11, } from 'react';
import React57, { useContext as useContext112, } from 'react';
import React64 from 'react';
import React58 from 'react';
import React59, { useCallback as useCallback7, useEffect as useEffect92, useRef as useRef102, } from 'react';
import React60 from 'react';
import { useLayoutEffect as useLayoutEffect22, } from 'react';
import React622 from 'react';
import React61 from 'react';
import React63 from 'react';
import React65, { createContext as createContext42, useContext as useContext122, useRef as useRef112, } from 'react';
import React67 from 'react';
import * as React66 from 'react';
import React69 from 'react';
import React68 from 'react';
import React722, { useContext as useContext132, } from 'react';
import React71 from 'react';
import React70 from 'react';
import React73 from 'react';
import ReactDOM from 'react-dom';
import React74 from 'react';
import React75 from 'react';
import React76 from 'react';
import React77 from 'react';
import * as React78 from 'react';
import React79 from 'react';
import React80 from 'react';
import {
  startTransition as startTransition22,
  useCallback as useCallback8,
  useContext as useContext142,
  useEffect as useEffect102,
  useRef as useRef122,
} from 'react';
import { useMemo as useMemo52, } from 'react';
import React81, { createRef, } from 'react';
import React822 from 'react';
import React83 from 'react';
import React84 from 'react';
import React85 from 'react';
import React86 from 'react';
import { useRef as useRef132, } from 'react';
import React87 from 'react';
import React88 from 'react';
import React89 from 'react';
import React90, { useRef as useRef14, } from 'react';
import React101, { Component as Component14, } from 'react';
import React91 from 'react';
import React94 from 'react';
import React922 from 'react';
import React93 from 'react';
import React96, { useEffect as useEffect112, useRef as useRef15, } from 'react';
import React95 from 'react';
import React99 from 'react';
import React97, { Component as Component12, } from 'react';
import React98, { Component as Component13, } from 'react';
import React100 from 'react';
import React1022 from 'react';
import React103 from 'react';
import React105, {
  Children as Children22,
  cloneElement as cloneElement22,
  forwardRef as forwardRef52,
  isValidElement as isValidElement22,
  useContext as useContext162,
  useInsertionEffect as useInsertionEffect42,
  useRef as useRef17,
} from 'react';
import * as React104 from 'react';
import { useRef as useRef16, } from 'react';
import { useEffect as useEffect132, useState as useState22, } from 'react';
var require_hsluv = __commonJS({
  '../../../node_modules/hsluv/hsluv.js'(exports, module,) {
    var hsluv = hsluv || {};
    hsluv.Geometry = function () {
    };
    hsluv.Geometry.intersectLineLine = function (a, b,) {
      var x = (a.intercept - b.intercept) / (b.slope - a.slope);
      var y = a.slope * x + a.intercept;
      return { x, y, };
    };
    hsluv.Geometry.distanceFromOrigin = function (point2,) {
      return Math.sqrt(Math.pow(point2.x, 2,) + Math.pow(point2.y, 2,),);
    };
    hsluv.Geometry.distanceLineFromOrigin = function (line,) {
      return Math.abs(line.intercept,) / Math.sqrt(Math.pow(line.slope, 2,) + 1,);
    };
    hsluv.Geometry.perpendicularThroughPoint = function (line, point2,) {
      var slope = -1 / line.slope;
      var intercept = point2.y - slope * point2.x;
      return { slope, intercept, };
    };
    hsluv.Geometry.angleFromOrigin = function (point2,) {
      return Math.atan2(point2.y, point2.x,);
    };
    hsluv.Geometry.normalizeAngle = function (angle,) {
      var m2 = 2 * Math.PI;
      return (angle % m2 + m2) % m2;
    };
    hsluv.Geometry.lengthOfRayUntilIntersect = function (theta, line,) {
      return line.intercept / (Math.sin(theta,) - line.slope * Math.cos(theta,));
    };
    hsluv.Hsluv = function () {
    };
    hsluv.Hsluv.getBounds = function (L,) {
      var result = [];
      var sub1 = Math.pow(L + 16, 3,) / 1560896;
      var sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;
      var _g = 0;
      while (_g < 3) {
        var c = _g++;
        var m1 = hsluv.Hsluv.m[c][0];
        var m2 = hsluv.Hsluv.m[c][1];
        var m3 = hsluv.Hsluv.m[c][2];
        var _g1 = 0;
        while (_g1 < 2) {
          var t = _g1++;
          var top1 = (284517 * m1 - 94839 * m3) * sub2;
          var top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
          var bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
          result.push({ slope: top1 / bottom, intercept: top2 / bottom, },);
        }
      }
      return result;
    };
    hsluv.Hsluv.maxSafeChromaForL = function (L,) {
      var bounds = hsluv.Hsluv.getBounds(L,);
      var min = Infinity;
      var _g = 0;
      while (_g < bounds.length) {
        var bound = bounds[_g];
        ++_g;
        var length = hsluv.Geometry.distanceLineFromOrigin(bound,);
        min = Math.min(min, length,);
      }
      return min;
    };
    hsluv.Hsluv.maxChromaForLH = function (L, H,) {
      var hrad = H / 360 * Math.PI * 2;
      var bounds = hsluv.Hsluv.getBounds(L,);
      var min = Infinity;
      var _g = 0;
      while (_g < bounds.length) {
        var bound = bounds[_g];
        ++_g;
        var length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad, bound,);
        if (length >= 0) {
          min = Math.min(min, length,);
        }
      }
      return min;
    };
    hsluv.Hsluv.dotProduct = function (a, b,) {
      var sum = 0;
      var _g1 = 0;
      var _g = a.length;
      while (_g1 < _g) {
        var i = _g1++;
        sum += a[i] * b[i];
      }
      return sum;
    };
    hsluv.Hsluv.fromLinear = function (c,) {
      if (c <= 31308e-7) {
        return 12.92 * c;
      } else {
        return 1.055 * Math.pow(c, 0.4166666666666667,) - 0.055;
      }
    };
    hsluv.Hsluv.toLinear = function (c,) {
      if (c > 0.04045) {
        return Math.pow((c + 0.055) / 1.055, 2.4,);
      } else {
        return c / 12.92;
      }
    };
    hsluv.Hsluv.xyzToRgb = function (tuple,) {
      return [
        hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0], tuple,),),
        hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1], tuple,),),
        hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2], tuple,),),
      ];
    };
    hsluv.Hsluv.rgbToXyz = function (tuple,) {
      var rgbl = [hsluv.Hsluv.toLinear(tuple[0],), hsluv.Hsluv.toLinear(tuple[1],), hsluv.Hsluv.toLinear(tuple[2],),];
      return [
        hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0], rgbl,),
        hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1], rgbl,),
        hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2], rgbl,),
      ];
    };
    hsluv.Hsluv.yToL = function (Y,) {
      if (Y <= hsluv.Hsluv.epsilon) {
        return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;
      } else {
        return 116 * Math.pow(Y / hsluv.Hsluv.refY, 0.3333333333333333,) - 16;
      }
    };
    hsluv.Hsluv.lToY = function (L,) {
      if (L <= 8) {
        return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;
      } else {
        return hsluv.Hsluv.refY * Math.pow((L + 16) / 116, 3,);
      }
    };
    hsluv.Hsluv.xyzToLuv = function (tuple,) {
      var X = tuple[0];
      var Y = tuple[1];
      var Z = tuple[2];
      var divider = X + 15 * Y + 3 * Z;
      var varU = 4 * X;
      var varV = 9 * Y;
      if (divider != 0) {
        varU /= divider;
        varV /= divider;
      } else {
        varU = NaN;
        varV = NaN;
      }
      var L = hsluv.Hsluv.yToL(Y,);
      if (L == 0) {
        return [0, 0, 0,];
      }
      var U = 13 * L * (varU - hsluv.Hsluv.refU);
      var V = 13 * L * (varV - hsluv.Hsluv.refV);
      return [L, U, V,];
    };
    hsluv.Hsluv.luvToXyz = function (tuple,) {
      var L = tuple[0];
      var U = tuple[1];
      var V = tuple[2];
      if (L == 0) {
        return [0, 0, 0,];
      }
      var varU = U / (13 * L) + hsluv.Hsluv.refU;
      var varV = V / (13 * L) + hsluv.Hsluv.refV;
      var Y = hsluv.Hsluv.lToY(L,);
      var X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);
      var Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);
      return [X, Y, Z,];
    };
    hsluv.Hsluv.luvToLch = function (tuple,) {
      var L = tuple[0];
      var U = tuple[1];
      var V = tuple[2];
      var C = Math.sqrt(U * U + V * V,);
      var H;
      if (C < 1e-8) {
        H = 0;
      } else {
        var Hrad = Math.atan2(V, U,);
        H = Hrad * 180 / Math.PI;
        if (H < 0) {
          H = 360 + H;
        }
      }
      return [L, C, H,];
    };
    hsluv.Hsluv.lchToLuv = function (tuple,) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      var Hrad = H / 360 * 2 * Math.PI;
      var U = Math.cos(Hrad,) * C;
      var V = Math.sin(Hrad,) * C;
      return [L, U, V,];
    };
    hsluv.Hsluv.hsluvToLch = function (tuple,) {
      var H = tuple[0];
      var S = tuple[1];
      var L = tuple[2];
      if (L > 99.9999999) {
        return [100, 0, H,];
      }
      if (L < 1e-8) {
        return [0, 0, H,];
      }
      var max = hsluv.Hsluv.maxChromaForLH(L, H,);
      var C = max / 100 * S;
      return [L, C, H,];
    };
    hsluv.Hsluv.lchToHsluv = function (tuple,) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      if (L > 99.9999999) {
        return [H, 0, 100,];
      }
      if (L < 1e-8) {
        return [H, 0, 0,];
      }
      var max = hsluv.Hsluv.maxChromaForLH(L, H,);
      var S = C / max * 100;
      return [H, S, L,];
    };
    hsluv.Hsluv.hpluvToLch = function (tuple,) {
      var H = tuple[0];
      var S = tuple[1];
      var L = tuple[2];
      if (L > 99.9999999) {
        return [100, 0, H,];
      }
      if (L < 1e-8) {
        return [0, 0, H,];
      }
      var max = hsluv.Hsluv.maxSafeChromaForL(L,);
      var C = max / 100 * S;
      return [L, C, H,];
    };
    hsluv.Hsluv.lchToHpluv = function (tuple,) {
      var L = tuple[0];
      var C = tuple[1];
      var H = tuple[2];
      if (L > 99.9999999) {
        return [H, 0, 100,];
      }
      if (L < 1e-8) {
        return [H, 0, 0,];
      }
      var max = hsluv.Hsluv.maxSafeChromaForL(L,);
      var S = C / max * 100;
      return [H, S, L,];
    };
    hsluv.Hsluv.rgbToHex = function (tuple,) {
      var h = '#';
      var _g = 0;
      while (_g < 3) {
        var i = _g++;
        var chan = tuple[i];
        var c = Math.round(chan * 255,);
        var digit2 = c % 16;
        var digit1 = (c - digit2) / 16 | 0;
        h += hsluv.Hsluv.hexChars.charAt(digit1,) + hsluv.Hsluv.hexChars.charAt(digit2,);
      }
      return h;
    };
    hsluv.Hsluv.hexToRgb = function (hex2,) {
      hex2 = hex2.toLowerCase();
      var ret = [];
      var _g = 0;
      while (_g < 3) {
        var i = _g++;
        var digit1 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 1,),);
        var digit2 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 2,),);
        var n = digit1 * 16 + digit2;
        ret.push(n / 255,);
      }
      return ret;
    };
    hsluv.Hsluv.lchToRgb = function (tuple,) {
      return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple,),),);
    };
    hsluv.Hsluv.rgbToLch = function (tuple,) {
      return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple,),),);
    };
    hsluv.Hsluv.hsluvToRgb = function (tuple,) {
      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple,),);
    };
    hsluv.Hsluv.rgbToHsluv = function (tuple,) {
      return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple,),);
    };
    hsluv.Hsluv.hpluvToRgb = function (tuple,) {
      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple,),);
    };
    hsluv.Hsluv.rgbToHpluv = function (tuple,) {
      return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple,),);
    };
    hsluv.Hsluv.hsluvToHex = function (tuple,) {
      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple,),);
    };
    hsluv.Hsluv.hpluvToHex = function (tuple,) {
      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple,),);
    };
    hsluv.Hsluv.hexToHsluv = function (s,) {
      return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s,),);
    };
    hsluv.Hsluv.hexToHpluv = function (s,) {
      return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s,),);
    };
    hsluv.Hsluv.m = [[3.240969941904521, -1.537383177570093, -0.498610760293,], [-0.96924363628087, 1.87596750150772, 0.041555057407175,], [
      0.055630079696993,
      -0.20397695888897,
      1.056971514242878,
    ],];
    hsluv.Hsluv.minv = [[0.41239079926595, 0.35758433938387, 0.18048078840183,], [0.21263900587151, 0.71516867876775, 0.072192315360733,], [
      0.019330818715591,
      0.11919477979462,
      0.95053215224966,
    ],];
    hsluv.Hsluv.refY = 1;
    hsluv.Hsluv.refU = 0.19783000664283;
    hsluv.Hsluv.refV = 0.46831999493879;
    hsluv.Hsluv.kappa = 903.2962962;
    hsluv.Hsluv.epsilon = 0.0088564516;
    hsluv.Hsluv.hexChars = '0123456789abcdef';
    var root = {
      'hsluvToRgb': hsluv.Hsluv.hsluvToRgb,
      'rgbToHsluv': hsluv.Hsluv.rgbToHsluv,
      'hpluvToRgb': hsluv.Hsluv.hpluvToRgb,
      'rgbToHpluv': hsluv.Hsluv.rgbToHpluv,
      'hsluvToHex': hsluv.Hsluv.hsluvToHex,
      'hexToHsluv': hsluv.Hsluv.hexToHsluv,
      'hpluvToHex': hsluv.Hsluv.hpluvToHex,
      'hexToHpluv': hsluv.Hsluv.hexToHpluv,
      'lchToHpluv': hsluv.Hsluv.lchToHpluv,
      'hpluvToLch': hsluv.Hsluv.hpluvToLch,
      'lchToHsluv': hsluv.Hsluv.lchToHsluv,
      'hsluvToLch': hsluv.Hsluv.hsluvToLch,
      'lchToLuv': hsluv.Hsluv.lchToLuv,
      'luvToLch': hsluv.Hsluv.luvToLch,
      'xyzToLuv': hsluv.Hsluv.xyzToLuv,
      'luvToXyz': hsluv.Hsluv.luvToXyz,
      'xyzToRgb': hsluv.Hsluv.xyzToRgb,
      'rgbToXyz': hsluv.Hsluv.rgbToXyz,
      'lchToRgb': hsluv.Hsluv.lchToRgb,
      'rgbToLch': hsluv.Hsluv.rgbToLch,
    };
    module.exports = root;
  },
},);
var require_eventemitter3 = __commonJS({
  '../../../node_modules/eventemitter3/index.js'(exports, module,) {
    'use strict';
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = '~';
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null,);
      if (!new Events().__proto__) {
        prefix2 = false;
      }
    }
    function EE(fn, context, once,) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once,) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function',);
      }
      var listener = new EE(fn, context || emitter, once,), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) {
        emitter._events[evt] = listener, emitter._eventsCount++;
      } else if (!emitter._events[evt].fn) {
        emitter._events[evt].push(listener,);
      } else {
        emitter._events[evt] = [emitter._events[evt], listener,];
      }
      return emitter;
    }
    function clearEvent(emitter, evt,) {
      if (--emitter._eventsCount === 0) {
        emitter._events = new Events();
      } else {
        delete emitter._events[evt];
      }
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) {
        return names;
      }
      for (name in events2 = this._events) {
        if (has.call(events2, name,)) {
          names.push(prefix2 ? name.slice(1,) : name,);
        }
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2,),);
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event,) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) {
        return [];
      }
      if (handlers.fn) {
        return [handlers.fn,];
      }
      for (var i = 0, l = handlers.length, ee = new Array(l,); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event,) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) {
        return 0;
      }
      if (listeners.fn) {
        return 1;
      }
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5,) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) {
        return false;
      }
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) {
          this.removeListener(event, listeners.fn, void 0, true,);
        }
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context,), true;
          case 2:
            return listeners.fn.call(listeners.context, a1,), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2,), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3,), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4,), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5,), true;
        }
        for (i = 1, args = new Array(len - 1,); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args,);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) {
            this.removeListener(event, listeners[i].fn, void 0, true,);
          }
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context,);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1,);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2,);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3,);
              break;
            default:
              if (!args) {
                for (j = 1, args = new Array(len - 1,); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              }
              listeners[i].fn.apply(listeners[i].context, args,);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context,) {
      return addListener(this, event, fn, context, false,);
    };
    EventEmitter2.prototype.once = function once(event, fn, context,) {
      return addListener(this, event, fn, context, true,);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once,) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) {
        return this;
      }
      if (!fn) {
        clearEvent(this, evt,);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt,);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i],);
          }
        }
        if (events2.length) {
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        } else {
          clearEvent(this, evt,);
        }
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event,) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) {
          clearEvent(this, evt,);
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ('undefined' !== typeof module) {
      module.exports = EventEmitter2;
    }
  },
},);
var require_browser = __commonJS({
  '../../../node_modules/process/browser.js'(exports, module,) {
    var process6 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined',);
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined',);
    }
    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun,) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0,);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0,);
      }
      try {
        return cachedSetTimeout(fun, 0,);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0,);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0,);
        }
      }
    }
    function runClearTimeout(marker,) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker,);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker,);
      }
      try {
        return cachedClearTimeout(marker,);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker,);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker,);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue,);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick,);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout,);
    }
    process6.nextTick = function (fun,) {
      var args = new Array(arguments.length - 1,);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item2(fun, args,),);
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue,);
      }
    };
    function Item2(fun, array,) {
      this.fun = fun;
      this.array = array;
    }
    Item2.prototype.run = function () {
      this.fun.apply(null, this.array,);
    };
    process6.title = 'browser';
    process6.browser = true;
    process6.env = {};
    process6.argv = [];
    process6.version = '';
    process6.versions = {};
    function noop2() {
    }
    process6.on = noop2;
    process6.addListener = noop2;
    process6.once = noop2;
    process6.off = noop2;
    process6.removeListener = noop2;
    process6.removeAllListeners = noop2;
    process6.emit = noop2;
    process6.prependListener = noop2;
    process6.prependOnceListener = noop2;
    process6.listeners = function (name,) {
      return [];
    };
    process6.binding = function (name,) {
      throw new Error('process.binding is not supported',);
    };
    process6.cwd = function () {
      return '/';
    };
    process6.chdir = function (dir,) {
      throw new Error('process.chdir is not supported',);
    };
    process6.umask = function () {
      return 0;
    };
  },
},);
var require_react_is_production_min = __commonJS({
  '../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js'(exports,) {
    'use strict';
    var b = 'function' === typeof Symbol && Symbol.for;
    var c = b ? Symbol.for('react.element',) : 60103;
    var d = b ? Symbol.for('react.portal',) : 60106;
    var e = b ? Symbol.for('react.fragment',) : 60107;
    var f = b ? Symbol.for('react.strict_mode',) : 60108;
    var g = b ? Symbol.for('react.profiler',) : 60114;
    var h = b ? Symbol.for('react.provider',) : 60109;
    var k = b ? Symbol.for('react.context',) : 60110;
    var l = b ? Symbol.for('react.async_mode',) : 60111;
    var m2 = b ? Symbol.for('react.concurrent_mode',) : 60111;
    var n = b ? Symbol.for('react.forward_ref',) : 60112;
    var p = b ? Symbol.for('react.suspense',) : 60113;
    var q = b ? Symbol.for('react.suspense_list',) : 60120;
    var r = b ? Symbol.for('react.memo',) : 60115;
    var t = b ? Symbol.for('react.lazy',) : 60116;
    var v = b ? Symbol.for('react.block',) : 60121;
    var w = b ? Symbol.for('react.fundamental',) : 60117;
    var x = b ? Symbol.for('react.responder',) : 60118;
    var y = b ? Symbol.for('react.scope',) : 60119;
    function z(a,) {
      if ('object' === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m2:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a,) {
      return z(a,) === m2;
    }
    exports.AsyncMode = l;
    exports.ConcurrentMode = m2;
    exports.ContextConsumer = k;
    exports.ContextProvider = h;
    exports.Element = c;
    exports.ForwardRef = n;
    exports.Fragment = e;
    exports.Lazy = t;
    exports.Memo = r;
    exports.Portal = d;
    exports.Profiler = g;
    exports.StrictMode = f;
    exports.Suspense = p;
    exports.isAsyncMode = function (a,) {
      return A(a,) || z(a,) === l;
    };
    exports.isConcurrentMode = A;
    exports.isContextConsumer = function (a,) {
      return z(a,) === k;
    };
    exports.isContextProvider = function (a,) {
      return z(a,) === h;
    };
    exports.isElement = function (a,) {
      return 'object' === typeof a && null !== a && a.$$typeof === c;
    };
    exports.isForwardRef = function (a,) {
      return z(a,) === n;
    };
    exports.isFragment = function (a,) {
      return z(a,) === e;
    };
    exports.isLazy = function (a,) {
      return z(a,) === t;
    };
    exports.isMemo = function (a,) {
      return z(a,) === r;
    };
    exports.isPortal = function (a,) {
      return z(a,) === d;
    };
    exports.isProfiler = function (a,) {
      return z(a,) === g;
    };
    exports.isStrictMode = function (a,) {
      return z(a,) === f;
    };
    exports.isSuspense = function (a,) {
      return z(a,) === p;
    };
    exports.isValidElementType = function (a,) {
      return 'string' === typeof a || 'function' === typeof a || a === e || a === m2 || a === g || a === f || a === p || a === q ||
        'object' === typeof a && null !== a &&
          (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w ||
            a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    exports.typeOf = z;
  },
},);
var require_react_is = __commonJS({
  '../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js'(exports, module,) {
    'use strict';
    if (true) {
      module.exports = require_react_is_production_min();
    } else {
      module.exports = null;
    }
  },
},);
var require_hoist_non_react_statics_cjs = __commonJS({
  '../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js'(exports, module,) {
    'use strict';
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true,
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true,
    };
    var FORWARD_REF_STATICS = {
      '$$typeof': true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
    };
    var MEMO_STATICS = {
      '$$typeof': true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true,
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component,) {
      if (reactIs.isMemo(component,)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist,) {
      if (typeof sourceComponent !== 'string') {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent,);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist,);
          }
        }
        var keys3 = getOwnPropertyNames(sourceComponent,);
        if (getOwnPropertySymbols) {
          keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent,),);
        }
        var targetStatics = getStatics(targetComponent,);
        var sourceStatics = getStatics(sourceComponent,);
        for (var i = 0; i < keys3.length; ++i) {
          var key7 = keys3[i];
          if (
            !KNOWN_STATICS[key7] && !(blacklist && blacklist[key7]) && !(sourceStatics && sourceStatics[key7]) &&
            !(targetStatics && targetStatics[key7])
          ) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key7,);
            try {
              defineProperty(targetComponent, key7, descriptor,);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  },
},);
var require_archy = __commonJS({
  '../../../node_modules/archy/index.js'(exports, module,) {
    module.exports = function archy2(obj, prefix2, opts,) {
      if (prefix2 === void 0) {
        prefix2 = '';
      }
      if (!opts) {
        opts = {};
      }
      var chr = function (s,) {
        var chars = {
          '\u2502': '|',
          '\u2514': '`',
          '\u251C': '+',
          '\u2500': '-',
          '\u252C': '-',
        };
        return opts.unicode === false ? chars[s] : s;
      };
      if (typeof obj === 'string') {
        obj = { label: obj, };
      }
      var nodes = obj.nodes || [];
      var lines = (obj.label || '').split('\n',);
      var splitter = '\n' + prefix2 + (nodes.length ? chr('\u2502',) : ' ') + ' ';
      return prefix2 + lines.join(splitter,) + '\n' + nodes.map(function (node, ix,) {
        var last = ix === nodes.length - 1;
        var more = node.nodes && node.nodes.length;
        var prefix_ = prefix2 + (last ? ' ' : chr('\u2502',)) + ' ';
        return prefix2 + (last ? chr('\u2514',) : chr('\u251C',)) + chr('\u2500',) + (more ? chr('\u252C',) : chr('\u2500',)) + ' ' +
          archy2(node, prefix_, opts,).slice(prefix2.length + 2,);
      },).join('',);
    };
  },
},);
var require_fontfaceobserver_standalone = __commonJS({
  '../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js'(exports, module,) {
    (function () {
      function l(a, b,) {
        document.addEventListener ? a.addEventListener('scroll', b, false,) : a.attachEvent('scroll', b,);
      }
      function m2(a,) {
        document.body ? a() : document.addEventListener
          ? document.addEventListener('DOMContentLoaded', function c() {
            document.removeEventListener('DOMContentLoaded', c,);
            a();
          },)
          : document.attachEvent('onreadystatechange', function k() {
            if ('interactive' == document.readyState || 'complete' == document.readyState) {
              document.detachEvent('onreadystatechange', k,), a();
            }
          },);
      }

      function t(a,) {
        this.a = document.createElement('div',);
        this.a.setAttribute('aria-hidden', 'true',);
        this.a.appendChild(document.createTextNode(a,),);
        this.b = document.createElement('span',);
        this.c = document.createElement('span',);
        this.h = document.createElement('span',);
        this.f = document.createElement('span',);
        this.g = -1;
        this.b.style.cssText =
          'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;';
        this.c.style.cssText =
          'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;';
        this.f.style.cssText =
          'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;';
        this.h.style.cssText = 'display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;';
        this.b.appendChild(this.h,);
        this.c.appendChild(this.f,);
        this.a.appendChild(this.b,);
        this.a.appendChild(this.c,);
      }
      function u(a, b,) {
        a.a.style.cssText =
          'max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:' +
          b + ';';
      }
      function z(a,) {
        var b = a.a.offsetWidth, c = b + 100;
        a.f.style.width = c + 'px';
        a.c.scrollLeft = c;
        a.b.scrollLeft = a.b.scrollWidth + 100;
        return a.g !== b ? (a.g = b, true) : false;
      }
      function A(a, b,) {
        function c() {
          var a2 = k;
          z(a2,) && a2.a.parentNode && b(a2.g,);
        }
        var k = a;
        l(a.b, c,);
        l(a.c, c,);
        z(a,);
      }

      function B(a, b,) {
        var c = b || {};
        this.family = a;
        this.style = c.style || 'normal';
        this.weight = c.weight || 'normal';
        this.stretch = c.stretch || 'normal';
      }
      var C = null, D = null, E = null, F = null;
      function G() {
        if (null === D) {
          if (J() && /Apple/.test(window.navigator.vendor,)) {
            var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent,);
            D = !!a && 603 > parseInt(a[1], 10,);
          } else {
            D = false;
          }
        }
        return D;
      }
      function J() {
        null === F && (F = !!document.fonts);
        return F;
      }
      function K() {
        if (null === E) {
          var a = document.createElement('div',);
          try {
            a.style.font = 'condensed 100px sans-serif';
          } catch (b) {
          }
          E = '' !== a.style.font;
        }
        return E;
      }
      function L(a, b,) {
        return [a.style, a.weight, K() ? a.stretch : '', '100px', b,].join(' ',);
      }
      B.prototype.load = function (a, b,) {
        var c = this, k = a || 'BESbswy', r = 0, n = b || 3e3, H = (/* @__PURE__ */ new Date()).getTime();
        return new Promise(function (a2, b2,) {
          if (J() && !G()) {
            var M = new Promise(function (a3, b3,) {
                function e() {
                  (/* @__PURE__ */ new Date()).getTime() - H >= n
                    ? b3(Error('' + n + 'ms timeout exceeded',),)
                    : document.fonts.load(L(c, '"' + c.family + '"',), k,).then(function (c2,) {
                      1 <= c2.length ? a3() : setTimeout(e, 25,);
                    }, b3,);
                }
                e();
              },),
              N = new Promise(function (a3, c2,) {
                r = setTimeout(function () {
                  c2(Error('' + n + 'ms timeout exceeded',),);
                }, n,);
              },);
            Promise.race([N, M,],).then(
              function () {
                clearTimeout(r,);
                a2(c,);
              },
              b2,
            );
          } else {
            m2(function () {
              function v() {
                var b3;
                if (b3 = -1 != f && -1 != g || -1 != f && -1 != h || -1 != g && -1 != h) {
                  (b3 = f != g && f != h && g != h) ||
                  (null === C &&
                    (b3 = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent,),
                      C = !!b3 && (536 > parseInt(b3[1], 10,) || 536 === parseInt(b3[1], 10,) && 11 >= parseInt(b3[2], 10,))),
                    b3 = C && (f == w && g == w && h == w || f == x && g == x && h == x || f == y && g == y && h == y)), b3 = !b3;
                }
                b3 && (d.parentNode && d.parentNode.removeChild(d,), clearTimeout(r,), a2(c,));
              }
              function I() {
                if ((/* @__PURE__ */ new Date()).getTime() - H >= n) {
                  d.parentNode && d.parentNode.removeChild(d,), b2(Error('' + n + 'ms timeout exceeded',),);
                } else {
                  var a3 = document.hidden;
                  if (true === a3 || void 0 === a3) {
                    f = e.a.offsetWidth, g = p.a.offsetWidth, h = q.a.offsetWidth, v();
                  }
                  r = setTimeout(I, 50,);
                }
              }
              var e = new t(k,),
                p = new t(k,),
                q = new t(k,),
                f = -1,
                g = -1,
                h = -1,
                w = -1,
                x = -1,
                y = -1,
                d = document.createElement('div',);
              d.dir = 'ltr';
              u(e, L(c, 'sans-serif',),);
              u(p, L(c, 'serif',),);
              u(q, L(c, 'monospace',),);
              d.appendChild(e.a,);
              d.appendChild(p.a,);
              d.appendChild(q.a,);
              document.body.appendChild(d,);
              w = e.a.offsetWidth;
              x = p.a.offsetWidth;
              y = q.a.offsetWidth;
              I();
              A(e, function (a3,) {
                f = a3;
                v();
              },);
              u(
                e,
                L(c, '"' + c.family + '",sans-serif',),
              );
              A(p, function (a3,) {
                g = a3;
                v();
              },);
              u(p, L(c, '"' + c.family + '",serif',),);
              A(q, function (a3,) {
                h = a3;
                v();
              },);
              u(q, L(c, '"' + c.family + '",monospace',),);
            },);
          }
        },);
      };
      'object' === typeof module
        ? module.exports = B
        : (window.FontFaceObserver = B, window.FontFaceObserver.prototype.load = B.prototype.load);
    })();
  },
},);
function renderPage(Page4, defaultPageStyle,) {
  return React12.isValidElement(Page4,)
    ? React12.cloneElement(Page4, { style: defaultPageStyle, },)
    : React12.createElement(Page4, { style: defaultPageStyle, },);
}
var NotFoundError = class extends Error {
};
var ErrorBoundary = class extends Component2 {
  constructor(props,) {
    super(props,);
    this.state = { error: void 0, forceUpdateKey: props.forceUpdateKey, };
  }
  static getDerivedStateFromError(error,) {
    return { error, };
  }
  /** Resets the error when forceUpdateKey gets bumped. */
  static getDerivedStateFromProps(nextProps, prevState,) {
    if (nextProps.forceUpdateKey !== prevState.forceUpdateKey) {
      const newState = {
        forceUpdateKey: nextProps.forceUpdateKey,
      };
      if (prevState.error) {
        newState.error = void 0;
      }
      return newState;
    }
    return null;
  }
  render() {
    if (this.state.error === void 0) {
      return this.props.children;
    }
    if (!(this.state.error instanceof NotFoundError)) {
      throw this.state.error;
    }
    const { notFoundPage, defaultPageStyle, } = this.props;
    if (!notFoundPage) {
      throw this.state.error;
    }
    return renderPage(notFoundPage, defaultPageStyle,);
  }
};
var pathVariablesRegExpRaw = ':([a-z]\\w*)';
var pathVariablesRegExp = new RegExp(pathVariablesRegExpRaw, 'gi',);
function fillPathVariables(path, variables,) {
  return path.replace(pathVariablesRegExp, (match, name,) => {
    const value = variables[name];
    if (typeof value !== 'string' || value.length === 0) {
      return match;
    }
    return encodeURIComponent(value,);
  },);
}
function computeRelativePath(from, to,) {
  if (!from.startsWith('/',) || !to.startsWith('/',)) {
    throw new Error('from/to paths are expected to be absolute',);
  }
  const [fromDir,] = getDirAndFile(from,);
  const [toDir, toFile,] = getDirAndFile(to,);
  let relativePath = relative(fromDir, toDir,);
  if (relativePath === '') {
    relativePath = '.';
  }
  if (!relativePath.startsWith('.',) && !relativePath.startsWith('/',)) {
    relativePath = './' + relativePath;
  }
  return relativePath + '/' + toFile;
}
function getDirAndFile(path,) {
  const index = path.lastIndexOf('/',);
  return [path.substring(0, index + 1,), path.substring(index + 1,),];
}
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var StringPrototypeCharCodeAt = (str, index,) => str.charCodeAt(index,);
var StringPrototypeLastIndexOf = (str, searchString,) => str.lastIndexOf(searchString,);
var StringPrototypeSlice = (str, start, end,) => str.slice(start, end,);
function relative(from, to,) {
  if (from === to) {
    return '';
  }
  from = '/' + normalizeString(from,);
  to = '/' + normalizeString(to,);
  if (from === to) {
    return '';
  }
  const fromStart = 1;
  const fromEnd = from.length;
  const fromLen = fromEnd - fromStart;
  const toStart = 1;
  const toLen = to.length - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i < length; i++) {
    const fromCode = StringPrototypeCharCodeAt(from, fromStart + i,);
    if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i,)) {
      break;
    } else if (fromCode === CHAR_FORWARD_SLASH) {
      lastCommonSep = i;
    }
  }
  if (i === length) {
    if (toLen > length) {
      if (StringPrototypeCharCodeAt(to, toStart + i,) === CHAR_FORWARD_SLASH) {
        return StringPrototypeSlice(to, toStart + i + 1,);
      }
      if (i === 0) {
        return StringPrototypeSlice(to, toStart + i,);
      }
    } else if (fromLen > length) {
      if (StringPrototypeCharCodeAt(from, fromStart + i,) === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      } else if (i === 0) {
        lastCommonSep = 0;
      }
    }
  }
  let out = '';
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || StringPrototypeCharCodeAt(from, i,) === CHAR_FORWARD_SLASH) {
      out += out.length === 0 ? '..' : '/..';
    }
  }
  return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep,)}`;
}
var allowAboveRoot = false;
var separator = '/';
var isPathSeparator = (code,) => code === CHAR_FORWARD_SLASH;
function normalizeString(path,) {
  let res = '';
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = StringPrototypeCharCodeAt(path, i,);
    } else if (isPathSeparator(code,)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator(code,)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (
          res.length < 2 || lastSegmentLength !== 2 || StringPrototypeCharCodeAt(res, res.length - 1,) !== CHAR_DOT ||
          StringPrototypeCharCodeAt(res, res.length - 2,) !== CHAR_DOT
        ) {
          if (res.length > 2) {
            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator,);
            if (lastSlashIndex === -1) {
              res = '';
              lastSegmentLength = 0;
            } else {
              res = StringPrototypeSlice(res, 0, lastSlashIndex,);
              lastSegmentLength = res.length - 1 - StringPrototypeLastIndexOf(res, separator,);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i,)}`;
        } else {
          res = StringPrototypeSlice(path, lastSlash + 1, i,);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function forwardCurrentQueryParams(href,) {
  const queryParamsString = typeof window !== 'undefined' ? window.location.search : '';
  if (!queryParamsString) {
    return href;
  }
  return forwardQueryParams(queryParamsString, href,);
}
function forwardQueryParams(queryParamsString, href,) {
  const startOfHash = href.indexOf('#',);
  const hrefWithoutHash = startOfHash === -1 ? href : href.substring(0, startOfHash,);
  const hash2 = startOfHash === -1 ? '' : href.substring(startOfHash,);
  const startOfSearch = hrefWithoutHash.indexOf('?',);
  if (startOfSearch === -1) {
    return hrefWithoutHash + queryParamsString + hash2;
  }
  const currentSearchParams = new URLSearchParams(queryParamsString,);
  const newSearchString = hrefWithoutHash.substring(startOfSearch + 1,);
  const newSearchParams = new URLSearchParams(newSearchString,);
  for (const [key7, value,] of currentSearchParams) {
    if (!newSearchParams.has(key7,)) {
      newSearchParams.append(key7, value,);
    }
  }
  return hrefWithoutHash.substring(0, startOfSearch + 1,) + newSearchParams.toString() + hash2;
}
function isObject(value,) {
  return typeof value === 'object' && value !== null && !Array.isArray(value,);
}
function isString2(value,) {
  return typeof value === 'string';
}
var preloadKey = 'preload';
function isLazyComponentType(componentType,) {
  return typeof componentType === 'object' && componentType !== null && !React22.isValidElement(componentType,) &&
    preloadKey in componentType;
}
function lazy(factory,) {
  const LazyComponent = React22.lazy(factory,);
  let factoryPromise;
  let LoadedComponent;
  const Component15 = React22.forwardRef(function LazyWithPreload(props, ref,) {
    return React22.createElement(
      LoadedComponent !== null && LoadedComponent !== void 0 ? LoadedComponent : LazyComponent,
      Object.assign(ref ? { ref, } : {}, props,),
    );
  },);
  Component15.preload = () => {
    if (!factoryPromise) {
      factoryPromise = factory().then((module,) => {
        LoadedComponent = module.default;
        return LoadedComponent;
      },);
    }
    return factoryPromise;
  };
  return Component15;
}
function getRouteElementId(route, hash2,) {
  if (hash2 && route) {
    if (route.elements && hash2 in route.elements) {
      return route.elements[hash2];
    } else {
      return hash2;
    }
  }
  return void 0;
}
function isBot(userAgent,) {
  return /bot|Mediapartners-Google|Google-PageRenderer|yandex|ia_archiver/i.test(userAgent,);
}
async function replacePathVariables(path, currentLocale, nextLocale, defaultLocale, collectionId, pathVariables, collectionUtils,) {
  var _a, _b, _c;
  let resultPath = path;
  let isMissingInLocale = false;
  const resultPathVariables = { ...pathVariables, };
  const matches = Array.from(resultPath.matchAll(pathVariablesRegExp,),);
  const replacements = await Promise.all(matches.map(async (match,) => {
    var _a2;
    const pathVariableWithDelimiter = match === null || match === void 0 ? void 0 : match[0];
    const pathVariableValue = match === null || match === void 0 ? void 0 : match[1];
    if (!pathVariableWithDelimiter || !pathVariableValue) {
      throw new Error('Failed to replace path variables: unexpected regex match group',);
    }
    const currentSlug = pathVariables[pathVariableValue];
    if (!currentSlug || !isString2(currentSlug,)) {
      throw new Error(`No slug found for path variable ${pathVariableValue}`,);
    }
    const utils =
      await ((_a2 = collectionUtils === null || collectionUtils === void 0 ? void 0 : collectionUtils[collectionId]) === null ||
          _a2 === void 0
        ? void 0
        : _a2.call(collectionUtils,));
    if (!utils || !currentLocale) {
      return currentSlug;
    }
    const recordId = await utils.getRecordIdBySlug(currentSlug, currentLocale,);
    if (!recordId) {
      return currentSlug;
    }
    const nextSlug = await utils.getSlugByRecordId(recordId, nextLocale,);
    if (!nextSlug) {
      isMissingInLocale = true;
      const defaultLocaleSlug = await utils.getSlugByRecordId(recordId, defaultLocale,);
      if (defaultLocaleSlug) {
        resultPathVariables[pathVariableValue] = defaultLocaleSlug;
      }
      return defaultLocaleSlug !== null && defaultLocaleSlug !== void 0 ? defaultLocaleSlug : currentSlug;
    }
    resultPathVariables[pathVariableValue] = nextSlug;
    return nextSlug;
  },),);
  let lastIndex = 0;
  let replacedPath = '';
  let hasMatch = false;
  for (let i = 0; i < matches.length; i++) {
    const match = matches[i];
    const replacement = replacements[i];
    if (!match || !replacement) {
      continue;
    }
    replacedPath += resultPath.substring(lastIndex, match.index,);
    lastIndex = ((_a = match.index) !== null && _a !== void 0 ? _a : 0) +
      ((_c = (_b = match[0]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);
    replacedPath += replacements[i];
    hasMatch = true;
  }
  if (hasMatch) {
    resultPath = replacedPath;
  }
  return {
    path: resultPath,
    pathVariables: resultPathVariables,
    isMissingInLocale,
  };
}
async function getLocalizedNavigationPath(
  { currentLocale, nextLocale, defaultLocale, route, pathVariables, collectionUtils, preserveQueryParams, },
) {
  const { path, } = route;
  let result = {
    path,
    pathVariables,
    isMissingInLocale: false,
  };
  if (!path) {
    return result;
  }
  if (pathVariables && route.collectionId) {
    try {
      const pathReplacement = await replacePathVariables(
        path,
        currentLocale,
        nextLocale,
        defaultLocale,
        route.collectionId,
        pathVariables,
        collectionUtils,
      );
      result = pathReplacement;
    } catch {
    }
  }
  if (nextLocale.slug) {
    result.path = '/' + nextLocale.slug + result.path;
  }
  if (preserveQueryParams && result.path) {
    result.path = forwardCurrentQueryParams(result.path,);
  }
  return result;
}
function getPageEffectForRoute(currentRouteId, nextRouteId, { global: global2, routes, },) {
  var _a;
  return ((_a = routes[currentRouteId]) === null || _a === void 0 ? void 0 : _a[nextRouteId]) || global2;
}
var defaultSitePageEffects = { global: void 0, routes: {}, };
var PageEffectsContext = React32.createContext(defaultSitePageEffects,);
function PageEffectsProvider({ children, value, },) {
  return React32.createElement(PageEffectsContext.Provider, { value, }, children,);
}
function usePageEffects() {
  return React32.useContext(PageEffectsContext,);
}
var step = 10;
var maxDuration3 = 1e4;
function createLinearEasing(generator,) {
  let time22 = step;
  let state = generator.next(0,);
  const keyframes2 = [state.value,];
  while (!state.done && time22 < maxDuration3) {
    state = generator.next(time22,);
    keyframes2.push(state.value,);
    time22 += step;
  }
  if (keyframes2.length === 1) {
    keyframes2.push(state.value,);
  }
  return {
    easing: `linear(${keyframes2.join(',',)})`,
    duration: time22 - step,
  };
}
var cssVariable = (name,) => `--view-transition-${name}`;
function parseUnit(value,) {
  return [parseFloat(value,), value.endsWith('px',) ? 'px' : '%',];
}
function calcMaskPosition(mask,) {
  const { innerWidth, innerHeight, } = window;
  const [x, xUnit,] = parseUnit(mask.x,);
  const [y, yUnit,] = parseUnit(mask.y,);
  return {
    x: xUnit === 'px' ? x : innerWidth * (x / 100),
    y: yUnit === 'px' ? y : innerHeight * (y / 100),
  };
}
var conic = {
  makeKeyframe: (mask, progress2, page,) => {
    let percentage = 0;
    if (
      page === 'exit' && mask.angularDirection === 'clockwise' && progress2 === 'start' ||
      page === 'exit' && mask.angularDirection === 'counter-clockwise' && progress2 === 'end' ||
      page === 'enter' && mask.angularDirection === 'counter-clockwise' && progress2 === 'start' ||
      page === 'enter' && mask.angularDirection === 'clockwise' && progress2 === 'end'
    ) {
      percentage = mask.sweepAngle / 360 * 100;
    }
    return `${cssVariable('conic-offset',)}: ${percentage}%;`;
  },
  makeStyles: (mask, page,) => {
    const offsetToken = `var(${cssVariable('conic-offset',)})`;
    const isTransparentToBlack = page === 'exit' && mask.angularDirection === 'clockwise' ||
      page === 'enter' && mask.angularDirection === 'counter-clockwise';
    const firstColor = isTransparentToBlack ? 'transparent' : 'black';
    const secondColor = isTransparentToBlack ? 'black' : 'transparent';
    let gradient = `conic-gradient(from `;
    gradient += `${mask.angle}deg at ${mask.x} ${mask.y}, `;
    gradient += `${firstColor} 0%, ${firstColor} ${offsetToken}, `;
    gradient += `${secondColor} ${offsetToken}, ${secondColor} 100%)`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => `
        @property ${cssVariable('conic-offset',)} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `,
};
var circle = {
  makeKeyframe: (mask, progress2,) => {
    const { x, y, } = calcMaskPosition(mask,);
    if (progress2 === 'start') {
      return `clip-path: circle(0 at ${x}px ${y}px);`;
    } else {
      const endRadius = Math.hypot(Math.max(x, window.innerWidth - x,), Math.max(y, window.innerHeight - y,),);
      return `clip-path: circle(${endRadius}px at ${x}px ${y}px);`;
    }
  },
};
var inset = {
  makeKeyframe: (mask, progress2,) => {
    const { x, y, } = calcMaskPosition(mask,);
    const bottom = window.innerHeight - y;
    const right = window.innerWidth - x;
    return progress2 === 'start'
      ? `clip-path: inset(${y}px ${right}px ${bottom}px ${x}px round ${mask.round}px);`
      : `clip-path: inset(0 round 0);`;
  },
};
var blinds = {
  makeKeyframe: (mask, progress2, page,) => {
    const [, unit,] = parseUnit(mask.width,);
    let width = `0${unit}`;
    if (progress2 === 'start' && page === 'exit' || progress2 === 'end' && page === 'enter') {
      width = mask.width;
    }
    return `${cssVariable('blinds-width',)}: ${width};`;
  },
  makeStyles: (mask, page,) => {
    const widthToken = `var(${cssVariable('blinds-width',)})`;
    const firstColor = page === 'exit' ? 'transparent' : 'black';
    const secondColor = page === 'exit' ? 'black' : 'transparent';
    let gradient = `repeating-linear-gradient(`;
    gradient += mask.angle + 90 + 'deg, ';
    gradient += `${firstColor} 0px, ${firstColor} ${widthToken}, `;
    gradient += `${secondColor} ${widthToken}, ${secondColor} ${mask.width})`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => {
    return `
            @property ${cssVariable('blinds-width',)} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `;
  },
};
var wipe = {
  makeKeyframe: (_mask, progress2, page,) => {
    const offset = progress2 === 'start' && page === 'exit' || progress2 === 'end' && page === 'enter' ? 1 : 0;
    return `${cssVariable('wipe-offset',)}: ${offset};`;
  },
  makeStyles: (mask, page,) => {
    const offsetToken = `var(${cssVariable('wipe-offset',)})`;
    const firstColor = page === 'exit' ? 'transparent' : 'black';
    const secondColor = page === 'exit' ? 'black' : 'transparent';
    let gradient = `linear-gradient(`;
    gradient += mask.angle + 90 + 'deg, ';
    gradient += `${firstColor} calc(calc(0% - ${mask.width}) + calc(calc(100% + ${mask.width}) * ${offsetToken})), `;
    gradient += `${secondColor} calc(calc(100% + ${mask.width}) * ${offsetToken}))`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => {
    return `
            @property ${cssVariable('wipe-offset',)} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `;
  },
};
var maskGenerators = { circle, conic, inset, blinds, wipe, };
var restState = {
  opacity: 1,
  x: '0px',
  y: '0px',
  scale: 1,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  mask: void 0,
};
function valuesToCSSKeyframes(values, progress2, page, maskGenerator,) {
  var _a;
  let keyframes2 = `
      opacity: ${values.opacity};
      transform: translate(${values.x}, ${values.y}) scale(${values.scale}) rotateX(${values.rotateX}deg) rotateY(${values.rotateY}deg) rotateZ(${values.rotate}deg);
    `;
  if (values.mask) {
    keyframes2 += ((_a = maskGenerator === null || maskGenerator === void 0 ? void 0 : maskGenerator.makeKeyframe) === null || _a === void 0
      ? void 0
      : _a.call(maskGenerator, values.mask, progress2, page,)) || '';
  }
  return keyframes2;
}
function getMaskGenerator(type,) {
  return type ? maskGenerators[type] : void 0;
}
function createPageTransitionRules(page, { transition, ...values },) {
  var _a;
  const name = 'view-transition-' + page;
  const settings = { duration: '0s', easing: 'linear', };
  if (transition.type === 'tween') {
    settings.duration = transition.duration + 's';
    settings.easing = `cubic-bezier(${transition.ease.join(',',)})`;
  } else if (transition.type === 'spring') {
    const { easing, duration, } = createLinearEasing(spring({
      keyframes: [0, 1,],
      stiffness: transition.stiffness,
      damping: transition.damping,
      mass: transition.mass,
      restDelta: 1e-3,
      restSpeed: 1e-4,
    },),);
    settings.duration = duration + 'ms';
    settings.easing = easing;
  }
  const maskGenerator = getMaskGenerator(
    (_a = values === null || values === void 0 ? void 0 : values.mask) === null || _a === void 0 ? void 0 : _a.type,
  );
  let startKeyframes = valuesToCSSKeyframes(values, 'start', page, maskGenerator,);
  let endKeyframes = valuesToCSSKeyframes({ ...restState, mask: values.mask, }, 'end', page, maskGenerator,);
  if (page === 'exit') {
    [startKeyframes, endKeyframes,] = [endKeyframes, startKeyframes,];
  }
  return `
        ${
    values.mask && (maskGenerator === null || maskGenerator === void 0 ? void 0 : maskGenerator.makePropertyRules)
      ? maskGenerator.makePropertyRules(values.mask,)
      : ''
  }

        @keyframes ${name} {
            0% {
                ${startKeyframes}
            }

            100% {
                ${endKeyframes}
            }
        }

        ::view-transition-${page === 'enter' ? 'new' : 'old'}(root) {
            animation-name: ${name};
            animation-duration: ${settings.duration};
            animation-delay: ${transition.delay}s;
            animation-timing-function: ${settings.easing};
            animation-fill-mode: both;
            ${
    values.mask && (maskGenerator === null || maskGenerator === void 0 ? void 0 : maskGenerator.makeStyles)
      ? maskGenerator.makeStyles(values.mask, page,)
      : ''
  }
        }
    `;
}
var VIEW_TRANSITION_STYLES_ID = 'view-transition-styles';
var defaultPageTransition = {
  x: '0px',
  y: '0px',
  scale: 1,
  opacity: 1,
  rotate3d: false,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  mask: void 0,
  transition: {
    type: 'tween',
    delay: 0,
    duration: 0.2,
    ease: [0.27, 0, 0.51, 1,],
    stiffness: 400,
    damping: 30,
    mass: 1,
  },
};
function createViewTransitionStylesheet({ exit = defaultPageTransition, enter, },) {
  const styleElement = document.createElement('style',);
  styleElement.id = VIEW_TRANSITION_STYLES_ID;
  let styleContent = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `;
  const disableMixPlusLighter = exit.mask || enter.mask || exit.opacity || enter.opacity || exit.transition.delay || enter.transition.delay;
  if (disableMixPlusLighter) {
    styleContent += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `;
  }
  styleContent += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `;
  styleContent += createPageTransitionRules('exit', exit,);
  styleContent += createPageTransitionRules('enter', enter,);
  styleElement.textContent = styleContent;
  document.head.appendChild(styleElement,);
}
function removeViewTransitionStylesheet() {
  frame.render(() => {
    const element = document.getElementById(VIEW_TRANSITION_STYLES_ID,);
    if (element) {
      document.head.removeChild(element,);
    }
  },);
}
function supportsViewTransitions() {
  return Boolean(document.startViewTransition,);
}
function startViewTransition(updateView, effect,) {
  if (!supportsViewTransitions()) {
    return void updateView();
  }
  createViewTransitionStylesheet(effect,);
  const transition = document.startViewTransition(updateView,);
  Promise.all([transition.ready, transition.finished,],).then(removeViewTransitionStylesheet,).catch(() => {
  },);
  return transition;
}
function useViewTransition() {
  const sitePageEffects = usePageEffects();
  const resolveHasPainted = useRef13(void 0,);
  useEffect16(() => {
    if (resolveHasPainted.current) {
      resolveHasPainted.current();
      resolveHasPainted.current = void 0;
    }
  },);
  return useCallback5((currentRouteId, nextRouteId, update,) => {
    const pageEffect = getPageEffectForRoute(currentRouteId, nextRouteId, sitePageEffects,);
    if (pageEffect) {
      const hasPainted = new Promise((resolve,) => {
        resolveHasPainted.current = resolve;
      },);
      const asyncUpdate = async () => {
        update();
        await hasPainted;
      };
      return startViewTransition(asyncUpdate, pageEffect,);
    } else {
      return update();
    }
  }, [sitePageEffects,],);
}
function pushRouteState(
  routeId,
  route,
  { currentRoutePath, currentPathVariables, hash: hash2, pathVariables, localeId, preserveQueryParams, },
) {
  const { path, } = route;
  if (!path) {
    return;
  }
  try {
    const newPath = getPathForRoute(route, {
      currentRoutePath,
      currentPathVariables,
      hash: hash2,
      pathVariables,
      preserveQueryParams,
    },);
    pushHistoryState({ routeId, hash: hash2, pathVariables, localeId, }, newPath,);
  } catch {
  }
}
function replaceHistoryState(data2, url,) {
  window.history.replaceState(
    data2,
    // Second arg is unused and exists for historical purposes only
    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState#unused
    '',
    url,
  );
}
function pushHistoryState(data2, url,) {
  window.history.pushState(
    data2,
    // Second arg is unused and exists for historical purposes only
    // https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#unused
    '',
    url,
  );
}
function useReplaceInitialState({ disabled, routeId, initialPathVariables, initialLocaleId, },) {
  React42.useLayoutEffect(() => {
    if (disabled) {
      return;
    }
    replaceHistoryState({ routeId, pathVariables: initialPathVariables, localeId: initialLocaleId, },);
  }, [],);
}
function usePopStateHandler(currentRouteId, setCurrentRouteId,) {
  const startViewTransition2 = useViewTransition();
  const viewTransitionReady = React42.useRef(void 0,);
  const popStateHandler = React42.useCallback(({ state, },) => {
    var _a, _b, _c;
    if (!isObject(state,)) {
      return;
    }
    const { routeId, hash: hash2, pathVariables, localeId, } = state;
    if (!isString2(routeId,)) {
      return;
    }
    const changeRoute = () => {
      setCurrentRouteId(
        routeId,
        isString2(localeId,) ? localeId : void 0,
        isString2(hash2,) ? hash2 : void 0,
        isObject(pathVariables,) ? pathVariables : void 0,
        false,
        true,
      );
    };
    const transition = startViewTransition2(currentRouteId.current, routeId, changeRoute,);
    if (transition) {
      void transition.updateCallbackDone.then((_a = viewTransitionReady.current) === null || _a === void 0 ? void 0 : _a.resolve,).catch(
        (_b = viewTransitionReady.current) === null || _b === void 0 ? void 0 : _b.reject,
      );
    } else {
      (_c = viewTransitionReady.current) === null || _c === void 0 ? void 0 : _c.resolve();
    }
  }, [currentRouteId, setCurrentRouteId, startViewTransition2,],);
  const traversalHandler = useCallback22((event,) => {
    if (event.navigationType !== 'traverse') {
      return;
    }
    event.intercept({
      async handler() {
        await new Promise((resolve, reject,) => {
          viewTransitionReady.current = { resolve, reject, };
        },);
      },
      scroll: 'after-transition',
    },);
  }, [],);
  React42.useEffect(() => {
    var _a;
    window.addEventListener('popstate', popStateHandler,);
    (_a = window.navigation) === null || _a === void 0 ? void 0 : _a.addEventListener('navigate', traversalHandler,);
    return () => {
      var _a2;
      window.removeEventListener('popstate', popStateHandler,);
      (_a2 = window.navigation) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener('navigate', traversalHandler,);
    };
  }, [popStateHandler, traversalHandler,],);
}
function getHashForRoute(hash2, route, hashVariables,) {
  const resolvedHash = getRouteElementId(route, hash2,);
  if (!resolvedHash) {
    return void 0;
  }
  const variables = Object.assign({}, route === null || route === void 0 ? void 0 : route.elements, hashVariables,);
  return resolvedHash.replace(pathVariablesRegExp, (m2, p1,) => {
    var _a;
    return String((_a = variables[p1]) !== null && _a !== void 0 ? _a : m2,);
  },);
}
function getPathForRoute(
  route,
  { currentRoutePath, currentPathVariables, hash: hash2, pathVariables, hashVariables, relative: relative2 = true, preserveQueryParams, },
) {
  var _a;
  let currentPath = currentRoutePath !== null && currentRoutePath !== void 0 ? currentRoutePath : '/';
  if (currentPathVariables) {
    currentPath = currentPath.replace(pathVariablesRegExp, (m2, p1,) => {
      var _a2;
      return String((_a2 = currentPathVariables[p1]) !== null && _a2 !== void 0 ? _a2 : m2,);
    },);
  }
  const targetPath = (_a = route === null || route === void 0 ? void 0 : route.path) !== null && _a !== void 0 ? _a : '/';
  let path = targetPath;
  if (pathVariables) {
    path = path.replace(pathVariablesRegExp, (m2, p1,) => {
      var _a2;
      return String((_a2 = pathVariables[p1]) !== null && _a2 !== void 0 ? _a2 : m2,);
    },);
  }
  const resolvedHash = getHashForRoute(hash2, route, hashVariables,);
  const isSamePageHashNavigation = currentPath === path && resolvedHash;
  if (relative2) {
    path = computeRelativePath(currentPath, path,);
  }
  if (preserveQueryParams || isSamePageHashNavigation) {
    path = forwardCurrentQueryParams(path,);
  }
  if (resolvedHash) {
    path = `${path}#${resolvedHash}`;
  }
  return path;
}
async function handleRedirectForMissingSlugs(route, pathVariables, nextLocale,) {
  if (!route.path) {
    return false;
  }
  if (!pathVariables) {
    return false;
  }
  const prefix2 = nextLocale.slug ? `/${nextLocale.slug}` : '';
  const nextLocaleWithDefaultSlugPath = `${prefix2}${fillPathVariables(route.path, pathVariables,)}`;
  const response = await fetch(nextLocaleWithDefaultSlugPath, {
    method: 'HEAD',
    redirect: 'manual',
  },);
  const isRedirect = response.type === 'opaqueredirect';
  if (isRedirect) {
    window.location.href = window.location.origin + nextLocaleWithDefaultSlugPath;
    return true;
  }
  return false;
}
async function switchLocale(options,) {
  const result = await getLocalizedNavigationPath(options,);
  if (!result) {
    return;
  }
  try {
    localStorage.setItem('preferredLocale', options.nextLocale.code,);
  } catch (error) {
  }
  try {
    if (typeof result.path !== 'string') {
      throw new Error('Expected result.path to be a string',);
    }
    if (result.isMissingInLocale) {
      const hasRedirect = await handleRedirectForMissingSlugs(options.route, result.pathVariables, options.nextLocale,);
      if (hasRedirect) {
        return;
      }
    }
    pushHistoryState({ routeId: options.routeId, pathVariables: result.pathVariables, localeId: options.nextLocale.id, }, result.path,);
  } catch {
  }
  return result;
}
function isSamePage(a, b,) {
  if (a.routeId !== b.routeId) {
    return false;
  }
  if (a.pathVariables === b.pathVariables) {
    return true;
  }
  const aPathVariables = a.pathVariables || {};
  const bPathVariables = b.pathVariables || {};
  return aPathVariables.length === bPathVariables.length &&
    Object.keys(aPathVariables,).every((key7,) => aPathVariables[key7] === bPathVariables[key7]);
}
function useGetRouteCallback(routes,) {
  return React52.useCallback((routeId,) => routes[routeId], [routes,],);
}
var RouterContext = React62.createContext({},);
function RouterAPIProvider({ api, children, },) {
  return React62.createElement(RouterContext.Provider, { value: api, }, children,);
}
function useRouter() {
  return React62.useContext(RouterContext,);
}
function RoutesProvider({ routes, children, },) {
  const getRoute = useGetRouteCallback(routes,);
  return React62.createElement(RouterContext.Provider, { value: { getRoute, }, }, children,);
}
var SuspenseErrorBoundary = class extends Component22 {
  constructor(props,) {
    super(props,);
    this.state = { error: void 0, };
  }
  static getDerivedStateFromError(error,) {
    return { error, };
  }
  componentDidCatch(error, errorInfo,) {
    var _a;
    console.error(
      'Error in SuspenseThatPreservesDom. That likely hints to some set state that has not been wrapped in startTransition.',
      error,
      errorInfo,
    );
    (_a = window.__framer_events) === null || _a === void 0 ? void 0 : _a.push([
      'published_site_load_recoverable_error',
      {
        message: String(error,),
        componentStack: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack,
      },
    ],);
  }
  render() {
    if (this.state.error === void 0) {
      return this.props.children;
    }
    return React72.createElement(Suspense, null, this.props.fallbackChildren,);
  }
};
var suspendPromise = typeof window !== 'undefined'
  ? new Promise(() => {
  },)
  : null;
function Suspend() {
  if (typeof window === 'undefined') {
    return null;
  }
  throw suspendPromise;
}
function SuspenseThatPreservesDom({ children, },) {
  return React82.createElement(
    SuspenseErrorBoundary,
    { fallbackChildren: children, },
    React82.createElement(Suspense2, { fallback: React82.createElement(Suspend, null,), }, children,),
  );
}
var defaultLocaleId = 'default';
function useForceUpdate2() {
  const [_, setForcedRenderCount,] = React92.useState(0,);
  return [_, React92.useCallback(() => setForcedRenderCount((v,) => v + 1), [],),];
}
var noopAsync = async () => {
};
var defaultLocaleInfo = {
  activeLocale: null,
  locales: [],
  setLocale: noopAsync,
};
var LocaleInfoContext = /* @__PURE__ */ React102.createContext(defaultLocaleInfo,);
function useLocaleInfo() {
  return React102.useContext(LocaleInfoContext,);
}
function useLocalizationInfo() {
  const { activeLocale, locales, setLocale, } = useLocaleInfo();
  return {
    activeLocalization: activeLocale,
    localizations: locales,
    setLocalization: setLocale,
  };
}
function useLocaleCode() {
  var _a, _b;
  return (_b = (_a = useLocaleInfo().activeLocale) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : 'en-US';
}
function useLocale() {
  return useLocaleCode();
}
function updateScrollPosition(hash2, smoothScroll, isHistoryTransition,) {
  const element = hash2 && document.getElementById(hash2,);
  if (element) {
    scrollElementIntoView(element, smoothScroll,);
    return;
  }
  if (isHistoryTransition) {
    return;
  }
  window.scrollTo(0, 0,);
}
function useScheduleRenderSideEffects(dep,) {
  const actions = React112.useRef([],);
  React112.useLayoutEffect(() => {
    var _a;
    if (!((_a = actions.current) === null || _a === void 0 ? void 0 : _a.length)) {
      return;
    }
    actions.current.forEach((action,) => action());
    actions.current = [];
  }, [dep,],);
  return React112.useCallback((cb,) => {
    actions.current.push(cb,);
  }, [],);
}
function Router(
  {
    defaultPageStyle,
    disableHistory,
    initialPathVariables,
    initialRoute,
    notFoundPage,
    collectionUtils,
    routes,
    initialLocaleId,
    locales = [],
    preserveQueryParams = false,
    enableSuspenseThatPreservesDom,
  },
) {
  useReplaceInitialState({
    disabled: disableHistory,
    routeId: initialRoute,
    initialPathVariables,
    initialLocaleId,
  },);
  const startViewTransition2 = useViewTransition();
  const currentRouteRef = React112.useRef(initialRoute,);
  const currentPathVariablesRef = React112.useRef(initialPathVariables,);
  const currentLocaleIdRef = React112.useRef(initialLocaleId,);
  const currentLocaleId = currentLocaleIdRef.current;
  const activeLocale = React112.useMemo(() => {
    var _a;
    return (_a = locales.find(({ id: id3, },) => {
            if (!currentLocaleId) {
              return id3 === defaultLocaleId;
            }
            return id3 === currentLocaleId;
          },)) !== null && _a !== void 0
      ? _a
      : null;
  }, [currentLocaleId, locales,],);
  const [dep, forceUpdate,] = useForceUpdate2();
  const localeInfo = React112.useMemo(() => {
    return {
      activeLocale,
      locales,
      setLocale: async (localeOrLocaleId,) => {
        let localeId;
        if (isString2(localeOrLocaleId,)) {
          localeId = localeOrLocaleId;
        } else if (isObject(localeOrLocaleId,)) {
          localeId = localeOrLocaleId.id;
        }
        const defaultLocale = locales.find(({ id: id3, },) => id3 === defaultLocaleId);
        const nextLocale = locales.find(({ id: id3, },) => id3 === localeId);
        if (!nextLocale) {
          return;
        }
        const currentRouteId2 = currentRouteRef.current;
        const currentRoute = routes[currentRouteId2];
        if (!currentRoute) {
          return;
        }
        try {
          const localeResult = await switchLocale({
            currentLocale: activeLocale,
            nextLocale,
            route: currentRoute,
            routeId: currentRouteId2,
            defaultLocale,
            pathVariables: currentPathVariablesRef.current,
            collectionUtils,
            preserveQueryParams,
          },);
          if (!localeResult) {
            return;
          }
          currentPathVariablesRef.current = localeResult.pathVariables;
          currentLocaleIdRef.current = nextLocale.id;
          startViewTransition2(currentRouteRef.current, currentRouteId2, () => startTransition2(forceUpdate,),);
        } catch {
        }
      },
    };
  }, [activeLocale, collectionUtils, forceUpdate, locales, routes, startViewTransition2, preserveQueryParams,],);
  const scheduleSideEffect = useScheduleRenderSideEffects(dep,);
  const setCurrentRouteId = React112.useCallback(
    (routeId, localeId, hash2, pathVariables, smoothScroll = false, isHistoryTransition = false,) => {
      currentRouteRef.current = routeId;
      currentPathVariablesRef.current = pathVariables;
      currentLocaleIdRef.current = localeId;
      scheduleSideEffect(() => {
        updateScrollPosition(hash2, smoothScroll, isHistoryTransition,);
      },);
      startTransition2(forceUpdate,);
    },
    [forceUpdate, scheduleSideEffect,],
  );
  usePopStateHandler(currentRouteRef, setCurrentRouteId,);
  const navigate = React112.useCallback((routeId, hash2, pathVariables, smoothScroll,) => {
    var _a, _b;
    const newRoute = routes[routeId];
    if (pathVariables) {
      const inUse = /* @__PURE__ */ new Set();
      const path = (_a = newRoute === null || newRoute === void 0 ? void 0 : newRoute.path) !== null && _a !== void 0 ? _a : '/';
      for (const match of path.matchAll(pathVariablesRegExp,)) {
        const usedVariable = match[1];
        if (usedVariable === void 0) {
          throw new Error('A matching path variable should not be undefined',);
        }
        inUse.add(usedVariable,);
      }
      pathVariables = Object.fromEntries(Object.entries(pathVariables,).filter(([key7,],) => inUse.has(key7,)),);
    }
    const routeElementId = getRouteElementId(newRoute, hash2,);
    if (
      isSamePage({
        routeId: currentRouteRef.current,
        pathVariables: currentPathVariablesRef.current,
      }, { routeId, pathVariables, },)
    ) {
      if (((_b = window.history.state) === null || _b === void 0 ? void 0 : _b.hash) !== hash2) {
        if (!disableHistory) {
          const route = routes[routeId];
          if (route) {
            pushRouteState(routeId, route, {
              currentRoutePath: route.path,
              currentPathVariables: currentPathVariablesRef.current,
              pathVariables,
              hash: hash2,
              localeId: currentLocaleIdRef.current,
              preserveQueryParams,
            },);
          }
        }
      }
      updateScrollPosition(routeElementId, smoothScroll, false,);
      return;
    }
    if (!newRoute) {
      return;
    }
    if (!disableHistory) {
      const currentRoute = routes[currentRouteRef.current];
      pushRouteState(routeId, newRoute, {
        currentRoutePath: currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.path,
        currentPathVariables: currentPathVariablesRef.current,
        hash: hash2,
        pathVariables,
        localeId: currentLocaleIdRef.current,
        preserveQueryParams,
      },);
    }
    const changeRoute = () => setCurrentRouteId(routeId, currentLocaleIdRef.current, routeElementId, pathVariables, smoothScroll, false,);
    startViewTransition2(currentRouteRef.current, routeId, changeRoute,);
  }, [routes, disableHistory, setCurrentRouteId, startViewTransition2, preserveQueryParams,],);
  const getRoute = useGetRouteCallback(routes,);
  const currentRouteId = currentRouteRef.current;
  const currentPathVariables = currentPathVariablesRef.current;
  const api = React112.useMemo(() => ({
    navigate,
    getRoute,
    currentRouteId,
    currentPathVariables,
    routes,
    collectionUtils,
    preserveQueryParams,
  }), [navigate, getRoute, currentRouteId, currentPathVariables, routes, collectionUtils, preserveQueryParams,],);
  const current = routes[currentRouteRef.current];
  if (!current) {
    throw new Error(`Router cannot find route for ${currentRouteRef.current}`,);
  }
  const pageExistsInCurrentLocale = !activeLocale || !current.includedLocales || current.includedLocales.includes(activeLocale.id,);
  const pathWithFilledVariables = current.path && currentPathVariables
    ? fillPathVariables(current.path, currentPathVariables,)
    : current.path;
  const remountKey = String(currentLocaleId,) + pathWithFilledVariables;
  const suspenseChildren = React112.createElement(
    ErrorBoundary,
    { notFoundPage, defaultPageStyle, forceUpdateKey: dep, },
    React112.createElement(
      React112.Fragment,
      { key: remountKey, },
      pageExistsInCurrentLocale ? renderPage(current.page, defaultPageStyle,) : notFoundPage && renderPage(notFoundPage, defaultPageStyle,),
    ),
  );
  return React112.createElement(
    RouterAPIProvider,
    { api, },
    React112.createElement(
      LocaleInfoContext.Provider,
      { value: localeInfo, },
      enableSuspenseThatPreservesDom
        ? React112.createElement(SuspenseThatPreservesDom, null, suspenseChildren,)
        : React112.createElement(React112.Suspense, { fallback: null, }, suspenseChildren,),
    ),
  );
}
function scrollElementIntoView(element, smoothScroll,) {
  const scrollIntoViewOptions = smoothScroll ? { behavior: 'smooth', block: 'start', inline: 'nearest', } : void 0;
  element.scrollIntoView(scrollIntoViewOptions,);
}
var memoPathRoutes;
var memoPaths;
var lastRoutes;
function getRouteInfoMemo(routes,) {
  if (lastRoutes !== routes) {
    memoPathRoutes = {};
    for (const [routeId, { path, },] of Object.entries(routes,)) {
      if (path) {
        memoPathRoutes[path] = { path, depth: pathDepth(path,), routeId, };
      }
    }
    memoPaths = Object.values(memoPathRoutes,);
    memoPaths.sort(({ depth: depth1, }, { depth: depth2, },) => depth2 - depth1);
    lastRoutes = routes;
  }
  return [memoPathRoutes, memoPaths,];
}
function inferInitialRouteFromPath(routes, decodedLocationPath, fallback = true, locales = [],) {
  const [pathRoutes, paths,] = getRouteInfoMemo(routes,);
  let activeLocale;
  let localeId;
  let locationPath = decodedLocationPath;
  if (locales.length > 0) {
    const firstPathSegment = locationPath.split('/',).find(Boolean,);
    if (firstPathSegment) {
      activeLocale = locales.find(({ slug, },) => slug === firstPathSegment);
      if (activeLocale) {
        localeId = activeLocale.id;
        locationPath = locationPath.substring(activeLocale.slug.length + 1,);
      }
    }
    if (!localeId) {
      const defaultLocale = locales.find(({ slug, },) => slug === '');
      if (defaultLocale) {
        localeId = defaultLocale.id;
      }
    }
  }
  const exactMatch = pathRoutes[locationPath];
  if (exactMatch) {
    const match = matchPath(locationPath, exactMatch.path,);
    if (match.isMatch) {
      return { routeId: exactMatch.routeId, localeId, pathVariables: match.pathVariables, };
    }
  }
  for (const { path, routeId, } of paths) {
    const match = matchPath(locationPath, path,);
    if (match.isMatch) {
      return { routeId, localeId, pathVariables: match.pathVariables, };
    }
  }
  if (!fallback) {
    throw new Error('No exact match found for path',);
  }
  const rootPath = pathRoutes['/'];
  if (rootPath) {
    return { routeId: rootPath.routeId, localeId, };
  }
  const firstRoute = Object.keys(routes,)[0];
  if (!firstRoute) {
    throw new Error('Router should not have undefined routes',);
  }
  return { routeId: firstRoute, localeId, };
}
function pathDepth(path,) {
  const pathWithTrimmedSlashes = path.replace(/^\/|\/$/g, '',);
  if (pathWithTrimmedSlashes === '') {
    return 0;
  }
  return pathWithTrimmedSlashes.split('/',).length;
}
function matchPath(path, routePath,) {
  const pathVariablesKeys = [];
  const safeRoutePath = escapeStringRegExp(routePath,);
  const routePathRegExpString = safeRoutePath.replace(pathVariablesRegExp, (_, name,) => {
    pathVariablesKeys.push(name,);
    return '([^/]+)';
  },);
  const routePathRegExp = new RegExp(routePathRegExpString + '$',);
  const matches = path.match(routePathRegExp,);
  if (!matches) {
    return { isMatch: false, };
  }
  if (matches.length === 1) {
    return { isMatch: true, };
  }
  const pathVariables = {};
  const pathVariablesValues = matches.slice(1,);
  for (let i = 0; i < pathVariablesKeys.length; ++i) {
    const key7 = pathVariablesKeys[i];
    if (key7 === void 0) {
      continue;
    }
    const value = pathVariablesValues[i];
    const existingValue = pathVariables[key7];
    if (existingValue) {
      if (existingValue !== value) {
        return { isMatch: false, };
      } else {
        continue;
      }
    }
    if (value === void 0) {
      throw new Error('Path variable values cannot be undefined',);
    }
    pathVariables[key7] = value;
  }
  return { isMatch: true, pathVariables, };
}
function escapeStringRegExp(string,) {
  return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&',).replace(/-/g, '\\x2d',);
}
var key = 'page';
function isRoute(route,) {
  return isObject(route,) && key in route && route.page !== void 0;
}
var CurrentRouteContext = React122.createContext(void 0,);
function useCurrentRoute() {
  var _a;
  const router = useRouter();
  const override = useContext16(CurrentRouteContext,);
  const id3 = override !== null && override !== void 0 ? override : router.currentRouteId;
  if (!id3) {
    return void 0;
  }
  const route = (_a = router.getRoute) === null || _a === void 0 ? void 0 : _a.call(router, id3,);
  if (!route) {
    return void 0;
  }
  return {
    ...route,
    id: id3,
    pathVariables: override ? void 0 : router.currentPathVariables,
  };
}
function useCurrentRouteId() {
  var _a;
  return (_a = useCurrentRoute()) === null || _a === void 0 ? void 0 : _a.id;
}
function useCurrentPathVariables() {
  var _a;
  return (_a = useCurrentRoute()) === null || _a === void 0 ? void 0 : _a.pathVariables;
}
function useRoute(routeId,) {
  var _a;
  const routerAPI = useRouter();
  if (!routeId) {
    return void 0;
  }
  return (_a = routerAPI.getRoute) === null || _a === void 0 ? void 0 : _a.call(routerAPI, routeId,);
}
var shouldPreloadBasedOnUA = typeof window !== 'undefined' && !isBot(navigator.userAgent,);
function useRoutePreloader(routeIds, enabled = true,) {
  const { getRoute, } = useRouter();
  React13.useEffect(() => {
    if (!getRoute || !enabled || !shouldPreloadBasedOnUA) {
      return;
    }
    for (const routeId of routeIds) {
      const route = getRoute(routeId,);
      if (route === null || route === void 0 ? void 0 : route.page) {
        preloadComponent(route.page,);
      }
    }
  }, [routeIds, getRoute, enabled,],);
}
function preloadComponent(component,) {
  if (!shouldPreloadBasedOnUA) {
    return;
  }
  if (isLazyComponentType(component,)) {
    void component.preload();
  }
}
function useRouteAnchor(routeId, { elementId, hash: linkHash, } = {},) {
  const { navigate, currentPathVariables, preserveQueryParams, } = useRouter();
  const route = useRoute(routeId,);
  const currentRouteId = useCurrentRouteId();
  const currentRoute = useRoute(currentRouteId !== null && currentRouteId !== void 0 ? currentRouteId : '',);
  useRoutePreloader([routeId,], true,);
  const hash2 = linkHash !== null && linkHash !== void 0 ? linkHash : elementId;
  const href = React14.useMemo(() =>
    getPathForRoute(route, {
      currentRoutePath: currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.path,
      currentPathVariables,
      hash: hash2,
      preserveQueryParams,
    },), [currentRoute, currentPathVariables, hash2, preserveQueryParams, route,],);
  const navigateToRoute = React14.useCallback(() => navigate === null || navigate === void 0 ? void 0 : navigate(routeId, hash2,), [
    hash2,
    navigate,
    routeId,
  ],);
  const onClick = React14.useCallback((event,) => {
    event.preventDefault();
    navigateToRoute();
  }, [navigateToRoute,],);
  return { onClick, href, };
}
function useRouteElementId(id3, targetRouteId,) {
  var _a;
  const currentRoute = useCurrentRoute();
  const route = (_a = useRoute(targetRouteId,)) !== null && _a !== void 0 ? _a : currentRoute;
  return React15.useMemo(() => {
    if (!route) {
      return id3;
    }
    return getRouteElementId(route, id3,);
  }, [id3, route,],);
}
function useRouteHandler(routeId, preload = false, elementId,) {
  const { navigate, } = useRouter();
  useRoutePreloader([routeId,], preload,);
  const handler = React16.useCallback(() => navigate === null || navigate === void 0 ? void 0 : navigate(routeId, elementId,), [
    navigate,
    elementId,
    routeId,
  ],);
  return handler;
}
var warningMessages = /* @__PURE__ */ new Set();
function warnOnce2(keyMessage, ...rest) {
  if (warningMessages.has(keyMessage,)) {
    return;
  }
  warningMessages.add(keyMessage,);
  console.warn(keyMessage, ...rest,);
}
function deprecationWarning(removedItem, removalVersion, replacement,) {
  const replacementText = replacement ? `, use ${replacement} instead` : '';
  const warningText = `Deprecation warning: ${removedItem} will be removed in version ${removalVersion}${replacementText}.`;
  warnOnce2(warningText,);
}
var Observers = class {
  constructor() {
    __publicField(this, 'observers', /* @__PURE__ */ new Set(),);
    __publicField(this, 'transactions', {},);
  }
  add(observer2,) {
    this.observers.add(observer2,);
    let isCalled = false;
    return () => {
      if (isCalled) {
        return;
      }
      isCalled = true;
      this.remove(observer2,);
    };
  }
  remove(observer2,) {
    this.observers.delete(observer2,);
  }
  notify(change, transaction,) {
    if (transaction) {
      const accumulatedChange = this.transactions[transaction] || change;
      accumulatedChange.value = change.value;
      this.transactions[transaction] = accumulatedChange;
    } else {
      this.callObservers(change,);
    }
  }
  finishTransaction(transaction,) {
    const accumulatedChange = this.transactions[transaction];
    delete this.transactions[transaction];
    return this.callObservers(accumulatedChange, transaction,);
  }
  callObservers(change, transaction,) {
    const finishObservers = [];
    new Set(this.observers,).forEach((observer2,) => {
      if (typeof observer2 === 'function') {
        observer2(change, transaction,);
      } else {
        observer2.update(change, transaction,);
        finishObservers.push(observer2.finish,);
      }
    },);
    return finishObservers;
  }
};
var Animatable = /* @__PURE__ */ (() => {
  function Animatable2(value,) {
    deprecationWarning('Animatable()', '2.0.0', 'the new animation API (https://www.framer.com/api/animation/)',);
    return isAnimatable2(value,) ? value : new AnimatableValue(value,);
  }
  Animatable2.transaction = (update,) => {
    const transactionId = Math.random();
    const updatedValues = /* @__PURE__ */ new Set();
    const updater = (animatable, value,) => {
      animatable.set(value, transactionId,);
      updatedValues.add(animatable,);
    };
    update(updater, transactionId,);
    const finishObservers = [];
    updatedValues.forEach((value,) => {
      finishObservers.push(...value.finishTransaction(transactionId,),);
    },);
    finishObservers.forEach((finish,) => {
      finish(transactionId,);
    },);
  };
  Animatable2.getNumber = (value, defaultValue = 0,) => {
    return Animatable2.get(value, defaultValue,);
  };
  Animatable2.get = (value, defaultValue,) => {
    if (value === void 0 || value === null) {
      return defaultValue;
    }
    if (isAnimatable2(value,)) {
      return value.get();
    }
    return value;
  };
  Animatable2.objectToValues = (object,) => {
    if (!object) {
      return object;
    }
    const result = {};
    for (const key7 in object) {
      const value = object[key7];
      if (isAnimatable2(value,)) {
        result[key7] = value.get();
      } else {
        result[key7] = value;
      }
    }
    return result;
  };
  return Animatable2;
})();
var onUpdateKey = 'onUpdate';
var finishTransactionKey = 'finishTransaction';
function isAnimatable2(value,) {
  return value !== null && typeof value === 'object' && onUpdateKey in value && value[onUpdateKey] instanceof Function &&
    finishTransactionKey in value && value[finishTransactionKey] instanceof Function;
}
function animatableInterpolation(value, currentInterpolation,) {
  return {
    interpolate(from, to,) {
      const fromValue = from.get();
      const toValue = to.get();
      const result = Animatable(fromValue,);
      return (progress2,) => {
        const v = currentInterpolation.interpolate(fromValue, toValue,)(progress2,);
        result.set(v,);
        return result;
      };
    },
    difference(from, to,) {
      const v = from.get();
      return currentInterpolation.difference(v, to.get(),);
    },
  };
}
var AnimatableValue = class {
  constructor(value,) {
    this.value = value;
    __publicField(this, 'observers', new Observers(),);
  }
  static interpolationFor(value, currentInterpolation,) {
    if (isAnimatable2(value,)) {
      return animatableInterpolation(value, currentInterpolation,);
    }
  }
  get() {
    return this.value;
  }
  set(value, transaction,) {
    const oldValue = this.value;
    if (isAnimatable2(value,)) {
      value = value.get();
    }
    this.value = value;
    const change = {
      value,
      oldValue,
    };
    this.observers.notify(change, transaction,);
  }
  finishTransaction(transaction,) {
    return this.observers.finishTransaction(transaction,);
  }
  onUpdate(handler,) {
    return this.observers.add(handler,);
  }
};
function roundedNumber(value, decimals,) {
  const d = Math.round(Math.abs(decimals,),);
  const multiplier = 10 ** d;
  return Math.round(value * multiplier,) / multiplier;
}
function roundedNumberString(value, decimals,) {
  const result = value.toFixed(decimals,);
  return decimals === 0 ? result : `${+result}`;
}
function roundWithOffset(value, offset,) {
  if (offset === 0) {
    return Math.round(value,);
  }
  offset -= offset | 0;
  if (offset < 0) {
    offset = 1 - offset;
  }
  return Math.round(value - offset,) + offset;
}
function Point(x, y,) {
  return { x, y, };
}
((Point2,) => {
  Point2.add = (...args) => {
    return args.reduce(
      (previousValue, currentValue,) => {
        return { x: previousValue.x + currentValue.x, y: previousValue.y + currentValue.y, };
      },
      { x: 0, y: 0, },
    );
  };
  Point2.subtract = (a, b,) => {
    return { x: a.x - b.x, y: a.y - b.y, };
  };
  Point2.multiply = (a, b,) => {
    return { x: a.x * b, y: a.y * b, };
  };
  Point2.divide = (a, b,) => {
    return { x: a.x / b, y: a.y / b, };
  };
  Point2.absolute = (point2,) => {
    return {
      x: Math.abs(point2.x,),
      y: Math.abs(point2.y,),
    };
  };
  Point2.reverse = (point2,) => {
    return {
      x: point2.x * -1,
      y: point2.y * -1,
    };
  };
  Point2.pixelAligned = (point2, offset = { x: 0, y: 0, },) => {
    return {
      x: roundWithOffset(point2.x, offset.x,),
      y: roundWithOffset(point2.y, offset.y,),
    };
  };
  Point2.distance = (a, b,) => {
    const deltaX = Math.abs(a.x - b.x,);
    const deltaY = Math.abs(a.y - b.y,);
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY,);
  };
  Point2.angle = (a, b,) => {
    return Math.atan2(b.y - a.y, b.x - a.x,) * 180 / Math.PI - 90;
  };
  Point2.isEqual = (a, b,) => {
    return a.x === b.x && a.y === b.y;
  };
  Point2.rotationNormalizer = () => {
    let lastValue;
    return (value,) => {
      if (typeof lastValue !== 'number') {
        lastValue = value;
      }
      const diff = lastValue - value;
      const maxDiff = Math.abs(diff,) + 180;
      const nTimes = Math.floor(maxDiff / 360,);
      if (diff < 180) {
        value -= nTimes * 360;
      }
      if (diff > 180) {
        value += nTimes * 360;
      }
      lastValue = value;
      return value;
    };
  };
  function center(a, b,) {
    return {
      x: (a.x + b.x) / 2,
      y: (a.y + b.y) / 2,
    };
  }
  Point2.center = center;
  function insidePoints(point2, points,) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const x = point2.x;
    const y = point2.y;
    let isInside = false;
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
      const xi = (_b = (_a = points[i]) == null ? void 0 : _a.x) != null ? _b : 0;
      const yi = (_d = (_c = points[i]) == null ? void 0 : _c.y) != null ? _d : 0;
      const xj = (_f = (_e = points[j]) == null ? void 0 : _e.x) != null ? _f : 0;
      const yj = (_h = (_g = points[j]) == null ? void 0 : _g.y) != null ? _h : 0;
      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  Point2.insidePoints = insidePoints;
})(Point || (Point = {}),);
var BezierDefaults = {
  curve: 'ease',
  duration: 1,
};
function controlPointsForCurve(curve,) {
  switch (curve) {
    case 'linear':
      return [0, 0, 1, 1,];
    case 'ease':
      return [0.25, 0.1, 0.25, 1,];
    case 'ease-in':
      return [0.42, 0, 1, 1,];
    case 'ease-out':
      return [0, 0, 0.58, 1,];
    case 'ease-in-out':
      return [0.42, 0, 0.58, 1,];
  }
}
var BezierAnimator = class {
  constructor(options, interpolation,) {
    this.interpolation = interpolation;
    __publicField(this, 'unitBezier',);
    __publicField(this, 'options',);
    __publicField(this, 'current',);
    __publicField(this, 'destination',);
    __publicField(this, 'interpolator',);
    __publicField(this, 'progress', 0,);
    __publicField(this, 'next', (delta,) => {
      const { duration, } = this.options;
      this.progress += delta / duration;
      const value = this.unitBezier.solve(this.progress, this.solveEpsilon(duration,),);
      this.current = this.interpolator(value,);
      return this.current;
    },);
    this.options = { ...BezierDefaults, ...options, };
    let controlPoints;
    if (typeof this.options.curve === 'string') {
      controlPoints = controlPointsForCurve(this.options.curve,);
    } else {
      controlPoints = this.options.curve;
    }
    const [p1x, p1y, p2x, p2y,] = controlPoints;
    this.unitBezier = new UnitBezier(Point(p1x, p1y,), Point(p2x, p2y,),);
  }
  setFrom(value,) {
    this.current = value;
    this.updateInterpolator();
  }
  setTo(value,) {
    this.destination = value;
    this.updateInterpolator();
  }
  isReady() {
    return this.interpolator !== void 0;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination,);
  }
  isFinished() {
    return this.progress >= 1;
  }
  solveEpsilon(duration,) {
    return 1 / (200 * duration);
  }
};
var UnitBezier = class {
  constructor(point1, point2,) {
    __publicField(this, 'a',);
    __publicField(this, 'b',);
    __publicField(this, 'c',);
    this.c = Point.multiply(point1, 3,);
    this.b = Point.subtract(Point.multiply(Point.subtract(point2, point1,), 3,), this.c,);
    this.a = Point.subtract(Point.subtract(Point(1, 1,), this.c,), this.b,);
  }
  solve(x, epsilon2,) {
    return this.sampleY(this.solveForT(x, epsilon2,),);
  }
  sampleX(t,) {
    return ((this.a.x * t + this.b.x) * t + this.c.x) * t;
  }
  sampleY(t,) {
    return ((this.a.y * t + this.b.y) * t + this.c.y) * t;
  }
  sampleDerivativeX(t,) {
    return (3 * this.a.x * t + 2 * this.b.x) * t + this.c.x;
  }
  solveForT(x, epsilon2,) {
    let t0, t1, t2, x2, d2, i;
    t2 = x;
    for (i = 0; i < 8; ++i) {
      x2 = this.sampleX(t2,) - x;
      if (Math.abs(x2,) < epsilon2) {
        return t2;
      }
      d2 = this.sampleDerivativeX(t2,);
      if (Math.abs(d2,) < epsilon2) {
        break;
      }
      t2 = t2 - x2 / d2;
    }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }
    while (t0 < t1) {
      x2 = this.sampleX(t2,);
      if (Math.abs(x2 - x,) < epsilon2) {
        return t2;
      }
      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }
      t2 = (t1 - t0) * 0.5 + t0;
    }
    return t2;
  }
};
var Integrator = class {
  constructor(accelerationFunction,) {
    __publicField(this, 'accelerationForState',);
    this.accelerationForState = accelerationFunction;
  }
  integrateState(state, dt,) {
    const a = this.evaluateState(state,);
    const b = this.evaluateStateWithDerivative(state, dt * 0.5, a,);
    const c = this.evaluateStateWithDerivative(state, dt * 0.5, b,);
    const d = this.evaluateStateWithDerivative(state, dt, c,);
    const dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx);
    const dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }
  evaluateState(initialState2,) {
    const dv = this.accelerationForState(initialState2,);
    return { dx: initialState2.v, dv, };
  }
  evaluateStateWithDerivative(initialState2, dt, derivative,) {
    const state = {
      x: initialState2.x + derivative.dx * dt,
      v: initialState2.v + derivative.dv * dt,
    };
    const output = {
      dx: state.v,
      dv: this.accelerationForState(state,),
    };
    return output;
  }
};
var FrictionAnimator = class {
  constructor(options,) {
    __publicField(this, 'options',);
    __publicField(this, 'state',);
    __publicField(this, 'integrator',);
    this.options = {
      velocity: 0,
      friction: 2,
      tolerance: 1 / 10,
    };
    Object.assign(this.options, options,);
    this.state = {
      x: 0,
      v: this.options.velocity,
    };
    this.integrator = new Integrator((state,) => -(this.options.friction * state.v));
  }
  setFrom(value,) {
    this.state.x = value;
  }
  setTo(value,) {
  }
  setVelocity(velocity,) {
    this.state.v = velocity;
  }
  getState() {
    return this.state;
  }
  isReady() {
    return true;
  }
  next(delta,) {
    this.state = this.integrator.integrateState(this.state, delta,);
    return this.state.x;
  }
  isFinished() {
    return Math.abs(this.state.v,) < this.options.tolerance;
  }
};
function isInterpolatable(value,) {
  return typeof value === 'function' && value.interpolationFor && typeof value.interpolationFor === 'function';
}
var Interpolation = {
  /**
   * @param from -
   * @param to -
   * @internal
   */
  handleUndefined: (from, to,) => {
    if (from === void 0) {
      from = to;
    }
    if (to === void 0) {
      to = from;
    }
    return [from, to,];
  },
};
var NumberInterpolation = {
  interpolate(from, to,) {
    [from, to,] = Interpolation.handleUndefined(from, to,);
    const a1 = +from;
    const b1 = to - a1;
    return (progress2,) => {
      const value = a1 + b1 * progress2;
      return value;
    };
  },
  difference(from, to,) {
    return to - from;
  },
};
var epsilon = 1e-3;
var minDuration2 = 0.01;
var maxDuration22 = 10;
var minDamping2 = Number.MIN_VALUE;
var maxDamping2 = 1;
function approximateRoot2(func, derivative, initialGuess, times = 12,) {
  let result = initialGuess;
  for (let i = 1, end = times, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
    result = result - func(result,) / derivative(result,);
  }
  return result;
}
function angularFrequency(undampedFrequency, dampingRatio,) {
  return undampedFrequency * Math.sqrt(1 - Math.pow(dampingRatio, 2,),);
}
var SpringCurveValueConverter = {
  computeDampingRatio: (tension, friction, mass = 1,) => {
    return friction / (2 * Math.sqrt(mass * tension,));
  },
  // Tries to compute the duration of a spring,
  // but can't for certain velocities and if dampingRatio >= 1
  // In those cases it will return null
  computeDuration: (tension, friction, velocity = 0, mass = 1,) => {
    let duration;
    const dampingRatio = SpringCurveValueConverter.computeDampingRatio(tension, friction,);
    const undampedFrequency = Math.sqrt(tension / mass,);
    if (dampingRatio < 1) {
      const a = Math.sqrt(1 - Math.pow(dampingRatio, 2,),);
      const b = velocity / (a * undampedFrequency);
      const c = dampingRatio / a;
      const d = -((b - c) / epsilon);
      if (d <= 0) {
        return null;
      }
      duration = Math.log(d,) / (dampingRatio * undampedFrequency);
    } else {
      return null;
    }
    return duration;
  },
  computeDerivedCurveOptions: (dampingRatio, duration, velocity = 0, mass = 1,) => {
    let derivative, envelope;
    dampingRatio = Math.max(Math.min(dampingRatio, maxDamping2,), minDamping2,);
    duration = Math.max(Math.min(duration, maxDuration22,), minDuration2,);
    if (dampingRatio < 1) {
      envelope = function (envelopeUndampedFrequency,) {
        const exponentialDecay = envelopeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = angularFrequency(envelopeUndampedFrequency, dampingRatio,);
        const c = Math.exp(-currentDisplacement,);
        return epsilon - a / b * c;
      };
      derivative = function (derivativeUndampedFrequency,) {
        const exponentialDecay = derivativeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const d = currentDisplacement * velocity + velocity;
        const e = Math.pow(dampingRatio, 2,) * Math.pow(derivativeUndampedFrequency, 2,) * duration;
        const f = Math.exp(-currentDisplacement,);
        const g = angularFrequency(Math.pow(derivativeUndampedFrequency, 2,), dampingRatio,);
        const factor = -envelope(derivativeUndampedFrequency,) + epsilon > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = function (envelopeUndampedFrequency,) {
        const a = Math.exp(-envelopeUndampedFrequency * duration,);
        const b = (envelopeUndampedFrequency - velocity) * duration + 1;
        return -epsilon + a * b;
      };
      derivative = function (derivativeUndampedFrequency,) {
        const a = Math.exp(-derivativeUndampedFrequency * duration,);
        const b = (velocity - derivativeUndampedFrequency) * Math.pow(duration, 2,);
        return a * b;
      };
    }
    const result = {
      tension: 100,
      friction: 10,
      velocity,
    };
    const initialGuess = 5 / duration;
    const undampedFrequency = approximateRoot2(envelope, derivative, initialGuess,);
    if (!isNaN(undampedFrequency,)) {
      result.tension = Math.pow(undampedFrequency, 2,) * mass;
      result.friction = dampingRatio * 2 * Math.sqrt(mass * result.tension,);
    }
    return result;
  },
};
var SpringTensionFrictionDefaults = {
  tension: 500,
  friction: 10,
  tolerance: 1 / 1e4,
  velocity: 0,
};
var SpringDampingDurationDefaults = {
  dampingRatio: 1,
  duration: 1,
  velocity: 0,
  mass: 1,
};
function isDampingDurationSpringOptions(options,) {
  if (!options) {
    return false;
  }
  return typeof options.dampingRatio === 'number' || typeof options.duration === 'number' || typeof options.mass === 'number';
}
var SpringAnimator = class {
  constructor(options, interpolation,) {
    this.interpolation = interpolation;
    __publicField(this, 'options',);
    __publicField(this, 'current',);
    __publicField(this, 'destination',);
    __publicField(this, 'difference',);
    __publicField(this, 'state',);
    __publicField(this, 'integrator',);
    __publicField(this, 'interpolator',);
    let _opt;
    if (isDampingDurationSpringOptions(options,)) {
      const toPass = { ...SpringDampingDurationDefaults, ...options, };
      _opt = SpringCurveValueConverter.computeDerivedCurveOptions(
        toPass.dampingRatio,
        toPass.duration,
        toPass.velocity,
        toPass.mass,
      );
    } else {
      _opt = options;
    }
    this.options = { ...SpringTensionFrictionDefaults, ..._opt, };
    this.state = {
      x: 0,
      v: this.options.velocity,
    };
    this.integrator = new Integrator((state,) => -this.options.tension * state.x - this.options.friction * state.v);
  }
  isReady() {
    return this.interpolator !== void 0 && this.difference !== void 0;
  }
  next(delta,) {
    this.state = this.integrator.integrateState(this.state, delta,);
    const value = this.interpolator(this.progress(),);
    return value;
  }
  isFinished() {
    const positionNearZero = Math.abs(this.state.x,) < this.options.tolerance;
    const velocityNearZero = Math.abs(this.state.v,) < this.options.tolerance;
    return positionNearZero && velocityNearZero;
  }
  setFrom(value,) {
    this.current = value;
    this.updateInterpolator();
  }
  setVelocity(velocity,) {
    this.state.v = velocity;
  }
  progress() {
    return 1 - this.state.x / this.difference;
  }
  // The spring always settles to 0, so we create an interpolation to the destination
  // And calculate the progress based on the current state and the span of the interpolation
  // This lets us integrate over state.x, even though Value is generic
  setTo(value,) {
    this.destination = value;
    this.difference = this.interpolation.difference(this.destination, this.current,);
    this.state.x = this.difference;
    this.updateInterpolator();
  }
  /** @internal */
  getState() {
    return this.state;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination,);
  }
};
var Defaults = {
  velocity: 0,
  min: 0,
  max: 0,
  momentum: {
    friction: 2,
    tolerance: 10,
  },
  bounce: {
    tension: 500,
    friction: 10,
    tolerance: 1,
  },
};
var InertialScrollAnimator = class {
  constructor(options,) {
    __publicField(this, 'options',);
    __publicField(this, 'current',);
    __publicField(this, 'frictionAnimator',);
    __publicField(this, 'springAnimator',);
    __publicField(this, 'useSpring',);
    this.options = Object.assign({ ...Defaults, }, options,);
    this.frictionAnimator = new FrictionAnimator({
      friction: this.options.momentum.friction,
      tolerance: this.options.momentum.tolerance,
      velocity: this.options.velocity,
    },);
    this.springAnimator = new SpringAnimator(
      {
        tension: this.options.bounce.tension,
        friction: this.options.bounce.friction,
        tolerance: this.options.bounce.tolerance,
        velocity: this.options.velocity,
      },
      NumberInterpolation,
    );
    this.useSpring = false;
  }
  isReady() {
    return true;
  }
  next(delta,) {
    this.current = this.currentAnimator.next(delta,);
    if (!this.useSpring) {
      this.tryTransitionToSpring();
    }
    return this.current;
  }
  get currentAnimator() {
    if (this.useSpring) {
      return this.springAnimator;
    }
    return this.frictionAnimator;
  }
  isFinished() {
    return this.currentAnimator.isFinished();
  }
  get state() {
    return this.currentAnimator.getState();
  }
  setFrom(value,) {
    this.setState({ x: value, v: this.state.v, },);
  }
  setState(state,) {
    this.frictionAnimator.setFrom(state.x,);
    this.frictionAnimator.setVelocity(state.v,);
    if (this.isValidState()) {
      return this.tryTransitionToSpring();
    } else {
      let bound = 0;
      if (this.state.x <= this.options.min) {
        bound = this.options.min;
      }
      if (this.state.x >= this.options.max) {
        bound = this.options.max;
      }
      return this.transitionToSpring(bound,);
    }
  }
  setTo(destination,) {
    this.frictionAnimator.setTo(destination,);
    this.springAnimator.setTo(destination,);
  }
  setLimits(min, max,) {
    this.options.min = min;
    this.options.max = max;
  }
  // If the position is outside the min and max bounds, and traveling
  // further away, then transition from friction to spring animation
  tryTransitionToSpring() {
    const belowMinWithVelocity = this.state.x < this.options.min && this.state.v <= 0;
    const aboveMaxWithVelocity = this.state.x > this.options.max && this.state.v >= 0;
    if (belowMinWithVelocity || aboveMaxWithVelocity) {
      let bound;
      if (belowMinWithVelocity) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      this.transitionToSpring(bound,);
    } else {
      this.useSpring = false;
    }
  }
  transitionToSpring(bound,) {
    this.springAnimator.setFrom(this.state.x,);
    this.springAnimator.setVelocity(this.state.v,);
    this.springAnimator.setTo(bound,);
    this.useSpring = true;
  }
  // If the position is outside the min and max bounds, but traveling
  // back towards the bounds, check if the velocity is sufficient to
  // carry the position back within bounds. If it is, let friction do the
  // work. If not, the state is invalid, so use the spring.
  isValidState() {
    const belowMinTravelingBack = this.state.x < this.options.min && this.state.v > 0;
    const aboveMaxTravelingBack = this.state.x > this.options.max && this.state.v < 0;
    if (belowMinTravelingBack || aboveMaxTravelingBack) {
      let bound;
      if (belowMinTravelingBack) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      const friction = this.frictionAnimator.options.friction;
      const solution = 1 - friction * (bound - this.state.x) / this.state.v;
      return solution > 0;
    }
    return true;
  }
  // The math behind _isValidState:
  //
  // 1. Integrate the friction animator's acceleration to find velocity
  //
  //         a = - k * v
  //     dv/dt = - k * v
  // Int(dv/v) = - k * Int(dt)
  //      ln v = - k * t + C
  //
  // => Solve for C at t = 0
  //
  // ln v(0) = - k * 0 + C
  // ln v(0) = C
  //
  // => Plug C back into v(t)
  //
  //     ln v = - k * t + ln v(0)
  // e^(ln v) = e^(- k * t) + e^(ln v(0))
  //        v = v(0) * e^(- k * t)
  //
  // 2. Integrate velocity to find position
  //
  // Int(v) = v(0) * Int(e^(- k * t))
  //      x = - v(0) * e^(-k * t) / k + C
  //
  // => Solve for C at t = 0
  //
  //            x(0) = - v(0) * e^(-k * 0) / k + C
  //            x(0) = - v(0) / k + C
  // x(0) + v(0) / k = C
  //
  // => Plug C back into x(t)
  //
  // x = - v(0) * e^(-k * t) / k + x(0) + v(0) / k
  //
  // 3. Check if a (real) solution exists for t for position x
  //
  //                                x = - v(0) * e^(-k * t) / k + x(0) + v(0) / k
  //                         x - x(0) = - v(0) * e^(-k * t) / k + v(0) / k
  //                   k * (x - x(0)) = - v(0) * e^(-k * t) + v(0)
  //            k * (x - x(0)) - v(0) = - v(0) * e^(-k * t)
  // (k * (x - x(0)) - v(0)) / - v(0) = e^(-k * t)
  //       1 - (k * (x - x(0)) / v(0) = e^(-k * t)
  //   ln(1 - (k * (x - x(0)) / v(0)) = -k * t
  //
  // Therefore, a real solution exists if 1 - (k * (x - x(0)) / v(0) > 0
};
var import_hsluv = __toESM(require_hsluv(), 1,);
var cssNames = {
  aliceblue: 'f0f8ff',
  antiquewhite: 'faebd7',
  aqua: '0ff',
  aquamarine: '7fffd4',
  azure: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '000',
  blanchedalmond: 'ffebcd',
  blue: '00f',
  blueviolet: '8a2be2',
  brown: 'a52a2a',
  burlywood: 'deb887',
  burntsienna: 'ea7e5d',
  cadetblue: '5f9ea0',
  chartreuse: '7fff00',
  chocolate: 'd2691e',
  coral: 'ff7f50',
  cornflowerblue: '6495ed',
  cornsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: '0ff',
  darkblue: '00008b',
  darkcyan: '008b8b',
  darkgoldenrod: 'b8860b',
  darkgray: 'a9a9a9',
  darkgreen: '006400',
  darkgrey: 'a9a9a9',
  darkkhaki: 'bdb76b',
  darkmagenta: '8b008b',
  darkolivegreen: '556b2f',
  darkorange: 'ff8c00',
  darkorchid: '9932cc',
  darkred: '8b0000',
  darksalmon: 'e9967a',
  darkseagreen: '8fbc8f',
  darkslateblue: '483d8b',
  darkslategray: '2f4f4f',
  darkslategrey: '2f4f4f',
  darkturquoise: '00ced1',
  darkviolet: '9400d3',
  deeppink: 'ff1493',
  deepskyblue: '00bfff',
  dimgray: '696969',
  dimgrey: '696969',
  dodgerblue: '1e90ff',
  firebrick: 'b22222',
  floralwhite: 'fffaf0',
  forestgreen: '228b22',
  fuchsia: 'f0f',
  gainsboro: 'dcdcdc',
  ghostwhite: 'f8f8ff',
  gold: 'ffd700',
  goldenrod: 'daa520',
  gray: '808080',
  green: '008000',
  greenyellow: 'adff2f',
  grey: '808080',
  honeydew: 'f0fff0',
  hotpink: 'ff69b4',
  indianred: 'cd5c5c',
  indigo: '4b0082',
  ivory: 'fffff0',
  khaki: 'f0e68c',
  lavender: 'e6e6fa',
  lavenderblush: 'fff0f5',
  lawngreen: '7cfc00',
  lemonchiffon: 'fffacd',
  lightblue: 'add8e6',
  lightcoral: 'f08080',
  lightcyan: 'e0ffff',
  lightgoldenrodyellow: 'fafad2',
  lightgray: 'd3d3d3',
  lightgreen: '90ee90',
  lightgrey: 'd3d3d3',
  lightpink: 'ffb6c1',
  lightsalmon: 'ffa07a',
  lightseagreen: '20b2aa',
  lightskyblue: '87cefa',
  lightslategray: '789',
  lightslategrey: '789',
  lightsteelblue: 'b0c4de',
  lightyellow: 'ffffe0',
  lime: '0f0',
  limegreen: '32cd32',
  linen: 'faf0e6',
  magenta: 'f0f',
  maroon: '800000',
  mediumaquamarine: '66cdaa',
  mediumblue: '0000cd',
  mediumorchid: 'ba55d3',
  mediumpurple: '9370db',
  mediumseagreen: '3cb371',
  mediumslateblue: '7b68ee',
  mediumspringgreen: '00fa9a',
  mediumturquoise: '48d1cc',
  mediumvioletred: 'c71585',
  midnightblue: '191970',
  mintcream: 'f5fffa',
  mistyrose: 'ffe4e1',
  moccasin: 'ffe4b5',
  navajowhite: 'ffdead',
  navy: '000080',
  oldlace: 'fdf5e6',
  olive: '808000',
  olivedrab: '6b8e23',
  orange: 'ffa500',
  orangered: 'ff4500',
  orchid: 'da70d6',
  palegoldenrod: 'eee8aa',
  palegreen: '98fb98',
  paleturquoise: 'afeeee',
  palevioletred: 'db7093',
  papayawhip: 'ffefd5',
  peachpuff: 'ffdab9',
  peru: 'cd853f',
  pink: 'ffc0cb',
  plum: 'dda0dd',
  powderblue: 'b0e0e6',
  purple: '800080',
  rebeccapurple: '663399',
  red: 'f00',
  rosybrown: 'bc8f8f',
  royalblue: '4169e1',
  saddlebrown: '8b4513',
  salmon: 'fa8072',
  sandybrown: 'f4a460',
  seagreen: '2e8b57',
  seashell: 'fff5ee',
  sienna: 'a0522d',
  silver: 'c0c0c0',
  skyblue: '87ceeb',
  slateblue: '6a5acd',
  slategray: '708090',
  slategrey: '708090',
  snow: 'fffafa',
  springgreen: '00ff7f',
  steelblue: '4682b4',
  tan: 'd2b48c',
  teal: '008080',
  thistle: 'd8bfd8',
  tomato: 'ff6347',
  turquoise: '40e0d0',
  violet: 'ee82ee',
  wheat: 'f5deb3',
  white: 'fff',
  whitesmoke: 'f5f5f5',
  yellow: 'ff0',
  yellowgreen: '9acd32',
};
var ColorFormat = /* @__PURE__ */ ((ColorFormat2,) => {
  ColorFormat2['RGB'] = 'rgb';
  ColorFormat2['HSL'] = 'hsl';
  ColorFormat2['HSV'] = 'hsv';
  ColorFormat2['HEX'] = 'hex';
  ColorFormat2['NAME'] = 'name';
  return ColorFormat2;
})(ColorFormat || {},);
var ColorMixModelType = /* @__PURE__ */ ((ColorMixModelType2,) => {
  ColorMixModelType2['RGB'] = 'rgb';
  ColorMixModelType2['RGBA'] = 'rgba';
  ColorMixModelType2['HSL'] = 'hsl';
  ColorMixModelType2['HSLA'] = 'hsla';
  ColorMixModelType2['HUSL'] = 'husl';
  return ColorMixModelType2;
})(ColorMixModelType || {},);
function modulate(value, rangeA, rangeB, limit = false,) {
  const [fromLow, fromHigh,] = rangeA;
  const [toLow, toHigh,] = rangeB;
  const fromDelta = fromHigh - fromLow;
  if (fromDelta === 0) {
    return (toHigh + toLow) / 2;
  }
  const toDelta = toHigh - toLow;
  if (toDelta === 0) {
    return toLow;
  }
  const result = toLow + (value - fromLow) / fromDelta * toDelta;
  if (limit === true) {
    if (toLow < toHigh) {
      if (result < toLow) {
        return toLow;
      }
      if (result > toHigh) {
        return toHigh;
      }
    } else {
      if (result > toLow) {
        return toLow;
      }
      if (result < toHigh) {
        return toHigh;
      }
    }
  }
  return result;
}
function isNumeric(value,) {
  return !isNaN(value,) && isFinite(value,);
}
function percentToFraction(val,) {
  const digits = numberFromString(val,);
  if (digits !== void 0) {
    if (val.includes('%',)) {
      return digits / 100;
    }
    return digits;
  }
  return 0;
}
function numberFromString(input,) {
  const match = /\d?\.?\d+/u.exec(input,);
  return match ? Number(match[0],) : void 0;
}
var { hsluvToRgb, rgbToHsluv: rgbToHsluvExternal, } = import_hsluv.default;
function rgbToHsluv(r, g, b,) {
  const [h, s, l,] = rgbToHsluvExternal([r / 255, g / 255, b / 255,],);
  return { h, s, l, };
}
function rgbaFromHusl(h, s, l, a = 1,) {
  const rgb = hsluvToRgb([h, s, l,],);
  return {
    r: rgb[0] * 255,
    g: rgb[1] * 255,
    b: rgb[2] * 255,
    a,
  };
}
function hsvToStr(h, s, v, a,) {
  const _h = Math.round(h,);
  const _s = Math.round(s * 100,);
  const _v = Math.round(v * 100,);
  return a === void 0 || a === 1 ? 'hsv(' + _h + ', ' + _s + '%, ' + _v + '%)' : 'hsva(' + _h + ', ' + _s + '%, ' + _v + '%, ' + a + ')';
}
function rgbToRgb(r, g, b,) {
  return {
    r: isNumeric(r,) ? bound01(r, 255,) * 255 : 0,
    g: isNumeric(g,) ? bound01(g, 255,) * 255 : 0,
    b: isNumeric(b,) ? bound01(b, 255,) * 255 : 0,
  };
}
function rgbToHex(r, g, b, allow3Char,) {
  const hex2 = [
    pad2(Math.round(r,).toString(16,),),
    pad2(Math.round(g,).toString(16,),),
    pad2(Math.round(b,).toString(16,),),
  ];
  if (
    allow3Char && hex2[0].charAt(0,) === hex2[0].charAt(1,) && hex2[1].charAt(0,) === hex2[1].charAt(1,) &&
    hex2[2].charAt(0,) === hex2[2].charAt(1,)
  ) {
    return hex2[0].charAt(0,) + hex2[1].charAt(0,) + hex2[2].charAt(0,);
  }
  return hex2.join('',);
}
function rgbToHsl(r, g, b,) {
  let l;
  let s;
  const _r = bound01(r, 255,);
  const _g = bound01(g, 255,);
  const _b = bound01(b, 255,);
  const max = Math.max(_r, _g, _b,);
  const min = Math.min(_r, _g, _b,);
  let h = s = l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case _r:
        h = (_g - _b) / d + (_g < _b ? 6 : 0);
        break;
      case _g:
        h = (_b - _r) / d + 2;
        break;
      case _b:
        h = (_r - _g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: h * 360, s, l, };
}
function hue2rgb(p, q, t,) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l,) {
  let r;
  let g;
  let b;
  h = bound01(h, 360,);
  s = bound01(s * 100, 100,);
  l = bound01(l * 100, 100,);
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3,);
    g = hue2rgb(p, q, h,);
    b = hue2rgb(p, q, h - 1 / 3,);
  }
  return { r: r * 255, g: g * 255, b: b * 255, };
}
function rgbToHsv(r, g, b,) {
  r = bound01(r, 255,);
  g = bound01(g, 255,);
  b = bound01(b, 255,);
  const max = Math.max(r, g, b,);
  const min = Math.min(r, g, b,);
  const d = max - min;
  let h;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (max === min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, v, };
}
function hsvToRgb(h, s, v,) {
  h = bound01(h, 360,) * 6;
  s = bound01(s * 100, 100,);
  v = bound01(v * 100, 100,);
  const i = Math.floor(h,);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v,][mod];
  const g = [t, v, v, q, p, p,][mod];
  const b = [p, p, t, v, v, q,][mod];
  return { r: r * 255, g: g * 255, b: b * 255, };
}
function bound01(n, max,) {
  let _max;
  let _n;
  if (typeof max === 'string') {
    _max = parseFloat(max,);
  } else {
    _max = max;
  }
  if (typeof n === 'string') {
    if (isOnePointZero(n,)) {
      n = '100%';
    }
    const processPercent = isPercentage(n,);
    _n = Math.min(_max, Math.max(0, parseFloat(n,),),);
    if (processPercent) {
      _n = Math.floor(_n * _max,) / 100;
    }
  } else {
    _n = n;
  }
  if (Math.abs(_n - _max,) < 1e-6) {
    return 1;
  }
  return _n % _max / _max;
}
function isOnePointZero(n,) {
  return typeof n === 'string' && n.includes('.',) && parseFloat(n,) === 1;
}
function isPercentage(n,) {
  return typeof n === 'string' && n.includes('%',);
}
function pad2(char,) {
  if (char.length === 1) {
    return '0' + char;
  } else {
    return '' + char;
  }
}
var matchers = (() => {
  const cssInteger = '[-\\+]?\\d+%?';
  const cssNumber = '[-\\+]?\\d*\\.\\d+%?';
  const cssUnit = '(?:' + cssNumber + ')|(?:' + cssInteger + ')';
  const permissiveMatch3 = '[\\s|\\(]+(' + cssUnit + ')[,|\\s]+(' + cssUnit + ')[,|\\s]+(' + cssUnit + ')\\s*\\)?';
  const permissiveMatch4 = '[\\s|\\(]+(' + cssUnit + ')[,|\\s]+(' + cssUnit + ')[,|\\s]+(' + cssUnit + ')[,|\\s]+(' + cssUnit + ')\\s*\\)?';
  return {
    rgb: new RegExp('rgb' + permissiveMatch3,),
    rgba: new RegExp('rgba' + permissiveMatch4,),
    hsl: new RegExp('hsl' + permissiveMatch3,),
    hsla: new RegExp('hsla' + permissiveMatch4,),
    hsv: new RegExp('hsv' + permissiveMatch3,),
    hsva: new RegExp('hsva' + permissiveMatch4,),
    hex3: /^([\da-f])([\da-f])([\da-f])$/iu,
    hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu,
    hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu,
    hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu,
  };
})();
function stringToObject(inputColor,) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
  if (inputColor.includes('gradient(',)) {
    return false;
  }
  if (inputColor.includes('var(',)) {
    return false;
  }
  const trimLeft = /^[\s,#]+/u;
  let color2 = inputColor.replace(trimLeft, '',).trimEnd().toLowerCase();
  const namedColor = cssNames[color2];
  if (namedColor) {
    color2 = namedColor;
  }
  if (color2 === 'transparent') {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: 'name',
      /* NAME */
    };
  }
  let match;
  if (match = matchers.rgb.exec(color2,)) {
    return {
      r: parseInt((_a = match[1]) != null ? _a : '',),
      g: parseInt((_b = match[2]) != null ? _b : '',),
      b: parseInt((_c = match[3]) != null ? _c : '',),
      a: 1,
      format: 'rgb',
      /* RGB */
    };
  }
  if (match = matchers.rgba.exec(color2,)) {
    return {
      r: parseInt((_d = match[1]) != null ? _d : '',),
      g: parseInt((_e = match[2]) != null ? _e : '',),
      b: parseInt((_f = match[3]) != null ? _f : '',),
      a: parseFloat((_g = match[4]) != null ? _g : '',),
      format: 'rgb',
      /* RGB */
    };
  }
  if (match = matchers.hsl.exec(color2,)) {
    return {
      h: parseInt((_h = match[1]) != null ? _h : '',),
      s: percentToFraction((_i = match[2]) != null ? _i : '',),
      l: percentToFraction((_j = match[3]) != null ? _j : '',),
      a: 1,
      format: 'hsl',
      /* HSL */
    };
  }
  if (match = matchers.hsla.exec(color2,)) {
    return {
      h: parseInt((_k = match[1]) != null ? _k : '',),
      s: percentToFraction((_l = match[2]) != null ? _l : '',),
      l: percentToFraction((_m = match[3]) != null ? _m : '',),
      a: parseFloat((_n = match[4]) != null ? _n : '',),
      format: 'hsl',
      /* HSL */
    };
  }
  if (match = matchers.hsv.exec(color2,)) {
    return {
      h: parseInt((_o = match[1]) != null ? _o : '',),
      s: percentToFraction((_p = match[2]) != null ? _p : '',),
      v: percentToFraction((_q = match[3]) != null ? _q : '',),
      a: 1,
      format: 'hsv',
      /* HSV */
    };
  }
  if (match = matchers.hsva.exec(color2,)) {
    return {
      h: parseInt((_r = match[1]) != null ? _r : '',),
      s: percentToFraction((_s = match[2]) != null ? _s : '',),
      v: percentToFraction((_t = match[3]) != null ? _t : '',),
      a: parseFloat((_u = match[4]) != null ? _u : '',),
      format: 'hsv',
      /* HSV */
    };
  }
  if (match = matchers.hex8.exec(color2,)) {
    return {
      r: parseIntFromHex((_v = match[1]) != null ? _v : '',),
      g: parseIntFromHex((_w = match[2]) != null ? _w : '',),
      b: parseIntFromHex((_x = match[3]) != null ? _x : '',),
      a: convertHexToDecimal((_y = match[4]) != null ? _y : '',),
      format: namedColor ? 'name' : 'hex',
      /* HEX */
    };
  }
  if (match = matchers.hex6.exec(color2,)) {
    return {
      r: parseIntFromHex((_z = match[1]) != null ? _z : '',),
      g: parseIntFromHex((_A = match[2]) != null ? _A : '',),
      b: parseIntFromHex((_B = match[3]) != null ? _B : '',),
      a: 1,
      format: namedColor ? 'name' : 'hex',
      /* HEX */
    };
  }
  if (match = matchers.hex4.exec(color2,)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`,),
      g: parseIntFromHex(`${match[2]}${match[2]}`,),
      b: parseIntFromHex(`${match[3]}${match[3]}`,),
      a: convertHexToDecimal(match[4] + '' + match[4],),
      format: namedColor ? 'name' : 'hex',
      /* HEX */
    };
  }
  if (match = matchers.hex3.exec(color2,)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`,),
      g: parseIntFromHex(`${match[2]}${match[2]}`,),
      b: parseIntFromHex(`${match[3]}${match[3]}`,),
      a: 1,
      format: namedColor ? 'name' : 'hex',
      /* HEX */
    };
  } else {
    return false;
  }
}
function parseIntFromHex(hex2,) {
  return parseInt(hex2, 16,);
}
function convertHexToDecimal(h,) {
  return parseIntFromHex(h,) / 255;
}
var cache = /* @__PURE__ */ new Map();
var Color = /* @__PURE__ */ (() => {
  function Color2(color2, r, g, b,) {
    if (typeof color2 === 'string') {
      let c = cache.get(color2,);
      if (c) {
        return c;
      }
      c = createColor(color2,);
      if (c === void 0) {
        return { ...Color2('black',), isValid: false, };
      }
      cache.set(color2, c,);
      return c;
    }
    const created = createColor(color2, r, g, b,);
    return created !== void 0 ? created : { ...Color2('black',), isValid: false, };
  }
  function createColor(color2, r, g, b,) {
    if (color2 === '') {
      return void 0;
    }
    const colorData = getCompleteColorStrategy(color2, r, g, b,);
    if (colorData) {
      const newColor = {
        r: colorData.r,
        g: colorData.g,
        b: colorData.b,
        a: colorData.a,
        h: colorData.h,
        s: colorData.s,
        l: colorData.l,
        initialValue: typeof color2 === 'string' && colorData.format !== 'hsv' ? color2 : void 0,
        roundA: Math.round(100 * colorData.a,) / 100,
        format: colorData.format,
        mix: Color2.mix,
        toValue: () => Color2.toRgbString(newColor,),
      };
      return newColor;
    } else {
      return void 0;
    }
  }
  const ColorMixModel = {
    isRGB(colorModel,) {
      return colorModel === 'rgb' || colorModel === 'rgba';
    },
    isHSL(colorModel,) {
      return colorModel === 'hsl' || colorModel === 'hsla';
    },
  };
  Color2.inspect = (color2, initialValue,) => {
    if (color2.format === 'hsl') {
      return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;
    } else if (color2.format === 'hex' || color2.format === 'name') {
      return `<${color2.constructor.name} "${initialValue}">`;
    } else {
      return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;
    }
  };
  Color2.isColor = (color2,) => {
    if (typeof color2 === 'string') {
      return Color2.isColorString(color2,);
    } else {
      return Color2.isColorObject(color2,);
    }
  };
  Color2.isColorString = (colorString,) => {
    if (typeof colorString === 'string') {
      return stringToObject(colorString,) !== false;
    }
    return false;
  };
  Color2.isColorObject = (color2,) => {
    return color2 && typeof color2 !== 'string' && typeof color2.r === 'number' && typeof color2.g === 'number' &&
      typeof color2.b === 'number' && typeof color2.h === 'number' && typeof color2.s === 'number' && typeof color2.l === 'number' &&
      typeof color2.a === 'number' && typeof color2.roundA === 'number' && typeof color2.format === 'string';
  };
  Color2.toString = (color2,) => {
    return Color2.toRgbString(color2,);
  };
  Color2.toHex = (color2, allow3Char = false,) => {
    return rgbToHex(color2.r, color2.g, color2.b, allow3Char,);
  };
  Color2.toHexString = (color2, allow3Char = false,) => {
    return `#${Color2.toHex(color2, allow3Char,)}`;
  };
  Color2.toRgbString = (color2,) => {
    return color2.a === 1
      ? 'rgb(' + Math.round(color2.r,) + ', ' + Math.round(color2.g,) + ', ' + Math.round(color2.b,) + ')'
      : 'rgba(' + Math.round(color2.r,) + ', ' + Math.round(color2.g,) + ', ' + Math.round(color2.b,) + ', ' + color2.roundA + ')';
  };
  Color2.toHusl = (color2,) => {
    return {
      ...rgbToHsluv(color2.r, color2.g, color2.b,),
      a: color2.roundA,
    };
  };
  Color2.toHslString = (color2,) => {
    const hsl = Color2.toHsl(color2,);
    const h = Math.round(hsl.h,);
    const s = Math.round(hsl.s * 100,);
    const l = Math.round(hsl.l * 100,);
    return color2.a === 1 ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)' : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + color2.roundA + ')';
  };
  Color2.toHsv = (color2,) => {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b,);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: color2.a, };
  };
  Color2.toHsvString = (color2,) => {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b,);
    const h = Math.round(hsv.h * 360,);
    const s = Math.round(hsv.s * 100,);
    const v = Math.round(hsv.v * 100,);
    return color2.a === 1 ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)' : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + color2.roundA + ')';
  };
  Color2.toName = (color2,) => {
    if (color2.a === 0) {
      return 'transparent';
    }
    if (color2.a < 1) {
      return false;
    }
    const hex2 = rgbToHex(color2.r, color2.g, color2.b, true,);
    for (const key7 of Object.keys(cssNames,)) {
      const value = cssNames[key7];
      if (value === hex2) {
        return key7;
      }
    }
    return false;
  };
  Color2.toHsl = (color2,) => {
    return {
      h: Math.round(color2.h,),
      s: color2.s,
      l: color2.l,
      a: color2.a,
    };
  };
  Color2.toRgb = (color2,) => {
    return {
      r: Math.round(color2.r,),
      g: Math.round(color2.g,),
      b: Math.round(color2.b,),
      a: color2.a,
    };
  };
  Color2.brighten = (color2, amount = 10,) => {
    const rgb = Color2.toRgb(color2,);
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100),),),);
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100),),),);
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100),),),);
    return Color2(rgb,);
  };
  Color2.lighten = (color2, amount = 10,) => {
    const hsl = Color2.toHsl(color2,);
    hsl.l += amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l,),);
    return Color2(hsl,);
  };
  Color2.darken = (color2, amount = 10,) => {
    const hsl = Color2.toHsl(color2,);
    hsl.l -= amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l,),);
    return Color2(hsl,);
  };
  Color2.saturate = (color2, amount = 10,) => {
    const hsl = Color2.toHsl(color2,);
    hsl.s += amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s,),);
    return Color2(hsl,);
  };
  Color2.desaturate = (color2, amount = 10,) => {
    const hsl = Color2.toHsl(color2,);
    hsl.s -= amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s,),);
    return Color2(hsl,);
  };
  Color2.grayscale = (color2,) => {
    return Color2.desaturate(color2, 100,);
  };
  Color2.hueRotate = (color2, angle,) => {
    const hsl = Color2.toHsl(color2,);
    hsl.h += angle;
    hsl.h = hsl.h > 360 ? hsl.h - 360 : hsl.h;
    return Color2(hsl,);
  };
  Color2.alpha = (color2, a = 1,) => {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a,
    },);
  };
  Color2.transparent = (color2,) => {
    return Color2.alpha(color2, 0,);
  };
  Color2.multiplyAlpha = (color2, alphaValue = 1,) => {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a: color2.a * alphaValue,
    },);
  };
  Color2.interpolate = (colorA, colorB, model = 'rgb',) => {
    if (!Color2.isColorObject(colorA,) || !Color2.isColorObject(colorB,)) {
      throw new TypeError('Both arguments for Color.interpolate must be Color objects',);
    }
    return (progress2,) => {
      const color2 = Color2.mixAsColor(colorA, colorB, progress2, false, model,);
      return color2;
    };
  };
  Color2.mix = (from, toColor, {
    model = 'rgb',
    /* RGB */
  } = {},) => {
    const fromColor = typeof from === 'string' ? Color2(from,) : from;
    const mixer = Color2.interpolate(fromColor, toColor, model,);
    return (p,) => Color2.toRgbString(mixer(p,),);
  };
  Color2.mixAsColor = (colorA, colorB, fraction2 = 0.5, limit = false, model = 'rgb',) => {
    let result = null;
    if (ColorMixModel.isRGB(model,)) {
      result = Color2({
        r: modulate(fraction2, [0, 1,], [colorA.r, colorB.r,], limit,),
        g: modulate(fraction2, [0, 1,], [colorA.g, colorB.g,], limit,),
        b: modulate(fraction2, [0, 1,], [colorA.b, colorB.b,], limit,),
        a: modulate(fraction2, [0, 1,], [colorA.a, colorB.a,], limit,),
      },);
    } else {
      let hslA, hslB;
      if (ColorMixModel.isHSL(model,)) {
        hslA = Color2.toHsl(colorA,);
        hslB = Color2.toHsl(colorB,);
      } else {
        hslA = Color2.toHusl(colorA,);
        hslB = Color2.toHusl(colorB,);
      }
      if (hslA.s === 0) {
        hslA.h = hslB.h;
      } else if (hslB.s === 0) {
        hslB.h = hslA.h;
      }
      const fromH = hslA.h;
      const toH = hslB.h;
      let deltaH = toH - fromH;
      if (deltaH > 180) {
        deltaH = toH - 360 - fromH;
      } else if (deltaH < -180) {
        deltaH = toH + 360 - fromH;
      }
      const tween = {
        h: modulate(fraction2, [0, 1,], [fromH, fromH + deltaH,], limit,),
        s: modulate(fraction2, [0, 1,], [hslA.s, hslB.s,], limit,),
        l: modulate(fraction2, [0, 1,], [hslA.l, hslB.l,], limit,),
        a: modulate(fraction2, [0, 1,], [colorA.a, colorB.a,], limit,),
      };
      if (ColorMixModel.isHSL(model,)) {
        result = Color2(tween,);
      } else {
        result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a,),);
      }
    }
    return result;
  };
  Color2.random = (alphaValue = 1,) => {
    function gen() {
      return Math.floor(Math.random() * 255,);
    }
    return Color2('rgba(' + gen() + ', ' + gen() + ', ' + gen() + ', ' + alphaValue + ')',);
  };
  Color2.grey = (amount = 0.5, alphaValue = 1,) => {
    amount = Math.floor(amount * 255,);
    return Color2('rgba(' + amount + ', ' + amount + ', ' + amount + ', ' + alphaValue + ')',);
  };
  Color2.gray = Color2.grey;
  Color2.rgbToHsl = (r, g, b,) => {
    return rgbToHsl(r, g, b,);
  };
  Color2.isValidColorProperty = (name, value,) => {
    const isColorKey = name.toLowerCase().slice(-5,) === 'color' || name === 'fill' || name === 'stroke';
    if (isColorKey && typeof value === 'string' && Color2.isColorString(value,)) {
      return true;
    }
    return false;
  };
  Color2.difference = (colorA, colorB,) => {
    const _r = (colorA.r + colorB.r) / 2;
    const deltaR = colorA.r - colorB.r;
    const deltaG = colorA.g - colorB.g;
    const deltaB = colorA.b - colorB.b;
    const deltaR2 = Math.pow(deltaR, 2,);
    const deltaG2 = Math.pow(deltaG, 2,);
    const deltaB2 = Math.pow(deltaB, 2,);
    return Math.sqrt(2 * deltaR2 + 4 * deltaG2 + 3 * deltaB2 + _r * (deltaR2 - deltaB2) / 256,);
  };
  Color2.equal = (colorA, colorB, tolerance = 0.1,) => {
    if (Math.abs(colorA.r - colorB.r,) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.g - colorB.g,) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.b - colorB.b,) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.a - colorB.a,) * 256 >= tolerance) {
      return false;
    }
    return true;
  };
  const channelToDecimal = interpolate([0, 255,], [0, 1,],);
  function convertChannelToLinearRgb(channel,) {
    channel = channelToDecimal(channel,);
    const abs = Math.abs(channel,);
    if (abs < 0.04045) {
      return channel / 12.92;
    }
    return (Math.sign(channel,) || 1) * Math.pow((abs + 0.055) / 1.055, 2.4,);
  }
  Color2.luminance = (color2,) => {
    const { r, g, b, } = Color2.toRgb(color2,);
    return 0.2126 * convertChannelToLinearRgb(r,) + 0.7152 * convertChannelToLinearRgb(g,) + 0.0722 * convertChannelToLinearRgb(b,);
  };
  Color2.contrast = (a, b,) => {
    const l1 = Color2.luminance(a,);
    const l2 = Color2.luminance(b,);
    return (Math.max(l1, l2,) + 0.05) / (Math.min(l1, l2,) + 0.05);
  };
  return Color2;
})();
function getCompleteColorStrategy(colorOrR, g, b, a = 1,) {
  let completeColor;
  if (
    typeof colorOrR === 'number' && !Number.isNaN(colorOrR,) && typeof g === 'number' && !Number.isNaN(g,) && typeof b === 'number' &&
    !Number.isNaN(b,)
  ) {
    const _r = colorOrR;
    const _g = g;
    const _b = b;
    const _a = a;
    completeColor = getCompleteColorFromRGB({ r: _r, g: _g, b: _b, a: _a, },);
  } else if (typeof colorOrR === 'string') {
    completeColor = getCompleteColorFromString(colorOrR,);
  } else if (typeof colorOrR === 'object') {
    if (colorOrR.hasOwnProperty('r',) && colorOrR.hasOwnProperty('g',) && colorOrR.hasOwnProperty('b',)) {
      completeColor = getCompleteColorFromRGB(colorOrR,);
    } else {
      completeColor = getCompleteColorFromHSL(colorOrR,);
    }
  }
  return completeColor;
}
function getCompleteColorFromString(color2,) {
  const result = stringToObject(color2,);
  if (result) {
    if (result.format === 'hsl') {
      return getCompleteColorFromHSL(result,);
    } else if (result.format === 'hsv') {
      return getCompleteColorFromHSV(result,);
    } else {
      return getCompleteColorFromRGB(result,);
    }
  }
}
function getCompleteColorFromHSV(color2,) {
  const rgb = hsvToRgb(color2.h, color2.s, color2.v,);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b,);
  return {
    ...hsl,
    ...rgb,
    format: 'rgb',
    a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1,
  };
}
function getCompleteColorFromRGB(color2,) {
  const rgb = rgbToRgb(color2.r, color2.g, color2.b,);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b,);
  return {
    ...hsl,
    ...rgb,
    format: 'rgb',
    a: color2.a !== void 0 ? correctAlpha(color2.a,) : 1,
  };
}
function getCompleteColorFromHSL(color2,) {
  let h;
  let s;
  let l;
  let rgb = { r: 0, g: 0, b: 0, };
  let hsl = { h: 0, s: 0, l: 0, };
  h = isNumeric(color2.h,) ? color2.h : 0;
  h = (h + 360) % 360;
  s = isNumeric(color2.s,) ? color2.s : 1;
  if (typeof color2.s === 'string') {
    s = numberFromString(color2.s,);
  }
  l = isNumeric(color2.l,) ? color2.l : 0.5;
  if (typeof color2.l === 'string') {
    l = numberFromString(color2.l,);
  }
  rgb = hslToRgb(h, s, l,);
  hsl = {
    h,
    s,
    l,
  };
  return {
    ...rgb,
    ...hsl,
    a: color2.a === void 0 ? 1 : color2.a,
    format: 'hsl',
    /* HSL */
  };
}
function correctAlpha(alphaValue,) {
  alphaValue = parseFloat(alphaValue,);
  if (alphaValue < 0) {
    alphaValue = 0;
  }
  if (isNaN(alphaValue,) || alphaValue > 1) {
    alphaValue = 1;
  }
  return alphaValue;
}
var ColorInterpolation = (type = 'husl',) => {
  return {
    interpolate(from, to,) {
      [from, to,] = Interpolation.handleUndefined(from, to,);
      return Color.interpolate(Color(from,), Color(to,), type,);
    },
    difference(from, to,) {
      return Color.difference(Color(from,), Color(to,),);
    },
  };
};
var NoInterpolation = {
  interpolate(from, to,) {
    [from, to,] = Interpolation.handleUndefined(from, to,);
    return (progress2,) => {
      return progress2 < 0.5 ? from : to;
    };
  },
  difference(from, to,) {
    return from === to ? 0 : 1;
  },
};
var ObjectInterpolation = (valueInterpolation,) => {
  return {
    interpolate(from, to,) {
      [from, to,] = Interpolation.handleUndefined(from, to,);
      const result = Object.assign({}, from,);
      const interpolations = {};
      const keys3 = /* @__PURE__ */ new Set();
      for (const key7 in from) {
        interpolations[key7] = valueInterpolation.interpolate(from[key7], to[key7],);
        keys3.add(key7,);
      }
      for (const key7 in to) {
        if (!keys3.has(key7,)) {
          interpolations[key7] = valueInterpolation.interpolate(from[key7], to[key7],);
          keys3.add(key7,);
        }
      }
      return (progress2,) => {
        for (const key7 in interpolations) {
          result[key7] = interpolations[key7](progress2,);
        }
        return result;
      };
    },
    difference(from, to,) {
      let sum = 0;
      for (const key7 in from) {
        const difference = valueInterpolation.difference(from[key7], to[key7],);
        sum += Math.pow(difference, 2,);
      }
      return Math.sqrt(sum,);
    },
  };
};
var DefaultInterpolationOptions = {
  colorModel: 'husl',
  /* HUSL */
};
var ValueInterpolation = class {
  /**
   * @internal
   */
  constructor(options = DefaultInterpolationOptions,) {
    __publicField(this, 'options',);
    __publicField(this, 'interpolate', (from, to,) => {
      [from, to,] = Interpolation.handleUndefined(from, to,);
      return this.interPolationForValue(from,).interpolate(from, to,);
    },);
    __publicField(this, 'difference', (from, to,) => {
      const interpolation = this.interPolationForValue(from,);
      return interpolation.difference(from, to,);
    },);
    this.options = { ...DefaultInterpolationOptions, ...options, };
  }
  /**
   * @internal
   */
  interPolationForValue(value,) {
    const type = typeof value;
    if (type === 'number') {
      return NumberInterpolation;
    } else if (type === 'boolean' || type === 'function') {
      return NoInterpolation;
    } else if (Color.isColor(value,)) {
      return ColorInterpolation(this.options.colorModel,);
    } else if (type === 'object') {
      if (value === null) {
        return NoInterpolation;
      }
      const constructor = value.constructor;
      if (constructor && isInterpolatable(constructor,)) {
        const interpolation = constructor.interpolationFor(value, this,);
        if (interpolation && interpolation !== this && interpolation.constructor !== ValueInterpolation) {
          return interpolation;
        }
      }
      return ObjectInterpolation(this,);
    }
    console.warn(`No interpolation defined for ${value}`,);
    return NoInterpolation;
  }
};
var AnyInterpolation = /* @__PURE__ */ new ValueInterpolation();
var isMotionValue2 = (v,) => v instanceof MotionValue;
var Defaults2 = {
  delta: 1 / 60,
  maxValues: 1e4,
};
var PrecalculatedAnimator = class {
  constructor(options,) {
    __publicField(this, 'animator',);
    __publicField(this, 'values',);
    __publicField(this, 'currentTime', 0,);
    __publicField(this, 'totalTime',);
    __publicField(this, 'options',);
    this.options = { ...Defaults2, ...options, };
    this.animator = options.animator;
  }
  preCalculate() {
    if (!this.animator.isReady()) {
      return;
    }
    const { delta, } = this.options;
    this.values = [];
    while (!this.animator.isFinished() && this.values.length < this.options.maxValues) {
      let value = this.animator.next(this.options.delta,);
      if (typeof value === 'object' && value) {
        const object = value;
        const copy = { ...object, };
        value = copy;
      }
      this.values.push(value,);
    }
    this.totalTime = this.values.length * delta;
  }
  indexForTime(time22,) {
    return Math.max(
      0,
      Math.min(this.values.length - 1, Math.round(this.values.length * (time22 / this.totalTime),) - 1,),
    );
  }
  valueForTime(time22,) {
    const index = this.indexForTime(time22,);
    const value = this.values[index];
    return value;
  }
  setFrom(value,) {
    this.animator.setFrom(value,);
    this.preCalculate();
  }
  setTo(end,) {
    this.animator.setTo(end,);
    this.preCalculate();
  }
  isReady() {
    return this.values !== void 0 && this.values.length > 0 && this.totalTime > 0;
  }
  next(delta,) {
    this.currentTime += delta;
    return this.valueForTime(this.currentTime,);
  }
  isFinished() {
    return this.totalTime === 0 || this.currentTime >= this.totalTime;
  }
  get endValue() {
    this.preCalculate();
    const value = this.valueForTime(this.totalTime,);
    return this.values.length > 0 ? value : this.animator.next(0,);
  }
};
var import_eventemitter3 = __toESM(require_eventemitter3(), 1,);
var { EventEmitter: EventEmitter3, } = import_eventemitter3.default;
var EventEmitter = class {
  constructor() {
    __publicField(this, '_emitter', new EventEmitter3(),);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  eventListeners() {
    const listeners = {};
    for (const eventName of this._emitter.eventNames()) {
      listeners[eventName] = this._emitter.listeners(eventName,);
    }
    return listeners;
  }
  on(eventName, fn,) {
    this.addEventListener(eventName, fn, false, false, this,);
  }
  off(eventName, fn,) {
    this.removeEventListeners(eventName, fn,);
  }
  once(eventName, fn,) {
    this.addEventListener(eventName, fn, true, false, this,);
  }
  unique(eventName, fn,) {
    this.addEventListener(eventName, fn, false, true, this,);
  }
  addEventListener(eventName, fn, once, unique, context,) {
    if (unique) {
      for (const name of this._emitter.eventNames()) {
        if (fn === this._emitter.listeners(name,)) {
          return;
        }
      }
    }
    if (once === true) {
      this._emitter.once(eventName, fn, context,);
    } else {
      this._emitter.addListener(eventName, fn, context,);
    }
  }
  removeEventListeners(eventName, fn,) {
    if (eventName) {
      this._emitter.removeListener(eventName, fn,);
    } else {
      this.removeAllEventListeners();
    }
  }
  removeAllEventListeners() {
    this._emitter.removeAllListeners();
  }
  countEventListeners(eventName, handler,) {
    if (eventName) {
      return this._emitter.listeners(eventName,).length;
    } else {
      let count = 0;
      for (const name of this._emitter.eventNames()) {
        count += this._emitter.listeners(name,).length;
      }
      return count;
    }
  }
  emit(eventName, ...args) {
    this._emitter.emit(eventName, ...args,);
  }
};
var mockWindow = {
  addEventListener: () => {
  },
  removeEventListener: () => {
  },
  dispatchEvent: () => false,
  ResizeObserver: void 0,
  onpointerdown: false,
  onpointermove: false,
  onpointerup: false,
  ontouchstart: false,
  ontouchmove: false,
  ontouchend: false,
  onmousedown: false,
  onmousemove: false,
  onmouseup: false,
  devicePixelRatio: 1,
  scrollX: 0,
  scrollY: 0,
  location: {
    href: '',
  },
  setTimeout: () => 0,
  clearTimeout: () => {
  },
  setInterval: () => 0,
  clearInterval: () => {
  },
  requestAnimationFrame: () => 0,
  cancelAnimationFrame: () => {
  },
  getSelection: () => null,
  matchMedia: (query,) => {
    return {
      matches: false,
      media: query,
      onchange: () => {
      },
      addEventListener: () => {
      },
      removeEventListener: () => {
      },
      addListener: () => {
      },
      removeListener: () => {
      },
      dispatchEvent: () => false,
    };
  },
  innerHeight: 0,
  innerWidth: 0,
  SVGSVGElement: {},
};
var safeWindow = typeof window === 'undefined' ? mockWindow : window;
var _raf = (f,) => {
  setTimeout(f, 1 / 60,);
};
var __raf = safeWindow['requestAnimationFrame'] || _raf;
var raf = (f,) => __raf(f,);
var LoopTimeStep = 1 / 60;
var Loop = class extends EventEmitter {
  /**
   * @internal
   */
  constructor(start = false,) {
    super();
    __publicField(this, '_started', false,);
    __publicField(this, '_frame', 0,);
    __publicField(this, '_frameTasks', [],);
    __publicField(this, 'tick', () => {
      if (!this._started) {
        return;
      }
      raf(this.tick,);
      this.emit('update', this._frame, LoopTimeStep,);
      this.emit('render', this._frame, LoopTimeStep,);
      this._processFrameTasks();
      this._frame++;
    },);
    if (start) {
      this.start();
    }
  }
  /**
   * To add a task to be done at the end of a frame.
   * Tasks added from a task will be ignored. These will run after loop events have been processed.
   * @internal
   */
  addFrameTask(task,) {
    this._frameTasks.push(task,);
  }
  _processFrameTasks() {
    var _a;
    const postEventTasks = this._frameTasks;
    const length = postEventTasks.length;
    if (length === 0) {
      return;
    }
    for (let i = 0; i < length; i++) {
      (_a = postEventTasks[i]) == null ? void 0 : _a.call(postEventTasks,);
    }
    postEventTasks.length = 0;
  }
  /**
   * @internal
   */
  static set TimeStep(value,) {
    LoopTimeStep = value;
  }
  /**
   * @internal
   */
  static get TimeStep() {
    return LoopTimeStep;
  }
  /**
   * @internal
   */
  start() {
    if (this._started) {
      return this;
    }
    this._frame = 0;
    this._started = true;
    raf(this.tick,);
    return this;
  }
  /**
   * @internal
   * @deprecated Don’t use `stop` as you could be stopping the MainLoop for others.
   */
  stop() {
    this._started = false;
    return this;
  }
  /**
   * @internal
   */
  get frame() {
    return this._frame;
  }
  /**
   * @internal
   */
  get time() {
    return this._frame * LoopTimeStep;
  }
};
var MainLoop = new Loop();
var RenderTarget = /* @__PURE__ */ ((RenderTarget2,) => {
  RenderTarget2['canvas'] = 'CANVAS';
  RenderTarget2['export'] = 'EXPORT';
  RenderTarget2['thumbnail'] = 'THUMBNAIL';
  RenderTarget2['preview'] = 'PREVIEW';
  return RenderTarget2;
})(RenderTarget || {},);
var RenderEnvironment = {
  target: 'PREVIEW',
  zoom: 1,
};
function executeInRenderEnvironment(customEnvironment, task,) {
  const previousEnvironment = Object.assign({}, RenderEnvironment,);
  Object.assign(RenderEnvironment, customEnvironment,);
  const result = task();
  Object.assign(RenderEnvironment, previousEnvironment,);
  return result;
}
function setGlobalRenderEnvironment(environment2,) {
  Object.assign(RenderEnvironment, environment2,);
}
function useRenderEnvironment(target, zoom,) {
  let willChangeElements = false;
  if (RenderEnvironment.target !== target) {
    RenderEnvironment.target = target;
    willChangeElements = true;
  }
  if (RenderEnvironment.zoom !== zoom) {
    RenderEnvironment.zoom = zoom;
  }
  return { willChangeElements, };
}
((RenderTarget2,) => {
  function current() {
    return RenderEnvironment.target;
  }
  RenderTarget2.current = current;
  function hasRestrictions() {
    const target = RenderEnvironment.target;
    if (target === 'CANVAS') {
      return true;
    }
    if (target === 'EXPORT') {
      return true;
    }
    return false;
  }
  RenderTarget2.hasRestrictions = hasRestrictions;
})(RenderTarget || (RenderTarget = {}),);
var AnimationDriver = class {
  constructor(animator, updateCallback, finishedCallback,) {
    this.animator = animator;
    this.updateCallback = updateCallback;
    this.finishedCallback = finishedCallback;
    __publicField(this, 'update', (frame2, elapsed,) => {
      if (this.animator.isFinished()) {
        this.finish();
      } else {
        const value = this.animator.next(elapsed,);
        this.updateCallback(value,);
      }
    },);
    if (!this.animator.isReady()) {
      console.warn('AnimationDriver initialized with animator that isn\'t ready',);
    }
  }
  finish() {
    if (this.finishedCallback) {
      this.finishedCallback(this.animator.isFinished(),);
    }
  }
  isFinished() {
    return this.animator.isFinished();
  }
};
var MainLoopAnimationDriver = class extends AnimationDriver {
  play() {
    if (RenderEnvironment.target !== 'PREVIEW') {
      this.finishedCallback && this.finishedCallback(false,);
      return;
    }
    MainLoop.on('update', this.update,);
  }
  cancel() {
    MainLoop.off('update', this.update,);
  }
  finish() {
    MainLoop.off('update', this.update,);
    super.finish();
  }
};
var DefaultDeprecatedAnimationOptions = {
  precalculate: false,
  colorModel: 'husl',
  /* HUSL */
};
var FramerAnimation = class {
  /**
   * @internal
   */
  constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver,) {
    __publicField(this, 'driver',);
    __publicField(this, 'playStateSource', 'idle',);
    __publicField(this, 'onfinish',);
    __publicField(this, 'oncancel',);
    __publicField(this, 'readyPromise', Promise.resolve(),);
    __publicField(this, 'readyResolve',);
    __publicField(this, 'finishedPromise',);
    __publicField(this, 'finishedResolve',);
    __publicField(this, 'finishedReject',);
    this.resetFinishedPromise();
    const deprecatedAnimationOptions = { ...DefaultDeprecatedAnimationOptions, };
    const animatorOptions = {};
    if (options) {
      Object.assign(deprecatedAnimationOptions, options,);
      Object.assign(animatorOptions, options,);
    }
    let interpolation;
    if (deprecatedAnimationOptions.customInterpolation) {
      interpolation = deprecatedAnimationOptions.customInterpolation;
    } else {
      interpolation = new ValueInterpolation(options,);
    }
    let animator;
    if (!animatorClass) {
      animator = new BezierAnimator({}, interpolation,);
    } else {
      animator = new animatorClass(animatorOptions, interpolation,);
    }
    if (deprecatedAnimationOptions.precalculate) {
      animator = new PrecalculatedAnimator({ animator, },);
    }
    animator.setFrom(from,);
    animator.setTo(to,);
    const updateCallback = (value,) => {
      FramerAnimation.driverCallbackHandler(target, value,);
    };
    const finishedCallback = (isFinished,) => {
      if (isFinished) {
        FramerAnimation.driverCallbackHandler(target, to,);
        if (this.playStateSource === 'running') {
          this.playStateValue = 'finished';
        }
      }
    };
    this.driver = new driverClass(animator, updateCallback, finishedCallback,);
  }
  /**
   * @internal
   */
  static driverCallbackHandler(target, value,) {
    if (isAnimatable2(target,) || isMotionValue2(target,)) {
      target.set(value,);
    } else {
      const targetObject = target;
      Animatable.transaction((update,) => {
        for (const key7 in targetObject) {
          const targetValue = targetObject[key7];
          if (isAnimatable2(targetValue,)) {
            update(targetValue, value[key7],);
          } else {
            targetObject[key7] = value[key7];
          }
        }
      },);
    }
  }
  /**
   * @internal
   */
  get playStateValue() {
    return this.playStateSource;
  }
  /**
   * @internal
   */
  set playStateValue(value,) {
    if (value !== this.playStateSource) {
      const oldValue = value;
      this.playStateSource = value;
      switch (value) {
        case 'idle':
          if (oldValue === 'running') {
            this.oncancel && this.oncancel();
          }
          this.readyResolve && this.readyResolve();
          this.resetReadyPromise();
          break;
        case 'finished':
          if (oldValue === 'idle') {
            console.warn('Bad state transition',);
            break;
          }
          this.onfinish && this.onfinish();
          this.finishedResolve && this.finishedResolve();
          break;
        case 'running':
          this.resetReadyPromise();
          break;
      }
      if (oldValue === 'finished') {
        this.resetFinishedPromise();
      }
      if (value === 'finished') {
        this.playStateValue = 'idle';
      }
    }
  }
  /**
   * @internal
   */
  get playState() {
    return this.playStateValue;
  }
  /**
   * @internal
   */
  resetReadyPromise() {
    this.readyResolve = null;
    this.readyPromise = new Promise((resolve, reject,) => {
      this.readyResolve = resolve;
    },);
  }
  /**
       * Wait for the animation to be ready to play.
       * @remarks
       * ```jsx
       * const animation = animate.ease(value, 100)
       * animation.ready().then(() => {
       *    // Animation is ready
       * })

       * // async/await syntax
       * const animation = animate.ease(value, 100)
       * await animation.ready()
       * // Animation is ready
       * ```
       * @returns Promise that is resolved when the animation is ready to play
       * @public
       */
  get ready() {
    return this.readyPromise;
  }
  /**
   * @internal
   */
  resetFinishedPromise() {
    this.finishedResolve = null;
    this.finishedReject = null;
    this.finishedPromise = new Promise((resolve, reject,) => {
      this.finishedResolve = resolve;
      this.finishedReject = reject;
    },);
    this.finishedPromise.catch((reason,) => {
    },);
  }
  /**
   * Wait for the animation to be finished.
   * @remarks
   * ```jsx
   * // async/await syntax
   * const animation = animate.ease(value, 100)
   * await animation.finished()
   * // Animation is finished
   *
   * const animation = animate.ease(value, 100)
   * animation.ready().then(() => {
   *    // Animation is finished
   * })
   * ```
   * @returns Promise that is resolved when the animation is ready to play
   * @public
   */
  get finished() {
    return this.finishedPromise;
  }
  /**
   * @internal
   */
  play() {
    this.playStateValue = 'running';
    this.driver.play();
  }
  /**
   * Cancels the animation if it is still running.
   * @remarks
   * ```jsx
   * const animation = animate.ease(value, 100, {duration: 3})
   * setTimeout(() => animation.cancel(), 500)
   * ```
   * @public
   */
  cancel() {
    if (this.playStateValue !== 'running') {
      return;
    }
    this.driver.cancel();
    if (this.playState !== 'idle') {
      const reason = 'AbortError';
      this.finishedReject && this.finishedReject(reason,);
    }
    this.playStateValue = 'idle';
  }
  /**
   * @internal
   */
  finish() {
    if (this.playStateSource === 'running') {
      this.playStateValue = 'finished';
      this.driver.finish();
    }
  }
  /**
   * @internal
   */
  isFinished() {
    return this.playStateValue === 'finished';
  }
};
var correctBorderScale = (axis,) => ({
  correct: (latest, { delta, treeScale, },) => {
    if (typeof latest === 'string') {
      latest = parseFloat(latest,);
    }
    if (latest === 0) {
      return '0px';
    }
    let corrected = latest;
    if (delta && treeScale) {
      corrected = Math.round(latest / delta[axis].scale / treeScale[axis],);
      corrected = Math.max(corrected, 1,);
    }
    return corrected + 'px';
  },
});
addScaleCorrector({
  borderTopWidth: correctBorderScale('y',),
  borderLeftWidth: correctBorderScale('x',),
  borderRightWidth: correctBorderScale('x',),
  borderBottomWidth: correctBorderScale('y',),
},);
function MotionSetup({ children, },) {
  return /* @__PURE__ */ React17.createElement(React17.Fragment, null, children,);
}
function startAnimation(_key, value, target, transition = {},) {
  warnOnce2(
    `"startAnimation" is unsupported. Use "animate" instead: https://www.framer.com/api/motion/utilities/#animate`,
  );
  return new Promise((resolve,) => {
    animate(value, target, {
      ...transition,
      onComplete: () => resolve(),
    },);
  },);
}
function deprecatedAnimate(from, to, animator, options,) {
  deprecationWarning('animate()', '2.0.0', 'the new animation API (https://www.framer.com/api/animation/)',);
  const target = from;
  let fromValue;
  if (isAnimatable2(from,) || isMotionValue2(from,)) {
    fromValue = from.get();
  } else {
    fromValue = Animatable.objectToValues(from,);
  }
  const animation = new FramerAnimation(target, fromValue, to, animator, options,);
  animation.play();
  return animation;
}
var animate2 = /* @__PURE__ */ (() => {
  function animate3(from, to, animatorOrTransition, options,) {
    return isAnimatable2(from,) ? deprecatedAnimate(from, to, animatorOrTransition, options,) : animate(from, to, animatorOrTransition,);
  }
  animate3.spring = (from, to, options,) => {
    return animate3(from, to, SpringAnimator, options,);
  };
  animate3.bezier = (from, to, options,) => {
    return animate3(from, to, BezierAnimator, options,);
  };
  animate3.linear = (from, to, options,) => {
    return animate3.bezier(from, to, {
      ...options,
      curve: 'linear',
      /* Linear */
    },);
  };
  animate3.ease = (from, to, options,) => {
    return animate3.bezier(from, to, {
      ...options,
      curve: 'ease',
      /* Ease */
    },);
  };
  animate3.easeIn = (from, to, options,) => {
    return animate3.bezier(from, to, {
      ...options,
      curve: 'ease-in',
      /* EaseIn */
    },);
  };
  animate3.easeOut = (from, to, options,) => {
    return animate3.bezier(from, to, {
      ...options,
      curve: 'ease-out',
      /* EaseOut */
    },);
  };
  animate3.easeInOut = (from, to, options,) => {
    return animate3.bezier(from, to, {
      ...options,
      curve: 'ease-in-out',
      /* EaseInOut */
    },);
  };
  return animate3;
})();
function assert(condition, ...msg2) {
  var _a, _b;
  if (condition) {
    return;
  }
  const e = Error('Assertion Error' + (msg2.length > 0 ? ': ' + msg2.join(' ',) : ''),);
  if (e.stack) {
    try {
      const lines = e.stack.split('\n',);
      if ((_a = lines[1]) == null ? void 0 : _a.includes('assert',)) {
        lines.splice(1, 1,);
        e.stack = lines.join('\n',);
      } else if ((_b = lines[0]) == null ? void 0 : _b.includes('assert',)) {
        lines.splice(0, 1,);
        e.stack = lines.join('\n',);
      }
    } catch {
    }
  }
  throw e;
}
function assertNever(x, error,) {
  throw error || new Error(x ? `Unexpected value: ${x}` : 'Application entered invalid state',);
}
var LayoutIdContext = React18.createContext({
  getLayoutId: (args,) => null,
  persistLayoutIdCache: () => {
  },
  top: false,
  enabled: true,
},);
function LayoutIdProvider({ children, },) {
  const context = useContext22(LayoutIdContext,);
  if (context.top) {
    return /* @__PURE__ */ React18.createElement(React18.Fragment, null, children,);
  }
  const cache3 = useRef22({
    // When we provide a layoutId for a node based on it's first
    // duplicatedFrom id, we save it's layoutId mapped to it's actual id.
    // Future screen's nodes will check this cache first, to see if they've
    // previously been assigned a layoutId, or if any of there other
    // duplicatedFrom ids matched a node that was previously assigned a
    // layoutId.
    byId: {},
    byName: {},
    // When we navigate from screens that were duplicated from a future
    // screen, to that future screen, we want to do a reverse lookup on the
    // last duplicatedFrom id, rather than the id. We need to keep them
    // separate so they don't overlap.
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {},
    // When we don't have a cached layoutId for all duplicatedFrom ids, we
    // need to increment and save it so that we don't create clashing
    // layoutIds. We also need to reset name counts between screens, so we
    // record those separately.
    count: {
      byId: {},
      byName: {},
    },
  },);
  const screen = useRef22({
    byId: {},
    byName: {},
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {},
  },);
  const usedIds = useRef22(/* @__PURE__ */ new Set(),).current;
  const getLayoutId = useCallback32(({ id: id3, name, duplicatedFrom, },) => {
    var _a;
    if (!id3) {
      return null;
    }
    const cacheKey = name ? 'byName' : 'byId';
    const previousId = cache3.current[cacheKey][id3];
    if (previousId) {
      return previousId;
    }
    const nodeIdentifier = name || id3;
    if (
      !duplicatedFrom && !usedIds.has(nodeIdentifier,) &&
      (!cache3.current.byLayoutId[nodeIdentifier] || cache3.current.byLayoutId[nodeIdentifier] === nodeIdentifier)
    ) {
      if (cache3.current.count[cacheKey][nodeIdentifier] === void 0) {
        cache3.current.count[cacheKey][nodeIdentifier] = 0;
        cache3.current.byLayoutId[nodeIdentifier] = nodeIdentifier;
        screen.current[cacheKey][id3] = nodeIdentifier;
      }
      usedIds.add(nodeIdentifier,);
      return nodeIdentifier;
    }
    let possibleMatch = void 0;
    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {
      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {
        const duplicatedId = duplicatedFrom[index];
        assert(!!duplicatedId, `duplicatedId must be defined`,);
        const match = cache3.current[cacheKey][duplicatedId];
        const byLastIdMatch = cache3.current.byLastId[duplicatedId];
        if (byLastIdMatch && !possibleMatch) {
          const matchedLayoutId = cache3.current.byLayoutId[byLastIdMatch];
          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;
          if (byLastIdMatch && !usedIds.has(byLastIdMatch,) && (name ? shouldUseNamedLastIdMatch : true)) {
            possibleMatch = [byLastIdMatch, duplicatedId,];
          }
        }
        const previousLayoutId = match ? cache3.current.byLayoutId[match] : void 0;
        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;
        if (match && !usedIds.has(match,) && (name ? shouldUseNamedMatch : true)) {
          screen.current[cacheKey][id3] = match;
          screen.current.byLastId[duplicatedId] = match;
          usedIds.add(match,);
          return match;
        }
      }
    }
    const last = cache3.current.byLastId[id3];
    if (last && !usedIds.has(last,)) {
      usedIds.add(last,);
      screen.current.byId[id3] = last;
      return last;
    }
    if (possibleMatch) {
      const [match, duplicatedId,] = possibleMatch;
      screen.current[cacheKey][id3] = match;
      screen.current.byLastId[duplicatedId] = match;
      usedIds.add(match,);
      return match;
    }
    const possible = cache3.current.byPossibleId[id3];
    if (possible && !usedIds.has(possible,)) {
      usedIds.add(possible,);
      screen.current.byId[id3] = possible;
      return possible;
    }
    const rootDuplicatedId = duplicatedFrom == null ? void 0 : duplicatedFrom[0];
    const identifier = name || rootDuplicatedId || id3;
    const value = ((_a = cache3.current.count[cacheKey][identifier]) != null ? _a : -1) + 1;
    const { layoutId, value: nextValue, } = nextLayoutId(identifier, value, usedIds,);
    cache3.current.count[cacheKey][identifier] = nextValue;
    screen.current[cacheKey][id3] = layoutId;
    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {
      if (!name) {
        const lastId = duplicatedFrom[duplicatedFrom.length - 1];
        if (lastId) {
          screen.current.byLastId[lastId] = layoutId;
        }
        if (duplicatedFrom.length > 1) {
          for (let index = 0; index < duplicatedFrom.length - 1; index++) {
            const possibleId = duplicatedFrom[index];
            if (possibleId === void 0) {
              continue;
            }
            if (!screen.current.byPossibleId[possibleId]) {
              screen.current.byPossibleId[possibleId] = layoutId;
            }
          }
        }
      }
    }
    screen.current.byLayoutId[layoutId] = nodeIdentifier;
    usedIds.add(layoutId,);
    return layoutId;
  }, [],);
  const persistLayoutIdCache = useCallback32(() => {
    cache3.current = {
      byId: {
        ...cache3.current.byId,
        ...screen.current.byId,
      },
      byLastId: {
        ...cache3.current.byLastId,
        ...screen.current.byLastId,
      },
      byPossibleId: {
        ...cache3.current.byPossibleId,
        ...screen.current.byPossibleId,
      },
      byName: {
        ...cache3.current.byName,
        ...screen.current.byName,
      },
      byLastName: { ...cache3.current.byLastName, ...screen.current.byLastName, },
      byLayoutId: { ...cache3.current.byLayoutId, ...screen.current.byLayoutId, },
      // Unlike the count.byId, we need to reset the count.byName because
      // named layers might not have duplicatedFrom ids (e.g. imported
      // from Figma). When we can use duplicatedFrom ids to check if an id
      // was assigned on a previous screen, we don't increment the count,
      // which means that the count only increments for new items, and
      // only increments on a new screen if the node is new. Since named
      // layers need to always match in some way between screens, we reset
      // the count so that the second named layer on a second screen is
      // always name-1 if it doesn't have any duplicatedFrom ids.
      count: {
        ...cache3.current.count,
        byName: {},
      },
    };
    screen.current = {
      byId: {},
      byName: {},
      byLastId: {},
      byPossibleId: {},
      byLastName: {},
      byLayoutId: {},
    };
    usedIds.clear();
  }, [],);
  const contextValue = useRef22({
    getLayoutId,
    persistLayoutIdCache,
    top: true,
    enabled: true,
  },).current;
  return /* @__PURE__ */ React18.createElement(LayoutIdContext.Provider, { value: contextValue, }, children,);
}
function nextLayoutId(identifier, initialValue, usedIds,) {
  let value = initialValue;
  let layoutId = value ? `${identifier}-${value}` : identifier;
  while (usedIds.has(layoutId,)) {
    value++;
    layoutId = `${identifier}-${value}`;
  }
  return { layoutId, value, };
}
function AutomaticLayoutIds({ enabled = true, ...props },) {
  const context = useContext22(LayoutIdContext,);
  const contextValue = useMemo8(() => {
    return {
      ...context,
      enabled,
    };
  }, [enabled,],);
  return /* @__PURE__ */ React18.createElement(LayoutIdContext.Provider, { ...props, value: contextValue, },);
}
function useConstant2(init,) {
  const ref = useRef32(null,);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
var baseStyle = {
  background: void 0,
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  lineHeight: '1.4em',
  textOverflow: 'ellipsis',
  overflow: 'hidden',
  minHeight: 0,
  width: '100%',
  height: '100%',
};
var errorStyle = {
  ...baseStyle,
  border: '1px solid rgba(149, 149, 149, 0.15)',
  borderRadius: 6,
  fontSize: '12px',
  backgroundColor: 'rgba(149, 149, 149, 0.1)',
  color: '#a5a5a5',
};
var textStyle = {
  overflow: 'hidden',
  whiteSpace: 'nowrap',
  textOverflow: 'ellipsis',
  maxWidth: '100%',
  flexShrink: 0,
  padding: `0 10px`,
};
var titleStyle = {
  ...textStyle,
  // TODO: Use Fresco tokens for this.
  fontWeight: 500,
};
var messageStyle = {
  ...textStyle,
  whiteSpace: 'pre',
  maxHeight: 'calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))',
  WebkitMaskImage: 'linear-gradient(to bottom, black 80%, transparent 100%)',
};
function ErrorPlaceholder(props,) {
  const { error, file, } = props;
  const title = file ? `Error in ${stripSlash(file,)}` : 'Error';
  const message = error instanceof Error ? error.message : '' + error;
  return /* @__PURE__ */ React19.createElement(
    'div',
    { style: errorStyle, },
    /* @__PURE__ */ React19.createElement('div', { className: 'text', style: titleStyle, }, title,),
    message && /* @__PURE__ */ React19.createElement('div', { className: 'text', style: messageStyle, }, message,),
  );
}
function stripSlash(title,) {
  if (title.startsWith('./',)) {
    return title.replace('./', '',);
  }
  return title;
}
function getScaleData(deviceOptions, containerSize,) {
  const { componentWidth, componentHeight, } = getComponentSize(deviceOptions,);
  const scaleX = containerSize.width / componentWidth;
  const scaleY = containerSize.height / componentHeight;
  const scale2 = Math.min(scaleX, scaleY, 1,);
  let screenScalePixelFix = 1;
  if (scale2 < 1) {
    const actualScreenWidth = deviceOptions.screenWidth * scale2;
    const desiredScreenWidth = actualScreenWidth + 1;
    const screenScaleX = desiredScreenWidth / actualScreenWidth;
    const actualScreenHeight = deviceOptions.screenHeight * scale2;
    const desiredScreenHeight = actualScreenHeight + 1;
    const screenScaleY = desiredScreenHeight / actualScreenHeight;
    const screenScale = Math.max(screenScaleX, screenScaleY,);
    screenScalePixelFix = screenScale;
  }
  return {
    scale: scale2,
    screenScalePixelFix,
    scaledComponentWidth: componentWidth * scale2,
    scaledComponentHeight: componentHeight * scale2,
    scaledDeviceWidth: deviceOptions.deviceWidth * scale2,
    scaledDeviceHeight: deviceOptions.deviceHeight * scale2,
  };
}
function getColorsFromTheme(theme, type,) {
  if (type === 'none') {
    return {};
  }
  if (!theme) {
    return {};
  }
  const isDarkTheme = theme === 'dark';
  return {
    shadowColor: isDarkTheme ? 'rgba(0, 0, 0, 0.55)' : 'rgba(0, 0, 0, 0.15)',
    bezelColor: isDarkTheme ? '#222' : '#fff',
    bezelShadeColor: isDarkTheme ? '#000' : 'rgba(0, 0, 0, 0.2)',
    screenColor: isDarkTheme ? '#333' : '#eee',
  };
}
var ErrorBoundary2 = class extends Component3 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'state', {},);
  }
  componentDidCatch(error, info,) {
    let stack = info.componentStack.split('\n',).filter((line,) => line.length !== 0);
    let currentIndex = 0;
    for (const line of stack) {
      if (line.startsWith(`    in ${this.constructor.name}`,)) {
        break;
      }
      currentIndex++;
    }
    stack = stack.slice(0, currentIndex,);
    this.setState({
      lastError: {
        error,
        componentStack: stack,
      },
    },);
  }
  componentDidUpdate(_, prevState,) {
    if (this.state.lastError === void 0) {
      return;
    }
    if (prevState.lastError === this.state.lastError) {
      this.setState({ lastError: void 0, },);
    }
  }
  render() {
    if (this.state.lastError) {
      return /* @__PURE__ */ React20.createElement(ErrorPlaceholder, { error: this.state.lastError.error.message, file: 'Prototype', },);
    }
    return this.props.children;
  }
};
function Device({
  canResize = false,
  children,
  ResizeObserver: ResizeObserver22 = safeWindow.ResizeObserver,
  ...options
},) {
  var _a, _b;
  const optionsRef = React20.useRef(void 0,);
  if (optionsRef.current === void 0) {
    optionsRef.current = options;
  }
  const deviceAppearance = (_a = options.deviceOptions) == null ? void 0 : _a.appearance.type;
  const scaleDataRef = React20.useRef();
  const containerRef = React20.useRef(null,);
  const deviceRef = React20.useRef(null,);
  const screenRef = React20.useRef(null,);
  const updateImperativeScale = ({ scale: scale2, screenScalePixelFix, },) => {
    if (!scaleDataRef.current || !deviceRef.current || !screenRef.current) {
      return;
    }
    deviceRef.current.style.transform = `scale(${scale2})`;
    screenRef.current.style.transform = `scale(${screenScalePixelFix})`;
  };
  if (scaleDataRef.current === void 0 && options.deviceOptions && options.scaleTo && options.scaleTo !== 'dynamic') {
    const scale2 = scaleDataRef.current = getScaleData(options.deviceOptions, options.scaleTo,);
    updateImperativeScale(scale2,);
  }
  const invertScale2 = React20.useCallback(
    (point2,) => {
      if (!scaleDataRef.current) {
        return point2;
      }
      const { scale: scale2 = 1, } = scaleDataRef.current;
      return { x: point2.x / scale2, y: point2.y / scale2, };
    },
    [scaleDataRef,],
  );
  const updateScale = React20.useCallback(() => {
    var _a2;
    const { deviceOptions, scaleTo, onScaleChange, } = (_a2 = optionsRef.current) != null ? _a2 : {};
    if (!deviceOptions || !scaleTo || scaleTo !== 'dynamic' || !containerRef.current) {
      return;
    }
    if (containerRef.current.offsetWidth === 0 || containerRef.current.offsetHeight === 0) {
      return;
    }
    const scaleData = scaleDataRef.current = getScaleData(deviceOptions, {
      width: containerRef.current.offsetWidth,
      height: containerRef.current.offsetHeight,
    },);
    onScaleChange == null ? void 0 : onScaleChange(scaleData,);
    updateImperativeScale(scaleData,);
  }, [],);
  const observer2 = useConstant2(() => {
    if (!ResizeObserver22) {
      return;
    }
    return new ResizeObserver22(() => updateScale());
  },);
  React20.useLayoutEffect(() => {
    optionsRef.current = {
      deviceOptions: options.deviceOptions,
      onScaleChange: options.onScaleChange,
      overrideTheme: options.overrideTheme,
      scaleTo: options.scaleTo,
    };
  }, [options.deviceOptions, options.onScaleChange, options.overrideTheme, options.scaleTo,],);
  React20.useLayoutEffect(() => {
    updateScale();
  }, [updateScale,],);
  React20.useEffect(() => {
    if (!observer2 || !containerRef.current) {
      return;
    }
    observer2.observe(containerRef.current,);
    return () => observer2.disconnect();
  }, [observer2,],);
  const { containerStyle, handStyle, deviceStyle, deviceImageStyle, screenStyle, } = getDeviceStyle(options,);
  const resizeStyles = canResize
    ? {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100%',
    }
    : {};
  const screenBackground = ((_b = options.deviceOptions) == null ? void 0 : _b.transparentBackground) ? 'transparent' : 'white';
  return /* @__PURE__ */ React20.createElement(
    'div',
    { style: { ...containerStyle, ...resizeStyles, }, ref: containerRef, },
    /* @__PURE__ */ React20.createElement(
      'div',
      { style: { ...deviceStyle, }, ref: deviceRef, },
      handStyle && /* @__PURE__ */ React20.createElement('div', { style: handStyle, },),
      deviceAppearance === 'external-clay' && deviceImageStyle && /* @__PURE__ */
        React20.createElement('div', { style: deviceImageStyle, },),
      /* @__PURE__ */ React20.createElement(
        'div',
        {
          style: {
            ...screenStyle,
            pointerEvents: void 0,
            backgroundColor: children ? screenBackground : screenStyle.backgroundColor,
          },
          ref: screenRef,
        },
        /* @__PURE__ */ React20.createElement(
          MotionConfig,
          { transformPagePoint: invertScale2, },
          /* @__PURE__ */ React20.createElement(ErrorBoundary2, null, children,),
        ),
      ),
      deviceAppearance === 'realistic' && deviceImageStyle && /* @__PURE__ */ React20.createElement('div', { style: deviceImageStyle, },),
    ),
  );
}
var DEVICE_PADDING = 45;
var HAND_IMG_WIDTH = 2400;
var HAND_IMG_HEIGHT = 3740;
var HAND_IMG_GAP_WIDTH = 859;
var HAND_IMG_GAP_LEFT = 772;
var HAND_IMG_GAP_BOTTOM = 992 - 5;
var noDeviceSize = { componentWidth: 500, componentHeight: 500, };
function getComponentSize(options,) {
  if (!options) {
    return noDeviceSize;
  }
  const { deviceWidth, deviceHeight, noPadding, } = options;
  const padding = noPadding ? 0 : DEVICE_PADDING * 2;
  return {
    componentWidth: deviceWidth + padding,
    componentHeight: deviceHeight + padding,
  };
}
function getDeviceStyle({ scaleTo, deviceOptions, overrideTheme, } = {},) {
  var _a, _b, _c;
  const noDeviceStyle = { containerStyle: {}, deviceStyle: {}, screenStyle: {}, };
  if (!deviceOptions) {
    return noDeviceStyle;
  }
  const { componentWidth, componentHeight, } = getComponentSize(deviceOptions,);
  const overriddenColors = getColorsFromTheme(overrideTheme, deviceOptions.appearance.type,);
  const {
    deviceWidth,
    deviceHeight,
    appearance,
    screenWidth,
    screenHeight,
    screenMaxHeight,
    screenOffsetTop,
    screenOffsetLeft,
    screenRadius,
    screenMaskImage,
    screenColor,
    shadow,
    background,
    transparentBackground,
    hand,
  } = deviceOptions;
  const boxShadows = [];
  if (appearance.type === 'clay' && shadow) {
    boxShadows.push(shadow,);
  }
  let bezelStyle = void 0;
  if (appearance.type === 'clay') {
    bezelStyle = {
      borderRadius: appearance.bezelRadius,
      backgroundColor: overriddenColors.bezelColor || appearance.bezelColor,
    };
    if (overriddenColors.bezelShadeColor || appearance.bezelShadeColor) {
      boxShadows.push(`inset 0 0 15px ${overriddenColors.bezelShadeColor || appearance.bezelShadeColor}`,);
    }
  }
  const handOffsetLeft = (_a = hand == null ? void 0 : hand.offsetLeft) != null ? _a : 0;
  const handOffsetRight = (_b = hand == null ? void 0 : hand.offsetRight) != null ? _b : 0;
  const handOffsetBottom = (_c = hand == null ? void 0 : hand.offsetBottom) != null ? _c : 0;
  const handScale = (deviceWidth - handOffsetLeft - handOffsetRight) / HAND_IMG_GAP_WIDTH;
  return {
    containerStyle: {
      width: scaleTo ? '100%' : componentWidth,
      height: scaleTo ? '100%' : componentHeight,
      flex: '1 1 0',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      overflow: 'hidden',
      background,
    },
    handStyle: hand && {
      width: HAND_IMG_WIDTH * handScale,
      height: HAND_IMG_HEIGHT * handScale,
      position: 'absolute',
      pointerEvents: 'none',
      backgroundImage: `url("${hand.imageUrl}")`,
      backgroundSize: 'contain',
      backgroundRepeat: 'no-repeat',
      left: -HAND_IMG_GAP_LEFT * handScale + handOffsetLeft,
      bottom: -HAND_IMG_GAP_BOTTOM * handScale + handOffsetBottom,
    },
    deviceStyle: {
      width: deviceWidth,
      height: deviceHeight,
      flexShrink: 0,
      position: 'absolute',
      boxShadow: boxShadows.join(',',),
      ...bezelStyle,
    },
    deviceImageStyle: appearance.type === 'realistic' || appearance.type === 'external-clay'
      ? {
        width: appearance.imageWidth,
        height: appearance.imageHeight,
        position: 'absolute',
        pointerEvents: 'none',
        overflow: 'hidden',
        backgroundImage: `url("${appearance.imageUrl}")`,
        backgroundPosition: 'top left',
        backgroundRepeat: 'no-repeat',
        backgroundSize: `${appearance.imageWidth}px ${appearance.imageHeight}px`,
        // Rotate 90 degrees counter-clockwise around (0,0), then move the
        // result down into the viewport (rightmost transform is applied first).
        transformOrigin: 'top left',
        transform: appearance.rotateImage ? `translateY(${appearance.imageWidth}px) rotate(-90deg)` : void 0,
      }
      : void 0,
    screenStyle: {
      width: screenWidth,
      height: screenHeight,
      maxHeight: screenMaxHeight,
      position: 'absolute',
      top: screenOffsetTop,
      left: screenOffsetLeft,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      overflow: 'hidden',
      borderRadius: screenRadius,
      backgroundColor: overriddenColors.screenColor || screenColor,
      ...screenMaskImage && {
        maskImage: screenMaskImage,
        WebkitMaskImage: screenMaskImage,
        maskSize: 'contain',
        WebkitMaskSize: 'contain',
      },
    },
  };
}
function isFiniteNumber(value,) {
  return typeof value === 'number' && isFinite(value,);
}
function finiteNumber(value,) {
  return isFiniteNumber(value,) ? value : void 0;
}
function isEmpty(obj,) {
  return !obj || !Object.keys(obj,).length && obj.constructor === Object;
}
function isReactElement(test2,) {
  return typeof test2 !== 'string' && typeof test2 !== 'number';
}
function isReactChild(test2,) {
  return test2 !== null && typeof test2 !== 'undefined' && typeof test2 !== 'boolean' && !isEmpty(test2,);
}
var Rect;
((Rect2,) => {
  function equals(rect, other,) {
    if (rect === other) {
      return true;
    }
    if (!rect || !other) {
      return false;
    }
    return rect.x === other.x && rect.y === other.y && rect.width === other.width && rect.height === other.height;
  }
  Rect2.equals = equals;
  Rect2.atOrigin = (size2,) => {
    return { ...size2, x: 0, y: 0, };
  };
  Rect2.fromTwoPoints = (a, b,) => {
    return {
      x: Math.min(a.x, b.x,),
      y: Math.min(a.y, b.y,),
      width: Math.abs(a.x - b.x,),
      height: Math.abs(a.y - b.y,),
    };
  };
  Rect2.fromRect = (rect,) => {
    return {
      x: rect.left,
      y: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top,
    };
  };
  Rect2.multiply = (rect, n,) => {
    return {
      x: rect.x * n,
      y: rect.y * n,
      width: rect.width * n,
      height: rect.height * n,
    };
  };
  Rect2.divide = (rect, n,) => {
    return (0, Rect2.multiply)(rect, 1 / n,);
  };
  Rect2.offset = (rect, delta2,) => {
    const xOffset = typeof delta2.x === 'number' ? delta2.x : 0;
    const yOffset = typeof delta2.y === 'number' ? delta2.y : 0;
    return {
      ...rect,
      x: rect.x + xOffset,
      y: rect.y + yOffset,
    };
  };
  function inflate(rect, value,) {
    if (value === 0) {
      return rect;
    }
    const doubleValue = 2 * value;
    return {
      x: rect.x - value,
      y: rect.y - value,
      width: rect.width + doubleValue,
      height: rect.height + doubleValue,
    };
  }
  Rect2.inflate = inflate;
  Rect2.pixelAligned = (rect,) => {
    const x = Math.round(rect.x,);
    const y = Math.round(rect.y,);
    const rectMaxX = Math.round(rect.x + rect.width,);
    const rectMaxY = Math.round(rect.y + rect.height,);
    const width = Math.max(rectMaxX - x, 0,);
    const height = Math.max(rectMaxY - y, 0,);
    return { x, y, width, height, };
  };
  Rect2.halfPixelAligned = (rect,) => {
    const x = Math.round(rect.x * 2,) / 2;
    const y = Math.round(rect.y * 2,) / 2;
    const rectMaxX = Math.round((rect.x + rect.width) * 2,) / 2;
    const rectMaxY = Math.round((rect.y + rect.height) * 2,) / 2;
    const width = Math.max(rectMaxX - x, 1,);
    const height = Math.max(rectMaxY - y, 1,);
    return { x, y, width, height, };
  };
  Rect2.round = (rect, decimals = 0,) => {
    const x = roundedNumber(rect.x, decimals,);
    const y = roundedNumber(rect.y, decimals,);
    const width = roundedNumber(rect.width, decimals,);
    const height = roundedNumber(rect.height, decimals,);
    return { x, y, width, height, };
  };
  Rect2.roundToOutside = (rect,) => {
    const x = Math.floor(rect.x,);
    const y = Math.floor(rect.y,);
    const rectMaxX = Math.ceil(rect.x + rect.width,);
    const rectMaxY = Math.ceil(rect.y + rect.height,);
    const width = Math.max(rectMaxX - x, 0,);
    const height = Math.max(rectMaxY - y, 0,);
    return { x, y, width, height, };
  };
  Rect2.minX = (rect,) => {
    return rect.x;
  };
  Rect2.maxX = (rect,) => {
    return rect.x + rect.width;
  };
  Rect2.minY = (rect,) => {
    return rect.y;
  };
  Rect2.maxY = (rect,) => {
    return rect.y + rect.height;
  };
  Rect2.positions = (rect,) => {
    return {
      minX: rect.x,
      midX: rect.x + rect.width / 2,
      maxX: (0, Rect2.maxX)(rect,),
      minY: rect.y,
      midY: rect.y + rect.height / 2,
      maxY: (0, Rect2.maxY)(rect,),
    };
  };
  Rect2.center = (rect,) => {
    return {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2,
    };
  };
  Rect2.boundingRectFromPoints = (ps,) => {
    const xValues = ps.map((point2,) => point2.x);
    const yValues = ps.map((point2,) => point2.y);
    const x = Math.min(...xValues,);
    const y = Math.min(...yValues,);
    const width = Math.max(...xValues,) - x;
    const height = Math.max(...yValues,) - y;
    return { x, y, width, height, };
  };
  Rect2.fromPoints = (ps,) => {
    const [tl, tr, _, bl,] = ps;
    const { x, y, } = tl;
    const width = Point.distance(tl, tr,);
    const height = Point.distance(tl, bl,);
    return { x, y, width, height, };
  };
  Rect2.merge = (...rect) => {
    const min = {
      x: Math.min(...rect.map(Rect2.minX,),),
      y: Math.min(...rect.map(Rect2.minY,),),
    };
    const max = {
      x: Math.max(...rect.map(Rect2.maxX,),),
      y: Math.max(...rect.map(Rect2.maxY,),),
    };
    return (0, Rect2.fromTwoPoints)(min, max,);
  };
  Rect2.intersection = (rect1, rect2,) => {
    const x = Math.max(rect1.x, rect2.x,);
    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width,);
    const y = Math.max(rect1.y, rect2.y,);
    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height,);
    return { x, y, width: x2 - x, height: y2 - y, };
  };
  Rect2.points = (rect,) => {
    return [
      { x: (0, Rect2.minX)(rect,), y: (0, Rect2.minY)(rect,), },
      { x: (0, Rect2.minX)(rect,), y: (0, Rect2.maxY)(rect,), },
      { x: (0, Rect2.maxX)(rect,), y: (0, Rect2.minY)(rect,), },
      { x: (0, Rect2.maxX)(rect,), y: (0, Rect2.maxY)(rect,), },
    ];
  };
  Rect2.transform = (rect, matrix,) => {
    const { x: x1, y: y1, } = matrix.transformPoint({ x: rect.x, y: rect.y, },);
    const { x: x2, y: y2, } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y, },);
    const { x: x3, y: y3, } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y + rect.height, },);
    const { x: x4, y: y4, } = matrix.transformPoint({ x: rect.x, y: rect.y + rect.height, },);
    const x = Math.min(x1, x2, x3, x4,);
    const width = Math.max(x1, x2, x3, x4,) - x;
    const y = Math.min(y1, y2, y3, y4,);
    const height = Math.max(y1, y2, y3, y4,) - y;
    return { x, y, width, height, };
  };
  Rect2.containsPoint = (rect, point2,) => {
    if (point2.x < (0, Rect2.minX)(rect,)) {
      return false;
    }
    if (point2.x > (0, Rect2.maxX)(rect,)) {
      return false;
    }
    if (point2.y < (0, Rect2.minY)(rect,)) {
      return false;
    }
    if (point2.y > (0, Rect2.maxY)(rect,)) {
      return false;
    }
    if (isNaN(rect.x,)) {
      return false;
    }
    if (isNaN(rect.y,)) {
      return false;
    }
    return true;
  };
  Rect2.containsRect = (rectA, rectB,) => {
    for (const point2 of (0, Rect2.points)(rectB,)) {
      if (!(0, Rect2.containsPoint)(rectA, point2,)) {
        return false;
      }
    }
    return true;
  };
  Rect2.toCSS = (rect,) => {
    return {
      display: 'block',
      transform: `translate(${rect.x}px, ${rect.y}px)`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
    };
  };
  Rect2.inset = (rect, n,) => {
    return {
      x: rect.x + n,
      y: rect.y + n,
      width: Math.max(0, rect.width - 2 * n,),
      height: Math.max(0, rect.height - 2 * n,),
    };
  };
  Rect2.intersects = (rectA, rectB,) => {
    return !(rectB.x >= (0, Rect2.maxX)(rectA,) || (0, Rect2.maxX)(rectB,) <= rectA.x || rectB.y >= (0, Rect2.maxY)(rectA,) ||
      (0, Rect2.maxY)(rectB,) <= rectA.y);
  };
  Rect2.overlapHorizontally = (rectA, rectB,) => {
    const aMax = Rect2.maxX(rectA,);
    const bMax = Rect2.maxX(rectB,);
    return aMax > rectB.x && bMax > rectA.x;
  };
  Rect2.overlapVertically = (rectA, rectB,) => {
    const aMax = Rect2.maxY(rectA,);
    const bMax = Rect2.maxY(rectB,);
    return aMax > rectB.y && bMax > rectA.y;
  };
  Rect2.doesNotIntersect = (rect, rects,) => {
    return rects.find((comparingRect,) => {
      return Rect2.intersects(comparingRect, rect,);
    },) === void 0;
  };
  Rect2.isEqual = (rectA, rectB,) => {
    return Rect2.equals(rectA, rectB,);
  };
  Rect2.cornerPoints = (rect,) => {
    const rectMinX = rect.x;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMaxY = rect.y + rect.height;
    const corner1 = { x: rectMinX, y: rectMinY, };
    const corner2 = { x: rectMaxX, y: rectMinY, };
    const corner3 = { x: rectMaxX, y: rectMaxY, };
    const corner4 = { x: rectMinX, y: rectMaxY, };
    return [corner1, corner2, corner3, corner4,];
  };
  Rect2.midPoints = (rect,) => {
    const rectMinX = rect.x;
    const rectMidX = rect.x + rect.width / 2;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMidY = rect.y + rect.height / 2;
    const rectMaxY = rect.y + rect.height;
    const top = { x: rectMidX, y: rectMinY, };
    const right = { x: rectMaxX, y: rectMidY, };
    const bottom = { x: rectMidX, y: rectMaxY, };
    const left = { x: rectMinX, y: rectMidY, };
    return [top, right, bottom, left,];
  };
  Rect2.pointDistance = (rect, point2,) => {
    let x = 0;
    let y = 0;
    if (point2.x < rect.x) {
      x = rect.x - point2.x;
    } else if (point2.x > Rect2.maxX(rect,)) {
      x = point2.x - Rect2.maxX(rect,);
    }
    if (point2.y < rect.y) {
      y = rect.y - point2.y;
    } else if (point2.y > Rect2.maxY(rect,)) {
      y = point2.y - Rect2.maxY(rect,);
    }
    return Point.distance({ x, y, }, { x: 0, y: 0, },);
  };
  const fromAnyDefaults = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  };
  Rect2.fromAny = (rect, defaults = fromAnyDefaults,) => {
    return {
      x: rect.x || defaults.x,
      y: rect.y || defaults.y,
      width: rect.width || defaults.width,
      height: rect.height || defaults.height,
    };
  };
  Rect2.delta = (a, b,) => {
    const pointA = { x: (0, Rect2.minX)(a,), y: (0, Rect2.minY)(a,), };
    const pointB = { x: (0, Rect2.minX)(b,), y: (0, Rect2.minY)(b,), };
    return {
      x: pointA.x - pointB.x,
      y: pointA.y - pointB.y,
    };
  };
  Rect2.withMinSize = (rect, minSize,) => {
    const { width: minWidth, height: minHeight, } = minSize;
    const diffX = rect.width - minWidth;
    const diffY = rect.height - minHeight;
    return {
      width: Math.max(rect.width, minWidth,),
      height: Math.max(rect.height, minHeight,),
      x: rect.width < minWidth ? rect.x + diffX / 2 : rect.x,
      y: rect.height < minHeight ? rect.y + diffY / 2 : rect.y,
    };
  };
  Rect2.rebaseRectOnto = (rect, anchorRect, direction, alignment,) => {
    const rebasedRect = { ...rect, };
    switch (direction) {
      case 'bottom':
      case 'top':
        switch (alignment) {
          case 'start':
            rebasedRect.x = anchorRect.x;
            break;
          case 'center':
            rebasedRect.x = anchorRect.x + anchorRect.width / 2 - rect.width / 2;
            break;
          case 'end':
            rebasedRect.x = anchorRect.x + anchorRect.width - rect.width;
            break;
          default:
            assertNever(alignment,);
        }
        break;
      case 'left':
        rebasedRect.x = anchorRect.x - rect.width;
        break;
      case 'right':
        rebasedRect.x = anchorRect.x + anchorRect.width;
        break;
      default:
        assertNever(direction,);
    }
    switch (direction) {
      case 'left':
      case 'right':
        switch (alignment) {
          case 'start':
            rebasedRect.y = anchorRect.y;
            break;
          case 'center':
            rebasedRect.y = anchorRect.y + anchorRect.height / 2 - rect.height / 2;
            break;
          case 'end':
            rebasedRect.y = anchorRect.y + anchorRect.height - rect.height;
            break;
          default:
            assertNever(alignment,);
        }
        break;
      case 'top':
        rebasedRect.y = anchorRect.y - rect.height;
        break;
      case 'bottom':
        rebasedRect.y = anchorRect.y + anchorRect.height;
        break;
      default:
        assertNever(direction,);
    }
    return rebasedRect;
  };
})(Rect || (Rect = {}),);
var constraintDefaults = {
  left: null,
  right: null,
  top: null,
  bottom: null,
  centerX: '50%',
  centerY: '50%',
  aspectRatio: null,
  parentSize: null,
  width: 100,
  height: 100,
};
var DimensionType = /* @__PURE__ */ ((DimensionType2,) => {
  DimensionType2[DimensionType2['FixedNumber'] = 0] = 'FixedNumber';
  DimensionType2[DimensionType2['Percentage'] = 1] = 'Percentage';
  DimensionType2[DimensionType2['Auto'] = 2] = 'Auto';
  DimensionType2[DimensionType2['FractionOfFreeSpace'] = 3] = 'FractionOfFreeSpace';
  DimensionType2[DimensionType2['Viewport'] = 4] = 'Viewport';
  return DimensionType2;
})(DimensionType || {},);
function isConstraintSupportingChild(child,) {
  if (!isReactChild(child,) || !isReactElement(child,)) {
    return false;
  }
  return true;
}
var ConstraintMask;
((ConstraintMask2,) => {
  ConstraintMask2.quickfix = (constraints,) => {
    if (constraints.widthType === 2 || constraints.heightType === 2) {
      constraints.aspectRatio = null;
    }
    if (isFiniteNumber(constraints.aspectRatio,)) {
      if (constraints.left && constraints.right) {
        constraints.widthType = 0;
      }
      if (constraints.top && constraints.bottom) {
        constraints.heightType = 0;
      }
      if (constraints.left && constraints.right && constraints.top && constraints.bottom) {
        constraints.bottom = false;
      }
      if (constraints.widthType !== 0 && constraints.heightType !== 0) {
        constraints.heightType = 0;
      }
    }
    if (constraints.left && constraints.right) {
      if (constraints.fixedSize || constraints.widthType === 2 || isFiniteNumber(constraints.maxWidth,)) {
        constraints.right = false;
      }
      constraints.widthType = 0;
    }
    if (constraints.top && constraints.bottom) {
      if (constraints.fixedSize || constraints.heightType === 2 || isFiniteNumber(constraints.maxHeight,)) {
        constraints.bottom = false;
      }
      constraints.heightType = 0;
    }
    return constraints;
  };
})(ConstraintMask || (ConstraintMask = {}),);
function valueToDimensionType(value,) {
  if (typeof value === 'string') {
    const trimmedValue = value.trim();
    if (trimmedValue === 'auto') {
      return 2;
    }
    if (trimmedValue.endsWith('fr',)) {
      return 3;
    }
    if (trimmedValue.endsWith('%',)) {
      return 1;
    }
    if (trimmedValue.endsWith('vw',) || trimmedValue.endsWith('vh',)) {
      return 4;
    }
  }
  return 0;
}
var ConstraintValues;
((ConstraintValues2,) => {
  ConstraintValues2.fromProperties = (props,) => {
    const { left, right, top, bottom, width, height, centerX, centerY, aspectRatio: aspectRatio2, autoSize, } = props;
    const constraints = ConstraintMask.quickfix({
      left: isFiniteNumber(left,) || isAnimatable2(left,),
      right: isFiniteNumber(right,) || isAnimatable2(right,),
      top: isFiniteNumber(top,) || isAnimatable2(top,),
      bottom: isFiniteNumber(bottom,) || isAnimatable2(bottom,),
      widthType: valueToDimensionType(width,),
      heightType: valueToDimensionType(height,),
      aspectRatio: aspectRatio2 || null,
      fixedSize: autoSize === true,
    },);
    let widthValue = null;
    let heightValue = null;
    let widthType = 0;
    let heightType = 0;
    if (constraints.widthType !== 0 && typeof width === 'string') {
      const parsedWidth = parseFloat(width,);
      if (width.endsWith('fr',)) {
        widthType = 3;
        widthValue = parsedWidth;
      } else if (width === 'auto') {
        widthType = 2;
      } else {
        widthType = 1;
        widthValue = parsedWidth / 100;
      }
    } else if (width !== void 0 && typeof width !== 'string') {
      widthValue = Animatable.getNumber(width,);
    }
    if (constraints.heightType !== 0 && typeof height === 'string') {
      const parsedHeight = parseFloat(height,);
      if (height.endsWith('fr',)) {
        heightType = 3;
        heightValue = parsedHeight;
      } else if (height === 'auto') {
        heightType = 2;
      } else {
        heightType = 1;
        heightValue = parseFloat(height,) / 100;
      }
    } else if (height !== void 0 && typeof height !== 'string') {
      heightValue = Animatable.getNumber(height,);
    }
    let centerAnchorX = 0.5;
    let centerAnchorY = 0.5;
    if (centerX) {
      centerAnchorX = parseFloat(centerX,) / 100;
    }
    if (centerY) {
      centerAnchorY = parseFloat(centerY,) / 100;
    }
    return {
      left: constraints.left ? Animatable.getNumber(left,) : null,
      right: constraints.right ? Animatable.getNumber(right,) : null,
      top: constraints.top ? Animatable.getNumber(top,) : null,
      bottom: constraints.bottom ? Animatable.getNumber(bottom,) : null,
      widthType,
      heightType,
      width: widthValue,
      height: heightValue,
      aspectRatio: constraints.aspectRatio || null,
      centerAnchorX,
      centerAnchorY,
    };
  };
  ConstraintValues2.toSize = (values, parentSizeInfo, autoSize, freeSpace,) => {
    let width = null;
    let height = null;
    const parentWidth = (parentSizeInfo == null ? void 0 : parentSizeInfo.sizing)
      ? Animatable.getNumber(parentSizeInfo == null ? void 0 : parentSizeInfo.sizing.width,)
      : null;
    const parentHeight = (parentSizeInfo == null ? void 0 : parentSizeInfo.sizing)
      ? Animatable.getNumber(parentSizeInfo == null ? void 0 : parentSizeInfo.sizing.height,)
      : null;
    const hOpposingPinsOffset = pinnedOffset(values.left, values.right,);
    if (parentWidth && isFiniteNumber(hOpposingPinsOffset,)) {
      width = parentWidth - hOpposingPinsOffset;
    } else if (autoSize && values.widthType === 2) {
      width = autoSize.width;
    } else if (isFiniteNumber(values.width,)) {
      switch (values.widthType) {
        case 0:
          width = values.width;
          break;
        case 3:
          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : null;
          break;
        case 1:
        case 4:
          if (parentWidth) {
            width = parentWidth * values.width;
          }
          break;
        case 2:
          break;
        default:
          assertNever(values.widthType,);
      }
    }
    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom,);
    if (parentHeight && isFiniteNumber(vOpposingPinsOffset,)) {
      height = parentHeight - vOpposingPinsOffset;
    } else if (autoSize && values.heightType === 2) {
      height = autoSize.height;
    } else if (isFiniteNumber(values.height,)) {
      switch (values.heightType) {
        case 0:
          height = values.height;
          break;
        case 3:
          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : null;
          break;
        case 1:
        case 4:
          if (parentHeight) {
            height = parentHeight * values.height;
          }
          break;
        case 2:
          break;
        default:
          assertNever(values.heightType,);
      }
    }
    return sizeAfterApplyingConstraintsAndAspectRatio(
      width,
      height,
      values,
      {
        height: parentHeight != null ? parentHeight : 0,
        width: parentWidth != null ? parentWidth : 0,
      },
      parentSizeInfo == null ? void 0 : parentSizeInfo.viewport,
    );
  };
  ConstraintValues2.toRect = (values, parentSizeInfo = null, autoSize = null, pixelAlign = false, freeSpace = null,) => {
    var _a;
    let x = values.left || 0;
    let y = values.top || 0;
    const { width, height, } = ConstraintValues2.toSize(values, parentSizeInfo, autoSize, freeSpace,);
    const parentSizeForPositioning = (_a = parentSizeInfo == null ? void 0 : parentSizeInfo.positioning) != null ? _a : null;
    const positioningParentWidth = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.width,) : null;
    const positioningParentHeight = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.height,) : null;
    if (values.left !== null) {
      x = values.left;
    } else if (positioningParentWidth && values.right !== null) {
      x = positioningParentWidth - values.right - width;
    } else if (positioningParentWidth) {
      x = values.centerAnchorX * positioningParentWidth - width / 2;
    }
    if (values.top !== null) {
      y = values.top;
    } else if (positioningParentHeight && values.bottom !== null) {
      y = positioningParentHeight - values.bottom - height;
    } else if (positioningParentHeight) {
      y = values.centerAnchorY * positioningParentHeight - height / 2;
    }
    const f = { x, y, width, height, };
    if (pixelAlign) {
      return Rect.pixelAligned(f,);
    }
    return f;
  };
})(ConstraintValues || (ConstraintValues = {}),);
var defaultWidth = 200;
var defaultHeight = 200;
function getConstraintValue(constraint, value, parentSize, viewport,) {
  if (typeof value === 'string') {
    if (value.endsWith('%',) && parentSize) {
      switch (constraint) {
        case 'maxWidth':
        case 'minWidth':
          return parseFloat(value,) / 100 * parentSize.width;
        case 'maxHeight':
        case 'minHeight':
          return parseFloat(value,) / 100 * parentSize.height;
        default:
          break;
      }
    }
    if (value.endsWith('vh',) && viewport) {
      switch (constraint) {
        case 'maxWidth':
        case 'minWidth':
          return parseFloat(value,) / 100 * viewport.width;
        case 'maxHeight':
        case 'minHeight':
          return parseFloat(value,) / 100 * viewport.height;
        default:
          break;
      }
    }
    return parseFloat(value,);
  }
  return value;
}
function constrainHeight(height, values, parentSize, viewport,) {
  if (values.minHeight) {
    height = Math.max(getConstraintValue('minHeight', values.minHeight, parentSize, viewport,), height,);
  }
  if (values.maxHeight) {
    height = Math.min(getConstraintValue('maxHeight', values.maxHeight, parentSize, viewport,), height,);
  }
  return height;
}
function constrainWidth(width, values, parentSize, viewport,) {
  if (values.minWidth) {
    width = Math.max(getConstraintValue('minWidth', values.minWidth, parentSize, viewport,), width,);
  }
  if (values.maxWidth) {
    width = Math.min(getConstraintValue('maxWidth', values.maxWidth, parentSize, viewport,), width,);
  }
  return width;
}
function sizeAfterApplyingConstraintsAndAspectRatio(width, height, values, parentSize, viewport,) {
  let w = constrainWidth(isFiniteNumber(width,) ? width : defaultWidth, values, parentSize, viewport,);
  let h = constrainHeight(isFiniteNumber(height,) ? height : defaultHeight, values, parentSize, viewport,);
  if (isFiniteNumber(values.aspectRatio,) && values.aspectRatio > 0) {
    if (isFiniteNumber(values.left,) && isFiniteNumber(values.right,)) {
      h = w / values.aspectRatio;
    } else if (isFiniteNumber(values.top,) && isFiniteNumber(values.bottom,)) {
      w = h * values.aspectRatio;
    } else if (values.widthType !== 0) {
      h = w / values.aspectRatio;
    } else {
      w = h * values.aspectRatio;
    }
  }
  return {
    width: w,
    height: h,
  };
}
function pinnedOffset(start, end,) {
  if (!isFiniteNumber(start,) || !isFiniteNumber(end,)) {
    return null;
  }
  return start + end;
}
function getMergedConstraintsProps(props, constraints,) {
  const result = {};
  if (props.constraints) {
    result.constraints = { ...props.constraints, ...constraints, };
  } else {
    Object.assign(result, constraints,);
  }
  return result;
}
function containsInvalidStringValues(props,) {
  if (typeof props.right === 'string') {
    return true;
  }
  if (typeof props.bottom === 'string') {
    return true;
  }
  if (typeof props.left === 'string' && (!props.center || props.center === 'y')) {
    return true;
  }
  if (typeof props.top === 'string' && (!props.center || props.center === 'x')) {
    return true;
  }
  return false;
}
function constraintsEnabled(props,) {
  if (!props._constraints) {
    return false;
  }
  if (containsInvalidStringValues(props,)) {
    return false;
  }
  return props._constraints.enabled;
}
function sizeFromFiniteNumberProps(props,) {
  const { size: size2, } = props;
  let { width, height, } = props;
  if (isFiniteNumber(size2,)) {
    if (width === void 0) {
      width = size2;
    }
    if (height === void 0) {
      height = size2;
    }
  }
  if (isFiniteNumber(width,) && isFiniteNumber(height,)) {
    return {
      width,
      height,
    };
  }
  return null;
}
function rectFromFiniteNumberProps(props,) {
  const size2 = sizeFromFiniteNumberProps(props,);
  if (size2 === null) {
    return null;
  }
  const { left, top, } = props;
  if (isFiniteNumber(left,) && isFiniteNumber(top,)) {
    return {
      x: left,
      y: top,
      ...size2,
    };
  }
  return null;
}
function calculateRect(props, parentSize, pixelAlign = true,) {
  if (props.positionFixed || props.positionAbsolute) {
    return null;
  }
  const parentSizeDisabled = parentSize === 1 || parentSize === 2;
  if (!constraintsEnabled(props,) || parentSizeDisabled) {
    return rectFromFiniteNumberProps(props,);
  }
  const constraintValues = getConstraintValues(props,);
  const enabledParentSize = deprecatedParentSize(parentSize,);
  const parentSizeInfo = enabledParentSize ? { sizing: enabledParentSize, positioning: enabledParentSize, viewport: null, } : null;
  return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, pixelAlign, null,);
}
function getConstraintValues(props,) {
  const { left, right, top, bottom, center, _constraints, size: size2, } = props;
  let { width, height, } = props;
  if (width === void 0) {
    width = size2;
  }
  if (height === void 0) {
    height = size2;
  }
  const { aspectRatio: aspectRatio2, autoSize, } = _constraints;
  const constraintMask = ConstraintMask.quickfix({
    left: isFiniteNumber(left,),
    right: isFiniteNumber(right,),
    top: isFiniteNumber(top,),
    bottom: isFiniteNumber(bottom,),
    widthType: valueToDimensionType(width,),
    heightType: valueToDimensionType(height,),
    aspectRatio: aspectRatio2 || null,
    fixedSize: autoSize === true,
  },);
  let widthValue = null;
  let heightValue = null;
  let widthType = 0;
  let heightType = 0;
  if (constraintMask.widthType !== 0 && typeof width === 'string') {
    const parsedWidth = parseFloat(width,);
    if (width.endsWith('fr',)) {
      widthType = 3;
      widthValue = parsedWidth;
    } else if (width === 'auto') {
      widthType = 2;
    } else {
      widthType = 1;
      widthValue = parsedWidth / 100;
    }
  } else if (width !== void 0 && typeof width !== 'string') {
    widthValue = width;
  }
  if (constraintMask.heightType !== 0 && typeof height === 'string') {
    const parsedHeight = parseFloat(height,);
    if (height.endsWith('fr',)) {
      heightType = 3;
      heightValue = parsedHeight;
    } else if (height === 'auto') {
      heightType = 2;
    } else {
      heightType = 1;
      heightValue = parseFloat(height,) / 100;
    }
  } else if (height !== void 0 && typeof height !== 'string') {
    heightValue = height;
  }
  let centerAnchorX = 0.5;
  let centerAnchorY = 0.5;
  if (center === true || center === 'x') {
    constraintMask.left = false;
    if (typeof left === 'string') {
      centerAnchorX = parseFloat(left,) / 100;
    }
  }
  if (center === true || center === 'y') {
    constraintMask.top = false;
    if (typeof top === 'string') {
      centerAnchorY = parseFloat(top,) / 100;
    }
  }
  return {
    // Because we check isFiniteNumber when creating the masks,
    // We know that left, right, top and bottom are numbers if the mask is true for the corresponding value
    // We need to cast this because typescript does not understand that
    left: constraintMask.left ? left : null,
    right: constraintMask.right ? right : null,
    top: constraintMask.top ? top : null,
    bottom: constraintMask.bottom ? bottom : null,
    widthType,
    heightType,
    width: widthValue,
    height: heightValue,
    aspectRatio: constraintMask.aspectRatio || null,
    centerAnchorX,
    centerAnchorY,
    minHeight: props.minHeight,
    maxHeight: props.maxHeight,
    minWidth: props.minWidth,
    maxWidth: props.maxWidth,
  };
}
var ParentSizeState = /* @__PURE__ */ ((ParentSizeState2,) => {
  ParentSizeState2[ParentSizeState2['Unknown'] = 0] = 'Unknown';
  ParentSizeState2[ParentSizeState2['Disabled'] = 1] = 'Disabled';
  ParentSizeState2[ParentSizeState2['DisabledForCurrentLevel'] = 2] = 'DisabledForCurrentLevel';
  return ParentSizeState2;
})(ParentSizeState || {},);
var ConstraintsContext = React21.createContext({
  parentSize: 0,
  /* Unknown */
},);
function deprecatedParentSize(parentSize,) {
  if (parentSize === 0 || parentSize === 1 || parentSize === 2) {
    return null;
  }
  return parentSize;
}
function useParentSize() {
  return React21.useContext(ConstraintsContext,).parentSize;
}
function isSize(o,) {
  return typeof o === 'object';
}
var ProvideParentSize = (props,) => {
  const currentParentSize = useParentSize();
  const { parentSize, children, } = props;
  const value = React21.useMemo(
    () => ({ parentSize, }),
    // We are generating the memoKeys in runtime and react doesn't like it,
    // but it should be safe to ignore.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [getParentWidth(parentSize,), getParentHeight(parentSize,),],
  );
  if (currentParentSize === 1) {
    return children ? /* @__PURE__ */ React21.createElement(React21.Fragment, null, children,) : null;
  }
  return /* @__PURE__ */ React21.createElement(ConstraintsContext.Provider, { value, }, children,);
};
function getParentWidth(parentSize,) {
  return isSize(parentSize,) ? parentSize.width : parentSize;
}
function getParentHeight(parentSize,) {
  return isSize(parentSize,) ? parentSize.height : parentSize;
}
var ConsumeParentSize = ConstraintsContext.Consumer;
function useProvideParentSize(node, parentSize,) {
  return /* @__PURE__ */ React21.createElement(ProvideParentSize, { parentSize, }, node,);
}
function useConstraints(props,) {
  const parentSize = useParentSize();
  const calculatedRect = calculateRect(props, parentSize, true,);
  return calculatedRect;
}
var ControlType = /* @__PURE__ */ ((ControlType2,) => {
  ControlType2['Boolean'] = 'boolean';
  ControlType2['Number'] = 'number';
  ControlType2['String'] = 'string';
  ControlType2['RichText'] = 'richtext';
  ControlType2['FusedNumber'] = 'fusednumber';
  ControlType2['Enum'] = 'enum';
  ControlType2['SegmentedEnum'] = 'segmentedenum';
  ControlType2['Color'] = 'color';
  ControlType2['Image'] = 'image';
  ControlType2['ResponsiveImage'] = 'responsiveimage';
  ControlType2['File'] = 'file';
  ControlType2['ComponentInstance'] = 'componentinstance';
  ControlType2['Array'] = 'array';
  ControlType2['EventHandler'] = 'eventhandler';
  ControlType2['Transition'] = 'transition';
  ControlType2['Link'] = 'link';
  ControlType2['Date'] = 'date';
  ControlType2['Object'] = 'object';
  ControlType2['Font'] = 'font';
  ControlType2['PageScope'] = 'pagescope';
  ControlType2['ScrollSectionRef'] = 'scrollsectionref';
  ControlType2['CustomCursor'] = 'customcursor';
  return ControlType2;
})(ControlType || {},);
var isFlexboxGapSupportedCached;
function isFlexboxGapSupported() {
  if (isFlexboxGapSupportedCached !== void 0) {
    return isFlexboxGapSupportedCached;
  }
  const flex = document.createElement('div',);
  Object.assign(flex.style, {
    position: 'absolute',
    // avoid layout shift
    display: 'flex',
    flexDirection: 'column',
    rowGap: '1px',
  },);
  flex.appendChild(document.createElement('div',),);
  flex.appendChild(document.createElement('div',),);
  document.body.appendChild(flex,);
  const isSupported = flex.scrollHeight === 1;
  if (flex.parentNode) {
    flex.parentNode.removeChild(flex,);
  }
  isFlexboxGapSupportedCached = isSupported;
  return isSupported;
}
var flexboxGapNotSupportedClass = 'flexbox-gap-not-supported';
var initialized = false;
function installFlexboxGapWorkaroundIfNeeded() {
  if (initialized) {
    return;
  }
  initialized = true;
  if (isFlexboxGapSupported()) {
    return;
  }
  document.body.classList.add(flexboxGapNotSupportedClass,);
}
var richTextStylesRule = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`;
var richTextParagraphSpacingStylesRule = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`;
var richTextBackgroundMaskStylesRule = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`;
var richTextLinkStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`;
var richTextLinkHoverStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`;
var richTextLinkCurrentStylesRule = `
a[data-framer-page-link-current],
a[data-framer-page-link-current] span:not([data-text-fill]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`;
var richTextLinkCurrentHoverStylesRule = `
a[data-framer-page-link-current]:hover,
a[data-framer-page-link-current]:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`;
var richTextBoldStylesRule = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`;
var richTextItalicStylesRule = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`;
var richTextImageRule = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`;
var richTextBlockElementResetRule = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`;
var richTextStylesPresetResetRule = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
}
`;
var richTextStylesList = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`;
var richTextStylesListItem = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`;
var richTextStylesNumberedListMarker = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`;
var richTextStylesBulletedListMarker = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`;
var deprecatedRichTextCSSRules = [
  `[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }`,
  richTextStylesPresetResetRule,
  richTextBlockElementResetRule,
  richTextStylesRule,
  richTextParagraphSpacingStylesRule,
  richTextBackgroundMaskStylesRule,
  richTextLinkStylesRule,
  richTextLinkHoverStylesRule,
  richTextLinkCurrentStylesRule,
  richTextLinkCurrentHoverStylesRule,
  richTextBoldStylesRule,
  richTextItalicStylesRule,
  richTextImageRule,
  richTextStylesList,
  richTextStylesListItem,
  richTextStylesNumberedListMarker,
  richTextStylesBulletedListMarker,
];
var richTextCSSRules = [
  /* css */
  `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `,
  /* css */
  `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
            font-style: var(--framer-font-style, normal);
            font-weight: var(--framer-font-weight, 400);
            color: var(--framer-text-color, #000);
            font-size: calc(var(--framer-font-size, 16px) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-letter-spacing, 0);
            text-transform: var(--framer-text-transform, none);
            text-decoration: var(--framer-text-decoration, none);
            line-height: var(--framer-line-height, 1.2em);
            text-align: var(--framer-text-alignment, start);
        }
    `,
  /* css */
  `
        .framer-fit-text .framer-text {
            white-space: nowrap;
        }
    `,
  /* css */
  `
        strong.framer-text {
            font-family: var(--framer-font-family-bold);
            font-style: var(--framer-font-style-bold);
            font-weight: var(--framer-font-weight-bold, bolder);
        }
    `,
  /* css */
  `
        em.framer-text {
            font-family: var(--framer-font-family-italic);
            font-style: var(--framer-font-style-italic, italic);
            font-weight: var(--framer-font-weight-italic);
        }
    `,
  /* css */
  `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-font-family-bold-italic);
            font-style: var(--framer-font-style-bold-italic, italic);
            font-weight: var(--framer-font-weight-bold-italic, bolder);
        }
    `,
  /* css */
  `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-paragraph-spacing, 0);
        }
    `,
  // The first child of a list item is a paragraph. If the second child is a
  // nested list we don't want it to have paragraph spacing.
  /* css */
  `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `,
  // background-clip: text clips to the physical dimensions of text as appose
  // to the rendered dimensions. normal text will bleed out side these
  // constraints but since this is just a clipping mask over the area the text
  // takes up we have cases where the text will get clipped. That is why we
  // need to expand the area that the gradient applies to to allow users to
  // use low line-heights. This will result in gradients not aligning
  // perfectly to the edges of the text. but this is a acceptable trade off at
  // this point. For now we increase the area of the clipping mask on the
  // bottom (for descenders) and the right for italic or wide fonts.
  /* css */
  `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / -2));
        }
    `,
  /* css */
  `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-code-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-font-size, 16px) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-letter-spacing, 0);
            line-height: var(--framer-line-height, 1.2em);
        }
    `,
  /* css */
  `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-link-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `,
  /* css */
  `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `,
  /* css */
  `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `,
  /* css */
  `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
        }
    `,
  /* css */
  `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `,
  /* css */
  `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `,
  /* css */
  `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `,
  /* css */
  `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `,
  /* css */
  `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `,
];
var defaultCache = /* @__PURE__ */ new Set();
var defaultSheet;
function injectCSSRule(cssRule, sheet, cache3 = defaultCache,) {
  if (!cssRule || cache3.has(cssRule,) || typeof document === 'undefined') {
    return;
  }
  cache3.add(cssRule,);
  if (!sheet) {
    if (!defaultSheet) {
      const styleElement = document.createElement('style',);
      styleElement.setAttribute('type', 'text/css',);
      styleElement.setAttribute('data-framer-css', 'true',);
      if (!document.head) {
        console.warn('not injecting CSS: the document is missing a <head> element',);
        return;
      }
      document.head.appendChild(styleElement,);
      if (styleElement.sheet) {
        defaultSheet = styleElement.sheet;
      } else {
        console.warn('not injecting CSS: injected <style> element does not have a sheet', styleElement,);
        return;
      }
    }
    sheet = defaultSheet;
  }
  try {
    sheet.insertRule(cssRule, sheet.cssRules.length,);
  } catch {
  }
}
var componentCSSRules = [`[data-framer-component-type] { position: absolute; }`,];
var textAlignmentRule = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`;
var textBlockSpanRule = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`;
var textInlineSpanRule = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`;
var renderTextStylesRule = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`;
var textStylesRule = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`;
var linkStylesRule = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`;
var linkHoverStylesRule = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`;
var linkCurrentStylesRule = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`;
var textCSSRules = [
  `[data-framer-component-type="Text"] { cursor: inherit; }`,
  `[data-framer-component-text-autosized] * { white-space: pre; }`,
  textAlignmentRule,
  textBlockSpanRule,
  textInlineSpanRule,
  renderTextStylesRule,
  textStylesRule,
  linkStylesRule,
  linkHoverStylesRule,
  linkCurrentStylesRule,
];
var stackPositionRule = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`;
var nativeStackGapRules = [
  `[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`,
  `.${flexboxGapNotSupportedClass} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`,
];
var stackGapRule = `
.${flexboxGapNotSupportedClass} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`;
var stackDirectionRuleVertical = `
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`;
var stackDirectionRuleHorizontal = `
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`;
var stackCSSRules = [
  stackPositionRule,
  stackGapRule,
  ...nativeStackGapRules,
  stackDirectionRuleVertical,
  stackDirectionRuleHorizontal,
];
var navigationCSSRules = [
  `
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`,
];
var scrollCSSRules = [
  `[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }`,
  `[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }`,
];
var nativeScrollCSSRules = [
  `[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }`,
  `[data-framer-component-type="NativeScroll"] > * { position: relative; }`,
  `[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }`,
  `[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }`,
  `[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }`,
  `[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }`,
  `[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }`,
  `[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }`,
];
var deviceComponentCSSRules = [
  `[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }`,
];
var pageContentWrapperWrapperCSSRules = [
  `[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }`,
];
var presenceCSS = [
  `[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }`,
];
var cursorCSS = [
  `[data-framer-cursor="pointer"] { cursor: pointer; }`,
  `[data-framer-cursor="grab"] { cursor: grab; }`,
  `[data-framer-cursor="grab"]:active { cursor: grabbing; }`,
];
var frameCSS = [
  // Non-sites prototyping projects render with FrameWithMotion and Stacks. In
  // that context this rule ensures pointer events work in a specific way
  // designed for prototypes that we don't care about anymore in sites. We
  // can't remove it for legacy reasons, but sites will never render any
  // elements that are impacted by this rule. However, users can still use the
  // <Frame> api in code, at which point this rule will kick in. We don't
  // encourage the use of this API anymore, and bugs that come from this will
  // be the user's concern.
  `[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }`,
  // This is fully deprecated, and will never exist in code that is generated
  // after 24/01/2023. There will be existing code-generated that depends on
  // this rule existing, so we can't remove it.
  `[data-framer-generated] * { pointer-events: unset }`,
];
var resetCSS = [
  `[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`,
];
var hideScrollbars = [
  `[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }`,
  `[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }`,
];
var frameCSSRules = (isPreview,) => {
  return isPreview ? frameCSS : [];
};
var svgCSSRules = [`.svgContainer svg { display: block; }`,];
var combineCSSRules = (isPreview,) => [
  ...componentCSSRules,
  ...textCSSRules,
  ...richTextCSSRules,
  ...deprecatedRichTextCSSRules,
  ...stackCSSRules,
  ...navigationCSSRules,
  ...scrollCSSRules,
  ...nativeScrollCSSRules,
  ...pageContentWrapperWrapperCSSRules,
  ...deviceComponentCSSRules,
  ...presenceCSS,
  ...cursorCSS,
  ...frameCSSRules(isPreview,),
  ...svgCSSRules,
  ...resetCSS,
  ...hideScrollbars,
];
export var combinedCSSRules = combineCSSRules(false,);
var combinedCSSRulesForPreview = combineCSSRules(true,);
var didInject = false;
function injectComponentCSSRules() {
  if (didInject) {
    return;
  }
  didInject = true;
  const styles = RenderTarget.current() === 'PREVIEW' ? combinedCSSRulesForPreview : combinedCSSRules;
  for (const rule of styles) {
    injectCSSRule(rule, void 0, void 0,);
  }
}
function isFunction(value,) {
  return typeof value === 'function';
}
function isBoolean(value,) {
  return typeof value === 'boolean';
}
function isString22(value,) {
  return typeof value === 'string';
}
function isNumber2(value,) {
  return Number.isFinite(value,);
}
function isArray(value,) {
  return Array.isArray(value,);
}
function isObject2(value,) {
  return value !== null && typeof value === 'object' && !isArray(value,);
}
function isUndefined(value,) {
  return typeof value === 'undefined';
}
function isNull(value,) {
  return value === null;
}
function isNullish(value,) {
  return isUndefined(value,) || isNull(value,);
}
function isValidDate(value,) {
  return value instanceof Date && !isNaN(value.getTime(),);
}
function isReactComponent(component,) {
  return isObject2(component,) || isFunction(component,);
}
var optionalKey = 'optional';
function controlIsOptional(control,) {
  return !!control && optionalKey in control && control[optionalKey] === true;
}
function shouldBeNever(_,) {
}
function getControlDefaultValue(control,) {
  try {
    switch (control.type) {
      case 'string':
      case 'color':
      case 'date':
      case 'link':
        return isString22(control.defaultValue,) ? control.defaultValue : void 0;
      case 'boolean':
        return isBoolean(control.defaultValue,) ? control.defaultValue : void 0;
      case 'enum':
        if (isUndefined(control.defaultValue,)) {
          return void 0;
        }
        return control.options.includes(control.defaultValue,) ? control.defaultValue : void 0;
      case 'fusednumber':
      case 'number':
        return isNumber2(control.defaultValue,) ? control.defaultValue : void 0;
      case 'transition':
        return isObject2(control.defaultValue,) ? control.defaultValue : void 0;
      case 'font':
        return isObject2(control.defaultValue,) ? control.defaultValue : void 0;
      case 'object': {
        const value = isObject2(control.defaultValue,) ? control.defaultValue : {};
        if (isObject2(control.controls,)) {
          applyControlDefaultsToDefaultProps(value, control.controls,);
        }
        return value;
      }
      case 'array':
        return isArray(control.defaultValue,) ? control.defaultValue : void 0;
      case 'file':
      case 'image':
      case 'richtext':
      case 'pagescope':
      case 'eventhandler':
      case 'segmentedenum':
      case 'responsiveimage':
      case 'componentinstance':
      case 'scrollsectionref':
      case 'customcursor':
        return void 0;
      default:
        shouldBeNever(control,);
        return void 0;
    }
  } catch {
    return void 0;
  }
}
function applyControlDefaultsToDefaultProps(defaultProps, controls,) {
  for (const controlKey in controls) {
    const control = controls[controlKey];
    if (!control) {
      continue;
    }
    const currentDefault = defaultProps[controlKey];
    if (!isUndefined(currentDefault,)) {
      continue;
    }
    if (controlIsOptional(control,)) {
      continue;
    }
    const defaultValue = getControlDefaultValue(control,);
    if (isUndefined(defaultValue,)) {
      continue;
    }
    defaultProps[controlKey] = defaultValue;
  }
}
function getDefaultProps(component,) {
  if (isObject2(component.defaultProps,)) {
    return component.defaultProps;
  }
  const defaultProps = {};
  component.defaultProps = defaultProps;
  return defaultProps;
}
function applyControlDefaultsToReactDefaultProps(component, controls,) {
  if (!isReactComponent(component,)) {
    return;
  }
  const defaultProps = getDefaultProps(component,);
  applyControlDefaultsToDefaultProps(defaultProps, controls,);
}
function addPropertyControls(component, propertyControls,) {
  Object.assign(component, { propertyControls, },);
  applyControlDefaultsToReactDefaultProps(component, propertyControls,);
}
function getPropertyControls(component,) {
  return component.propertyControls;
}
var defaultPresetId = 'iphone-12-pro';
var presetsBase = {
  iPhonePro: {
    // Screen mask takes care of the rounded screen corners for iPhones Pro,
    // and actually using a radius here produces visual artifacts in Chrome.
    screenRadius: (
      /* 38 */
      0
    ),
    clayBezelLeft: 21,
    clayBezelRight: 21,
    clayBezelTop: 21,
    clayBezelBottom: 21,
    clayBezelRadius: 38 + 21,
  },
  iPhone8: {
    screenRadius: 0,
    clayBezelLeft: 24,
    clayBezelRight: 24,
    clayBezelTop: 96,
    clayBezelBottom: 96,
    clayBezelRadius: 38 * 1.5,
  },
  iPadPro: {
    screenRadius: 25,
    clayBezelLeft: 38,
    clayBezelRight: 38,
    clayBezelTop: 38,
    clayBezelBottom: 38,
    clayBezelRadius: 25 + 38,
  },
  desktop: {
    clayBezelLeft: 20,
    clayBezelRight: 20,
    clayBezelTop: 20,
    clayBezelBottom: 20,
    clayBezelRadius: 20,
  },
};
var devicePresets = [
  {
    id: 'iphone-12',
    title: 'iPhone 12',
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 390,
    screenHeight: 844,
    externalClay: {
      width: 500,
      height: 974,
      screenOffsetTop: 65,
      screenOffsetLeft: 55,
    },
    screenMask:
      '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 490,
      height: 944,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
        { id: 'blue', title: 'Blue', colorValue: '#14496D', },
        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
        { id: 'red', title: 'Red', colorValue: '#DB4141', },
      ],
      handOffset: { left: 29, right: 29, bottom: 29, },
    },
  },
  {
    id: 'iphone-12-mini',
    title: 'iPhone 12 Mini',
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 780,
    externalClay: {
      width: 450,
      height: 890,
      screenOffsetTop: 55,
      screenOffsetLeft: 45,
    },
    screenMask:
      '<g style="transform: scale(0.5);"><path d="M142 18c0 19 14 47 43 48h349c31 0 44-29 44-48 0-12 4-18 14-18h18c38 0 52 4 66 11 14 8 25 19 33 33v1c7 14 11 28 11 65v1340c0 38-4 52-11 66-8 14-19 25-33 33h-1c-14 7-28 11-65 11H110c-38 0-52-4-66-11-14-8-25-19-33-33v-1c-7-13-11-27-11-64V110c0-38 4-52 11-66 8-14 19-25 33-33h1C58 4 72 0 109 0h16c11 0 17 6 17 18z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 460,
      height: 880,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
        { id: 'blue', title: 'Blue', colorValue: '#14496D', },
        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
        { id: 'red', title: 'Red', colorValue: '#DB4141', },
      ],
      handOffset: { left: 31.5, right: 30.5, bottom: 30, },
    },
  },
  {
    id: 'iphone-12-pro',
    title: 'iPhone 12 Pro',
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 390,
    screenHeight: 844,
    externalClay: {
      width: 494,
      height: 968,
      screenOffsetTop: 62,
      screenOffsetLeft: 52,
    },
    screenMask:
      '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 490,
      height: 944,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'graphite', title: 'Graphite', colorValue: '#585753', },
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'pacific-blue', title: 'Pacific Blue', colorValue: '#415D6C', },
        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
      ],
      handOffset: { left: 29, right: 29, bottom: 29, },
    },
  },
  {
    id: 'iphone-12-pro-max',
    title: 'iPhone 12 Pro Max',
    screenRadius: 50,
    // to prevent leaking pixel in the corners, see https://github.com/framer/company/issues/20429
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 428,
    screenHeight: 926,
    externalClay: {
      width: 532,
      height: 1050,
      screenOffsetTop: 62,
      screenOffsetLeft: 52,
    },
    screenMask:
      '<path d="M102 0c6 0 7 3 7 9 0 10 7 23 24 23h164c13 0 22-12 22-23 0-6 1-9 7-9h34c24 0 32 2 41 7s15 11 20 20 7 17 7 41v790c0 24-2 32-7 41s-11 15-20 20-17 7-41 7H68c-24 0-32-2-41-7s-15-11-20-20-7-17-7-41V68c0-24 2-32 7-41S18 12 27 7s17-7 41-7h34z" fill="#000" fill-rule="evenodd"/>',
    realisticImage: {
      width: 528,
      height: 1026,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'graphite', title: 'Graphite', colorValue: '#585753', },
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'pacific-blue', title: 'Pacific Blue', colorValue: '#415D6C', },
        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
      ],
      handOffset: { left: 28.5, right: 28, bottom: 29, },
    },
  },
  {
    id: 'iphone-11',
    title: 'iPhone 11',
    // Screen mask takes care of the rounded screen corners for iPhones Pro,
    // and actually using a radius here produces visual artifacts in Chrome.
    screenRadius: (
      /* 38 */
      0
    ),
    clayBezelLeft: 35.5,
    clayBezelRight: 35.5,
    clayBezelTop: 35.5,
    clayBezelBottom: 35.5,
    clayBezelRadius: 77,
    screenWidth: 414,
    screenHeight: 896,
    externalClay: {
      width: 524,
      height: 1026,
      screenOffsetTop: 65,
      screenOffsetLeft: 55,
    },
    screenMask:
      '<path d="M85.5 0C89.1 0 92 3 92 6.5c.3 6 1.5 10 3.4 13.5 2.2 4.1 5.5 7.4 9.6 9.6 4.2 2.2 8.9 3.4 17 3.4h170c8.1 0 12.8-1.2 17-3.4 4.1-2.2 7.4-5.5 9.6-9.6A31 31 0 00322 6.5c0-3.6 3-6.5 6.5-6.5h32.3c18.5 0 25.2 2 32 5.5 6.7 3.7 12 9 15.7 15.7 3.6 6.8 5.5 13.5 5.5 32v789.6c0 18.5-2 25.2-5.5 32-3.7 6.7-9 12-15.7 15.7-6.8 3.6-13.5 5.5-32 5.5H53.2c-18.5 0-25.2-2-32-5.5-6.7-3.7-12-9-15.7-15.7C2 868 0 861.3 0 842.8V53.2c0-18.5 2-25.2 5.5-32 3.7-6.7 9-12 15.7-15.7C28 2 34.7 0 53.2 0h32.3z" fill="#000" fill-rule="nonzero"/>',
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#202120', },
        { id: 'white', title: 'White', colorValue: '#F9F6EF', },
        { id: 'purple', title: 'Purple', colorValue: '#D1CDDB', },
        { id: 'green', title: 'Green', colorValue: '#ADE0CD', },
        { id: 'red', title: 'Red', colorValue: '#B90D2E', },
        { id: 'yellow', title: 'Yellow', colorValue: '#FFE680', },
      ],
      handOffset: { left: 14.5, right: 14.5, bottom: 14.5, },
    },
  },
  {
    id: 'iphone-11-pro',
    title: 'iPhone 11 Pro',
    ...presetsBase.iPhonePro,
    screenWidth: 375,
    screenHeight: 812,
    externalClay: {
      width: 485,
      height: 942,
      screenOffsetTop: 65,
      screenOffsetLeft: 55,
    },
    screenMask:
      '<path d="M292 8.668V9c0 9.266-7.07 21-23.332 21h-162C90.402 30 83.332 18.266 83.332 9v-.332c0-4.285 0-8.668-7.664-8.668H43.332C16.312 0 0 16.313 0 43.332v725.336C0 795.688 16.313 812 43.332 812h288.336c27.02 0 43.332-16.313 43.332-43.332V43.332C375 16.312 358.687 0 331.668 0h-32C292 0 292 4.383 292 8.668zm0 0"/>',
    realisticImage: {
      width: 475,
      height: 912,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#52514F', },
        { id: 'silver', title: 'Silver', colorValue: '#EBEBE3', },
        { id: 'gold', title: 'Gold', colorValue: '#FBD7BD', },
        { id: 'midnight-green', title: 'Midnight Green', colorValue: '#4F5850', },
      ],
      handOffset: { left: 24.5, right: 24.5, bottom: 23.5, },
    },
  },
  {
    id: 'iphone-11-pro-max',
    title: 'iPhone 11 Pro Max',
    ...presetsBase.iPhonePro,
    screenWidth: 414,
    screenHeight: 896,
    externalClay: {
      width: 524,
      height: 1026,
      screenOffsetTop: 65,
      screenOffsetLeft: 55,
    },
    screenMask:
      '<path d="M96 0c3.313 0 5.91 2.688 6 6 .18 6.645 1.191 10.148 2.938 13.41 1.917 3.586 4.73 6.402 8.316 8.317 3.586 1.918 7.441 2.941 15.445 2.941h156.602c8.004 0 11.86-1.023 15.445-2.941 3.586-1.915 6.399-4.73 8.317-8.317 1.746-3.265 2.746-6.758 2.937-13.41.094-3.313 2.688-6 6-6h46.004c17.387 0 23.687 1.809 30.043 5.21 6.355 3.4 11.344 8.388 14.742 14.743C412.191 26.31 414 32.61 414 49.996v796.008c0 17.387-1.809 23.687-5.21 30.043-3.4 6.355-8.388 11.344-14.743 14.742-6.356 3.402-12.656 5.211-30.043 5.211H49.996c-17.387 0-23.687-1.809-30.043-5.21-6.355-3.4-11.344-8.388-14.742-14.743C1.809 869.69 0 863.39 0 846.004V49.996C0 32.61 1.809 26.31 5.21 19.953c3.4-6.355 8.388-11.344 14.743-14.742C26.31 1.809 32.61 0 49.996 0zm0 0"/>',
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#52514F', },
        { id: 'silver', title: 'Silver', colorValue: '#EBEBE3', },
        { id: 'gold', title: 'Gold', colorValue: '#FBD7BD', },
        { id: 'midnight-green', title: 'Midnight Green', colorValue: '#4F5850', },
      ],
      handOffset: { left: 23.5, right: 24.5, bottom: 24, },
    },
  },
  {
    id: 'iphone-8',
    title: 'iPhone 8',
    ...presetsBase.iPhone8,
    screenWidth: 375,
    screenHeight: 667,
    externalClay: {
      width: 491,
      height: 971,
      screenOffsetLeft: 58,
      screenOffsetTop: 152,
    },
    realisticImage: {
      width: 475,
      height: 927,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#28282A', },
        { id: 'silver', title: 'Silver', colorValue: '#DFE1E2', },
        { id: 'gold', title: 'Gold', colorValue: '#F6E6DB', },
      ],
      handOffset: { left: 22, right: 22, bottom: 18.5, },
    },
  },
  {
    id: 'iphone-8-plus',
    title: 'iPhone 8 Plus',
    ...presetsBase.iPhone8,
    screenWidth: 414,
    screenHeight: 736,
    externalClay: {
      width: 530,
      height: 1064,
      screenOffsetLeft: 58,
      screenOffsetTop: 164,
    },
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#28282A', },
        { id: 'silver', title: 'Silver', colorValue: '#DFE1E2', },
        { id: 'gold', title: 'Gold', colorValue: '#F6E6DB', },
      ],
      handOffset: { left: 21, right: 20.5, bottom: 19, },
    },
  },
  {
    id: 'iphone-se',
    title: 'iPhone SE',
    screenWidth: 320,
    screenHeight: 568,
    screenRadius: 0,
    clayBezelLeft: 20,
    clayBezelRight: 20,
    clayBezelTop: 112,
    clayBezelBottom: 112,
    clayBezelRadius: 38 * 1.5,
    externalClay: {
      width: 436,
      height: 872,
      screenOffsetLeft: 58,
      screenOffsetTop: 152,
    },
    realisticImage: {
      width: 420,
      height: 828,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
        { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },
        { id: 'rose-gold', title: 'Rose Gold', colorValue: '#F7CFCA', },
      ],
      handOffset: { left: 22, right: 22, bottom: 26.5, },
    },
  },
  {
    id: 'samsung-galaxy-s7',
    title: 'Samsung Galaxy S7',
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 640,
    externalClay: {
      width: 454,
      height: 880,
      screenOffsetTop: 120,
      screenOffsetLeft: 47,
    },
    realisticImage: {
      width: 440,
      height: 860,
      screenOffsetLeft: 40,
      screenOffsetTop: 110,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
      ],
      handOffset: { left: 26, right: 25.5, bottom: 32, },
    },
  },
  // deprecated
  {
    id: 'samsung-note-10',
    title: 'Samsung Note 10',
    screenWidth: 360,
    screenHeight: 760,
    screenRadius: 10,
    clayBezelLeft: 7,
    clayBezelRight: 7,
    clayBezelTop: 15,
    clayBezelBottom: 15,
    clayBezelRadius: 15,
  },
  {
    id: 'pixel-5',
    title: 'Google Pixel 5',
    screenRadius: 31,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 780,
    externalClay: {
      width: 460,
      height: 900,
      screenOffsetTop: 60,
      screenOffsetLeft: 50,
    },
    realisticImage: {
      width: 920 / 2,
      height: 1760 / 2,
      screenOffsetLeft: 100 / 2,
      screenOffsetTop: 100 / 2,
      availableColors: [
        { id: 'just-black', title: 'Just Black', colorValue: '#2E2C36', },
        { id: 'sorta-sage', title: 'Sorta Sage', colorValue: '#B7C9C0', },
      ],
      handOffset: {
        left: 31.5,
        right: 31,
        bottom: 31,
        /* 1t */
      },
    },
  },
  {
    id: 'pixel-4',
    title: 'Google Pixel 4',
    screenWidth: 360,
    screenHeight: 760,
    screenRadius: 34,
    clayBezelLeft: 10,
    clayBezelRight: 10,
    clayBezelTop: 50,
    clayBezelBottom: 25,
    clayBezelRadius: 50,
    externalClay: {
      width: 460,
      height: 938,
      screenOffsetLeft: 50,
      screenOffsetTop: 89,
    },
    realisticImage: {
      width: 460,
      height: 920,
      screenOffsetLeft: 50,
      screenOffsetTop: 80,
      availableColors: [
        { id: 'clearly-white', title: 'Clearly White', colorValue: '#EAEDF2', },
        { id: 'just-black', title: 'Just Black', colorValue: '#1A1A1A', },
        { id: 'oh-so-orange', title: 'Oh So Orange', colorValue: '#FF7A68', },
      ],
      handOffset: {
        left: 35.5,
        right: 35.5,
        bottom: 57,
        /* 1t */
      },
    },
  },
  // Desktop ------------------------------------------------------------------------------------------------------------------------
  {
    id: 'macbook-air',
    title: 'MacBook Air',
    screenWidth: 1440,
    screenHeight: 900,
    disableRotation: true,
    externalClay: {
      width: 1890,
      height: 1125,
      screenOffsetLeft: 225,
      screenOffsetTop: 98,
    },
    realisticImage: {
      width: 3848 / 2,
      height: 2240 / 2,
      screenOffsetLeft: 484 / 2,
      screenOffsetTop: 196 / 2,
      availableColors: [
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'space-grey', title: 'Space Grey', colorValue: '#B1B5B7', },
        { id: 'gold', title: 'Gold', colorValue: '#FCECD5', },
      ],
    },
  },
  {
    id: 'macbook-pro-13',
    title: `MacBook Pro 13"`,
    screenWidth: 1440,
    screenHeight: 900,
    disableRotation: true,
    externalClay: {
      width: 1914,
      height: 1169,
      screenOffsetLeft: 236,
      screenOffsetTop: 109,
    },
    realisticImage: {
      width: 3916 / 2,
      height: 2330 / 2,
      screenOffsetLeft: 518 / 2,
      screenOffsetTop: 218 / 2,
      availableColors: [
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'space-grey', title: 'Space Grey', colorValue: '#B1B5B7', },
      ],
    },
  },
  {
    id: 'macbook-pro-16',
    title: `MacBook Pro 16"`,
    screenWidth: 1536,
    screenHeight: 960,
    disableRotation: true,
    externalClay: {
      width: 1984,
      height: 1179,
      screenOffsetLeft: 225,
      screenOffsetTop: 78,
    },
    realisticImage: {
      width: 4032 / 2,
      height: 2348 / 2,
      screenOffsetLeft: 480 / 2,
      screenOffsetTop: 148 / 2,
      availableColors: [
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'space-grey', title: 'Space Grey', colorValue: '#B1B5B7', },
      ],
    },
  },
  {
    id: 'imac-21-5',
    title: `iMac 21.5"`,
    screenWidth: 2048,
    screenHeight: 1152,
    disableRotation: true,
    externalClay: {
      width: 2288,
      height: 1892,
      screenOffsetLeft: 120,
      screenOffsetTop: 120,
    },
    realisticImage: {
      width: 4562 / 2,
      height: 3796 / 2,
      screenOffsetLeft: 232 / 2,
      screenOffsetTop: 244 / 2,
    },
  },
  {
    id: 'imac-27',
    title: `iMac 27"`,
    screenWidth: 2560,
    screenHeight: 1440,
    disableRotation: true,
    externalClay: {
      width: 2848,
      height: 2351,
      screenOffsetLeft: 144,
      screenOffsetTop: 151,
    },
    realisticImage: {
      width: 5676 / 2,
      height: 4720 / 2,
      screenOffsetLeft: 278 / 2,
      screenOffsetTop: 292 / 2,
      availableColors: [
        { id: 'silver', title: 'Silver', colorValue: '#E5E6E1', },
        { id: 'pro', title: 'Pro', colorValue: '#5F5E63', },
      ],
    },
  },
  {
    id: 'pro-display-xdr',
    title: `Pro Display XDR`,
    screenWidth: 3008,
    screenHeight: 1692,
    disableRotation: true,
    externalClay: {
      width: 3148,
      height: 2325,
      screenOffsetLeft: 70,
      screenOffsetTop: 60,
    },
    realisticImage: {
      width: 6276 / 2,
      height: 4695 / 2,
      screenOffsetLeft: 130 / 2,
      screenOffsetTop: 130 / 2,
    },
  },
  {
    id: 'dell-xps',
    title: `Dell XPS`,
    screenWidth: 1920,
    screenHeight: 1080,
    disableRotation: true,
    externalClay: {
      width: 2624,
      height: 1381,
      screenOffsetLeft: 352,
      screenOffsetTop: 57,
    },
    realisticImage: {
      width: 5412 / 2,
      height: 2746 / 2,
      screenOffsetLeft: 786 / 2,
      screenOffsetTop: 108 / 2,
    },
  },
  {
    id: 'surface-book',
    title: `Microsoft Surface Book`,
    screenWidth: 1500,
    screenHeight: 1e3,
    disableRotation: true,
    externalClay: {
      width: 2089,
      height: 1234,
      screenOffsetLeft: 296,
      screenOffsetTop: 93,
    },
    realisticImage: {
      width: 4200 / 2,
      height: 2508 / 2,
      screenOffsetLeft: 600 / 2,
      screenOffsetTop: 210 / 2,
    },
  },
  // Tablets ------------------------------------------------------------------------------------------------------------------------
  {
    id: 'ipad',
    title: 'iPad',
    screenRadius: 0,
    screenWidth: 810,
    screenHeight: 1080,
    clayBezelLeft: 30,
    clayBezelRight: 30,
    clayBezelTop: 95,
    clayBezelBottom: 95,
    clayBezelRadius: 0,
    externalClay: {
      width: 966,
      height: 1378,
      screenOffsetLeft: 78,
      screenOffsetTop: 149,
    },
    realisticImage: {
      width: 1920 / 2,
      height: 2720 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 140,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
        { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },
      ],
    },
  },
  {
    id: 'ipad-mini',
    title: 'iPad Mini',
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 768,
    screenHeight: 1024,
    externalClay: {
      width: 924,
      height: 1384,
      screenOffsetLeft: 78,
      screenOffsetTop: 180,
    },
    realisticImage: {
      width: 1856 / 2,
      height: 2728 / 2,
      screenOffsetLeft: 160 / 2,
      screenOffsetTop: 340 / 2,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
        { id: 'gold', title: 'Gold', colorValue: '#EFD8BD', },
      ],
    },
  },
  {
    id: 'ipad-air',
    title: 'iPad Air',
    screenRadius: 18,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 820,
    screenHeight: 1180,
    externalClay: {
      width: 994,
      height: 1374,
      screenOffsetLeft: 87,
      screenOffsetTop: 97,
    },
    realisticImage: {
      width: 1960 / 2,
      height: 2680 / 2,
      screenOffsetLeft: 160 / 2,
      screenOffsetTop: 160 / 2,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
        { id: 'rose-gold', title: 'Rose Gold', colorValue: '#ECCBC4', },
        { id: 'blue', title: 'Blue', colorValue: '#CBDAE6', },
        { id: 'green', title: 'Green', colorValue: '#DAF0D9', },
      ],
    },
  },
  {
    id: 'ipad-pro-11',
    title: 'iPad Pro 11\u2033',
    screenRadius: 17,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 834,
    screenHeight: 1194,
    externalClay: {
      width: 990,
      height: 1370,
      screenOffsetLeft: 78,
      screenOffsetTop: 88,
    },
    realisticImage: {
      width: 1968 / 2,
      height: 2688 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 75,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
      ],
    },
  },
  {
    id: 'ipad-pro-12-9',
    title: 'iPad Pro 12.9\u2033',
    ...presetsBase.iPadPro,
    screenRadius: 17,
    screenWidth: 1024,
    screenHeight: 1366,
    externalClay: {
      width: 1180,
      height: 1542,
      screenOffsetLeft: 78,
      screenOffsetTop: 88,
    },
    realisticImage: {
      width: 2348 / 2,
      height: 3032 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 75,
      availableColors: [
        { id: 'space-grey', title: 'Space Grey', colorValue: '#C3C4C8', },
        { id: 'silver', title: 'Silver', colorValue: '#E1E2E4', },
      ],
    },
  },
  {
    id: 'surface-3',
    title: 'Microsoft Surface 3',
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 960,
    screenHeight: 640,
    externalClay: {
      width: 1184,
      height: 864,
      screenOffsetLeft: 112,
      screenOffsetTop: 112,
    },
    realisticImage: {
      width: 2280 / 2,
      height: 1580 / 2,
      screenOffsetLeft: 180 / 2,
      screenOffsetTop: 150 / 2,
    },
  },
  {
    id: 'surface-pro-4',
    title: 'Microsoft Surface Pro 4',
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 1368,
    screenHeight: 912,
    externalClay: {
      width: 1592,
      height: 1136,
      screenOffsetLeft: 112,
      screenOffsetTop: 112,
    },
    realisticImage: {
      width: 3176 / 2,
      height: 2224 / 2,
      screenOffsetLeft: 220 / 2,
      screenOffsetTop: 200 / 2,
    },
  },
  // Watches ------------------------------------------------------------------------------------------------------------------------
  {
    id: 'apple-watch-44',
    title: `Apple Watch 44mm`,
    screenRadius: 33,
    screenWidth: 184,
    screenHeight: 224,
    disableRotation: true,
    externalClay: {
      width: 298,
      height: 502,
      screenOffsetLeft: 57,
      screenOffsetTop: 129,
    },
    realisticImage: {
      width: 548 / 2,
      height: 908 / 2,
      screenOffsetLeft: 90 / 2,
      screenOffsetTop: 230 / 2,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
        { id: 'yellow', title: 'Yellow', colorValue: '#FDDC6C', },
        { id: 'orange', title: 'Orange', colorValue: '#F35C56', },
      ],
    },
  },
  {
    id: 'apple-watch-40',
    title: `Apple Watch 40mm`,
    screenRadius: 27,
    screenWidth: 162,
    screenHeight: 197,
    disableRotation: true,
    externalClay: {
      width: 280,
      height: 463,
      screenOffsetLeft: 59,
      screenOffsetTop: 124,
    },
    realisticImage: {
      width: 504 / 2,
      height: 854 / 2,
      screenOffsetLeft: 90 / 2,
      screenOffsetTop: 230 / 2,
      availableColors: [
        { id: 'black', title: 'Black', colorValue: '#2E2C36', },
        { id: 'white', title: 'White', colorValue: '#F7F3F0', },
        { id: 'yellow', title: 'Yellow', colorValue: '#FDDC6C', },
        { id: 'orange', title: 'Orange', colorValue: '#F35C56', },
      ],
    },
  },
  // TVs ------------------------------------------------------------------------------------------------------------------------
  {
    id: 'tv-full-hd',
    title: `Full HD`,
    screenRadius: 0,
    screenWidth: 1920,
    screenHeight: 1080,
    externalClay: {
      width: 1968,
      height: 1168,
      screenOffsetLeft: 24,
      screenOffsetTop: 12,
    },
    realisticImage: {
      width: 4040 / 2,
      height: 2360 / 2,
      screenOffsetLeft: 100 / 2,
      screenOffsetTop: 100 / 2,
    },
  },
  {
    id: 'tv-4k',
    title: `4K`,
    screenRadius: 0,
    screenWidth: 3840,
    screenHeight: 2160,
    externalClay: {
      width: 3908,
      height: 2308,
      screenOffsetLeft: 34,
      screenOffsetTop: 24,
    },
    realisticImage: {
      width: 7960 / 2,
      height: 4600 / 2,
      screenOffsetLeft: 140 / 2,
      screenOffsetTop: 140 / 2,
    },
  },
  // Old devices ------------------------------------------------------------------------------------------------------------------------
  // deprecated
  {
    id: '720p',
    title: '720p',
    ...presetsBase.desktop,
    screenWidth: 720,
    screenHeight: 1280,
  },
  // deprecated
  {
    id: '900p',
    title: '900p',
    ...presetsBase.desktop,
    screenWidth: 900,
    screenHeight: 1440,
  },
  // deprecated
  {
    id: '1080p',
    title: '1080p',
    ...presetsBase.desktop,
    screenWidth: 1080,
    screenHeight: 1920,
  },
  // deprecated
  {
    id: '1440p',
    title: '1440p',
    ...presetsBase.desktop,
    screenWidth: 1440,
    screenHeight: 2560,
  },
  // deprecated
  {
    id: '4k',
    title: '4K',
    ...presetsBase.desktop,
    screenWidth: 2160,
    screenHeight: 3840,
  },
];
var deviceCodeComponentPresetIds = [
  'iphone-12',
  'iphone-12-mini',
  'iphone-12-pro',
  'iphone-11',
  'iphone-11-pro',
  'iphone-11-pro-max',
  'iphone-8',
  'iphone-8-plus',
  'iphone-se',
  'samsung-note-10',
  'pixel-4',
  'ipad',
  'ipad-pro-11',
  'ipad-pro-12-9',
  '720p',
  '900p',
  '1080p',
  '1440p',
  '4k',
];
var devicePresetsMap = devicePresets.reduce(
  (map, preset,) => {
    map[preset.id] = preset;
    return map;
  },
  {},
);
function getDevicePreset(presetId,) {
  var _a;
  return (_a = devicePresetsMap[presetId]) != null ? _a : devicePresetsMap[defaultPresetId];
}
var defaultDeviceProps = {
  preset: defaultPresetId,
  customWidth: 375,
  customHeight: 800,
  customBezel: 20,
  isMixedBezel: false,
  bezelTop: 20,
  bezelRight: 20,
  bezelBottom: 20,
  bezelLeft: 20,
  customBezelRadius: 20,
  customScreenRadius: 0,
  orientation: 'portrait',
  skin: 'clay',
  theme: 'dark',
  shadow: true,
  backgroundColor: void 0,
};
function convertPropsToDeviceOptions(props, { forceOldClay = false, } = {},) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (props.preset === 'no-device') {
    return;
  }
  let preset;
  if (props.preset === 'custom') {
    preset = {
      screenWidth: props.customWidth,
      screenHeight: props.customHeight,
      screenRadius: props.customScreenRadius,
      clayBezelTop: props.isMixedBezel ? props.bezelTop : props.customBezel,
      clayBezelRight: props.isMixedBezel ? props.bezelRight : props.customBezel,
      clayBezelBottom: props.isMixedBezel ? props.bezelBottom : props.customBezel,
      clayBezelLeft: props.isMixedBezel ? props.bezelLeft : props.customBezel,
      clayBezelRadius: props.customBezelRadius,
    };
  } else {
    preset = getDevicePreset(props.preset,);
  }
  const colors = getColorsFromTheme(props.theme,);
  const shadowColor = colors.shadowColor;
  const shadow = props.shadow ? `0 10px 30px ${shadowColor}` : void 0;
  const rotate = !preset.disableRotation && (props.orientation === 'landscape' || props.rotated);
  let deviceWidth;
  let deviceHeight;
  let screenOffsetTop;
  let screenOffsetLeft;
  let colorId = props.colorId;
  let appearance;
  if ((props.skin === void 0 || props.skin === 'realistic') && preset.realisticImage && props.preset) {
    deviceWidth = preset.realisticImage.width;
    deviceHeight = preset.realisticImage.height;
    screenOffsetTop = preset.realisticImage.screenOffsetTop;
    screenOffsetLeft = preset.realisticImage.screenOffsetLeft;
    colorId = colorId != null ? colorId : colorIdForTheme(props.theme, preset.realisticImage.availableColors,);
    appearance = {
      type: 'realistic',
      imageUrl: colorId
        ? `https://preview.framercdn.com/images/devices/${props.preset}-${colorId}.png`
        : `https://preview.framercdn.com/images/devices/${props.preset}.png`,
      imageWidth: preset.realisticImage.width,
      imageHeight: preset.realisticImage.height,
      rotateImage: rotate,
    };
  } else {
    deviceWidth = preset.screenWidth + ((_a = preset.clayBezelLeft) != null ? _a : 0) + ((_b = preset.clayBezelRight) != null ? _b : 0);
    deviceHeight = preset.screenHeight + ((_c = preset.clayBezelTop) != null ? _c : 0) + ((_d = preset.clayBezelBottom) != null ? _d : 0);
    screenOffsetTop = (_e = preset.clayBezelTop) != null ? _e : 0;
    screenOffsetLeft = (_f = preset.clayBezelLeft) != null ? _f : 0;
    if (preset.externalClay && !forceOldClay) {
      deviceWidth = preset.externalClay.width;
      deviceHeight = preset.externalClay.height;
      screenOffsetTop = preset.externalClay.screenOffsetTop;
      screenOffsetLeft = preset.externalClay.screenOffsetLeft;
      appearance = {
        type: 'external-clay',
        imageUrl: `https://preview.framercdn.com/images/devices/${props.preset}-${props.theme}.svg`,
        imageWidth: preset.externalClay.width,
        imageHeight: preset.externalClay.height,
        rotateImage: rotate,
      };
    } else {
      appearance = {
        type: 'clay',
        bezelRadius: preset.clayBezelRadius !== void 0 ? `${preset.clayBezelRadius}px` : void 0,
        bezelColor: colors.bezelColor,
        bezelShadeColor: colors.bezelShadeColor,
      };
    }
  }
  let screenWidth = preset.screenWidth;
  let screenHeight = preset.screenHeight;
  if (rotate) {
    const screenOffsetRight = deviceWidth - screenWidth - screenOffsetLeft;
    [deviceWidth, deviceHeight,] = [deviceHeight, deviceWidth,];
    [screenWidth, screenHeight,] = [screenHeight, screenWidth,];
    [screenOffsetTop, screenOffsetLeft,] = [screenOffsetRight, screenOffsetTop,];
  }
  const handOffset = (_g = preset.realisticImage) == null ? void 0 : _g.handOffset;
  return {
    deviceWidth,
    deviceHeight,
    appearance,
    screenWidth,
    screenHeight,
    screenOffsetTop,
    screenOffsetLeft,
    screenRadius: preset.screenRadius !== void 0 ? `${preset.screenRadius}px` : void 0,
    screenMaskImage: appearance.type !== 'realistic' && preset.screenMask
      ? makeScreenMaskImage({
        mask: preset.screenMask,
        // width/height of the mask = screen width/height pre-rotation
        width: preset.screenWidth,
        height: preset.screenHeight,
        rotate,
      },)
      : void 0,
    screenColor: colors.screenColor,
    shadow,
    hand: props.hand !== void 0 && supportsHand(props,)
      ? {
        imageUrl: `https://preview.framercdn.com/images/hands/${props.hand}.png`,
        offsetLeft: handOffset == null ? void 0 : handOffset.left,
        offsetRight: handOffset == null ? void 0 : handOffset.right,
        offsetBottom: handOffset == null ? void 0 : handOffset.bottom,
      }
      : void 0,
    background: props.backgroundColor,
    theme: props.theme,
    colorId,
  };
}
function makeScreenMaskImage({
  mask,
  width,
  height,
  rotate = false,
},) {
  const transform2 = rotate
    ? (
      // Rotate 90 degrees counter-clockwise around (0,0), then move the
      // result down into the viewport (rightmost transform is applied first).
      `transform="translate(0 ${width}) rotate(-90)"`
    )
    : '';
  const encoded = encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" viewport="0 0 ${width} ${height}" preserveAspectRatio="none"><g x="0" y="0" ${transform2}>${mask}</g></svg>`,
  );
  return `url("data:image/svg+xml;utf8,${encoded}")`;
}
var lightColors = /* @__PURE__ */ new Set(['white', 'silver', 'clearly-white', 'sorta-sage',],);
var darkColors = /* @__PURE__ */ new Set(['black', 'space-grey', 'graphite', 'just-black', 'pro',],);
function colorIdForTheme(theme, availableColors,) {
  var _a;
  if (!availableColors) {
    return;
  }
  const colors = theme === 'light' ? lightColors : darkColors;
  for (const color2 of availableColors) {
    if (colors.has(color2.id,)) {
      return color2.id;
    }
  }
  return (_a = availableColors[0]) == null ? void 0 : _a.id;
}
function supportsHand({ preset: presetId, skin, orientation = 'portrait', },) {
  var _a;
  if (!presetId || presetId === 'custom' || presetId === 'no-device' || orientation === 'landscape') {
    return false;
  }
  const preset = getDevicePreset(presetId,);
  return skin !== 'clay' && ((_a = preset.realisticImage) == null ? void 0 : _a.handOffset) !== void 0;
}
function applyMetaTag(name, props,) {
  var _a;
  let tag = document.querySelector(`meta[name="${name}"]`,);
  if (!tag) {
    tag = document.createElement('meta',);
    (_a = document.getElementsByTagName('head',)[0]) == null ? void 0 : _a.appendChild(tag,);
    tag.setAttribute('name', name,);
  }
  for (const [k, v,] of Object.entries(props,)) {
    tag.setAttribute(k, v,);
  }
}
function usePrototypingMetaTags() {
  React222.useEffect(() => {
    applyMetaTag('mobile-web-app-capable', { content: 'yes', },);
    applyMetaTag('apple-mobile-web-app-capable', { content: 'yes', },);
    applyMetaTag('apple-mobile-web-app-status-bar-style', {
      content: 'black-translucent',
    },);
    applyMetaTag('viewport', {
      content: 'viewport-fit=cover, user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1',
    },);
  }, [],);
}
function DeviceCodeComponentInner({ children, ...props },) {
  usePrototypingMetaTags();
  const deviceOptions = convertPropsToDeviceOptions(props, { forceOldClay: true, },);
  React23.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  if (!deviceOptions) {
    return /* @__PURE__ */ React23.createElement(
      'div',
      {
        'data-framer-component-type': 'DeviceComponent',
        className: 'no-device',
        style: { width: '100%', height: '100%', },
      },
      /* @__PURE__ */ React23.createElement(ProvideParentSize, {
        parentSize: 1,
        /* Disabled */
      }, children,),
    );
  }
  const child = Array.isArray(children,) ? children[0] : children;
  const resizedChild = child && React23.isValidElement(child,)
    ? React23.cloneElement(child, {
      width: deviceOptions.screenWidth,
      height: deviceOptions.screenHeight,
    },)
    : null;
  return /* @__PURE__ */ React23.createElement(Device, { scaleTo: 'dynamic', deviceOptions, }, resizedChild,);
}
var DeviceCodeComponent = /* @__PURE__ */ (() => {
  const { componentWidth: defaultWidth2, componentHeight: defaultHeight2, } = getComponentSize(
    convertPropsToDeviceOptions(defaultDeviceProps, { forceOldClay: true, },),
  );
  DeviceCodeComponentInner.defaultProps = {
    width: defaultWidth2,
    height: defaultHeight2,
    ...defaultDeviceProps,
  };
  const deviceCodeComponentPresets = devicePresets.filter((preset,) => deviceCodeComponentPresetIds.includes(preset.id,));
  addPropertyControls(DeviceCodeComponentInner, {
    children: {
      title: 'Content',
      type: 'componentinstance',
      /* ComponentInstance */
    },
    preset: {
      type: 'enum',
      options: ['no-device', 'custom',].concat(deviceCodeComponentPresets.map((preset,) => preset.id),),
      optionTitles: ['No Device', 'Custom',].concat(deviceCodeComponentPresets.map((preset,) => preset.title),),
    },
    customWidth: {
      title: 'Width',
      type: 'number',
      min: 0,
      displayStepper: true,
      hidden: (props,) => props.preset !== 'custom',
    },
    customHeight: {
      title: 'Height',
      type: 'number',
      min: 0,
      displayStepper: true,
      hidden: (props,) => props.preset !== 'custom',
    },
    customBezel: {
      title: 'Bezel',
      type: 'fusednumber',
      min: 0,
      toggleKey: 'isMixedBezel',
      toggleTitles: ['a', 'b',],
      valueKeys: ['bezelTop', 'bezelRight', 'bezelBottom', 'bezelLeft',],
      valueLabels: ['T', 'R', 'B', 'L',],
      hidden: (props,) => props.preset !== 'custom',
    },
    customBezelRadius: {
      title: 'Bezel Radius',
      type: 'number',
      min: 0,
      displayStepper: true,
      hidden: (props,) => props.preset !== 'custom',
    },
    customScreenRadius: {
      title: 'Screen Radius',
      type: 'number',
      min: 0,
      displayStepper: true,
      hidden: (props,) => props.preset !== 'custom',
    },
    orientation: {
      type: 'enum',
      displaySegmentedControl: true,
      options: ['portrait', 'landscape',],
      optionTitles: ['Portrait', 'Landscape',],
      optionIcons: ['orientation-portrait', 'orientation-landscape',],
      hidden: (props,) => !!props.preset && !supportsOrientation(props.preset,),
    },
    skin: {
      title: 'Device',
      type: 'enum',
      displaySegmentedControl: true,
      options: ['realistic', 'clay',],
      optionTitles: ['Realistic', 'Clay',],
      defaultValue: 'clay',
      hidden: (props,) => !!props.preset && !supportsRealisticSkin(props.preset,),
    },
    theme: {
      type: 'enum',
      displaySegmentedControl: true,
      options: ['light', 'dark',],
      optionTitles: ['Light', 'Dark',],
      hidden: (props,) => !!props.preset && !supportsThemes(props.preset, props.skin,),
    },
    shadow: {
      type: 'boolean',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      hidden: ({ skin, preset, },) => preset !== 'custom' && skin === 'realistic' || preset === 'no-device',
    },
    hand: {
      type: 'enum',
      options: [void 0, 'hand-1', 'hand-2',],
      optionTitles: ['None', 'Model 1', 'Model 2',],
      hidden: (props,) => !supportsHand(props,),
    },
    backgroundColor: {
      type: 'color',
      title: 'Background',
      optional: true,
      hidden: ({ preset, },) => preset === 'no-device',
    },
  },);
  return DeviceCodeComponentInner;
})();
function supportsOrientation(presetId,) {
  if (presetId === 'no-device') {
    return false;
  }
  if (presetId === 'custom') {
    return true;
  }
  const preset = getDevicePreset(presetId,);
  return !preset.disableRotation;
}
function supportsRealisticSkin(presetId,) {
  if (presetId === 'custom' || presetId === 'no-device') {
    return false;
  }
  const preset = getDevicePreset(presetId,);
  return !!preset.realisticImage;
}
function supportsThemes(presetId, skin,) {
  if (presetId === 'no-device') {
    return false;
  }
  if (presetId === 'custom' || skin !== 'realistic') {
    return true;
  }
  const preset = getDevicePreset(presetId,);
  const realisticImage = preset.realisticImage;
  if (realisticImage === void 0) {
    return true;
  }
  if (colorIdForTheme('dark', realisticImage.availableColors,) !== void 0) {
    return true;
  }
  return false;
}
var asRecord = (object,) => object;
function memoize(fn,) {
  const cache3 = Object.create(Object.prototype,);
  return (arg,) => {
    if (cache3[arg] === void 0) {
      cache3[arg] = fn(arg,);
    }
    return cache3[arg];
  };
}
var reactPropsRegex =
  /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/;
var isPropValid = /* @__PURE__ */ memoize(
  (prop,) => reactPropsRegex.test(prop,) || prop.charCodeAt(0,) === 111 && prop.charCodeAt(1,) === 110 && prop.charCodeAt(2,) < 91,
  /* Z+1 */
);
var LibraryFeaturesContext = /* @__PURE__ */ React24.createContext(void 0,);
var LibraryFeaturesProvider = LibraryFeaturesContext.Provider;
var useLibraryFeatures = () => {
  const context = React24.useContext(LibraryFeaturesContext,);
  return context != null ? context : {};
};
var import_process = __toESM(require_browser(), 1,);
var safeNavigator = typeof navigator !== 'undefined' ? navigator : void 0;
var isBrowser2 = () => typeof document === 'object';
var isWebKit = () => {
  var _a;
  return ((_a = safeNavigator) == null ? void 0 : _a.userAgent.includes('AppleWebKit/',)) && !isChrome() && !isEdge();
};
var webkitVersion = () => {
  let version2 = -1;
  const regexp = /AppleWebKit\/([\d.]+)/;
  const result = safeNavigator && regexp.exec(safeNavigator.userAgent,);
  if (result && result[1]) {
    version2 = parseFloat(result[1],);
  }
  return version2;
};
var safariVersion = () => {
  let version2 = -1;
  const regexp = /Version\/([\d.]+)/;
  const result = safeNavigator && regexp.exec(safeNavigator.userAgent,);
  if (result && result[1]) {
    version2 = parseFloat(result[1],);
  }
  return version2;
};
var isChrome = () => safeNavigator && /Chrome/.test(safeNavigator.userAgent,) && /Google Inc/.test(safeNavigator.vendor,) && !isEdge();
var isSafari = () => safeNavigator && /Safari/.test(safeNavigator.userAgent,) && /Apple Computer/.test(safeNavigator.vendor,);
var isFirefox = () => safeNavigator && /Firefox\/\d+\.\d+$/.test(safeNavigator.userAgent,);
var isFramerX = () => safeNavigator && /FramerX/.test(safeNavigator.userAgent,);
var isEdge = () => safeNavigator && /Edg\//.test(safeNavigator.userAgent,);
var isAndroid = () => safeNavigator && /android/i.test(safeNavigator.userAgent,);
var isIOS = () => safeNavigator && /iPhone|iPod|iPad/i.test(safeNavigator.platform,);
var isMacOS = () => safeNavigator && /Mac/.test(safeNavigator.platform,);
var isWindows = () => safeNavigator && /Win/.test(safeNavigator.platform,);
var isTouch = () => safeWindow.ontouchstart === null && safeWindow.ontouchmove === null && safeWindow.ontouchend === null;
var isDesktop = () => deviceType() === 'desktop';
var isPhone = () => deviceType() === 'phone';
var isTablet = () => deviceType() === 'tablet';
var isMobile = () => isPhone() || isTablet();
var isFileUrl = (url,) => url.startsWith('file://',);
var isDataUrl = (url,) => url.startsWith('data:',);
var isTest = () => import_process.default.env.NODE_ENV === 'test';
var isRelativeUrl = (url,) => !/^[a-z]{1,8}:\/\/.*$/i.test(url,);
var isLocalServerUrl = (url,) => /[a-z]{1,8}:\/\/127\.0\.0\.1/i.test(url,) || /[a-zA-Z]{1,8}:\/\/localhost/.test(url,);
var isLocalUrl = (url,) => {
  if (isFileUrl(url,)) {
    return true;
  }
  if (isLocalServerUrl(url,)) {
    return true;
  }
  return false;
};
var isLocalAssetUrl = (url, baseUrl,) => {
  if (baseUrl === null) {
    baseUrl = safeWindow.location.href;
  }
  if (isDataUrl(url,)) {
    return false;
  }
  if (isLocalUrl(url,)) {
    return true;
  }
  if (isRelativeUrl(url,) && isLocalUrl(baseUrl,)) {
    return true;
  }
  return false;
};
var devicePixelRatio2 = () => safeWindow.devicePixelRatio;
var isJP2Supported = function () {
  if (isFirefox()) {
    return false;
  }
  return isWebKit();
};
var isWebPSupported = () => isChrome();
var deviceType = () => {
  if (safeNavigator && /tablet|iPad|Nexus 9/i.test(safeNavigator.userAgent,)) {
    return 'tablet';
  }
  if (safeNavigator && /mobi/i.test(safeNavigator.userAgent,)) {
    return 'phone';
  }
  return 'desktop';
};
var deviceOS = () => {
  if (isMacOS()) {
    return 'macos';
  }
  if (isIOS()) {
    return 'ios';
  }
  if (isAndroid()) {
    return 'android';
  }
  if (isWindows()) {
    return 'windows';
  }
};
var deviceFont = (os,) => {
  if (!os) {
    os = deviceOS();
  }
  const fonts = {
    apple: '-apple-system, BlinkMacSystemFont, SF Pro Text, SF UI Text, Helvetica Neue',
    google: 'Roboto, Helvetica Neue',
    microsoft: 'Segoe UI, Helvetica Neue',
  };
  if (os === 'macos') {
    return fonts.apple;
  }
  if (os === 'ios') {
    return fonts.apple;
  }
  if (os === 'android') {
    return fonts.google;
  }
  if (os === 'windows') {
    return fonts.microsoft;
  }
  return fonts.apple;
};
var environment = {
  isWebKit,
  webkitVersion,
  isChrome,
  isSafari,
  isFirefox,
  isFramerX,
  isEdge,
  isAndroid,
  isIOS,
  isMacOS,
  isWindows,
  isTouch,
  isDesktop,
  isPhone,
  isTablet,
  isMobile,
  isFileUrl,
  isDataUrl,
  isRelativeUrl,
  isLocalServerUrl,
  isLocalUrl,
  isLocalAssetUrl,
  devicePixelRatio: devicePixelRatio2,
  isJP2Supported,
  isWebPSupported,
  deviceType,
  deviceOS,
  deviceFont,
  safariVersion,
};
var mockWithWarning = (message,) => {
  return () => {
    warnOnce2(message,);
  };
};
var mockWithoutWarning = () => {
  return () => {
  };
};
var implementation = {
  // We need a default implementation for useImageSource and useImageElement as it is used for rendering image backgrounds which would break otherwise.
  // The default value is used for HTML export and when using the library without Framer.
  useImageSource(image,) {
    var _a;
    return (_a = image.src) != null ? _a : '';
  },
  useImageElement(image, rect, nodeId,) {
    const element = new Image();
    element.src = runtime.useImageSource(image, rect, nodeId,);
    if (image.srcSet) {
      element.srcset = image.srcSet;
    }
    return element;
  },
  canRenderOptimizedCanvasImage() {
    return false;
  },
};
var isRuntimeInjected = false;
var runtimeProxy = {
  get(target, key7, reciever,) {
    if (Reflect.has(target, key7,)) {
      return Reflect.get(target, key7, reciever,);
    }
    if (['getLogger',].includes(String(key7,),)) {
      return mockWithoutWarning();
    }
    if (isRuntimeInjected) {
      return mockWithWarning(`${String(key7,)} is not available in this version of Framer.`,);
    }
    return mockWithWarning(`${String(key7,)} is only available inside of Framer. https://www.framer.com/`,);
  },
};
var runtime = new Proxy(implementation, runtimeProxy,);
function _injectRuntime(injectedRuntime,) {
  Object.assign(implementation, injectedRuntime,);
  isRuntimeInjected = true;
}
function minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3 = 1,) {
  var _a, _b, _c, _d;
  let { width: frameWidth, height: frameHeight, } = containerSize;
  const imageWidth = (_b = (_a = image.pixelWidth) != null ? _a : image.intrinsicWidth) != null ? _b : 0;
  const imageHeight = (_d = (_c = image.pixelHeight) != null ? _c : image.intrinsicHeight) != null ? _d : 0;
  if (frameWidth < 1 || frameHeight < 1 || imageWidth < 1 || imageHeight < 1) {
    return void 0;
  }
  frameWidth *= devicePixelRatio3;
  frameHeight *= devicePixelRatio3;
  const frameAspectRatio = frameWidth / frameHeight;
  const imageAspectRatio = imageWidth / imageHeight;
  switch (image.fit) {
    case 'fill':
      if (imageAspectRatio > frameAspectRatio) {
        return imageHeight / frameHeight;
      } else {
        return imageWidth / frameWidth;
      }
    case 'fit':
    case 'stretch':
      return Math.max(imageWidth / frameWidth, imageHeight / frameHeight,);
  }
}
function imageRenderingForZoom(zoom, minPixelatedZoom,) {
  if (minPixelatedZoom && Math.max(1, zoom,) > minPixelatedZoom) {
    return 'pixelated';
  }
  return 'auto';
}
var wrapperStyle = {
  position: 'absolute',
  borderRadius: 'inherit',
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
};
var placeholderStyle = {
  backgroundSize: '16px 16px',
  backgroundImage:
    'repeating-linear-gradient(45deg, rgba(180, 180, 180, 0.8) 0, rgba(180, 180, 180, 0.8) 1px, rgba(255, 255, 255, 0.2) 0, rgba(255, 255, 255, 0.2) 50%)',
  border: '1px solid #c4c4c4',
};
function cssObjectFit(imageFit,) {
  switch (imageFit) {
    case 'fit':
      return 'contain';
    case 'stretch':
      return 'fill';
    default:
      return 'cover';
  }
}
function cssObjectPosition(positionX, positionY,) {
  const x = positionX != null ? positionX : 'center';
  const y = positionY != null ? positionY : 'center';
  if (x === 'center' && y === 'center') {
    return 'center';
  }
  return x + ' ' + y;
}
function cssImageRendering(image, containerSize,) {
  if (!containerSize) {
    return 'auto';
  }
  const devicePixelRatio3 = RenderTarget.current() === 'CANVAS' ? safeWindow.devicePixelRatio : 1;
  const minPixelatedZoom = minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3,);
  if (RenderTarget.current() === 'CANVAS') {
    return imageRenderingForZoom(1, minPixelatedZoom,);
  } else {
    return imageRenderingForZoom(RenderEnvironment.zoom, minPixelatedZoom,);
  }
}
function getImageStyle(image, containerSize,) {
  return {
    display: 'block',
    width: '100%',
    height: '100%',
    borderRadius: 'inherit',
    objectPosition: cssObjectPosition(image.positionX, image.positionY,),
    objectFit: cssObjectFit(image.fit,),
    imageRendering: cssImageRendering(image, containerSize,),
  };
}
function StaticImage({ image, containerSize, nodeId, alt, },) {
  const source = runtime.useImageSource(image, containerSize, nodeId,);
  const imageStyle = getImageStyle(image, containerSize,);
  const [measuredSizes, setMeasuredSizes,] = React25.useState();
  const imageRef = React25.useRef(null,);
  const libraryFeatures = useLibraryFeatures();
  React25.useEffect(() => {
    if (!libraryFeatures.imgSizesWorkaroundEnabled) {
      return;
    }
    const imageElement = imageRef.current;
    if (!imageElement) {
      return;
    }
    if (isTest()) {
      return;
    }
    if (!image.sizes) {
      return;
    }
    const smartComponentParent = imageElement.closest('[data-framer-name]',);
    if (!smartComponentParent) {
      return;
    }
    const imageNodeWidth = imageElement.clientWidth;
    const currentSizes = Number(image.sizes.replace('px', '',),);
    if (
      // If we successfully parsed `sizes`, and...
      !isNaN(currentSizes,) && // ...if the image node is smaller than the currently set `sizes`
      // attribute,..
      imageNodeWidth < currentSizes
    ) {
      return;
    }
    setMeasuredSizes(imageNodeWidth + 'px',);
  }, [image.sizes,],);
  return /* @__PURE__ */ React25.createElement(
    'img',
    {
      ref: imageRef,
      decoding: 'async',
      loading: image.loading,
      sizes: measuredSizes != null ? measuredSizes : image.sizes,
      srcSet: image.srcSet,
      src: source,
      alt: alt != null ? alt : image.alt,
      style: imageStyle,
    },
  );
}
function CanvasImage({ image, containerSize, nodeId, },) {
  const wrapperRef = React25.useRef(null,);
  const imageElement = runtime.useImageElement(image, containerSize, nodeId,);
  const imageStyle = getImageStyle(image, containerSize,);
  React25.useLayoutEffect(() => {
    const wrapper = wrapperRef.current;
    if (wrapper === null) {
      return;
    }
    wrapper.appendChild(imageElement,);
    return () => {
      wrapper.removeChild(imageElement,);
    };
  }, [imageElement,],);
  Object.assign(imageElement.style, imageStyle,);
  return /* @__PURE__ */ React25.createElement('div', { ref: wrapperRef, style: { display: 'contents', borderRadius: 'inherit', }, },);
}
function OptimizedCanvasImage({ nodeId, image, containerSize, },) {
  const wrapperRef = React25.useRef(null,);
  const source = runtime.useImageSource(image, containerSize, nodeId,);
  React25.useLayoutEffect(() => {
    const wrapper = wrapperRef.current;
    if (wrapper === null) {
      return;
    }
    const imageStyle = getImageStyle(image, containerSize,);
    runtime.renderOptimizedCanvasImage(wrapper, source, imageStyle, nodeId,);
  }, [nodeId, image, source, containerSize,],);
  return /* @__PURE__ */ React25.createElement('div', { ref: wrapperRef, style: { display: 'contents', borderRadius: 'inherit', }, },);
}
function BackgroundImageComponent({ layoutId, image, ...props },) {
  if (layoutId) {
    layoutId = layoutId + '-background';
  }
  const fallbackWrapperStyles = { ...wrapperStyle, ...placeholderStyle, };
  let imageNode = null;
  if (isString22(image.src,)) {
    if (image.fit === 'tile' && image.pixelWidth && image.pixelHeight) {
      const backgroundSize = isNumber2(image.backgroundSize,) ? image.backgroundSize : 1;
      const tileSize = {
        width: Math.round(backgroundSize * image.pixelWidth,),
        height: Math.round(backgroundSize * image.pixelHeight,),
      };
      const imageSource = runtime.useImageSource(image, tileSize,);
      fallbackWrapperStyles.backgroundImage = `url(${imageSource})`;
      fallbackWrapperStyles.backgroundRepeat = 'repeat';
      fallbackWrapperStyles.backgroundPosition = cssObjectPosition(image.positionX, image.positionY,);
      if (image.pixelWidth) {
        fallbackWrapperStyles.backgroundSize = `${(backgroundSize * (image.pixelWidth / 2)).toFixed(2,)}px auto`;
      }
      fallbackWrapperStyles.border = 0;
      imageNode = null;
    } else if (RenderTarget.current() !== 'CANVAS') {
      imageNode = /* @__PURE__ */ React25.createElement(StaticImage, { image, ...props, },);
    } else if (runtime.canRenderOptimizedCanvasImage(runtime.useImageSource(image,),)) {
      imageNode = /* @__PURE__ */ React25.createElement(OptimizedCanvasImage, { image, ...props, },);
    } else {
      imageNode = /* @__PURE__ */ React25.createElement(CanvasImage, { image, ...props, },);
    }
  }
  return /* @__PURE__ */ React25.createElement(
    motion.div,
    {
      layoutId,
      style: imageNode ? wrapperStyle : fallbackWrapperStyles,
      'data-framer-background-image-wrapper': true,
    },
    imageNode,
  );
}
var key2 = 'src';
var BackgroundImage;
((BackgroundImage2,) => {
  BackgroundImage2.isImageObject = function (image,) {
    if (!image || typeof image === 'string') {
      return false;
    }
    return key2 in image;
  };
})(BackgroundImage || (BackgroundImage = {}),);
function applyForwardOverrides(background, props,) {
  const { _forwardedOverrideId, _forwardedOverrides, id: id3, } = props;
  const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id3;
  const src = _forwardedOverrides && forwardedOverrideId ? _forwardedOverrides[forwardedOverrideId] : void 0;
  if (src && typeof src === 'string') {
    background = { ...background, src, };
  }
  return background;
}
function backgroundImageFromProps(props,) {
  const { background, image, } = props;
  if (image !== void 0 && background && !BackgroundImage.isImageObject(background,)) {
    return;
  }
  let backgroundImage = null;
  if (isString22(image,)) {
    backgroundImage = { alt: '', src: image, };
  } else {
    backgroundImage = Animatable.get(background, null,);
  }
  if (!BackgroundImage.isImageObject(backgroundImage,)) {
    return;
  }
  return applyForwardOverrides(backgroundImage, props,);
}
function collectBorderStyleForProps(props, style, collapseEqualBorders = true,) {
  const { borderWidth, borderStyle, borderColor, } = props;
  if (!borderWidth) {
    return;
  }
  let borderTop;
  let borderBottom;
  let borderLeft;
  let borderRight;
  if (typeof borderWidth === 'number') {
    borderTop =
      borderBottom =
      borderLeft =
      borderRight =
        borderWidth;
  } else {
    borderTop = borderWidth.top || 0;
    borderBottom = borderWidth.bottom || 0;
    borderLeft = borderWidth.left || 0;
    borderRight = borderWidth.right || 0;
  }
  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) {
    return;
  }
  if (collapseEqualBorders && borderTop === borderBottom && borderTop === borderLeft && borderTop === borderRight) {
    style.border = `${borderTop}px ${borderStyle} ${borderColor}`;
    return;
  }
  style.borderStyle = props.borderStyle;
  style.borderColor = props.borderColor;
  style.borderTopWidth = `${borderTop}px`;
  style.borderBottomWidth = `${borderBottom}px`;
  style.borderLeftWidth = `${borderLeft}px`;
  style.borderRightWidth = `${borderRight}px`;
}
function Border(props,) {
  const layoutId = props.layoutId ? `${props.layoutId}-border` : void 0;
  if (!props.borderWidth) {
    return null;
  }
  const style = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    borderRadius: 'inherit',
    pointerEvents: 'none',
  };
  if (props.border) {
    style.border = props.border;
    return /* @__PURE__ */ React26.createElement(motion.div, { style, },);
  }
  collectBorderStyleForProps(props, style, false,);
  return /* @__PURE__ */ React26.createElement(motion.div, { 'data-frame-border': true, style, layoutId, },);
}
function htmlElementAsMotionComponent(asElem,) {
  return asElem && asElem !== 'search' && asElem !== 'slot' && asElem !== 'template' ? motion[asElem] : motion['div'];
}
var isChrome2 = isChrome();
function layoutHintDataPropsForCenter(center,) {
  const props = {};
  if (!isChrome2 || RenderTarget.current() !== 'CANVAS') {
    return props;
  }
  if (center === true || center === 'x') {
    props['data-framer-layout-hint-center-x'] = true;
  }
  if (center === true || center === 'y') {
    props['data-framer-layout-hint-center-y'] = true;
  }
  return props;
}
function nodeIdFromString(str,) {
  return str.replace(/^id_/, '',).replace(/\\/g, '',);
}
function countNodeRender() {
  if (true) {
    return;
  }
  const perf = asRecord(safeWindow,)['perf'];
  if (!perf) {
    return;
  }
  perf.nodeRender();
}
function processOverrideForwarding(props, children,) {
  if (!children) {
    children = props.children;
    if (!children) {
      return { props, children, };
    }
  }
  let _forwardedOverrides = props._forwardedOverrides;
  const extractions = props._overrideForwardingDescription;
  if (extractions) {
    _forwardedOverrides = void 0;
    for (const key7 in extractions) {
      const propName = extractions[key7];
      const value = props[propName];
      if (value !== void 0) {
        if (!_forwardedOverrides) {
          _forwardedOverrides = {};
          props = { ...props, };
        }
        _forwardedOverrides[key7] = props[propName];
        delete props[propName];
      }
    }
  }
  if (!_forwardedOverrides) {
    return { props, children, };
  }
  children = React27.Children.map(children, (child,) => {
    if (!React27.isValidElement(child,)) {
      return child;
    }
    return React27.cloneElement(child, { _forwardedOverrides, },);
  },);
  return { props, children, };
}
function transformTemplate(center,) {
  return (_, generated,) => {
    if (center === true) {
      return `translate(-50%, -50%) ${generated}`;
    } else {
      if (center === 'x') {
        return `translateX(-50%) ${generated}`;
      } else if (center === 'y') {
        return `translateY(-50%) ${generated}`;
      }
    }
    return generated || 'none';
  };
}
function useLayoutId2(props, { specificLayoutId, postfix, } = {},) {
  const { name, layoutIdKey, duplicatedFrom, __fromCodeComponentNode = false, drag: drag2, } = props;
  const { getLayoutId, enabled, } = useContext32(LayoutIdContext,);
  return useMemo22(() => {
    if (!enabled) {
      return props.layoutId;
    }
    const existingLayoutId = specificLayoutId || props.layoutId;
    if (!existingLayoutId) {
      if (drag2 || !layoutIdKey || __fromCodeComponentNode) {
        return void 0;
      }
    }
    const layoutIdCandidate = existingLayoutId || getLayoutId({ id: layoutIdKey, name, duplicatedFrom, },);
    if (!layoutIdCandidate) {
      return void 0;
    }
    return postfix ? `${layoutIdCandidate}-${postfix}` : layoutIdCandidate;
  }, [enabled,],);
}
var useIsomorphicLayoutEffect2 = typeof document !== 'undefined' ? useLayoutEffect2 : useEffect22;
var ComponentContainerContext = React28.createContext(false,);
var resizeObservers = [];
var hasActiveObservations = function () {
  return resizeObservers.some(function (ro,) {
    return ro.activeTargets.length > 0;
  },);
};
var hasSkippedObservations = function () {
  return resizeObservers.some(function (ro,) {
    return ro.skippedTargets.length > 0;
  },);
};
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
  var event;
  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg,
    },);
  } else {
    event = document.createEvent('Event',);
    event.initEvent('error', false, false,);
    event.message = msg;
  }
  window.dispatchEvent(event,);
};
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions2,) {
  ResizeObserverBoxOptions2['BORDER_BOX'] = 'border-box';
  ResizeObserverBoxOptions2['CONTENT_BOX'] = 'content-box';
  ResizeObserverBoxOptions2['DEVICE_PIXEL_CONTENT_BOX'] = 'device-pixel-content-box';
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}),);
var freeze = function (obj,) {
  return Object.freeze(obj,);
};
var ResizeObserverSize = /* @__PURE__ */ function () {
  function ResizeObserverSize2(inlineSize, blockSize,) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this,);
  }
  return ResizeObserverSize2;
}();
var DOMRectReadOnly = function () {
  function DOMRectReadOnly2(x, y, width, height,) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this,);
  }
  DOMRectReadOnly2.prototype.toJSON = function () {
    var _a = this,
      x = _a.x,
      y = _a.y,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom,
      left = _a.left,
      width = _a.width,
      height = _a.height;
    return { x, y, top, right, bottom, left, width, height, };
  };
  DOMRectReadOnly2.fromRect = function (rectangle,) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height,);
  };
  return DOMRectReadOnly2;
}();
var isSVG = function (target,) {
  return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function (target,) {
  if (isSVG(target,)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj,) {
  var _a, _b;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target,) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
var global = typeof window !== 'undefined' ? window : {};
var cache2 = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent,);
var parseDimension = function (pixel,) {
  return parseFloat(pixel || '0',);
};
var size = function (inlineSize, blockSize, switchSizes,) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0,);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0,),
},);
var calculateBoxSizes = function (target, forceRecalculation,) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache2.has(target,) && !forceRecalculation) {
    return cache2.get(target,);
  }
  if (isHidden(target,)) {
    cache2.set(target, zeroBoxes,);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target,);
  var svg = isSVG(target,) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '',);
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '',);
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '',);
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop,);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight,);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom,);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft,);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth,);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth,);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth,);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth,);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width,) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height,) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(
      Math.round(contentWidth * devicePixelRatio,),
      Math.round(contentHeight * devicePixelRatio,),
      switchSizes,
    ),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes,),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes,),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight,),
  },);
  cache2.set(target, boxes,);
  return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation,) {
  var _a = calculateBoxSizes(target, forceRecalculation,),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = /* @__PURE__ */ function () {
  function ResizeObserverEntry2(target,) {
    var boxes = calculateBoxSizes(target,);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize,],);
    this.contentBoxSize = freeze([boxes.contentBoxSize,],);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize,],);
  }
  return ResizeObserverEntry2;
}();
var calculateDepthForNode = function (node,) {
  if (isHidden(node,)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro,) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot,) {
      var entry = new ResizeObserverEntry(ot.target,);
      var targetDepth = calculateDepthForNode(ot.target,);
      entries.push(entry,);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox,);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    },);
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer,);
    },);
    ro.activeTargets.splice(0, ro.activeTargets.length,);
  },);
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function (depth,) {
  resizeObservers.forEach(function processObserver(ro,) {
    ro.activeTargets.splice(0, ro.activeTargets.length,);
    ro.skippedTargets.splice(0, ro.skippedTargets.length,);
    ro.observationTargets.forEach(function processTarget(ot,) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target,) > depth) {
          ro.activeTargets.push(ot,);
        } else {
          ro.skippedTargets.push(ot,);
        }
      }
    },);
  },);
};
var process3 = function () {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth,);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth,);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify2 = function () {
  return callbacks.splice(0,).forEach(function (cb,) {
    return cb();
  },);
};
var queueMicroTask = function (callback,) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('',);
    var config = { characterData: true, };
    new MutationObserver(function () {
      return notify2();
    },).observe(el_1, config,);
    trigger = function () {
      el_1.textContent = '' + (toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback,);
  trigger();
};
var queueResizeObserver = function (cb,) {
  queueMicroTask(function ResizeObserver22() {
    requestAnimationFrame(cb,);
  },);
};
var watching = 0;
var isWatching = function () {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true, };
var events = [
  'resize',
  'load',
  'transitionend',
  'animationend',
  'animationstart',
  'animationiteration',
  'keyup',
  'keydown',
  'mouseup',
  'mousedown',
  'mouseover',
  'mouseout',
  'blur',
  'focus',
];
var time2 = function (timeout,) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function () {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function () {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function (timeout,) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time2(timeout,);
    queueResizeObserver(function () {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process3();
      } finally {
        scheduled = false;
        timeout = until - time2();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3,);
        } else if (timeout > 0) {
          _this.run(timeout,);
        } else {
          _this.start();
        }
      }
    },);
  };
  Scheduler2.prototype.schedule = function () {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function () {
    var _this = this;
    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig,);
    };
    document.body ? cb() : global.addEventListener('DOMContentLoaded', cb,);
  };
  Scheduler2.prototype.start = function () {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener,);
      this.observe();
      events.forEach(function (name,) {
        return global.addEventListener(name, _this.listener, true,);
      },);
    }
  };
  Scheduler2.prototype.stop = function () {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name,) {
        return global.removeEventListener(name, _this.listener, true,);
      },);
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function (n,) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function (target,) {
  return !isSVG(target,) && !isReplacedElement(target,) && getComputedStyle(target,).display === 'inline';
};
var ResizeObservation = function () {
  function ResizeObservation2(target, observedBox,) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0,
    };
  }
  ResizeObservation2.prototype.isActive = function () {
    var size2 = calculateBoxSize(this.target, this.observedBox, true,);
    if (skipNotifyOnElement(this.target,)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();
var ResizeObserverDetail = /* @__PURE__ */ function () {
  function ResizeObserverDetail2(resizeObserver, callback,) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function (observationTargets, target,) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function () {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function (resizeObserver, callback,) {
    var detail = new ResizeObserverDetail(resizeObserver, callback,);
    observerMap.set(resizeObserver, detail,);
  };
  ResizeObserverController2.observe = function (resizeObserver, target, options,) {
    var detail = observerMap.get(resizeObserver,);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target,) < 0) {
      firstObservation && resizeObservers.push(detail,);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box,),);
      updateCount(1,);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function (resizeObserver, target,) {
    var detail = observerMap.get(resizeObserver,);
    var index = getObservationIndex(detail.observationTargets, target,);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail,), 1,);
      detail.observationTargets.splice(index, 1,);
      updateCount(-1,);
    }
  };
  ResizeObserverController2.disconnect = function (resizeObserver,) {
    var _this = this;
    var detail = observerMap.get(resizeObserver,);
    detail.observationTargets.slice().forEach(function (ot,) {
      return _this.unobserve(resizeObserver, ot.target,);
    },);
    detail.activeTargets.splice(0, detail.activeTargets.length,);
  };
  return ResizeObserverController2;
}();
var ResizeObserver2 = function () {
  function ResizeObserver22(callback,) {
    if (arguments.length === 0) {
      throw new TypeError('Failed to construct \'ResizeObserver\': 1 argument required, but only 0 present.',);
    }
    if (typeof callback !== 'function') {
      throw new TypeError('Failed to construct \'ResizeObserver\': The callback provided as parameter 1 is not a function.',);
    }
    ResizeObserverController.connect(this, callback,);
  }
  ResizeObserver22.prototype.observe = function (target, options,) {
    if (arguments.length === 0) {
      throw new TypeError('Failed to execute \'observe\' on \'ResizeObserver\': 1 argument required, but only 0 present.',);
    }
    if (!isElement(target,)) {
      throw new TypeError('Failed to execute \'observe\' on \'ResizeObserver\': parameter 1 is not of type \'Element',);
    }
    ResizeObserverController.observe(this, target, options,);
  };
  ResizeObserver22.prototype.unobserve = function (target,) {
    if (arguments.length === 0) {
      throw new TypeError('Failed to execute \'unobserve\' on \'ResizeObserver\': 1 argument required, but only 0 present.',);
    }
    if (!isElement(target,)) {
      throw new TypeError('Failed to execute \'unobserve\' on \'ResizeObserver\': parameter 1 is not of type \'Element',);
    }
    ResizeObserverController.unobserve(this, target,);
  };
  ResizeObserver22.prototype.disconnect = function () {
    ResizeObserverController.disconnect(this,);
  };
  ResizeObserver22.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };
  return ResizeObserver22;
}();
function useForceUpdate3() {
  const [_, setForcedRenderCount,] = React29.useState(0,);
  return React29.useCallback(() => setForcedRenderCount((v,) => v + 1), [],);
}
var DEFAULT_SIZE = 200;
var _sharedResizeObserver;
var _callbacks;
var SharedObserver = class {
  constructor() {
    __privateAdd(this, _sharedResizeObserver, void 0,);
    __privateAdd(this, _callbacks, /* @__PURE__ */ new WeakMap(),);
    var _a;
    const ResizeObserver22 = (_a = safeWindow.ResizeObserver) != null ? _a : ResizeObserver2;
    __privateSet(this, _sharedResizeObserver, new ResizeObserver22(this.updateResizedElements.bind(this,),),);
  }
  updateResizedElements(entries,) {
    for (const entry of entries) {
      const callbackForElement = __privateGet(this, _callbacks,).get(entry.target,);
      if (callbackForElement) {
        callbackForElement(entry.contentRect,);
      }
    }
  }
  observeElementWithCallback(element, callback,) {
    __privateGet(this, _sharedResizeObserver,).observe(element,);
    __privateGet(this, _callbacks,).set(element, callback,);
  }
  unobserve(element,) {
    __privateGet(this, _sharedResizeObserver,).unobserve(element,);
    __privateGet(this, _callbacks,).delete(element,);
  }
};
_sharedResizeObserver = /* @__PURE__ */ new WeakMap();
_callbacks = /* @__PURE__ */ new WeakMap();
var sharedResizeObserver = isBrowser2() ? new SharedObserver() : void 0;
function useRerenderOnResize(ref,) {
  const update = useForceUpdate3();
  useEffect32(() => {
    const element = ref == null ? void 0 : ref.current;
    if (!element) {
      return;
    }
    sharedResizeObserver == null ? void 0 : sharedResizeObserver.observeElementWithCallback(ref.current, update,);
    return () => {
      sharedResizeObserver == null ? void 0 : sharedResizeObserver.unobserve(element,);
    };
  }, [ref, update,],);
}
function useMeasuredSize(ref,) {
  const forceUpdate = useForceUpdate3();
  const size2 = React30.useRef(null,);
  function updateSize(newSize,) {
    if (newSize.width === 0 && newSize.height === 0) {
      return;
    }
    if (!size2.current || newSize.height !== size2.current.height || newSize.width !== size2.current.width) {
      size2.current = { width: newSize.width, height: newSize.height, };
      forceUpdate();
    }
  }
  useIsomorphicLayoutEffect2(() => {
    if (!ref.current) {
      return;
    }
    const { offsetWidth, offsetHeight, } = ref.current;
    updateSize({
      width: offsetWidth,
      height: offsetHeight,
    },);
    sharedResizeObserver.observeElementWithCallback(ref.current, updateSize,);
    return () => {
      if (!ref.current) {
        return;
      }
      sharedResizeObserver.unobserve(ref.current,);
    };
  }, [],);
  return size2.current;
}
var SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = 'data-framer-size-compatibility-wrapper';
var withMeasuredSize = (Component15,) => (props,) => {
  var _a, _b, _c, _d;
  const ref = React30.useRef(null,);
  const size2 = useMeasuredSize(ref,);
  const dataProps = { [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true, };
  const shouldRender = Boolean(size2,);
  const fallbackWidth = (_a = props.width) != null ? _a : DEFAULT_SIZE;
  const fallbackHeight = (_b = props.height) != null ? _b : DEFAULT_SIZE;
  return /* @__PURE__ */ React30.createElement(
    'div',
    { style: { width: '100%', height: '100%', pointerEvents: 'none', }, ref, ...dataProps, },
    shouldRender && /* @__PURE__ */ React30.createElement(
      Component15,
      {
        ...props,
        width: (_c = size2 == null ? void 0 : size2.width) != null ? _c : fallbackWidth,
        height: (_d = size2 == null ? void 0 : size2.height) != null ? _d : fallbackHeight,
      },
    ),
  );
};
function getMeasurableCodeComponentChildren(element,) {
  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE,)
    ? element.firstElementChild.children
    : element.children;
  return [...childrenCollection,].filter(isMeasurable,).map(unwrapInlinedDisplayContents,);
}
function isMeasurable(element,) {
  if (
    element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement ||
    element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement ||
    element instanceof HTMLTitleElement
  ) {
    return false;
  }
  return element instanceof HTMLElement || element instanceof SVGElement;
}
function unwrapInlinedDisplayContents(element,) {
  if (!(element instanceof HTMLElement)) {
    return element;
  }
  if (element.children.length === 0) {
    return element;
  }
  if (element.style.display !== 'contents') {
    return element;
  }
  const firstMeasurableChild = [...element.children,].find(isMeasurable,);
  if (firstMeasurableChild) {
    return unwrapInlinedDisplayContents(firstMeasurableChild,);
  }
  return element;
}
function useMeasureLayout(props, ref, getChildren = () => [], options = {},) {
  const { id: id3, visible, _needsMeasure, } = props;
  const { skipHook = false, } = options;
  const inCodeComponent = Boolean(useContext42(ComponentContainerContext,),);
  const onCanvas = RenderTarget.current() === 'CANVAS';
  useIsomorphicLayoutEffect2(() => {
    if (!onCanvas || inCodeComponent || skipHook) {
      return;
    }
    if (!(ref.current && id3 && visible && _needsMeasure)) {
      return;
    }
    runtime.queueMeasureRequest(nodeIdFromString(id3,), ref.current, getChildren(ref.current,),);
  },);
}
function measureClosestComponentContainer(element,) {
  const container = element.closest('[data-framer-component-container]',);
  if (!container) {
    return;
  }
  runtime.queueMeasureRequest(
    nodeIdFromString(container.id,),
    container,
    getMeasurableCodeComponentChildren(container,),
  );
}
var objectKeys = Object.keys;
function hasProp(o, prop,) {
  return Object.prototype.hasOwnProperty.call(o, prop,);
}
function withEquals(o,) {
  if (!hasProp(o, 'equals',)) {
    return false;
  }
  return typeof o.equals === 'function';
}
function valueEqual(a, b,) {
  if (a === b) {
    return true;
  }
  return a !== a && b !== b;
}
function arrayShallowEqual(a, b,) {
  const length = a.length;
  if (length !== b.length) {
    return false;
  }
  for (let i = length; i-- !== 0;) {
    if (!valueEqual(a[i], b[i],)) {
      return false;
    }
  }
  return true;
}
function arrayDeepEqual(a, b,) {
  const length = a.length;
  if (length !== b.length) {
    return false;
  }
  for (let i = length; i-- !== 0;) {
    if (!equal(a[i], b[i], true,)) {
      return false;
    }
  }
  return true;
}
function mapShallowEqual(a, b,) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key7, aValue,] of a.entries()) {
    if (!valueEqual(aValue, b.get(key7,),)) {
      return false;
    }
  }
  return true;
}
function mapDeepEqual(a, b,) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key7, aValue,] of a.entries()) {
    if (!equal(aValue, b.get(key7,), true,)) {
      return false;
    }
  }
  return true;
}
function setEqual(a, b,) {
  if (a.size !== b.size) {
    return false;
  }
  for (const aValue of a.keys()) {
    if (!b.has(aValue,)) {
      return false;
    }
  }
  return true;
}
function objectShallowEqual(a, b,) {
  const keys3 = objectKeys(a,);
  if (keys3.length !== objectKeys(b,).length) {
    return false;
  }
  for (const key7 of keys3) {
    if (!hasProp(b, key7,)) {
      return false;
    }
    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) {
      continue;
    }
    if (!valueEqual(a[key7], b[key7],)) {
      return false;
    }
  }
  return true;
}
function objectDeepEqual(a, b,) {
  const keys3 = objectKeys(a,);
  if (keys3.length !== objectKeys(b,).length) {
    return false;
  }
  for (const key7 of keys3) {
    if (!hasProp(b, key7,)) {
      return false;
    }
    if (key7 === '_owner' && hasProp(a, '$$typeof',) && a.$$typeof) {
      continue;
    }
    if (!equal(a[key7], b[key7], true,)) {
      return false;
    }
  }
  return true;
}
function equal(a, b, deep,) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return a !== a && b !== b;
  }
  const typeA = typeof a;
  const typeB = typeof b;
  if (typeA !== typeB) {
    return false;
  }
  if (typeA !== 'object') {
    return false;
  }
  const aIsArray = Array.isArray(a,);
  const bIsArray = Array.isArray(b,);
  if (aIsArray && bIsArray) {
    if (deep) {
      return arrayDeepEqual(a, b,);
    } else {
      return arrayShallowEqual(a, b,);
    }
  } else if (aIsArray !== bIsArray) {
    return false;
  }
  const aIsMap = a instanceof Map;
  const bIsMap = b instanceof Map;
  if (aIsMap && bIsMap) {
    if (deep) {
      return mapDeepEqual(a, b,);
    } else {
      return mapShallowEqual(a, b,);
    }
  } else if (aIsMap !== bIsMap) {
    return false;
  }
  const aIsSet = a instanceof Set;
  const bIsSet = b instanceof Set;
  if (aIsSet && bIsSet) {
    return setEqual(a, b,);
  } else if (aIsSet !== bIsSet) {
    return false;
  }
  const dateA = a instanceof Date;
  const dateB = b instanceof Date;
  if (dateA && dateB) {
    return a.getTime() === b.getTime();
  } else if (dateA !== dateB) {
    return false;
  }
  const regexpA = a instanceof RegExp;
  const regexpB = b instanceof RegExp;
  if (regexpA && regexpB) {
    return a.toString() === b.toString();
  } else if (regexpA !== regexpB) {
    return false;
  }
  if (withEquals(a,) && withEquals(b,)) {
    return a.equals(b,);
  }
  if (deep) {
    return objectDeepEqual(a, b,);
  } else {
    return objectShallowEqual(a, b,);
  }
}
function isEqual(a, b, deep = true,) {
  try {
    return equal(a, b, deep,);
  } catch (error) {
    if (error instanceof Error && /stack|recursion/iu.exec(error.message,)) {
      console.warn('Warning: isEqual does not handle circular references.', error.name, error.message,);
      return false;
    }
    throw error;
  }
}
var smallValue = '0.000001px';
var translateZ = ` translateZ(${smallValue})`;
var useTranslateZHack = isFramerX() || isSafari() || isTest();
function forceLayerBackingWithMotionStyle(motionStyle,) {
  motionStyle.willChange = 'transform';
  const onCanvas = RenderTarget.current() === 'CANVAS';
  if (useTranslateZHack && onCanvas) {
    motionStyle.translateZ = smallValue;
  }
}
function forceLayerBackingWithCSSProperties(cssProperties,) {
  cssProperties.willChange = 'transform';
  setTranslateZHack(cssProperties, true,);
}
function setTranslateZHack(style, enabled,) {
  const onCanvas = RenderTarget.current() === 'CANVAS';
  if (!useTranslateZHack || !onCanvas) {
    return;
  }
  const transform2 = style.transform || '';
  if (enabled) {
    const hasTranslateZ = transform2.includes(translateZ,);
    if (!hasTranslateZ) {
      style.transform = transform2 + translateZ;
    }
  } else {
    style.transform = transform2.replace(translateZ, '',);
  }
}
function resetSetStyle(element, key7, toValue, microtask2 = true,) {
  if (!element) {
    return;
  }
  const style = asRecord(element.style,);
  const value = toValue ? toValue : style[key7];
  const reset = () => {
    style[key7] = value;
  };
  style[key7] = null;
  if (microtask2) {
    void Promise.resolve().then(reset,);
  } else {
    setTimeout(reset, 0,);
  }
}
var Layer = class extends Component4 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'layerElement', null,);
    __publicField(this, 'setLayerElement', (element,) => {
      this.layerElement = element;
    },);
  }
  static applyWillChange(props, style, usingMotionStyle,) {
    if (props.willChangeTransform) {
      if (usingMotionStyle) {
        forceLayerBackingWithMotionStyle(style,);
      } else {
        forceLayerBackingWithCSSProperties(style,);
      }
    }
  }
  /** @internal */
  shouldComponentUpdate(nextProps, nextState,) {
    return nextProps._needsMeasure || this.state !== nextState || !isEqual(this.props, nextProps,);
  }
  /** @internal */
  componentDidUpdate(prevProps,) {
    if (asRecord(this.props,)['clip'] && asRecord(this.props,)['radius'] === 0 && asRecord(prevProps,)['radius'] !== 0) {
      resetSetStyle(this.layerElement, 'overflow', 'hidden', false,);
    }
  }
};
__publicField(Layer, 'defaultProps', {},);
function manageCache(cache3, maxEntries,) {
  const size2 = cache3.size;
  if (size2 < maxEntries) {
    return;
  }
  let i = Math.round(Math.random(),);
  for (const key7 of cache3.keys()) {
    if ((++i & 1) === 1) {
      continue;
    }
    cache3.delete(key7,);
  }
}
function memoize2(maxEntries, cache3, key7, create,) {
  const r = cache3.get(key7,);
  if (r) {
    return r;
  }
  manageCache(cache3, maxEntries,);
  const g = create(key7,);
  cache3.set(key7, g,);
  return g;
}
var hash = (value,) => {
  let hasher = 0, i, chr;
  if (value.length === 0) {
    return hasher;
  }
  for (i = 0; i < value.length; i++) {
    chr = value.charCodeAt(i,);
    hasher = (hasher << 5) - hasher + chr;
    hasher |= 0;
  }
  return hasher;
};
var ConvertColor = {
  hueRotate: (color2, angle,) => {
    return Color.toHslString(Color.hueRotate(Color(color2,), angle,),);
  },
  setAlpha: (color2, alpha2,) => {
    return Color.toRgbString(Color.alpha(Color(color2,), alpha2,),);
  },
  getAlpha: (color2,) => {
    const obj = stringToObject(color2,);
    return obj ? obj.a : 1;
  },
  multiplyAlpha: (color2, alpha2,) => {
    return Color.toRgbString(Color.multiplyAlpha(Color(color2,), alpha2,),);
  },
  toHex: (color2,) => {
    return Color.toHexString(Color(color2,),).toUpperCase();
  },
  toRgb: (color2,) => {
    return Color.toRgb(Color(color2,),);
  },
  toRgbString: (color2,) => {
    return Color.toRgbString(Color(color2,),);
  },
  toHSV: (color2,) => {
    return Color.toHsv(Color(color2,),);
  },
  toHSL: (color2,) => {
    return Color.toHsl(Color(color2,),);
  },
  toHslString: (color2,) => {
    return Color.toHslString(Color(color2,),);
  },
  toHsvString: (color2,) => {
    return Color.toHsvString(Color(color2,),);
  },
  hsvToHSLString: (hsv,) => {
    return Color.toHslString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a,),),);
  },
  hsvToHex: (hsv,) => {
    return Color.toHexString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a,),),).toUpperCase();
  },
  hsvToRgbString: (hsv,) => {
    return Color.toRgbString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a,),),);
  },
  hsvToString: (hsv,) => {
    return hsvToStr(hsv.h, hsv.s, hsv.v,);
  },
  rgbaToString: (color2,) => {
    return Color.toRgbString(Color(color2,),);
  },
  rgbToHexString: (color2,) => {
    return Color.toHexString(Color(color2,),);
  },
  hslToString: (color2,) => {
    return Color.toHslString(Color(color2,),);
  },
  hslToRgbString: (color2,) => {
    return Color.toRgbString(Color(color2,),);
  },
  toColorPickerSquare: (h,) => {
    return Color.toRgbString(Color({ h, s: 1, l: 0.5, a: 1, },),);
  },
  isValid: (color2,) => {
    return Color(color2,).isValid !== false;
  },
  equals: (a, b,) => {
    if (typeof a === 'string') {
      a = Color(a,);
    }
    if (typeof b === 'string') {
      b = Color(b,);
    }
    return Color.equal(a, b,);
  },
  toHexOrRgbaString: (input,) => {
    const color2 = Color(input,);
    return color2.a !== 1 ? Color.toRgbString(color2,) : Color.toHexString(color2,);
  },
};
var CSSVariableRegExp = /var\(.+\)/;
var colorCache = /* @__PURE__ */ new Map();
function cachedMultiplyAlpha(s, a,) {
  const key7 = [s, a,];
  if (CSSVariableRegExp.test(s,)) {
    return s;
  }
  return memoize2(1e3, colorCache, key7, () => ConvertColor.multiplyAlpha(s, a,),);
}
function gradientColorStops(gradient, alpha2 = 1,) {
  let stops;
  if ('stops' in gradient) {
    stops = gradient.stops;
  } else {
    stops = [
      { value: gradient.start, position: 0, },
      { value: gradient.end, position: 1, },
    ];
  }
  if (alpha2 === 1) {
    return stops;
  } else {
    return stops.map((stop,) => ({ ...stop, value: cachedMultiplyAlpha(stop.value, alpha2,), }));
  }
}
function gradientColorStopsHash(gradient, alpha2,) {
  let result = 0;
  gradientColorStops(gradient, alpha2,).forEach((stop,) => {
    result ^= hash(stop.value,) ^ stop.position;
  },);
  return result;
}
var multiStopGradientKeys = ['stops',];
function isMultiStopGradient(value,) {
  return value && multiStopGradientKeys.every((key7,) => key7 in value);
}
var simpleGradientKeys = ['start', 'end',];
function isSimpleGradient(value,) {
  return value && simpleGradientKeys.every((key7,) => key7 in value);
}
var linearGradientKeys = ['angle', 'alpha',];
var LinearGradient = {
  /**
   * @param value -
   */
  isLinearGradient: (value,) => {
    return value && linearGradientKeys.every((key7,) => key7 in value) && (isSimpleGradient(value,) || isMultiStopGradient(value,));
  },
  /** @internal */
  hash: (linearGradient,) => {
    return linearGradient.angle ^ gradientColorStopsHash(linearGradient, linearGradient.alpha,);
  },
  /** @internal */
  toCSS: (linearGradient, overrideAngle,) => {
    const stops = gradientColorStops(linearGradient, linearGradient.alpha,);
    const angle = overrideAngle !== void 0 ? overrideAngle : linearGradient.angle;
    const cssStops = stops.map((stop,) => `${stop.value} ${stop.position * 100}%`);
    return `linear-gradient(${angle}deg, ${cssStops.join(', ',)})`;
  },
};
var radialGradientKeys = [
  'widthFactor',
  'heightFactor',
  'centerAnchorX',
  'centerAnchorY',
  'alpha',
];
var RadialGradient = {
  /**
   * @param value -
   * @public
   */
  isRadialGradient: (value,) => {
    return value && radialGradientKeys.every((key7,) => key7 in value) && (isSimpleGradient(value,) || isMultiStopGradient(value,));
  },
  /** @internal */
  hash: (radialGradient,) => {
    return radialGradient.centerAnchorX ^ radialGradient.centerAnchorY ^ radialGradient.widthFactor ^ radialGradient.heightFactor ^
      gradientColorStopsHash(radialGradient, radialGradient.alpha,);
  },
  /** @internal */
  toCSS: (radialGradient,) => {
    const { alpha: alpha2, widthFactor, heightFactor, centerAnchorX, centerAnchorY, } = radialGradient;
    const stops = gradientColorStops(radialGradient, alpha2,);
    const cssStops = stops.map((stop,) => `${stop.value} ${stop.position * 100}%`);
    return `radial-gradient(${widthFactor * 100}% ${heightFactor * 100}% at ${centerAnchorX * 100}% ${centerAnchorY * 100}%, ${
      cssStops.join(', ',)
    })`;
  },
};
function collectBackgroundFromProps({ background, backgroundColor, }, style,) {
  if (backgroundColor) {
    if (typeof backgroundColor === 'string' || isMotionValue2(backgroundColor,)) {
      style.backgroundColor = backgroundColor;
    } else if (Color.isColorObject(background,)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background,);
    }
  } else if (background) {
    background = Animatable.get(background, null,);
    if (typeof background === 'string' || isMotionValue2(background,)) {
      style.background = background;
    } else if (LinearGradient.isLinearGradient(background,)) {
      style.background = LinearGradient.toCSS(background,);
    } else if (RadialGradient.isRadialGradient(background,)) {
      style.background = RadialGradient.toCSS(background,);
    } else if (Color.isColorObject(background,)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background,);
    }
  }
}
function extractStyleFromProps(props, name, styleRef, into,) {
  if (into === void 0) {
    into = name;
  }
  if (props[name] !== void 0) {
    styleRef[into] = props[name];
    return;
  }
}
function hasLeftAndRight(style,) {
  if (!style) {
    return false;
  }
  return style.left !== void 0 && style.right !== void 0;
}
function hasTopAndBottom(style,) {
  if (!style) {
    return false;
  }
  return style.top !== void 0 && style.bottom !== void 0;
}
function getStyleForFrameProps(props,) {
  if (!props) {
    return {};
  }
  const style = {};
  if (props.preserve3d === true) {
    style.transformStyle = 'preserve-3d';
  } else if (props.preserve3d === false) {
    style.transformStyle = 'flat';
  }
  if (props.backfaceVisible === true) {
    style.backfaceVisibility = 'visible';
  } else if (props.backfaceVisible === false) {
    style.backfaceVisibility = 'hidden';
  }
  if (style.backfaceVisibility) {
    style.WebkitBackfaceVisibility = style.backfaceVisibility;
  }
  if (props.perspective !== void 0) {
    style.perspective = style.WebkitPerspective = props.perspective;
  }
  if (!props.__fromCanvasComponent) {
    if (props.center === true) {
      style.left = '50%';
      style.top = '50%';
    } else {
      if (props.center === 'x') {
        style.left = '50%';
      } else if (props.center === 'y') {
        style.top = '50%';
      }
    }
  }
  extractStyleFromProps(props, 'size', style,);
  extractStyleFromProps(props, 'width', style,);
  extractStyleFromProps(props, 'height', style,);
  extractStyleFromProps(props, 'minWidth', style,);
  extractStyleFromProps(props, 'minHeight', style,);
  extractStyleFromProps(props, 'top', style,);
  extractStyleFromProps(props, 'right', style,);
  extractStyleFromProps(props, 'bottom', style,);
  extractStyleFromProps(props, 'left', style,);
  extractStyleFromProps(props, 'position', style,);
  extractStyleFromProps(props, 'overflow', style,);
  extractStyleFromProps(props, 'opacity', style,);
  if (!props._border || !props._border.borderWidth) {
    extractStyleFromProps(props, 'border', style,);
  }
  extractStyleFromProps(props, 'borderRadius', style,);
  extractStyleFromProps(props, 'radius', style, 'borderRadius',);
  extractStyleFromProps(props, 'color', style,);
  extractStyleFromProps(props, 'shadow', style, 'boxShadow',);
  extractStyleFromProps(props, 'x', style,);
  extractStyleFromProps(props, 'y', style,);
  extractStyleFromProps(props, 'z', style,);
  extractStyleFromProps(props, 'rotate', style,);
  extractStyleFromProps(props, 'rotateX', style,);
  extractStyleFromProps(props, 'rotateY', style,);
  extractStyleFromProps(props, 'rotateZ', style,);
  extractStyleFromProps(props, 'scale', style,);
  extractStyleFromProps(props, 'scaleX', style,);
  extractStyleFromProps(props, 'scaleY', style,);
  extractStyleFromProps(props, 'skew', style,);
  extractStyleFromProps(props, 'skewX', style,);
  extractStyleFromProps(props, 'skewY', style,);
  extractStyleFromProps(props, 'originX', style,);
  extractStyleFromProps(props, 'originY', style,);
  extractStyleFromProps(props, 'originZ', style,);
  collectBackgroundFromProps(props, style,);
  return style;
}
function hasEvents(props,) {
  for (const key7 in props) {
    if (
      key7 === 'drag' || key7.startsWith('while',) ||
      typeof asRecord(props,)[key7] === 'function' && key7.startsWith('on',) && !key7.includes('Animation',)
    ) {
      return true;
    }
  }
  return false;
}
var pointerEvents = [
  'onClick',
  'onDoubleClick',
  'onMouse',
  'onMouseDown',
  'onMouseUp',
  'onTapDown',
  'onTap',
  'onTapUp',
  'onPointer',
  'onPointerDown',
  'onPointerUp',
  'onTouch',
  'onTouchDown',
  'onTouchUp',
];
var pointerEventsSet = /* @__PURE__ */ new Set([
  ...pointerEvents,
  ...pointerEvents.map((event,) => `${event}Capture`),
  // Add capture event variants
],);
function getCursorFromEvents(props,) {
  if (props.drag) {
    return 'grab';
  }
  for (const key7 in props) {
    if (pointerEventsSet.has(key7,)) {
      return 'pointer';
    }
  }
  return void 0;
}
var overflowKey = 'overflow';
function hasScrollableContent(props,) {
  if (hasScrollingOverflow(props,)) {
    return true;
  }
  if (!props.style) {
    return false;
  }
  if (hasScrollingOverflow(props.style,)) {
    return true;
  }
  return false;
}
function hasScrollingOverflow(props,) {
  if (overflowKey in props && (props[overflowKey] === 'scroll' || props[overflowKey] === 'auto')) {
    return true;
  }
  return false;
}
function unwrapFrameProps(frameProps,) {
  const {
    left,
    top,
    bottom,
    right,
    width,
    height,
    center,
    _constraints,
    size: size2,
    widthType,
    heightType,
    positionFixed,
    positionAbsolute,
  } = frameProps;
  const minWidth = resolveMotionValue(frameProps.minWidth,);
  const minHeight = resolveMotionValue(frameProps.minHeight,);
  const maxWidth = resolveMotionValue(frameProps.maxWidth,);
  const maxHeight = resolveMotionValue(frameProps.maxHeight,);
  const constraintProps = {
    top: resolveMotionValue(top,),
    left: resolveMotionValue(left,),
    bottom: resolveMotionValue(bottom,),
    right: resolveMotionValue(right,),
    width: resolveMotionValue(width,),
    height: resolveMotionValue(height,),
    size: resolveMotionValue(size2,),
    center,
    _constraints,
    widthType,
    heightType,
    positionFixed,
    positionAbsolute,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
  };
  return constraintProps;
}
var defaultFrameRect = { x: 0, y: 0, width: 200, height: 200, };
function useStyleAndRect(props,) {
  var _a, _b, _c;
  React31.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  const inCodeComponent = Boolean(useContext52(ComponentContainerContext,),);
  const { style, _initialStyle, __fromCanvasComponent, size: size2, } = props;
  const unwrappedProps = unwrapFrameProps(props,);
  const constraintsRect = useConstraints(unwrappedProps,);
  const defaultStyle = {
    display: 'block',
    flex: (_a = style == null ? void 0 : style.flex) != null ? _a : '0 0 auto',
    userSelect: RenderTarget.current() !== 'PREVIEW' ? 'none' : void 0,
  };
  if (!props.__fromCanvasComponent) {
    defaultStyle.backgroundColor = props.background === void 0 ? 'rgba(0, 170, 255, 0.3)' : void 0;
  }
  const shouldDisablePointerEvents = !hasEvents(props,) && !props.__fromCanvasComponent && !hasScrollableContent(props,);
  const safeToEditPointerEvents = props.style ? !('pointerEvents' in props.style) : true;
  if (shouldDisablePointerEvents && safeToEditPointerEvents) {
    defaultStyle.pointerEvents = 'none';
  }
  const addTextCentering = React31.Children.count(props.children,) > 0 && React31.Children.toArray(props.children,).every((child,) => {
    return typeof child === 'string' || typeof child === 'number';
  },);
  const centerTextStyle = addTextCentering && {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    textAlign: 'center',
  };
  const propsStyle = getStyleForFrameProps(props,);
  if (size2 === void 0 && !__fromCanvasComponent) {
    if (!hasLeftAndRight(propsStyle,)) {
      defaultStyle.width = defaultFrameRect.width;
    }
    if (!hasTopAndBottom(propsStyle,)) {
      defaultStyle.height = defaultFrameRect.height;
    }
  }
  if (unwrappedProps.minWidth !== void 0) {
    defaultStyle.minWidth = unwrappedProps.minWidth;
  }
  if (unwrappedProps.minHeight !== void 0) {
    defaultStyle.minHeight = unwrappedProps.minHeight;
  }
  let constraintsStyle = {};
  if (constraintsEnabled(unwrappedProps,)) {
    if (constraintsRect && !isAutoSized(props,)) {
      constraintsStyle = {
        left: constraintsRect.x,
        top: constraintsRect.y,
        width: constraintsRect.width,
        height: constraintsRect.height,
        right: void 0,
        bottom: void 0,
      };
    }
  }
  Object.assign(defaultStyle, centerTextStyle, _initialStyle, propsStyle, constraintsStyle, style,);
  Object.assign(defaultStyle, {
    overflowX: (_b = defaultStyle.overflowX) != null ? _b : defaultStyle.overflow,
    overflowY: (_c = defaultStyle.overflowY) != null ? _c : defaultStyle.overflow,
    overflow: void 0,
  },);
  Layer.applyWillChange(props, defaultStyle, true,);
  let resultStyle = defaultStyle;
  if (!defaultStyle.transform) {
    resultStyle = { x: 0, y: 0, ...defaultStyle, };
  }
  const onCanvas = RenderTarget.current() === 'CANVAS';
  if (props.positionSticky) {
    if (!onCanvas || inCodeComponent) {
      resultStyle.position = 'sticky';
      resultStyle.willChange = 'transform';
      resultStyle.zIndex = 1;
      resultStyle.top = props.positionStickyTop;
      resultStyle.right = props.positionStickyRight;
      resultStyle.bottom = props.positionStickyBottom;
      resultStyle.left = props.positionStickyLeft;
    }
  } else if (onCanvas && (props.positionFixed || props.positionAbsolute)) {
    resultStyle.position = 'absolute';
  }
  if ('rotate' in resultStyle && resultStyle.rotate === void 0) {
    delete resultStyle.rotate;
  }
  return [resultStyle, constraintsRect,];
}
var filteredProps = /* @__PURE__ */ new Set([
  'width',
  'height',
  'opacity',
  'overflow',
  'radius',
  'background',
  'color',
  'x',
  'y',
  'z',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'scale',
  'scaleX',
  'scaleY',
  'skew',
  'skewX',
  'skewY',
  'originX',
  'originY',
  'originZ',
],);
function getMotionProps(props,) {
  const motionProps = {};
  for (const key7 in props) {
    const isValid = isValidMotionProp(key7,) || isPropValid(key7,);
    if (isValid && !filteredProps.has(key7,)) {
      motionProps[key7] = asRecord(props,)[key7];
    } else if (key7 === 'positionTransition' || key7 === 'layoutTransition') {
      motionProps['layout'] = true;
      if (typeof asRecord(props,)[key7] !== 'boolean' && !props.transition) {
        motionProps['transition'] = asRecord(props,)[key7];
      }
    }
  }
  return motionProps;
}
function hasDataFramerName(props,) {
  return 'data-framer-name' in props;
}
var VisibleFrame = /* @__PURE__ */ forwardRef4(function VisibleFrame2(props, forwardedRef,) {
  var _a;
  const { name, center, border, _border, __portal, } = props;
  const { props: propsWithOverrides, children, } = processOverrideForwarding(props,);
  const motionProps = getMotionProps(propsWithOverrides,);
  const layoutId = useLayoutId2(props,);
  const cursor = getCursorFromEvents(props,);
  const fallbackRef = useRef52(null,);
  const ref = forwardedRef != null ? forwardedRef : fallbackRef;
  const dataProps = {
    'data-framer-component-type': 'Frame',
    'data-framer-cursor': cursor,
    'data-framer-highlight': cursor === 'pointer' ? true : void 0,
    'data-layoutid': layoutId,
    'data-framer-offset-parent-id': asRecord(props,)['data-framer-offset-parent-id'],
  };
  if (!hasDataFramerName(props,) && name) {
    asRecord(dataProps,)['data-framer-name'] = name;
  }
  const [currentStyle, rect,] = useStyleAndRect(propsWithOverrides,);
  const unwrappedProps = unwrapFrameProps(propsWithOverrides,);
  const autoSized = isAutoSized(unwrappedProps,);
  if (center && !(rect && !autoSized && constraintsEnabled(unwrappedProps,))) {
    if (!motionProps.transformTemplate) {
      motionProps.transformTemplate = transformTemplate(center,);
    }
    Object.assign(dataProps, layoutHintDataPropsForCenter(center,),);
  } else if (!motionProps.transformTemplate) {
    motionProps.transformTemplate = void 0;
  }
  useMeasureLayout(props, ref,);
  const backgroundImage = backgroundImageFromProps(props,);
  const inCodeComponent = Boolean(useContext52(ComponentContainerContext,),);
  const parentSize = resolveParentSize(propsWithOverrides, unwrappedProps, rect, inCodeComponent,);
  const wrappedContent = useProvideParentSize(
    /* @__PURE__ */ React31.createElement(
      React31.Fragment,
      null,
      backgroundImage
        ? /* @__PURE__ */ React31.createElement(
          BackgroundImageComponent,
          {
            alt: (_a = props.alt) != null ? _a : '',
            image: backgroundImage,
            containerSize: rect != null ? rect : void 0,
            nodeId: props.id && nodeIdFromString(props.id,),
            layoutId,
          },
        )
        : null,
      children,
      /* @__PURE__ */ React31.createElement(Border, { ..._border, border, layoutId, },),
    ),
    parentSize,
  );
  const MotionComponent = htmlElementAsMotionComponent(props.as,);
  const { size: size2, radius, shadow, } = currentStyle;
  if (size2 !== void 0) {
    delete currentStyle.size;
    if (currentStyle.height === void 0) {
      currentStyle.height = size2;
    }
    if (currentStyle.width === void 0) {
      currentStyle.width = size2;
    }
  }
  if (radius !== void 0) {
    delete currentStyle.radius;
    currentStyle.borderRadius = radius;
  }
  if (shadow !== void 0) {
    delete currentStyle.shadow;
    currentStyle.boxShadow = shadow;
  }
  return /* @__PURE__ */ React31.createElement(
    MotionComponent,
    { ...dataProps, ...motionProps, layoutId, style: currentStyle, ref, },
    wrappedContent,
    __portal,
  );
},);
var FrameWithMotion = /* @__PURE__ */ forwardRef4(
  function FrameWithMotion2(props, ref,) {
    countNodeRender();
    const { visible = true, } = props;
    if (!visible) {
      return null;
    }
    return /* @__PURE__ */ React31.createElement(VisibleFrame, { ...props, ref, },);
  },
);
function resolveParentSize(props, unwrappedProps, rect, inCodeComponent,) {
  if (inCodeComponent) {
    const parentSize = rect ? { width: rect.width, height: rect.height, } : 1;
    return parentSize;
  }
  const { _usesDOMRect, } = props;
  const {
    widthType = 0,
    heightType = 0,
    width,
    height,
  } = unwrappedProps;
  if (rect && !_usesDOMRect) {
    return rect;
  }
  if (widthType === 0 && heightType === 0 && typeof width === 'number' && typeof height === 'number') {
    return { width, height, };
  }
  if (_usesDOMRect || props.positionFixed || props.positionAbsolute) {
    return 2;
  }
  return 0;
}
function isAutoSized({
  width,
  height,
},) {
  return width === 'auto' || width === 'min-content' || height === 'auto' || height === 'min-content';
}
function EmptyState({
  title = '',
  description = 'Click and drag the connector to any frame on the canvas \u2192',
  children,
  size: size2,
  hide,
  insideUserCodeComponent = false,
  position = 'absolute',
},) {
  const { target, } = RenderEnvironment;
  const childCount = React322.Children.count(children,);
  if (insideUserCodeComponent && childCount === 0) {
    return /* @__PURE__ */ React322.createElement(FrameWithMotion, { ...size2, 'data-name': 'placeholder', },);
  }
  if (target !== 'CANVAS') {
    return null;
  }
  if (hide) {
    return null;
  }
  if (childCount !== 0) {
    return null;
  }
  return /* @__PURE__ */ React322.createElement(
    FrameWithMotion,
    {
      key: 'empty-state',
      className: 'framerInternalUI-canvasPlaceholder',
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      style: { position, ...size2, },
    },
    /* @__PURE__ */ React322.createElement(
      'div',
      {
        style: {
          display: 'flex',
          alignItems: 'center',
          lineHeight: '1.4',
          height: '100%',
          width: '100%',
        },
      },
      /* @__PURE__ */ React322.createElement(
        'div',
        {
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column',
            width: '100%',
            // Use a mask to fade out the right edge of the content as it gets cropped.
            WebkitMaskImage: `linear-gradient(90deg, black, black calc(100% - 12px * ${scaleFactor}), transparent)`,
          },
        },
        /* @__PURE__ */ React322.createElement(Title, null, title,),
        /* @__PURE__ */ React322.createElement(Description, null, description,),
      ),
    ),
  );
}
var scaleFactor = 'var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)';
function Title({ children, },) {
  return /* @__PURE__ */ React322.createElement(
    'span',
    {
      style: {
        display: 'flex',
        flexDirection: 'column',
        textAlign: 'center',
        flexGrow: 1,
        flexShrink: 0,
        fontWeight: 600,
        marginBottom: '5px',
      },
    },
    children,
  );
}
function Description({ children, },) {
  return /* @__PURE__ */ React322.createElement(
    'span',
    {
      style: {
        display: 'flex',
        flexDirection: 'column',
        textAlign: 'center',
        flexGrow: 1,
        flexShrink: 0,
        fontWeight: 400,
        maxWidth: '200px',
      },
    },
    children,
  );
}
var TREE_ROOT_ID = '__LAYOUT_TREE_ROOT';
var SharedLayoutContext = /* @__PURE__ */ React33.createContext({
  schedulePromoteTree: () => {
  },
  scheduleProjectionDidUpdate: () => {
  },
  initLead: () => {
  },
},);
var SharedLayoutRoot = class extends Component5 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'shouldAnimate', false,);
    __publicField(this, 'transition',);
    __publicField(this, 'lead',);
    __publicField(this, 'follow',);
    __publicField(this, 'scheduledPromotion', false,);
    __publicField(this, 'scheduledDidUpdate', false,);
    __publicField(this, 'scheduleProjectionDidUpdate', () => {
      this.scheduledDidUpdate = true;
    },);
    __publicField(this, 'schedulePromoteTree', (tree, transition, shouldAnimate,) => {
      this.follow = this.lead;
      this.shouldAnimate = shouldAnimate;
      this.lead = tree;
      this.transition = transition;
      this.scheduledPromotion = true;
    },);
    __publicField(this, 'initLead', (tree, shouldAnimate,) => {
      this.follow = this.lead;
      this.lead = tree;
      if (this.follow && shouldAnimate) {
        this.follow.layoutMaybeMutated = true;
      }
    },);
    __publicField(this, 'sharedLayoutContext', {
      schedulePromoteTree: this.schedulePromoteTree,
      scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate,
      initLead: this.initLead,
    },);
  }
  // Runs after all descendent SharedLayoutTree finish taking snapshots in
  // their getSnapshotBeforeUpdate lifecycle method.
  getSnapshotBeforeUpdate() {
    var _a;
    if (!this.scheduledPromotion || !this.lead || !this.follow) {
      return null;
    }
    const needsReset = !!((_a = this.lead) == null ? void 0 : _a.layoutMaybeMutated) && !this.shouldAnimate;
    this.lead.projectionNodes.forEach((projectionNode,) => {
      var _a2;
      projectionNode == null ? void 0 : projectionNode.promote({
        needsReset,
        transition: this.shouldAnimate ? this.transition : void 0,
        preserveFollowOpacity: projectionNode.options.layoutId === TREE_ROOT_ID && !((_a2 = this.follow) == null ? void 0 : _a2.isExiting),
      },);
    },);
    if (this.shouldAnimate) {
      this.follow.layoutMaybeMutated = true;
    } else {
      this.scheduleProjectionDidUpdate();
    }
    this.lead.layoutMaybeMutated = false;
    this.transition = void 0;
    this.scheduledPromotion = false;
    return null;
  }
  componentDidUpdate() {
    var _a, _b;
    if (!this.lead) {
      return null;
    }
    if (this.scheduledDidUpdate) {
      (_b = (_a = this.lead.rootProjectionNode) == null ? void 0 : _a.root) == null ? void 0 : _b.didUpdate();
      this.scheduledDidUpdate = false;
    }
  }
  render() {
    return /* @__PURE__ */ React33.createElement(SharedLayoutContext.Provider, { value: this.sharedLayoutContext, }, this.props.children,);
  }
};
var rootStyles = {
  width: '100%',
  height: '100%',
  backgroundColor: 'none',
};
function MagicMotionCrossfadeRoot(props,) {
  return /* @__PURE__ */ React34.createElement(motion.div, { layoutId: TREE_ROOT_ID, style: rootStyles, }, props.children,);
}
var _sharedIntersectionObserver;
var _callbacks2;
var SharedIntersectionObserver = class {
  constructor(options,) {
    __privateAdd(this, _sharedIntersectionObserver, void 0,);
    __privateAdd(this, _callbacks2, /* @__PURE__ */ new WeakMap(),);
    if (!document) {
      return;
    }
    __privateSet(this, _sharedIntersectionObserver, new IntersectionObserver(this.resizeObserverCallback.bind(this,), options,),);
  }
  resizeObserverCallback(entries, observer2,) {
    for (const entry of entries) {
      const callbackForElement = __privateGet(this, _callbacks2,).get(entry.target,);
      if (callbackForElement) {
        callbackForElement([entry,], observer2,);
      }
    }
  }
  observeElementWithCallback(element, callback,) {
    if (!__privateGet(this, _sharedIntersectionObserver,)) {
      return;
    }
    __privateGet(this, _sharedIntersectionObserver,).observe(element,);
    __privateGet(this, _callbacks2,).set(element, callback,);
  }
  unobserve(element,) {
    if (!__privateGet(this, _sharedIntersectionObserver,)) {
      return;
    }
    __privateGet(this, _sharedIntersectionObserver,).unobserve(element,);
    __privateGet(this, _callbacks2,).delete(element,);
  }
  get root() {
    var _a;
    return (_a = __privateGet(this, _sharedIntersectionObserver,)) == null ? void 0 : _a.root;
  }
};
_sharedIntersectionObserver = /* @__PURE__ */ new WeakMap();
_callbacks2 = /* @__PURE__ */ new WeakMap();
var SharedIntersectionObserverContext = /* @__PURE__ */ React35.createContext(/* @__PURE__ */ new Map(),);
function useSharedIntersectionObserver(ref, callback, options,) {
  if (typeof IntersectionObserver === 'undefined') {
    return;
  }
  const key7 = useConstant2(() => `${options.rootMargin}`);
  const observers2 = React35.useContext(SharedIntersectionObserverContext,);
  const { enabled, } = options;
  React35.useEffect(() => {
    var _a;
    const element = ref.current;
    if (!enabled || !element) {
      return;
    }
    let observer2 = observers2.get(key7,);
    if (!observer2 || observer2.root !== ((_a = options.root) == null ? void 0 : _a.current)) {
      const { root, ...rest } = options;
      observer2 = new SharedIntersectionObserver({ ...rest, root: root == null ? void 0 : root.current, },);
      observers2.set(key7, observer2,);
    }
    observer2.observeElementWithCallback(element, callback,);
    return () => observer2 == null ? void 0 : observer2.unobserve(element,);
  }, [enabled,],);
}
var thresholds2 = /* @__PURE__ */ new Array(100,).fill(void 0,).map((_, i,) => i * 0.01);
var ViewportContext = /* @__PURE__ */ React35.createContext(null,);
function useAppearEffect(ref, appearCallback, options,) {
  const internalState = React35.useRef({
    isInView: false,
    hasAnimatedOnce: false,
  },);
  const { enabled, animateOnce, threshold, rootMargin = `0px 0px 0px 0px`, } = options;
  const callback = React35.useCallback(
    ([entry,],) => {
      var _a;
      if (!entry) {
        return;
      }
      const { isInView, hasAnimatedOnce, } = internalState.current;
      const isIntersecting = isIntersectingWithThreshold(entry, (_a = threshold == null ? void 0 : threshold.y) != null ? _a : 0,);
      if (isIntersecting && !isInView) {
        if (animateOnce && hasAnimatedOnce) {
          return;
        }
        internalState.current.hasAnimatedOnce = true;
        internalState.current.isInView = true;
        appearCallback(true,);
        return;
      }
      if (!isIntersecting && isInView) {
        internalState.current.isInView = false;
        if (animateOnce) {
          return;
        }
        appearCallback(false,);
        return;
      }
    },
    [animateOnce, threshold == null ? void 0 : threshold.y, appearCallback,],
  );
  useSharedIntersectionObserver(ref, callback, {
    threshold: thresholds2,
    rootMargin,
    enabled: enabled != null ? enabled : true,
  },);
}
function calculatedIntersection(intersectionRect, boundingClientRect,) {
  if (boundingClientRect.height === 0) {
    return 0;
  }
  return intersectionRect.height / Math.min(boundingClientRect.height, safeWindow.innerHeight,);
}
function isIntersectingWithThreshold({ boundingClientRect, intersectionRect, isIntersecting, }, threshold,) {
  if (boundingClientRect.height === 0) {
    return isIntersecting;
  }
  return isIntersecting && calculatedIntersection(intersectionRect, boundingClientRect,) >= threshold;
}
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs(), 1,);
function pointForEvent(event, customTarget = null,) {
  let target;
  if (customTarget instanceof HTMLElement) {
    target = customTarget;
  }
  if (!target && event.target instanceof HTMLElement) {
    target = event.target;
  }
  if (!target) {
    return { x: event.pageX, y: event.pageY, };
  }
  if ('webkitConvertPointFromPageToNode' in safeWindow) {
    let webkitPoint = new safeWindow.WebKitPoint(event.pageX, event.pageY,);
    webkitPoint = safeWindow.webkitConvertPointFromPageToNode(target, webkitPoint,);
    return { x: webkitPoint.x, y: webkitPoint.y, };
  }
  const rect = target.getBoundingClientRect();
  const width = parseFloat(target.style.width,);
  const height = parseFloat(target.style.height,);
  const scale2 = {
    x: width ? width / rect.width : 1,
    y: height ? height / rect.height : 1,
  };
  const point2 = {
    x: scale2.x * (event.pageX - rect.left - target.clientLeft + target.scrollLeft),
    y: scale2.y * (event.pageY - rect.top - target.clientTop + target.scrollTop),
  };
  return point2;
}
var FramerEvent = class {
  /**
   * @internal
   */
  constructor(originalEvent, session,) {
    this.originalEvent = originalEvent;
    this.session = session;
    __publicField(this, 'time', Date.now(),);
    __publicField(this, 'loopTime', MainLoop.time,);
    __publicField(this, 'point',);
    __publicField(this, 'devicePoint',);
    __publicField(this, 'target',);
    __publicField(this, 'delta',);
    const customTarget = session && session.startEvent && session.startEvent.target || originalEvent.target;
    const eventLike = FramerEvent.eventLikeFromOriginalEvent(originalEvent,);
    this.point = pointForEvent(eventLike, customTarget,);
    const deviceTarget = session && session.originElement ? session.originElement : document.body;
    this.devicePoint = pointForEvent(eventLike, deviceTarget,);
    this.target = originalEvent.target || null;
    const lastEvent = session && session.lastEvent;
    if (originalEvent instanceof WheelEvent) {
      this.delta = { x: originalEvent.deltaX, y: originalEvent.deltaY, };
    } else if (lastEvent && this.devicePoint && lastEvent.devicePoint) {
      this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint,);
    } else {
      this.delta = { x: 0, y: 0, };
    }
  }
  static eventLikeFromOriginalEvent(originalEvent,) {
    if ('touches' in originalEvent) {
      let touches = originalEvent.touches;
      if (!touches || !touches.length) {
        if (originalEvent.changedTouches && originalEvent.changedTouches.length) {
          touches = originalEvent.changedTouches;
        }
      }
      const firstTouch = touches[0];
      if (!touches || !firstTouch) {
        return { pageX: 0, pageY: 0, target: null, };
      }
      const pageX = firstTouch.clientX || firstTouch.screenX || firstTouch.pageX;
      const pageY = firstTouch.clientY || firstTouch.screenY || firstTouch.pageY;
      return {
        pageX,
        pageY,
        target: originalEvent.target,
      };
    }
    return originalEvent;
  }
  /**
   * @internal
   */
  velocity(t,) {
    return this.session ? this.session.velocity(t,) : { x: 0, y: 0, };
  }
  /**
   * @internal
   */
  get offset() {
    return this.session ? this.session.offset(this,) : { x: 0, y: 0, };
  }
  /**
   * @internal
   */
  get isLeftMouseClick() {
    if (environment.isTouch()) {
      return void 0;
    }
    if ('button' in this.originalEvent && 'buttons' in this.originalEvent && 'ctrlKey' in this.originalEvent) {
      return (this.originalEvent.button === 0 || this.originalEvent.buttons === 1) && !this.originalEvent.ctrlKey;
    }
    return false;
  }
};
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs(), 1,);
var clamp2 = (value, a, b,) => {
  const min = Math.min(a, b,);
  const max = Math.max(a, b,);
  if (value < min) {
    value = min;
  }
  if (value > max) {
    value = max;
  }
  return value;
};
var DraggingContext = React36.createContext({ dragging: false, },);
function WithDragging(Component15,) {
  const _WithDraggingHOC = class extends React36.Component {
    constructor(props, defaultProps,) {
      super(props, defaultProps,);
      __publicField(this, 'state', {
        isDragging: false,
      },);
      __publicField(this, 'x', Animatable(0,),);
      __publicField(this, 'y', Animatable(0,),);
      __publicField(this, 'onChangePosition', (change, transaction,) => {
        if (change.value === change.oldValue) {
          return;
        }
        if (this.props.onMove) {
          this.props.onMove(this.point, this,);
        }
      },);
      __publicField(this, 'isMoving', false,);
      __publicField(this, 'isAnimating', false,);
      __publicField(this, 'directionLockAxis', null,);
      __publicField(this, 'layerStartPoint',);
      __publicField(this, 'correctedLayerStartPoint',);
      __publicField(this, 'previousPoint',);
      __publicField(this, '_constraints', null,);
      __publicField(this, 'animation',);
      __publicField(this, 'panStart', (event,) => {
        if (!this.props.enabled) {
          return;
        }
        this.isMoving = this.isAnimating;
        this.stopAnimation();
        this.resetdirectionLock();
        this.layerStartPoint = this.point;
        this.correctedLayerStartPoint = this.point;
        if (this._constraints && this.props.bounce) {
          this.correctedLayerStartPoint = this.constrainPosition(
            this.correctedLayerStartPoint,
            this._constraints,
            1 / this.props.overdragScale,
          );
        }
        this.previousPoint = this.correctedLayerStartPoint;
        if (!this.state.isDragging) {
          this.setState({ isDragging: true, },);
        }
        if (this.props.onDragSessionStart) {
          this.props.onDragSessionStart(event, this,);
        }
      },);
      __publicField(this, 'pan', (event,) => {
        const {
          enabled,
          speedX,
          speedY,
          directionLock,
          overdragScale,
          vertical,
          horizontal,
          pixelAlign,
          onDragStart,
          onDragWillMove,
          onDragDidMove,
          onDragSessionMove,
        } = this.props;
        if (!enabled) {
          return;
        }
        let point2 = { ...this.previousPoint, };
        point2.x += event.delta.x * speedX;
        point2.y += event.delta.y * speedY;
        this.previousPoint = { ...point2, };
        if (this._constraints) {
          point2 = this.constrainPosition(point2, this._constraints, overdragScale,);
        }
        if (directionLock) {
          if (this.directionLockAxis === null) {
            const offset = event.offset;
            offset.x = offset.x * speedX;
            offset.y = offset.y * speedY;
            this.updatedirectionLock(offset,);
            return;
          } else {
            if (this.directionLockAxis === 'y') {
              point2.x = this.layerStartPoint.x;
            }
            if (this.directionLockAxis === 'x') {
              point2.y = this.layerStartPoint.y;
            }
          }
        }
        if (!this.state.isDragging) {
          this.setState({ isDragging: true, },);
          this.isMoving = true;
          if (onDragStart) {
            onDragStart(event, this,);
          }
        }
        if (onDragWillMove) {
          onDragWillMove(event, this,);
        }
        if (pixelAlign) {
          point2.x = Math.round(point2.x,);
          point2.y = Math.round(point2.y,);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = 'x';
        } else if (vertical && !horizontal) {
          axis = 'y';
        }
        this.setPoint(point2, axis,);
        if (onDragDidMove) {
          onDragDidMove(event, this,);
        }
        if (onDragSessionMove) {
          onDragSessionMove(event, this,);
        }
      },);
      __publicField(this, 'panEnd', (event,) => {
        if (!this.props.enabled) {
          return;
        }
        this.startAnimation(event,);
        const { onDragSessionEnd, onDragEnd, } = this.props;
        if (this.state.isDragging) {
          if (onDragEnd) {
            onDragEnd(event, this,);
          }
        }
        if (onDragSessionEnd) {
          onDragSessionEnd(event, this,);
        }
        if (this.state.isDragging) {
          this.setState({ isDragging: false, },);
        }
        this.isMoving = this.isAnimating;
      },);
      __publicField(this, 'mouseWheelStart', (event,) => {
        this.correctedLayerStartPoint = this.point;
        this.previousPoint = this.correctedLayerStartPoint;
        this.stopAnimation();
      },);
      __publicField(this, 'mouseWheel', (event,) => {
        const {
          enabled,
          speedX,
          speedY,
          vertical,
          horizontal,
          pixelAlign,
          onDragWillMove,
          onDragDidMove,
          mouseWheel,
        } = this.props;
        if (!mouseWheel || !enabled) {
          return;
        }
        let point2 = { ...this.point, };
        point2.x -= event.delta.x * speedX;
        point2.y -= event.delta.y * speedY;
        if (this._constraints) {
          point2 = this.constrainPosition(point2, this._constraints, 0, false,);
        }
        if (onDragWillMove) {
          onDragWillMove(event, this,);
        }
        if (pixelAlign) {
          point2.x = Math.round(point2.x,);
          point2.y = Math.round(point2.y,);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = 'x';
        } else if (vertical && !horizontal) {
          axis = 'y';
        }
        this.setPoint(point2, axis,);
        if (onDragDidMove) {
          onDragDidMove(event, this,);
        }
      },);
      __publicField(this, 'mouseWheelEnd', (event,) => {
      },);
      __publicField(this, 'onAnimationStep', (axis, value,) => {
        if (axis === 'x' && this.props.horizontal === false) {
          return;
        }
        if (axis === 'y' && this.props.vertical === false) {
          return;
        }
        let delta = 0;
        if (this.constraints) {
          if (this.props.bounce) {
            delta = value - this.getValue(axis,);
          } else {
            const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
            if (axis === 'x') {
              delta = clamp2(value, minX, maxX,) - this.getValue(axis,);
            }
            if (axis === 'y') {
              delta = clamp2(value, minY, maxY,) - this.getValue(axis,);
            }
          }
        } else {
          delta = value - this.getValue(axis,);
        }
        const updatePoint = this.point;
        if (axis === 'x') {
          updatePoint[axis] = updatePoint[axis] + delta;
        }
        if (axis === 'y') {
          updatePoint[axis] = updatePoint[axis] + delta;
        }
        this.setPoint(updatePoint, axis,);
      },);
      __publicField(this, 'onAnimationStop', (axis,) => {
        if (axis === 'x' && this.props.horizontal === false) {
          return;
        }
        if (axis === 'y' && this.props.vertical === false) {
          return;
        }
        if (!this.animation) {
          return;
        }
        if (this.props.pixelAlign) {
          const point2 = this.point;
          point2.x = Math.round(point2.x,);
          point2.y = Math.round(point2.y,);
          this.setPoint(point2, axis,);
        }
        if (this.animation.x.isFinished() && this.animation.y.isFinished()) {
          return this.stopAnimation();
        }
      },);
      __publicField(this, 'stopAnimation', () => {
        this.isAnimating = false;
        this.isMoving = false;
        if (!this.animation) {
          return;
        }
        this.animation.x.cancel();
        this.animation.y.cancel();
        if (this.props.onDragAnimationEnd) {
          this.props.onDragAnimationEnd(this.animation, this,);
        }
        this.animation = null;
      },);
      const x = this.props.left;
      const y = this.props.top;
      if (!x) {
        this.x = Animatable(0,);
      } else if (isAnimatable2(x,)) {
        this.x = x;
      } else {
        this.x = Animatable(x,);
      }
      if (!y) {
        this.y = Animatable(0,);
      } else if (isAnimatable2(y,)) {
        this.y = y;
      } else {
        this.y = Animatable(y,);
      }
      this.x.onUpdate(this.onChangePosition,);
      this.y.onUpdate(this.onChangePosition,);
      const constraints = this.props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    UNSAFE_componentWillReceiveProps(props,) {
      if (this.props.left !== props.left && isFiniteNumber(props.left,)) {
        this.x.set(props.left,);
      }
      if (this.props.top !== props.top && isFiniteNumber(props.top,)) {
        this.y.set(props.top,);
      }
      const constraints = props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    get point() {
      return { x: this.x.get(), y: this.y.get(), };
    }
    setPoint(point2, axis = null,) {
      switch (axis) {
        case 'x':
          this.x.set(point2.x,);
          break;
        case 'y':
          this.y.set(point2.y,);
          break;
        case null:
          this.x.set(point2.x,);
          this.y.set(point2.y,);
          break;
      }
    }
    getValue(axis,) {
      switch (axis) {
        case 'x':
          return this.x.get();
        case 'y':
          return this.y.get();
      }
    }
    get width() {
      const width = this.props.width;
      if (!width) {
        return 100;
      }
      if (isAnimatable2(width,)) {
        return width.get();
      }
      if (typeof width === 'string') {
        return parseFloat(width,);
      }
      return width;
    }
    get height() {
      const height = this.props.height;
      if (!height) {
        return 100;
      }
      if (isAnimatable2(height,)) {
        return height.get();
      }
      if (typeof height === 'string') {
        return parseFloat(height,);
      }
      return height;
    }
    get constraints() {
      return this._constraints;
    }
    set constraints(value,) {
      if (value !== null && typeof value === 'object') {
        this._constraints = {
          x: value.x || 0,
          y: value.y || 0,
          width: value.width || 0,
          height: value.height || 0,
        };
      } else {
        this._constraints = null;
      }
      if (this._constraints) {
        this.updateAnimationConstraints(this._constraints,);
      }
    }
    get constraintsOffset() {
      if (!this.constraints) {
        return { x: 0, y: 0, };
      }
      const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
      const point2 = this.point;
      const constrainedPoint = { x: clamp2(point2.x, minX, maxX,), y: clamp2(point2.y, minY, maxY,), };
      const offset = { x: point2.x - constrainedPoint.x, y: point2.y - constrainedPoint.y, };
      return offset;
    }
    get isBeyondConstraints() {
      const constraintsOffset = this.constraintsOffset;
      if (constraintsOffset.x !== 0) {
        return true;
      }
      if (constraintsOffset.y !== 0) {
        return true;
      }
      return false;
    }
    clampAndScale(value, min, max, scale2, scaleAllowed,) {
      if (!scaleAllowed) {
        return clamp2(value, min, max,);
      }
      if (value < min) {
        value = min + (value - min) * scale2;
      }
      if (value > max) {
        value = max + (value - max) * scale2;
      }
      return value;
    }
    calculateConstraints(bounds,) {
      if (!bounds) {
        return { minX: Infinity, maxX: Infinity, minY: Infinity, maxY: Infinity, };
      }
      if (bounds.width < this.width) {
        bounds.width = this.width;
      }
      if (bounds.height < this.height) {
        bounds.height = this.height;
      }
      const constraints = {
        minX: Rect.minX(bounds,),
        maxX: Rect.maxX(bounds,),
        minY: Rect.minY(bounds,),
        maxY: Rect.maxY(bounds,),
      };
      constraints.maxX -= this.width;
      constraints.maxY -= this.height;
      return constraints;
    }
    constrainPosition(proposedPoint, bounds, scale2, overdrag = this.props.overdrag,) {
      const { maxX, maxY, minX, minY, } = this.calculateConstraints(this._constraints,);
      const point2 = {
        x: this.clampAndScale(proposedPoint.x, minX, maxX, scale2, overdrag,),
        y: this.clampAndScale(proposedPoint.y, minY, maxY, scale2, overdrag,),
      };
      if (this.props.speedX === 0 || this.props.horizontal === false) {
        point2.x = proposedPoint.x;
      }
      if (this.props.speedY === 0 || this.props.vertical === false) {
        point2.y = proposedPoint.y;
      }
      return point2;
    }
    /* private */
    updatedirectionLock(correctedDelta,) {
      if (Math.abs(correctedDelta.y,) > this.props.directionLockThreshold.y) {
        this.directionLockAxis = 'y';
      } else if (Math.abs(correctedDelta.x,) > this.props.directionLockThreshold.x) {
        this.directionLockAxis = 'x';
      }
      if (this.directionLockAxis !== null) {
        if (this.props.onDragDirectionLockStart) {
          this.props.onDragDirectionLockStart(this.directionLockAxis, this,);
        }
      }
    }
    resetdirectionLock() {
      this.directionLockAxis = null;
    }
    // Inertial scroll animation
    setupAnimation() {
      if (this.animation) {
        return;
      }
      this.animation = { x: this.setupAnimationForAxis('x',), y: this.setupAnimationForAxis('y',), };
      this.updateAnimationConstraints(this._constraints,);
    }
    setupAnimationForAxis(axis,) {
      const animator = new InertialScrollAnimator({
        momentum: this.props.momentumOptions,
        bounce: this.props.bounceOptions,
      },);
      const updateCallback = (value,) => {
        this.onAnimationStep(axis, value,);
      };
      const doneCallback = () => {
        this.onAnimationStop(axis,);
      };
      return new MainLoopAnimationDriver(animator, updateCallback, doneCallback,);
    }
    updateAnimationConstraints(constraints,) {
      if (!this.animation) {
        return;
      }
      if (constraints) {
        const { minX, minY, maxX, maxY, } = this.calculateConstraints(constraints,);
        this.animation.x.animator.setLimits(minX, maxX,);
        this.animation.y.animator.setLimits(minY, maxY,);
      } else {
        this.animation.x.animator.setLimits(-Infinity, Infinity,);
        this.animation.y.animator.setLimits(-Infinity, Infinity,);
      }
    }
    startAnimation(event,) {
      const { momentum, bounce, momentumVelocityMultiplier, speedX, speedY, overdrag, onDragAnimationStart, } = this.props;
      if (!(momentum || bounce)) {
        return;
      }
      if (this.isBeyondConstraints === false && momentum === false) {
        return;
      }
      if (this.isBeyondConstraints === false && this.state.isDragging === false) {
        return;
      }
      const { minX, minY, maxX, maxY, } = this.calculateConstraints(this._constraints,);
      const startAnimationX = overdrag === true || this.point.x > minX && this.point.x < maxX;
      const startAnimationY = overdrag === true || this.point.y > minY && this.point.y < maxY;
      if (startAnimationX === startAnimationY && startAnimationY === false) {
        return;
      }
      const velocity = event.velocity(0.1,);
      let velocityX = velocity.x * momentumVelocityMultiplier * speedX;
      let velocityY = velocity.y * momentumVelocityMultiplier * speedY;
      if (this.directionLockAxis === 'x') {
        velocityY = 0;
      }
      if (this.directionLockAxis === 'y') {
        velocityX = 0;
      }
      this.setupAnimation();
      this.isAnimating = true;
      this.isMoving = true;
      if (!this.animation) {
        return;
      }
      this.animation.x.animator.setState({ x: this.point.x, v: velocityX, },);
      if (startAnimationX) {
        this.animation.x.play();
      }
      this.animation.y.animator.setState({ x: this.point.y, v: velocityY, },);
      if (startAnimationY) {
        this.animation.y.play();
      }
      if (onDragAnimationStart) {
        onDragAnimationStart(this.animation, this,);
      }
    }
    wrapHandler(ownHandler, originalHandler,) {
      if (!originalHandler) {
        return ownHandler;
      }
      return (event,) => {
        ownHandler(event,);
        originalHandler(event,);
      };
    }
    render() {
      const { onPanStart, onPan, onPanEnd, onMouseWheelStart, onMouseWheel, onMouseWheelEnd, ...attributes } = this.props;
      const originalProps = { ...attributes, };
      Object.keys(_WithDraggingHOC.draggingDefaultProps,).forEach((key7,) => {
        delete asRecord(originalProps,)[key7];
      },);
      originalProps.onPanStart = this.wrapHandler(this.panStart, onPanStart,);
      originalProps.onPan = this.wrapHandler(this.pan, onPan,);
      originalProps.onPanEnd = this.wrapHandler(this.panEnd, onPanEnd,);
      originalProps.onMouseWheelStart = this.wrapHandler(this.mouseWheelStart, onMouseWheelStart,);
      originalProps.onMouseWheel = this.wrapHandler(this.mouseWheel, onMouseWheel,);
      originalProps.onMouseWheelEnd = this.wrapHandler(this.mouseWheelEnd, onMouseWheelEnd,);
      originalProps.left = this.x;
      originalProps.top = this.y;
      return /* @__PURE__ */ React36.createElement(
        DraggingContext.Provider,
        { value: { dragging: this.state.isDragging, }, },
        /* @__PURE__ */ React36.createElement(Component15, { ...originalProps, },),
      );
    }
  };
  let WithDraggingHOC = _WithDraggingHOC;
  __publicField(WithDraggingHOC, 'draggingDefaultProps', {
    momentum: true,
    momentumOptions: { friction: 2.1, tolerance: 1, },
    momentumVelocityMultiplier: 800,
    speedX: 1,
    speedY: 1,
    bounce: true,
    bounceOptions: { friction: 40, tension: 200, tolerance: 1, },
    directionLock: false,
    directionLockThreshold: { x: 10, y: 10, },
    overdrag: true,
    overdragScale: 0.5,
    pixelAlign: true,
    velocityTimeout: 100,
    velocityScale: 890,
    horizontal: true,
    vertical: true,
    enabled: true,
    constraints: {},
    mouseWheel: false,
  },);
  __publicField(
    WithDraggingHOC,
    'defaultProps',
    Object.assign(
      {},
      Component15.defaultProps,
      _WithDraggingHOC.draggingDefaultProps,
    ),
  );
  const withDragging = WithDraggingHOC;
  (0, import_hoist_non_react_statics.default)(withDragging, Component15,);
  return withDragging;
}
var hoverProps = {
  onMouseEnter: 'mouseenter',
  onMouseLeave: 'mouseleave',
};
var hoverEventKeys = Object.keys(hoverProps,);
var eventHandlerMapping = {
  panstart: ['onPanStart',],
  pan: ['onPan',],
  panend: ['onPanEnd',],
  tapstart: ['onTapStart', 'onMouseDown',],
  tap: ['onTap', 'onClick',],
  tapend: ['onTapEnd', 'onMouseUp',],
  mousewheelstart: ['onMouseWheelStart',],
  mousewheel: ['onMouseWheel',],
  mousewheelend: ['onMouseWheelEnd',],
};
var tapEventKeys = /* @__PURE__ */ new Set(['tapstart', 'tap', 'tapend',],);
function WithEvents(BaseComponent,) {
  var _a;
  const withEvents = (_a = class extends React37.Component {
    constructor() {
      super(...arguments,);
      __publicField(this, 'shouldCancelTap', false,);
      __publicField(this, 'activeEventListeners', /* @__PURE__ */ new Map(),);
      __publicField(this, 'hasFramerEventListener', false,);
      __publicField(this, 'component', React37.createRef(),);
    }
    get element() {
      return this.component.current && this.component.current.element;
    }
    componentDidMount() {
      this.addEventListeners();
    }
    componentDidUpdate(prevProps,) {
      this.addEventListeners(prevProps,);
    }
    componentWillUnmount() {
      this.removeEventListeners();
    }
    addEventListeners(prevProps,) {
      if (this.element && !this.hasFramerEventListener) {
        this.element.addEventListener('FramerEvent', ({ detail, },) => {
          const type = detail.type;
          const framerEvent = detail.event;
          this.handleEvent(type, framerEvent,);
        },);
        hoverEventKeys.forEach((eventName,) => this.addHoverEvent(eventName,));
        this.hasFramerEventListener = true;
      } else if (this.element && prevProps) {
        hoverEventKeys.forEach((eventName,) => this.checkHoverEvent(eventName, prevProps,));
      } else if (!this.element) {
        this.hasFramerEventListener = false;
      }
    }
    removeEventListeners() {
      hoverEventKeys.forEach((eventName,) => this.removeHoverEvent(eventName,));
    }
    addHoverEvent(eventName,) {
      const originalEventListener = this.props[eventName];
      if (this.element && originalEventListener) {
        const eventListener = (e,) => {
          const framerEvent = new FramerEvent(e,);
          originalEventListener(framerEvent,);
        };
        this.activeEventListeners.set(eventName, eventListener,);
        const domEventName = hoverProps[eventName];
        this.element.addEventListener(domEventName, eventListener,);
      }
    }
    removeHoverEvent(eventName,) {
      const eventListener = this.activeEventListeners.get(eventName,);
      if (this.element && eventListener) {
        const domEventName = hoverProps[eventName];
        this.element.removeEventListener(domEventName, eventListener,);
        this.activeEventListeners.delete(eventName,);
      }
    }
    checkHoverEvent(eventName, prevProps,) {
      if (prevProps[eventName] !== this.props[eventName]) {
        this.removeHoverEvent(eventName,);
        this.addHoverEvent(eventName,);
      }
    }
    handleEvent(type, framerEvent,) {
      const eventListenerKeys = eventHandlerMapping[type];
      if (!eventListenerKeys) {
        return;
      }
      eventListenerKeys.forEach((eventKey,) => {
        const eventListener = this.props[eventKey];
        const cancelEvent = this.shouldCancelTap && tapEventKeys.has(eventKey,);
        if (eventListener && !cancelEvent) {
          eventListener(framerEvent,);
        }
      },);
    }
    render() {
      return /* @__PURE__ */ React37.createElement(DraggingContext.Consumer, null, (value,) => {
        this.shouldCancelTap = value.dragging;
        return /* @__PURE__ */ React37.createElement(BaseComponent, { ...this.props, ref: this.component, },);
      },);
    }
  },
    __publicField(_a, 'defaultProps', Object.assign({}, BaseComponent.defaultProps,),),
    _a);
  (0, import_hoist_non_react_statics2.default)(withEvents, BaseComponent,);
  return withEvents;
}
var hasOwnProperty = (obj, prop,) => Object.prototype.hasOwnProperty.call(obj, prop,);
var $private = /* @__PURE__ */ Symbol('private',);
var ObservableObject = /* @__PURE__ */ (() => {
  function ObservableObject2(initial = {}, makeAnimatables = false, observeAnimatables = true,) {
    const unproxiedState = {
      [$private]: {
        makeAnimatables,
        observeAnimatables,
        observers: new Observers(),
        reset() {
          for (const key7 in state) {
            if (hasOwnProperty(state, key7,)) {
              const value = hasOwnProperty(initial, key7,) ? asRecord(initial,)[key7] : void 0;
              if (value !== void 0) {
                state[key7] = value;
              } else {
                delete state[key7];
              }
            }
          }
        },
        transactions: /* @__PURE__ */ new Set(),
      },
    };
    const state = new Proxy(unproxiedState, sharedProxyHandler,);
    Object.assign(state, initial,);
    return state;
  }
  ObservableObject2.resetObject = (target,) => {
    return target[$private].reset();
  };
  ObservableObject2.addObserver = (target, observer2,) => {
    return target[$private].observers.add(observer2,);
  };
  return ObservableObject2;
})();
var ObservableObjectProxyHandler = class {
  constructor() {
    __publicField(this, 'set', (target, key7, value, receiver,) => {
      if (key7 === $private) {
        return false;
      }
      const privateObject = target[$private];
      let animatable;
      let rawValue;
      if (isAnimatable2(value,)) {
        animatable = value;
        rawValue = animatable.get();
      } else {
        rawValue = value;
      }
      if (privateObject.makeAnimatables && typeof value !== 'function' && typeof value !== 'object' && !animatable) {
        animatable = Animatable(value,);
      }
      if (privateObject.observeAnimatables && animatable) {
        const transactions = privateObject.transactions;
        animatable.onUpdate({
          update: (change, transaction,) => {
            if (transaction) {
              transactions.add(transaction,);
            }
            privateObject.observers.notify({ value: receiver, }, transaction,);
          },
          finish: (transaction,) => {
            if (transactions.delete(transaction,)) {
              privateObject.observers.finishTransaction(transaction,);
            }
          },
        },);
      }
      let result = false;
      let changed = true;
      const targetValue = asRecord(target,)[key7];
      if (targetValue !== void 0) {
        if (isAnimatable2(targetValue,)) {
          changed = targetValue.get() !== rawValue;
          targetValue.set(rawValue,);
        } else {
          changed = targetValue !== rawValue;
          asRecord(target,)[key7] = rawValue;
        }
        const rawValueIsObject = rawValue !== null && typeof rawValue === 'object';
        if (Array.isArray(rawValue,) || rawValueIsObject) {
          changed = true;
        }
        result = true;
      } else {
        if (animatable) {
          value = animatable;
        }
        result = Reflect.set(target, key7, value,);
      }
      if (changed) {
        privateObject.observers.notify({ value: receiver, },);
      }
      return result;
    },);
    __publicField(this, 'get', (target, key7, receiver,) => {
      if (key7 === $private) {
        return asRecord(target,)[key7];
      }
      const value = Reflect.get(target, key7, receiver,);
      return typeof value === 'function' ? value.bind(receiver,) : value;
    },);
  }
  deleteProperty(target, key7,) {
    const result = Reflect.deleteProperty(target, key7,);
    target[$private].observers.notify({ value: target, },);
    return result;
  }
  ownKeys(target,) {
    const keys3 = Reflect.ownKeys(target,);
    const privateIndex = keys3.indexOf($private,);
    if (privateIndex !== -1) {
      keys3.splice(privateIndex, 1,);
    }
    return keys3;
  }
  getOwnPropertyDescriptor(target, key7,) {
    if (key7 === $private) {
      return void 0;
    }
    return Reflect.getOwnPropertyDescriptor(target, key7,);
  }
};
var sharedProxyHandler = /* @__PURE__ */ new ObservableObjectProxyHandler();
function collectBlendingFromProps(node, style,) {
  if (!node.blendingMode || node.blendingMode === 'normal') {
    return;
  }
  style.mixBlendMode = node.blendingMode;
}
var key3 = 'opacity';
function withOpacity(target,) {
  return key3 in target;
}
function collectOpacityFromProps(props, style,) {
  if (!withOpacity(props,)) {
    return;
  }
  const opacity = Animatable.getNumber(props.opacity,);
  if (opacity === 1) {
    return;
  }
  style.opacity = opacity;
}
function collectOverflowFromProps(props, style,) {
  if (props.overflow) {
    style.overflow = props.overflow;
  }
}
var key4 = 'radius';
function hasRadius(props,) {
  return key4 in props;
}
function getRadiusValue(value,) {
  let num = Number(value,);
  if (typeof value === 'string' && isNaN(num,)) {
    return value;
  } else if (isAnimatable2(value,)) {
    num = Animatable.getNumber(value,);
  }
  return num ? `${num}px` : '0';
}
function hasRadiusValue(value,) {
  return value && value !== '0';
}
function collectRadiusFromProps(props, style,) {
  if (!hasRadius(props,)) {
    return;
  }
  const { radius, } = props;
  if (typeof radius === 'string' || isAnimatable2(radius,) || isFiniteNumber(radius,)) {
    const radiusValue = getRadiusValue(radius,);
    if (hasRadiusValue(radiusValue,)) {
      style.borderTopLeftRadius =
        style.borderTopRightRadius =
        style.borderBottomRightRadius =
        style.borderBottomLeftRadius =
          radiusValue;
    }
  } else if (radius) {
    const topLeft = getRadiusValue(radius.topLeft,);
    const topRight = getRadiusValue(radius.topRight,);
    const bottomRight = getRadiusValue(radius.bottomRight,);
    const bottomLeft = getRadiusValue(radius.bottomLeft,);
    if (hasRadiusValue(topLeft,) || hasRadiusValue(topRight,) || hasRadiusValue(bottomRight,) || hasRadiusValue(bottomLeft,)) {
      style.borderTopLeftRadius = topLeft;
      style.borderTopRightRadius = topRight;
      style.borderBottomRightRadius = bottomRight;
      style.borderBottomLeftRadius = bottomLeft;
    }
  }
}
function collectTextColorFromProps(props, style,) {
  const { color: color2, } = props;
  if (typeof color2 === 'string') {
    style.color = color2;
  } else if (Color.isColorObject(color2,)) {
    style.color = color2.initialValue || Color.toRgbString(color2,);
  }
}
var shadowKeys = ['color', 'x', 'y', 'blur',];
var Shadow = {
  is: (shadow,) => {
    return shadow && shadowKeys.every((key7,) => key7 in shadow);
  },
};
var boxShadowKeys = ['x', 'y', 'color', 'inset', 'blur', 'spread',];
var BoxShadow = {
  is: (shadow,) => {
    return shadow && boxShadowKeys.every((key7,) => key7 in shadow);
  },
  toCSS: (shadow,) => {
    const inset2 = shadow.inset ? 'inset ' : '';
    return `${inset2}${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.spread}px ${shadow.color}`;
  },
};
function shadowsAsFilter(shadows,) {
  const filters = [];
  if (shadows && shadows.length) {
    const dropShadows = shadows.map((shadowItem,) => {
      return `drop-shadow(${shadowItem.x}px ${shadowItem.y}px ${shadowItem.blur}px ${shadowItem.color})`;
    },);
    filters.push(...dropShadows,);
  }
  return filters;
}
function collectTextShadowsForProps(props, style,) {
  if (!props.shadows || props.shadows.length === 0) {
    return;
  }
  const textShadow = props.shadows.map((shadow,) => {
    return `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.color}`;
  },).join(', ',);
  if (!textShadow) {
    return;
  }
  style.textShadow = textShadow;
}
function collectBoxShadowsForProps(props, style,) {
  if (!props.shadows || props.shadows.length === 0) {
    return;
  }
  const boxShadow = props.shadows.map((shadowItem,) => BoxShadow.toCSS(shadowItem,)).join(', ',);
  if (!boxShadow) {
    return;
  }
  style.boxShadow = boxShadow;
}
function shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strokeWidth, strokeClipId, svgStrokeAttributes,) {
  const definition = [];
  let outsetElement = null;
  let insetElement = null;
  const needsStrokeClip = false;
  const shadows = [];
  const insetShadows = [];
  const boxShadowsCount = boxShadows.length;
  const svgShadowClass = 'svg-shadow';
  const svgShadowProps = RenderTarget.current() === 'CANVAS' ? { className: svgShadowClass, } : {};
  for (const shadow of boxShadows) {
    shadow.inset ? insetShadows.push(shadow,) : shadows.push(shadow,);
  }
  if (shadows.length > 0) {
    shadows.reverse();
    const outsideShadowId = shapeId.add('_shadow_out',);
    const normalizedFrame = Rect.atOrigin(rect,);
    const shadowRects = [normalizedFrame,];
    for (const shadow of shadows) {
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true,);
      if (shadowFrame === null) {
        continue;
      }
      shadowRects.push(shadowFrame,);
    }
    let maxBlur = 0;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = shadows.length; i < il; i++) {
      const shadow = shadows[i];
      if (!shadow) {
        continue;
      }
      const shadowElements = outerShadowElements(shapeId, shadow, i,);
      maxBlur = Math.max(maxBlur, shadow.blur,);
      filterElements.push(shadowElements.filterElements,);
      mergeElements.push(shadowElements.mergeElement,);
    }
    let expandStrokeWidth = strokeWidth;
    if (!isFiniteNumber(expandStrokeWidth,)) {
      expandStrokeWidth = 0;
    }
    let miter = svgStrokeAttributes.strokeMiterlimit;
    if (!isFiniteNumber(miter,)) {
      miter = 4;
    }
    let shadowRect = Rect.merge(...shadowRects,);
    shadowRect = Rect.inflate(shadowRect, (expandStrokeWidth * miter / 2 + maxBlur) * 1.1,);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    definition.push(
      /* @__PURE__ */ React38.createElement(
        'filter',
        {
          key: outsideShadowId.id,
          id: outsideShadowId.id,
          x: `${filterX.toFixed(1,)}%`,
          y: `${filterY.toFixed(1,)}%`,
          width: `${filterWidth.toFixed(1,)}%`,
          height: `${filterHeight.toFixed(1,)}%`,
          filterUnits: 'objectBoundingBox',
          ...svgShadowProps,
        },
        filterElements,
        shadows.length > 1 ? /* @__PURE__ */ React38.createElement('feMerge', null, mergeElements,) : null,
      ),
    );
    outsetElement = /* @__PURE__ */ React38.createElement(
      'g',
      { filter: outsideShadowId.urlLink, ...svgShadowProps, },
      /* @__PURE__ */ React38.createElement(
        'use',
        {
          ...svgStrokeAttributes,
          fill: 'black',
          fillOpacity: fillAlpha <= 0 ? 0 : 1,
          stroke: 'black',
          strokeOpacity: strokeAlpha <= 0 ? 0 : 1,
          strokeWidth: strokeAlpha > 0 ? strokeWidth : 0,
          xlinkHref: shapeId.link,
          clipPath: strokeClipId.urlLink,
        },
      ),
    );
  }
  if (insetShadows.length) {
    insetShadows.reverse();
    const insideShadowId = shapeId.add('_shadow_inside',);
    const normalizedFrame = Rect.atOrigin(rect,);
    const shadowFrames = [normalizedFrame,];
    for (const shadow of insetShadows) {
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true,);
      if (shadowFrame === null) {
        continue;
      }
      shadowFrames.push(shadowFrame,);
    }
    const shadowRect = Rect.merge(...shadowFrames,);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = insetShadows.length; i < il; i++) {
      const shadow = insetShadows[i];
      if (!shadow) {
        continue;
      }
      const shadowElements = innerShadowElements(shapeId, shadow, i,);
      filterElements.push(shadowElements.filterElements,);
      mergeElements.push(shadowElements.mergeElement,);
    }
    definition.push(
      /* @__PURE__ */ React38.createElement(
        'filter',
        {
          key: insideShadowId.id,
          id: insideShadowId.id,
          x: `${filterX.toFixed(1,)}%`,
          y: `${filterY.toFixed(1,)}%`,
          width: `${filterWidth.toFixed(1,)}%`,
          height: `${filterHeight.toFixed(1,)}%`,
          filterUnits: 'objectBoundingBox',
          ...svgShadowProps,
        },
        filterElements,
        insetShadows.length > 1 ? /* @__PURE__ */ React38.createElement('feMerge', null, mergeElements,) : null,
      ),
    );
    let clipPath;
    if (needsStrokeClip) {
      clipPath = strokeClipId.urlLink;
    }
    insetElement = /* @__PURE__ */ React38.createElement(
      'use',
      {
        fill: 'black',
        fillOpacity: '1',
        filter: insideShadowId.urlLink,
        xlinkHref: shapeId.link,
        clipPath,
        ...svgShadowProps,
      },
    );
  }
  return { definition, outsetElement, insetElement, needsStrokeClip, };
}
function outerShadowElements(shapeID, shadow, index,) {
  const shadowKey = shapeID.add('_outer_shadow' + index,);
  const offsetResultId = shadowKey.add('offset',).id;
  const blurResultId = shadowKey.add('blur',).id;
  const matrixResultId = shadowKey.add('matrix',).id;
  const filterElements = /* @__PURE__ */ React38.createElement(
    OuterShadowFilterElements,
    {
      key: shadowKey.id + '-filters',
      shadow,
      blurId: blurResultId,
      offsetId: offsetResultId,
      matrixId: matrixResultId,
    },
  );
  const mergeElement = /* @__PURE__ */ React38.createElement('feMergeNode', { key: shadowKey.id + '-merge', in: matrixResultId, },);
  return { filterElements, mergeElement, };
}
var OuterShadowFilterElements = (props,) => {
  const { shadow, blurId, offsetId, matrixId, } = props;
  const color2 = shadow.color;
  const rgb = ConvertColor.toRgb(color2,);
  const r = roundedNumberString(rgb.r / 255, 3,);
  const g = roundedNumberString(rgb.g / 255, 3,);
  const b = roundedNumberString(rgb.b / 255, 3,);
  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b}  0 0 0 ${rgb.a} 0`;
  return /* @__PURE__ */ React38.createElement(
    React38.Fragment,
    null,
    /* @__PURE__ */ React38.createElement('feOffset', { dx: shadow.x, dy: shadow.y, in: 'SourceAlpha', result: offsetId, },),
    /* @__PURE__ */ React38.createElement('feGaussianBlur', { stdDeviation: shadow.blur / 2, in: offsetId, result: blurId, },),
    /* @__PURE__ */ React38.createElement(
      'feColorMatrix',
      {
        colorInterpolationFilters: 'sRGB',
        values: matrixValues,
        type: 'matrix',
        in: blurId,
        result: matrixId,
      },
    ),
  );
};
function innerShadowElements(shapeID, shadow, index,) {
  const shadowKey = shapeID.add('_inside_shadow' + index,);
  const blurId = shadowKey.add('blur',).id;
  const offsetId = shadowKey.add('offset',).id;
  const compositeId = shadowKey.add('composite',).id;
  const matrixId = shadowKey.add('matrix',).id;
  const filterElements = /* @__PURE__ */ React38.createElement(
    InnerShadowFilterElements,
    {
      key: shadowKey.id + '-filters',
      shadow,
      blurId,
      offsetId,
      compositeId,
      matrixId,
    },
  );
  const mergeElement = /* @__PURE__ */ React38.createElement('feMergeNode', { key: shadowKey.id + '-merge', in: matrixId, },);
  return { filterElements, mergeElement, };
}
var InnerShadowFilterElements = (props,) => {
  const { shadow, blurId, offsetId, compositeId, matrixId, } = props;
  const color2 = shadow.color;
  const rgb = ConvertColor.toRgb(color2,);
  const r = rgb.r / 255;
  const g = rgb.g / 255;
  const b = rgb.b / 255;
  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b}  0 0 0 ${rgb.a} 0`;
  return /* @__PURE__ */ React38.createElement(
    React38.Fragment,
    null,
    /* @__PURE__ */ React38.createElement('feGaussianBlur', { stdDeviation: shadow.blur / 2, in: 'SourceAlpha', result: blurId, },),
    /* @__PURE__ */ React38.createElement('feOffset', { dx: shadow.x, dy: shadow.y, in: blurId, result: offsetId, },),
    /* @__PURE__ */ React38.createElement('feComposite', {
      in: offsetId,
      in2: 'SourceAlpha',
      operator: 'arithmetic',
      k2: '-1',
      k3: '1',
      result: compositeId,
    },),
    /* @__PURE__ */ React38.createElement(
      'feColorMatrix',
      {
        colorInterpolationFilters: 'sRGB',
        values: matrixValues,
        type: 'matrix',
        in: compositeId,
        result: matrixId,
      },
    ),
  );
};
function calcMaxRealisticShadowBlur(distance2, focus,) {
  return interpolate([0, 0.5, 1,], [distance2 * 5, distance2, 0,],)(focus,);
}
var maxSpread = 5;
function calcRealisticShadowSpread(diffusion,) {
  return mix(-maxSpread, 0, diffusion,);
}
function localShadowFrame(shadow, frame2, isSVG2 = false,) {
  if (!isSVG2 && asRecord(shadow,)['inset']) {
    return null;
  }
  let growth = shadow.blur;
  let minX;
  let maxX;
  let minY;
  let maxY;
  if (isSVG2) {
    minX = -Math.abs(shadow.x,) - growth;
    maxX = Math.abs(shadow.x,) + frame2.width + growth;
    minY = -Math.abs(shadow.y,) - growth;
    maxY = Math.abs(shadow.y,) + frame2.height + growth;
  } else if (BoxShadow.is(shadow,) && shadow.type === 'realistic') {
    growth = calcMaxRealisticShadowBlur(distance(shadow.x, shadow.y,), shadow.focus,) + calcRealisticShadowSpread(shadow.diffusion,);
    if (shadow.x >= 0) {
      minX = 0 - growth;
      maxX = shadow.x + frame2.width + growth;
    } else {
      minX = shadow.x - growth;
      maxX = frame2.width + growth;
    }
    if (shadow.y >= 0) {
      minY = 0 - growth;
      maxY = shadow.y + frame2.height + growth;
    } else {
      minY = shadow.y - growth;
      maxY = frame2.height + growth;
    }
  } else {
    growth += shadow.spread;
    minX = shadow.x - growth;
    maxX = shadow.x + frame2.width + growth;
    minY = shadow.y - growth;
    maxY = shadow.y + frame2.height + growth;
  }
  if (maxX <= minX || maxY <= minY) {
    return null;
  }
  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, };
}
function collectLayerFilters(props, style,) {
  const filters = [];
  if (isFiniteNumber(props.brightness,)) {
    filters.push(`brightness(${props.brightness / 100})`,);
  }
  if (isFiniteNumber(props.contrast,)) {
    filters.push(`contrast(${props.contrast / 100})`,);
  }
  if (isFiniteNumber(props.grayscale,)) {
    filters.push(`grayscale(${props.grayscale / 100})`,);
  }
  if (isFiniteNumber(props.hueRotate,)) {
    filters.push(`hue-rotate(${props.hueRotate}deg)`,);
  }
  if (isFiniteNumber(props.invert,)) {
    filters.push(`invert(${props.invert / 100})`,);
  }
  if (isFiniteNumber(props.saturate,)) {
    filters.push(`saturate(${props.saturate / 100})`,);
  }
  if (isFiniteNumber(props.sepia,)) {
    filters.push(`sepia(${props.sepia / 100})`,);
  }
  if (isFiniteNumber(props.blur,)) {
    filters.push(`blur(${props.blur}px)`,);
  }
  if (props.dropShadows) {
    filters.push(...shadowsAsFilter(props.dropShadows,),);
  }
  if (filters.length === 0) {
    return;
  }
  style.filter = style.WebkitFilter = filters.join(' ',);
}
function collectBackgroundFilters(props, style,) {
  if (isFiniteNumber(props.backgroundBlur,)) {
    style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;
  }
}
function collectFiltersFromProps(props, style,) {
  collectBackgroundFilters(props, style,);
  collectLayerFilters(props, style,);
}
function collectVisualStyleFromProps(props, style, isTextNode = false,) {
  collectBackgroundFromProps(props, style,);
  collectRadiusFromProps(props, style,);
  collectFiltersFromProps(props, style,);
  collectBlendingFromProps(props, style,);
  collectOverflowFromProps(props, style,);
  collectOpacityFromProps(props, style,);
  collectTextColorFromProps(props, style,);
  if (isTextNode) {
    collectTextShadowsForProps(props, style,);
  } else {
    collectBoxShadowsForProps(props, style,);
  }
}
var { getNumber, } = Animatable;
var transformDefaults = {
  z: 0,
  rotation: 0,
  rotationX: 0,
  rotationY: 0,
  rotationZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0,
};
function getRotation(rotation, rotate,) {
  if (typeof rotate === 'string') {
    rotate = parseFloat(rotate,);
  }
  return isFiniteNumber(rotate,) ? rotate : getNumber(rotation,);
}
function collectTransformFromProps(props, rect, style,) {
  const motionStyle = style;
  const x = typeof rect.x === 'number' ? `${rect.x}px` : rect.x;
  const y = typeof rect.y === 'number' ? `${rect.y}px` : rect.y;
  const z = getNumber(props.z,);
  const scaleZ = getNumber(props.scaleZ,);
  const originZ = getNumber(props.originZ,);
  const rotationZ = getRotation(props.rotationZ, resolveMotionValue(motionStyle.rotateZ,),);
  const rotationX = getRotation(props.rotationX, resolveMotionValue(motionStyle.rotateX,),);
  const rotationY = getRotation(props.rotationY, resolveMotionValue(motionStyle.rotateY,),);
  const scale2 = getNumber(props.scale,);
  const scaleX = getNumber(props.scaleX,);
  const scaleY = getNumber(props.scaleY,);
  const skew = getNumber(props.skew,);
  const skewX = getNumber(props.skewX,);
  const skewY = getNumber(props.skewY,);
  const rotation = getRotation(props.rotation, resolveMotionValue(motionStyle.rotate,),);
  const force3d = RenderEnvironment.target === 'EXPORT';
  if (force3d || z !== 0 || scaleZ !== 1 || originZ !== 0 || rotationZ !== 0 || rotationX !== 0 || rotationY !== 0) {
    style.transform = `
            ${`translate3d(${x}, ${y}, ${z}px)`}
            scale3d(${scaleX * scale2}, ${scaleY * scale2}, ${scaleZ})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            translateZ(${originZ}px)
            rotateX(${rotationX}deg)
            rotateY(${rotationY}deg)
            rotateZ(${(rotation + rotationZ).toFixed(4,)}deg)
            translateZ(${-originZ}px)`;
  } else {
    style.transform = `
            ${`translate(${x}, ${y})`}
            scale(${scaleX * scale2}, ${scaleY * scale2})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            rotate(${rotation.toFixed(4,)}deg)`;
  }
  const transformOrigin = `${getNumber(props.originX,) * 100}% ${getNumber(props.originY,) * 100}%`;
  style.transformOrigin = transformOrigin;
  style.WebkitTransformOrigin = transformOrigin;
}
function cssBackgroundSize(size2,) {
  switch (size2) {
    case 'fit':
      return 'contain';
    case 'stretch':
      return '100% 100%';
    default:
      return 'cover';
  }
}
function collectBackgroundImageFromProps(props, style,) {
  const image = backgroundImageFromProps(props,);
  if (image) {
    style.backgroundImage = `url("${image.src}")`;
    style.backgroundSize = cssBackgroundSize(image.fit,);
    style.backgroundRepeat = 'no-repeat';
    style.backgroundPosition = 'center';
  }
}
function toPixelString(value,) {
  return isFiniteNumber(value,) ? `${value}px` : value;
}
function applyLayoutProp(style, props, key7,) {
  if (props[key7] !== void 0) {
    const value = Animatable.get(props[key7], void 0,);
    asRecord(style,)[key7] = toPixelString(value,);
  }
}
var DeprecatedFrame = /* @__PURE__ */ (() => {
  const _DeprecatedFrameInner = class extends Layer {
    constructor() {
      super(...arguments,);
      __publicField(this, 'element', null,);
      __publicField(this, 'imageDidChange', false,);
      __publicField(this, 'state', {
        size: null,
      },);
      __publicField(this, 'updateStyle', () => {
        if (!this.element) {
          return;
        }
        Object.assign(this.element.style, this.getStyle(),);
      },);
      __publicField(this, 'setElement', (element,) => {
        this.element = element;
        this.setLayerElement(element,);
      },);
      __publicField(this, 'propsObserver',);
      __publicField(this, 'propsObserverCancel',);
      __publicField(this, 'sizeObserver',);
      __publicField(this, 'sizeObserverCancel',);
      __publicField(this, 'onPropsChange', (props,) => {
        const rect = _DeprecatedFrameInner.rect(Animatable.objectToValues(props.value,),);
        if (this.state.size && isAnimatable2(this.state.size.width,) && isAnimatable2(props.value.width,)) {
          this.state.size.width.set(rect.width,);
        }
        if (this.state.size && isAnimatable2(this.state.size.height,) && isAnimatable2(props.value.height,)) {
          this.state.size.height.set(rect.height,);
        }
        this.updateStyle();
      },);
      __publicField(this, 'onSizeChange', () => {
        this.updateStyle();
      },);
    }
    static rect(props,) {
      const constraintValues = ConstraintValues.fromProperties(props,);
      const parentSizeInfo = props.parentSize
        ? {
          sizing: props.parentSize,
          positioning: props.parentSize,
          viewport: null,
        }
        : null;
      return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, true,);
    }
    get rect() {
      return _DeprecatedFrameInner.rect(this.props,);
    }
    static getDerivedStateFromProps(nextProps, prevState,) {
      const size2 = _DeprecatedFrameInner.updatedSize(nextProps, prevState,);
      const { target, } = RenderEnvironment;
      const nextBackgroundImageSrc = nextProps.background && BackgroundImage.isImageObject(nextProps.background,)
        ? nextProps.background.src
        : null;
      if (nextBackgroundImageSrc) {
        return {
          size: size2,
        };
      }
      if (prevState.size) {
        if (target === 'PREVIEW') {
          return null;
        }
        if (prevState.size.width === size2.width && prevState.size.height === size2.height) {
          return null;
        }
      }
      return {
        size: size2,
      };
    }
    static updatedSize(props, state,) {
      const rect = _DeprecatedFrameInner.rect(props,);
      let size2 = state.size;
      const newSize = { width: rect.width, height: rect.height, };
      const { target, } = RenderEnvironment;
      if (!size2) {
        if (target === 'PREVIEW') {
          size2 = ObservableObject(newSize, true,);
        } else {
          size2 = newSize;
        }
      } else {
        if (isAnimatable2(size2.width,) && isAnimatable2(size2.height,)) {
          size2.width.set(newSize.width,);
          size2.height.set(newSize.height,);
        } else {
          size2 = newSize;
        }
      }
      return size2;
    }
    getStyle() {
      const rect = this.rect;
      const style = {
        display: 'block',
        position: 'absolute',
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        pointerEvents: void 0,
        // TODO: this should be "none" for non-event consuming instances, for performance.
        userSelect: 'none',
      };
      let left = Animatable.get(this.props.left, void 0,);
      let top = Animatable.get(this.props.top, void 0,);
      Object.assign(style, this.props._initialStyle,);
      const hasParentSize = this.context.parentSize !== 1;
      const perspective = Animatable.get(this.props.perspective, void 0,);
      style.perspective = perspective;
      style.WebkitPerspective = perspective;
      let backfaceVisibility = void 0;
      const backfaceVisible = Animatable.get(this.props.backfaceVisible, void 0,);
      if (backfaceVisible === true) {
        backfaceVisibility = 'visible';
      } else if (backfaceVisible === false) {
        backfaceVisibility = 'hidden';
      }
      style.backfaceVisibility = backfaceVisibility;
      style.WebkitBackfaceVisibility = backfaceVisibility;
      const preserve3d = Animatable.get(this.props.preserve3d, void 0,);
      if (preserve3d === true) {
        style.transformStyle = 'preserve-3d';
      } else if (preserve3d === false) {
        style.transformStyle = 'flat';
      }
      if (!hasParentSize) {
        applyLayoutProp(style, this.props, 'right',);
        applyLayoutProp(style, this.props, 'bottom',);
        const width = Animatable.get(this.props.width, void 0,);
        const stringWidth = toPixelString(width,);
        const height = Animatable.get(this.props.height, void 0,);
        const stringHeight = toPixelString(height,);
        if (typeof left === 'string' && left.endsWith('%',) && this.props.right === null) {
          left = `calc(${left} - calc(${stringWidth}} / 2))`;
          style.width = stringWidth;
        }
        if (typeof top === 'string' && top.endsWith('%',) && this.props.bottom === null) {
          top = `calc(${top} - calc(${stringHeight} / 2))`;
          style.height = stringHeight;
        }
        if (top !== void 0 && style.bottom !== void 0) {
          style.height = void 0;
          top = toPixelString(Animatable.get(this.props.top, void 0,),);
        } else {
          style.height = stringHeight;
        }
        if (left !== void 0 && style.right !== void 0) {
          style.width = void 0;
          left = toPixelString(Animatable.get(this.props.left, void 0,),);
        } else {
          style.width = stringWidth;
        }
      }
      const transformRect = { ...rect, };
      if (typeof left !== 'undefined') {
        transformRect.x = left;
      }
      if (typeof top !== 'undefined') {
        transformRect.y = top;
      }
      collectTransformFromProps(this.props, transformRect, style,);
      collectVisualStyleFromProps(this.props, style,);
      collectBackgroundImageFromProps(this.props, style,);
      Layer.applyWillChange(this.props, style, false,);
      if (this.props.style) {
        Object.assign(style, this.props.style,);
      }
      return style;
    }
    componentDidMount() {
      const { target, } = RenderEnvironment;
      if (target === 'PREVIEW') {
        this.propsObserver = ObservableObject(this.props, true,);
        this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange,);
        if (this.props.parentSize && isAnimatable2(this.props.parentSize.width,) && isAnimatable2(this.props.parentSize.height,)) {
          this.sizeObserver = ObservableObject(this.props.parentSize, true,);
          this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange,);
        }
      }
    }
    componentDidUpdate() {
      const { target, } = RenderEnvironment;
      this.propsObserverCancel && this.propsObserverCancel();
      this.sizeObserverCancel && this.sizeObserverCancel();
      if (target === 'PREVIEW') {
        this.propsObserver = ObservableObject(this.props, true,);
        this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange,);
        if (this.props.parentSize && isAnimatable2(this.props.parentSize.width,) && isAnimatable2(this.props.parentSize.height,)) {
          this.sizeObserver = ObservableObject(this.props.parentSize, true,);
          this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange,);
        }
      }
    }
    componentWillUnmount() {
      this.propsObserverCancel && this.propsObserverCancel();
      this.propsObserverCancel = void 0;
      this.sizeObserverCancel && this.sizeObserverCancel();
      this.sizeObserverCancel = void 0;
    }
    render() {
      countNodeRender();
      const { visible, id: id3, className, } = this.props;
      if (!visible) {
        return null;
      }
      const style = this.getStyle();
      const rect = this.rect;
      const parentSize = { width: rect.width, height: rect.height, };
      return /* @__PURE__ */ React39.createElement(
        'div',
        { id: id3, style, ref: this.setElement, className, },
        /* @__PURE__ */ React39.createElement(ProvideParentSize, { parentSize, }, this.layoutChildren(),),
        /* @__PURE__ */ React39.createElement(Border, { ...this.props, },),
      );
    }
    layoutChildren() {
      let _forwardedOverrides = this.props._forwardedOverrides;
      const extractions = this.props._overrideForwardingDescription;
      if (extractions) {
        let added = false;
        _forwardedOverrides = {};
        for (const [key7, value,] of Object.entries(extractions,)) {
          added = true;
          _forwardedOverrides[key7] = asRecord(this.props,)[value];
        }
        if (!added) {
          _forwardedOverrides = void 0;
        }
      }
      let children = React39.Children.map(this.props.children, (child,) => {
        if (isConstraintSupportingChild(child,)) {
          return React39.cloneElement(child, {
            parentSize: this.state.size,
            _forwardedOverrides,
          },);
        } else if (_forwardedOverrides && child) {
          return React39.cloneElement(child, { _forwardedOverrides, },);
        } else {
          return child;
        }
      },);
      if (children && children.length === 1 && typeof children[0] === 'string') {
        children = [/* @__PURE__ */ React39.createElement(Center, { key: '0', }, children,),];
      }
      return children;
    }
  };
  let DeprecatedFrameInner = _DeprecatedFrameInner;
  __publicField(DeprecatedFrameInner, 'supportsConstraints', true,);
  __publicField(DeprecatedFrameInner, 'defaultFrameSpecificProps', {
    ...constraintDefaults,
    ...transformDefaults,
    opacity: 1,
    background: Color('rgba(0, 170, 255, 0.3)',),
    visible: true,
    borderWidth: 0,
    borderColor: '#222',
    borderStyle: 'solid',
  },);
  __publicField(DeprecatedFrameInner, 'defaultProps', {
    ...Layer.defaultProps,
    ..._DeprecatedFrameInner.defaultFrameSpecificProps,
  },);
  DeprecatedFrameInner.contextType = ConstraintsContext;
  return DeprecatedFrameInner;
})();
function Center(props,) {
  const style = Object.assign(
    {},
    {
      height: '100%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: 'Helvetica',
    },
    props.style || {},
  );
  return /* @__PURE__ */ React39.createElement('div', { style, }, props.children,);
}
var frameWithMotionPropsFields = [
  '_border',
  '_constraints',
  'animate',
  'initial',
  'variants',
  'transition',
  'inherit',
  'center',
  'initial',
  'transformTemplate',
  'animate',
  'variants',
  'transition',
  'onUpdate',
  'onAnimationComplete',
  'onPanSessionStart',
  'onTapCancel',
  'whileTap',
  'whileHover',
  'onHoverStart',
  'onHoverEnd',
  'drag',
  'dragDirectionLock',
  'dragPropagation',
  'dragConstraints',
  'dragElastic',
  'dragMomentum',
  'dragTransition',
  'onDragStart',
  'onDragEnd',
  'onDrag',
  'onDirectionLock',
  'onDragTransitionEnd',
  'x',
  'y',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'position',
  'border',
  'borderRadius',
  'shadow',
  'size',
];
var deprecatedFramePropsFields = [
  'autoSize',
  'aspectRatio',
  'borderWidth',
  'borderStyle',
  'borderColor',
  'centerX',
  'centerY',
];
function isDeprecatedFrameProps(props,) {
  let field;
  for (const propKey in props) {
    if (isAnimatable2(props[propKey],)) {
      return true;
    }
  }
  for (field of frameWithMotionPropsFields) {
    if (props.hasOwnProperty(field,)) {
      return false;
    }
  }
  for (field of deprecatedFramePropsFields) {
    if (props.hasOwnProperty(field,)) {
      return true;
    }
  }
  return false;
}
var DeprecatedFrameWithEvents = /* @__PURE__ */ WithEvents(DeprecatedFrame,);
var Frame = /* @__PURE__ */ (() => {
  const FrameInner = forwardRef22(function FrameInner2(props, ref,) {
    const parentSize = useParentSize();
    if (isDeprecatedFrameProps(props,)) {
      const currentParentSize = props.parentSize || deprecatedParentSize(parentSize,);
      return /* @__PURE__ */ React40.createElement(DeprecatedFrameWithEvents, { ...props, parentSize: currentParentSize, },);
    }
    return /* @__PURE__ */ React40.createElement(FrameWithMotion, { ...props, ref, },);
  },);
  FrameInner['displayName'] = 'Frame';
  return FrameInner;
})();
var LayoutTree = class extends Component6 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'layoutMaybeMutated',);
    __publicField(this, 'projectionNodes', /* @__PURE__ */ new Map(),);
    __publicField(this, 'rootProjectionNode',);
    __publicField(this, 'isExiting',);
    __publicField(this, 'shouldPreserveFollowOpacity', (child,) => {
      return child.options.layoutId === TREE_ROOT_ID && !this.props.isExiting;
    },);
    __publicField(this, 'switchLayoutGroupContext', {
      register: (child,) => this.addChild(child,),
      deregister: (child,) => this.removeChild(child,),
      // Configs to use for the initial promotion on mount in Motion
      transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0,
      shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity,
    },);
  }
  componentDidMount() {
    if (this.props.isLead) {
      this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout,);
    }
  }
  shouldComponentUpdate(nextProps,) {
    const { isLead, isExiting, isOverlayed, animatesLayout, transition, sharedLayoutContext, } = nextProps;
    this.isExiting = isExiting;
    if (isLead === void 0) {
      return true;
    }
    const hasBecomeLead = !this.props.isLead && !!isLead;
    const hasExitBeenCancelled = this.props.isExiting && !isExiting;
    const shouldPromote = hasBecomeLead || hasExitBeenCancelled;
    const shouldDemote = !!this.props.isLead && !isLead;
    const overlayChanged = this.props.isOverlayed !== isOverlayed;
    if (shouldPromote || shouldDemote) {
      this.projectionNodes.forEach((projection,) => projection == null ? void 0 : projection.willUpdate());
    }
    if (shouldPromote) {
      sharedLayoutContext.schedulePromoteTree(this, transition, !!animatesLayout,);
    } else if (overlayChanged) {
      sharedLayoutContext.scheduleProjectionDidUpdate();
    }
    return !!shouldPromote && !!animatesLayout;
  }
  addChild(child,) {
    const layoutId = child.options.layoutId;
    if (layoutId) {
      this.projectionNodes.set(layoutId, child,);
      this.setRootChild(child,);
    }
  }
  /**
   * As children are added, make sure that `this.rootProjectionNode` is always the
   * child with the smallest depth.
   */
  setRootChild(child,) {
    if (!this.rootProjectionNode) {
      return this.rootProjectionNode = child;
    }
    this.rootProjectionNode = this.rootProjectionNode.depth < child.depth ? this.rootProjectionNode : child;
  }
  removeChild(child,) {
    const layoutId = child.options.layoutId;
    if (layoutId) {
      this.projectionNodes.delete(layoutId,);
    }
  }
  render() {
    return /* @__PURE__ */ React41.createElement(
      SwitchLayoutGroupContext.Provider,
      { value: this.switchLayoutGroupContext, },
      this.props.children,
    );
  }
};
var SharedLayoutTree = (props,) => {
  const sharedLayoutContext = React41.useContext(SharedLayoutContext,);
  return /* @__PURE__ */ React41.createElement(LayoutTree, { ...props, sharedLayoutContext, },);
};
var NavigationContainerContext = React422.createContext(true,);
function useIsInCurrentNavigationTarget() {
  const isInCurrentNavigationTarget = useContext62(NavigationContainerContext,);
  return isInCurrentNavigationTarget;
}
function newMap() {
  return /* @__PURE__ */ new Map();
}
function useMap() {
  return useConstant2(newMap,);
}
var NavigationTargetContext = /* @__PURE__ */ createContext9({
  register: () => {
  },
  deregister: () => {
  },
},);
var NavigationTargetWrapper = ({ isCurrent, isOverlayed, children, },) => {
  const callbacks2 = useMap();
  const register = useCallback42(
    (fn,) => {
      if (callbacks2.has(fn,)) {
        console.warn('NavigationTargetWrapper: already registered',);
        return;
      }
      callbacks2.set(fn, void 0,);
    },
    [
      callbacks2,
      /* constant, so should never change */
    ],
  );
  const deregister = useCallback42(
    (fn,) => {
      const cleanup = callbacks2.get(fn,);
      cleanup == null ? void 0 : cleanup();
      callbacks2.delete(fn,);
    },
    [
      callbacks2,
      /* constant, so should never change */
    ],
  );
  const value = useRef62({ register, deregister, },).current;
  useEffect52(() => {
    callbacks2.forEach((_, cb,) => {
      const newCleanup = cb(isCurrent, isOverlayed,);
      callbacks2.set(cb, isFunction(newCleanup,) ? newCleanup : void 0,);
    },);
    return () => {
      callbacks2.forEach((cleanup, cb,) => {
        if (!cleanup) {
          return;
        }
        cleanup();
        callbacks2.set(cb, void 0,);
      },);
    };
  }, [
    isCurrent,
    isOverlayed,
    callbacks2,
    /* constant, so should never change */
  ],);
  return /* @__PURE__ */ React43.createElement(NavigationTargetContext.Provider, { value, }, children,);
};
function useOnCurrentTargetChange(callback, deps = [],) {
  const { register, deregister, } = useContext72(NavigationTargetContext,);
  useEffect52(() => {
    if (!callback) {
      return;
    }
    register(callback,);
    return () => deregister(callback,);
  }, [register, deregister, ...deps,],);
}
var NavigationContainer = /* @__PURE__ */ React44.memo(function NavigationContainer2({
  isLayeredContainer,
  isCurrent,
  isPrevious,
  isOverlayed = false,
  visible,
  transitionProps,
  children,
  backdropColor,
  onTapBackdrop,
  backfaceVisible,
  exitBackfaceVisible,
  animation,
  exitAnimation,
  instant,
  initialProps,
  exitProps,
  position = { top: 0, right: 0, bottom: 0, left: 0, },
  withMagicMotion,
  index,
  areMagicMotionLayersPresent,
  id: id3,
  isInitial,
},) {
  const animate3 = useAnimation();
  const presence = useContext82(PresenceContext,);
  const { persistLayoutIdCache, } = useContext82(LayoutIdContext,);
  const previousState = useRef72({
    wasCurrent: void 0,
    wasPrevious: false,
    wasBeingRemoved: false,
    wasReset: true,
    origins: getOriginProps({}, initialProps, transitionProps,),
  },);
  const viewportRef = useRef72(null,);
  const isBeingRemoved = presence !== null && !presence.isPresent;
  if (isCurrent && previousState.current.wasCurrent === void 0) {
    persistLayoutIdCache();
  }
  useEffect62(() => {
    if (isLayeredContainer || !animate3) {
      return;
    }
    if (isBeingRemoved) {
      previousState.current = {
        ...previousState.current,
        wasBeingRemoved: isBeingRemoved,
      };
      return;
    }
    const { wasPrevious, wasCurrent, } = previousState.current;
    const shouldAnimateIn = isCurrent && !wasCurrent || // If the screen was being removed as a result of a "go back" transition, but that removal is interrupted,
      // resulting in this screen being restored to the current screen, we need to trigger an animation.
      !isBeingRemoved && previousState.current.wasBeingRemoved && isCurrent;
    const shouldAnimateOut = isPrevious && !wasPrevious;
    const origins = getOriginProps(previousState.current.origins, initialProps, transitionProps,);
    let wasReset = previousState.current.wasReset;
    if (shouldAnimateIn || shouldAnimateOut) {
      animate3.stop();
      animate3.start({
        zIndex: index,
        ...origins,
        ...transitionProps,
      },);
      wasReset = false;
    } else if (wasReset === false) {
      animate3.stop();
      animate3.set({ zIndex: index, ...allAnimatableProperties, opacity: 0, },);
      wasReset = true;
    }
    previousState.current = {
      wasCurrent: !!isCurrent,
      wasPrevious: !!isPrevious,
      wasBeingRemoved: false,
      wasReset,
      origins,
    };
  }, [isCurrent, isPrevious, isBeingRemoved,],);
  const transition = instant ? { type: false, } : 'velocity' in animation ? { ...animation, velocity: 0, } : animation;
  const exitTransition = instant ? { type: false, } : exitAnimation || animation;
  const layout2 = { ...position, };
  if (layout2.left === void 0 || layout2.right === void 0) {
    layout2.width = 'auto';
  }
  if (layout2.top === void 0 || layout2.bottom === void 0) {
    layout2.height = 'auto';
  }
  const needsPerspective = contains3Dprops(transitionProps,) || contains3Dprops(initialProps,);
  const perspective = needsPerspective && (isLayeredContainer || isCurrent || isPrevious) ? 1200 : void 0;
  const identity = { ...allAnimatableProperties, ...previousState.current.origins, };
  const animations2 = isLayeredContainer
    ? {
      initial: { ...identity, ...initialProps, },
      animate: { ...identity, ...transitionProps, transition, },
      // Overlay animations are sometimes instant
      exit: { ...identity, ...exitProps, transition: animation, },
      // Overlay exits are always animated
    }
    : {
      animate: animate3,
      exit: { ...identity, ...exitProps, transition: exitTransition, },
    };
  const isPresent2 = isBeingRemoved || areMagicMotionLayersPresent === false ? false : true;
  const isCurrentTarget = !!isCurrent && isPresent2;
  const forceOpacity = isCurrent && isInitial;
  return /* @__PURE__ */ React44.createElement(
    FrameWithMotion,
    {
      'data-framer-component-type': 'NavigationContainerWrapper',
      width: '100%',
      height: '100%',
      style: {
        position: 'absolute',
        transformStyle: 'flat',
        backgroundColor: 'transparent',
        overflow: 'hidden',
        // Unlike Overlays, Screens set zIndex via animation controls to ensure it's set in parallel with the animation being played.
        // However, when a screen exits, it needs to preserve it's zIndex, which can't be applied through an `exit` animation,
        // and might be impacted by the layer created by `perspective`.
        zIndex: isLayeredContainer || isBeingRemoved || isCurrent && withMagicMotion ? index : void 0,
        pointerEvents: void 0,
        visibility: visible ? 'visible' : 'hidden',
        perspective,
      },
    },
    isLayeredContainer && /* @__PURE__ */ React44.createElement(
      FrameWithMotion,
      {
        width: '100%',
        height: '100%',
        'data-framer-component-type': 'NavigationContainerBackdrop',
        transition: animation,
        initial: { opacity: instant && visible ? 1 : 0, },
        animate: { opacity: 1, },
        exit: { opacity: 0, },
        backgroundColor: backdropColor ? backdropColor : 'transparent',
        onTap: !isBeingRemoved ? onTapBackdrop : void 0,
      },
    ),
    /* @__PURE__ */ React44.createElement(
      FrameWithMotion,
      {
        ...layout2,
        ...animations2,
        transition: {
          default: transition,
          originX: { type: false, },
          originY: { type: false, },
          originZ: { type: false, },
        },
        backgroundColor: 'transparent',
        backfaceVisible: !isBeingRemoved ? backfaceVisible : exitBackfaceVisible,
        'data-framer-component-type': 'NavigationContainer',
        'data-framer-is-current-navigation-target': !!isCurrent,
        style: {
          pointerEvents: void 0,
          // When we mount a new screen that is going to be animated in with animation controls,
          // we need to ensure that the screen is hidden until the animation starts.
          opacity: forceOpacity || isLayeredContainer || isCurrent && withMagicMotion ? 1 : 0,
        },
        'data-is-present': isPresent2 ? void 0 : false,
        ref: viewportRef,
      },
      /* @__PURE__ */ React44.createElement(
        ViewportContext.Provider,
        { value: viewportRef, },
        /* @__PURE__ */ React44.createElement(
          NavigationContainerContext.Provider,
          { value: isCurrentTarget, },
          /* @__PURE__ */ React44.createElement(
            NavigationTargetWrapper,
            { isCurrent: isCurrentTarget, isOverlayed, },
            /* @__PURE__ */ React44.createElement(
              SharedLayoutTree,
              {
                isLead: isCurrent,
                animatesLayout: !!withMagicMotion,
                transition,
                isExiting: !isPresent2,
                isOverlayed,
                id: id3,
              },
              children,
            ),
          ),
        ),
      ),
    ),
  );
}, shouldUsePreviousValue,);
function shouldUsePreviousValue(prevProps, nextProps,) {
  if (nextProps.isCurrent === void 0) {
    return false;
  }
  if (prevProps.isCurrent !== nextProps.isCurrent) {
    return false;
  }
  if (prevProps.isPrevious !== nextProps.isPrevious) {
    return false;
  }
  if (nextProps.isCurrent && prevProps.isOverlayed !== nextProps.isOverlayed) {
    return false;
  }
  return true;
}
function getOriginProps(currentOriginProps, initialProps, transitionProps,) {
  const result = { ...currentOriginProps, };
  if (initialProps) {
    if (isFiniteNumber(initialProps.originX,)) {
      result.originX = initialProps.originX;
    }
    if (isFiniteNumber(initialProps.originY,)) {
      result.originY = initialProps.originY;
    }
    if (isFiniteNumber(initialProps.originZ,)) {
      result.originZ = initialProps.originZ;
    }
  }
  if (transitionProps) {
    if (isFiniteNumber(transitionProps.originX,)) {
      result.originX = transitionProps.originX;
    }
    if (isFiniteNumber(transitionProps.originY,)) {
      result.originY = transitionProps.originY;
    }
    if (isFiniteNumber(transitionProps.originZ,)) {
      result.originZ = transitionProps.originZ;
    }
  }
  return result;
}
function contains3Dprops(containerProps,) {
  var _a, _b, _c;
  if (!containerProps) {
    return false;
  }
  const containsProps = 'rotateX' in containerProps || 'rotateY' in containerProps || 'z' in containerProps;
  if (!containsProps) {
    return false;
  }
  const toPropsContain3d = containerProps.rotateX !== 0 || containerProps.rotateY !== 0 || containerProps.z !== 0;
  const fromPropsContain3d =
    ((_a = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _a.rotateX.from) !== 0 ||
    ((_b = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _b.rotateY.from) !== 0 ||
    ((_c = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _c.z.from) !== 0;
  return toPropsContain3d || fromPropsContain3d;
}
var allAnimatableProperties = {
  x: 0,
  y: 0,
  z: 0,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0,
  opacity: 1,
};
var NavigatorMock = class {
  constructor() {
    __publicField(this, 'warning', () => {
      warnOnce2('The Navigator API is only available inside of Framer: https://www.framer.com/',);
    },);
    __publicField(this, 'goBack', () => this.warning(),);
    __publicField(this, 'instant', () => this.warning(),);
    __publicField(this, 'fade', () => this.warning(),);
    __publicField(this, 'push', () => this.warning(),);
    __publicField(this, 'modal', () => this.warning(),);
    __publicField(this, 'overlay', () => this.warning(),);
    __publicField(this, 'flip', () => this.warning(),);
    __publicField(this, 'customTransition', () => this.warning(),);
    __publicField(this, 'magicMotion', () => this.warning(),);
  }
};
var navigatorMock = new NavigatorMock();
var NavigationContext = createContext22(navigatorMock,);
var TransitionDefaults = {
  Fade: {
    exit: { opacity: 0, },
    enter: { opacity: 0, },
  },
  PushLeft: {
    exit: { x: '-30%', },
    enter: { x: '100%', },
  },
  PushRight: {
    exit: { x: '30%', },
    enter: { x: '-100%', },
  },
  PushUp: {
    exit: { y: '-30%', },
    enter: { y: '100%', },
  },
  PushDown: {
    exit: { y: '30%', },
    enter: { y: '-100%', },
  },
  Instant: {
    animation: { type: false, },
    enter: { opacity: 0, },
  },
  Modal: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { center: true, },
    enter: { opacity: 0, scale: 1.2, },
  },
  OverlayLeft: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { right: 0, top: 0, bottom: 0, },
    enter: { x: '100%', },
  },
  OverlayRight: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { left: 0, top: 0, bottom: 0, },
    enter: { x: '-100%', },
  },
  OverlayUp: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { bottom: 0, left: 0, right: 0, },
    enter: { y: '100%', },
  },
  OverlayDown: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { top: 0, left: 0, right: 0, },
    enter: { y: '-100%', },
  },
  FlipLeft: {
    backfaceVisible: false,
    exit: { rotateY: -180, },
    enter: { rotateY: 180, },
  },
  FlipRight: {
    backfaceVisible: false,
    exit: { rotateY: 180, },
    enter: { rotateY: -180, },
  },
  FlipUp: {
    backfaceVisible: false,
    exit: { rotateX: 180, },
    enter: { rotateX: -180, },
  },
  FlipDown: {
    backfaceVisible: false,
    exit: { rotateX: -180, },
    enter: { rotateX: 180, },
  },
  MagicMotion: {
    withMagicMotion: true,
  },
};
function pushTransition(options,) {
  const side = options && options.appearsFrom ? options.appearsFrom : 'right';
  switch (side) {
    case 'right':
      return TransitionDefaults.PushLeft;
    case 'left':
      return TransitionDefaults.PushRight;
    case 'bottom':
      return TransitionDefaults.PushUp;
    case 'top':
      return TransitionDefaults.PushDown;
  }
}
function overlayTransition(options,) {
  const side = options && options.appearsFrom ? options.appearsFrom : 'bottom';
  switch (side) {
    case 'right':
      return TransitionDefaults.OverlayLeft;
    case 'left':
      return TransitionDefaults.OverlayRight;
    case 'bottom':
      return TransitionDefaults.OverlayUp;
    case 'top':
      return TransitionDefaults.OverlayDown;
  }
}
function flipTransition(options,) {
  const side = options && options.appearsFrom ? options.appearsFrom : 'bottom';
  switch (side) {
    case 'right':
      return TransitionDefaults.FlipLeft;
    case 'left':
      return TransitionDefaults.FlipRight;
    case 'bottom':
      return TransitionDefaults.FlipUp;
    case 'top':
      return TransitionDefaults.FlipDown;
  }
}
var defaultState = () => ({
  current: -1,
  previous: -1,
  currentOverlay: -1,
  previousOverlay: -1,
  visualIndex: 0,
  overlayItemId: 0,
  historyItemId: 0,
  history: [],
  overlayStack: [],
  containers: {},
  containerIndex: {},
  containerVisualIndex: {},
  containerIsRemoved: {},
  transitionForContainer: {},
  previousTransition: null,
});
function reduceNavigationStateForAction(state, action,) {
  switch (action.type) {
    case 'addOverlay':
      return addOverlay(state, action.transition, action.component,);
    case 'removeOverlay':
      return removeOverlay(state,);
    case 'add':
      return add(state, action.key, action.transition, action.component,);
    case 'remove':
      return remove(state,);
    case 'update':
      return updateComponent(state, action.key, action.component,);
    case 'back':
      return back(state,);
    case 'forward':
      return forward(state,);
    default:
      return;
  }
}
function updateComponent(currentState, key7, component,) {
  return {
    ...currentState,
    containers: {
      ...currentState.containers,
      [key7]: component,
    },
  };
}
function addOverlay(currentState, transition, component,) {
  const currentOverlay = currentState.overlayStack[currentState.currentOverlay];
  if (currentOverlay && currentOverlay.component === component) {
    return;
  }
  const overlayItemId = currentState.overlayItemId + 1;
  const overlayStack = [
    ...currentState.overlayStack,
    {
      key: `stack-${overlayItemId}`,
      component,
      transition,
    },
  ];
  return {
    ...currentState,
    overlayStack,
    overlayItemId,
    currentOverlay: Math.max(0, Math.min(currentState.currentOverlay + 1, overlayStack.length - 1,),),
    previousOverlay: currentState.currentOverlay,
  };
}
function removeOverlay(currentState,) {
  return {
    ...currentState,
    overlayStack: [],
    currentOverlay: -1,
    previousOverlay: currentState.currentOverlay,
  };
}
function add(currentState, key7, transition, component,) {
  if (!currentState.containers[key7]) {
    currentState.containers[key7] = component;
  }
  currentState.history = currentState.history.slice(0, currentState.current + 1,);
  currentState.visualIndex = Math.max(currentState.history.length, 0,);
  const currentItem = currentState.history[currentState.history.length - 1];
  const isCurrentScreen = currentItem && currentItem.key === key7;
  currentState.overlayStack = [];
  if (isCurrentScreen && currentState.currentOverlay > -1) {
    return {
      ...currentState,
      currentOverlay: -1,
      previousOverlay: currentState.currentOverlay,
    };
  }
  if (isCurrentScreen) {
    return;
  }
  const nextIndex = currentState.containerVisualIndex[key7];
  const removed = currentState.containerIsRemoved[key7];
  const shouldMoveForward = (currentItem == null ? void 0 : currentItem.key) && transition.withMagicMotion
    ? isNextTargetForward(key7, nextIndex, removed, currentState.history,)
    : true;
  currentState.history.push({
    key: key7,
    transition,
    visualIndex: shouldMoveForward ? Math.max(currentState.visualIndex, 0,) : currentState.containerVisualIndex[key7],
  },);
  const current = currentState.current + 1;
  const previous = currentState.current;
  for (const containerKey in currentState.containerIndex) {
    if (currentState.containerIndex[containerKey] === current) {
      currentState.containerIndex[containerKey] = findLatestHistoryIndex(containerKey, currentState.history,);
    }
  }
  currentState.containerIndex[key7] = current;
  const { containerVisualIndex, containerIsRemoved, } = magicMotionPropsForAdd(currentState, key7, shouldMoveForward,);
  const transitionForContainer = updateTransitions(
    current,
    previous,
    currentState.history,
    currentState.containerIndex,
    currentState.transitionForContainer,
  );
  return {
    ...currentState,
    current,
    previous,
    containerVisualIndex,
    containerIsRemoved,
    transitionForContainer,
    previousTransition: null,
    currentOverlay: -1,
    historyItemId: currentState.historyItemId + 1,
    previousOverlay: currentState.currentOverlay,
  };
}
function back(currentState,) {
  const containers = { ...currentState.containers, };
  const nextState = remove(currentState,);
  if (!nextState) {
    return;
  }
  nextState.containers = containers;
  return nextState;
}
function forward(currentState,) {
  const nextItem = currentState.history[currentState.current + 1];
  if (!nextItem) {
    return;
  }
  const { key: key7, transition, component, } = nextItem;
  const history = [...currentState.history,];
  const nextState = add(currentState, key7, transition, component,);
  if (!nextState) {
    return;
  }
  nextState.history = history;
  return nextState;
}
function remove(currentState,) {
  const history = [...currentState.history.slice(0, currentState.current + 1,),];
  if (history.length === 1) {
    return;
  }
  const currentItem = history.pop();
  if (!currentItem) {
    return;
  }
  const target = history[history.length - 1];
  assert(target, 'The navigation history must have at least one component',);
  currentState.containerIndex[target.key] = history.length - 1;
  const shouldRemoveContainer = history.every((item,) => item.key !== currentItem.key);
  if (shouldRemoveContainer) {
    delete currentState.containers[currentItem.key];
  }
  const current = currentState.current - 1;
  const previous = currentState.current;
  const { containerIsRemoved, containerVisualIndex, previousTransition, visualIndex, } = magicMotionPropsForRemove(
    currentState,
    target,
    currentItem,
  );
  const transitionForContainer = updateTransitions(
    current,
    previous,
    currentState.history,
    currentState.containerIndex,
    currentState.transitionForContainer,
  );
  return {
    ...currentState,
    current,
    previous,
    containerIsRemoved,
    containerVisualIndex,
    previousTransition,
    visualIndex,
    transitionForContainer,
  };
}
function magicMotionPropsForAdd(currentState, nextKey, shouldMoveForward,) {
  const update = {
    containerVisualIndex: { ...currentState.containerVisualIndex, },
    containerIsRemoved: { ...currentState.containerIsRemoved, },
  };
  if (shouldMoveForward) {
    update.containerVisualIndex[nextKey] = currentState.history.length - 1;
    update.containerIsRemoved[nextKey] = false;
  } else {
    const nextVisualIndex = currentState.containerVisualIndex[nextKey];
    for (const [key7, visualIndex,] of Object.entries(currentState.containerVisualIndex,)) {
      if (nextVisualIndex !== void 0 && visualIndex > nextVisualIndex) {
        update.containerIsRemoved[key7] = true;
      }
    }
  }
  return update;
}
function magicMotionPropsForRemove(currentState, target, currentItem,) {
  const validTargets = [target.key, currentItem.key,];
  const nextValidTarget = currentState.history[currentState.history.length - 2];
  const previousTransition = currentState.previousTransition === null ? null : { ...currentState.previousTransition, };
  const update = {
    containerIsRemoved: { ...currentState.containerIsRemoved, },
    containerVisualIndex: { ...currentState.containerVisualIndex, },
    previousTransition,
    visualIndex: currentState.visualIndex,
  };
  if (nextValidTarget) {
    validTargets.push(nextValidTarget.key,);
  }
  const targetVisualIndex = currentState.containerVisualIndex[target.key];
  const currentVisualIndex = currentState.containerVisualIndex[currentItem.key];
  const shouldRemoveLastKey = targetVisualIndex !== void 0 && currentVisualIndex !== void 0 && targetVisualIndex <= currentVisualIndex ||
    target.visualIndex !== void 0 && target.visualIndex < currentState.history.length - 1;
  const nextIndex = target.visualIndex;
  if (shouldRemoveLastKey) {
    update.containerIsRemoved[currentItem.key] = true;
    update.containerVisualIndex[target.key] = nextIndex !== void 0 ? nextIndex : currentState.history.length - 1;
  } else {
    update.visualIndex = currentState.visualIndex + 1;
    update.containerVisualIndex[target.key] = currentState.visualIndex + 1;
  }
  if (currentItem.transition.withMagicMotion) {
    update.previousTransition = currentItem.transition || null;
  }
  currentState.containerIsRemoved[target.key] = false;
  return update;
}
function findLatestHistoryIndex(key7, history,) {
  var _a;
  for (let index = history.length; index > history.length; index--) {
    if (((_a = history[index]) == null ? void 0 : _a.key) === key7) {
      return index;
    }
  }
  return -1;
}
function updateTransitions(current, previous, history, containerIndex, transitionForContainer,) {
  const transitions = { ...transitionForContainer, };
  for (const [key7, screenIndex,] of Object.entries(containerIndex,)) {
    const transition = transitionForScreen(screenIndex, { current, previous, history, },);
    if (transition) {
      transitions[key7] = transition;
    }
  }
  return transitions;
}
function isNextTargetForward(key7, index, removed, history,) {
  if (removed || index === void 0) {
    return true;
  }
  if (index === 0) {
    return false;
  }
  const forwardHistory = history.slice(index, history.length,);
  if (forwardHistory.findIndex((item,) => item.key === key7) > -1) {
    return true;
  }
  const backwardsHistory = history.slice(0, index - 1,);
  if (backwardsHistory.findIndex((item,) => item.key === key7) > -1) {
    return false;
  }
  return true;
}
function transitionForScreen(screenIndex, stackState,) {
  const { current, previous, history, } = stackState;
  if (screenIndex !== current && screenIndex !== previous) {
    return void 0;
  }
  if (screenIndex === current && current > previous) {
    const item = history[screenIndex];
    return sequence('enter', item == null ? void 0 : item.transition.enter, item == null ? void 0 : item.transition.animation,);
  }
  if (screenIndex === previous && current > previous) {
    const item = history[screenIndex + 1];
    return sequence('exit', item == null ? void 0 : item.transition.exit, item == null ? void 0 : item.transition.animation,);
  }
  if (screenIndex === current && current < previous) {
    const item = history[screenIndex + 1];
    return sequence('enter', item == null ? void 0 : item.transition.exit, item == null ? void 0 : item.transition.animation,);
  }
  if (screenIndex === previous && current < previous) {
    const item = history[screenIndex];
    return sequence('exit', item == null ? void 0 : item.transition.enter, item == null ? void 0 : item.transition.animation,);
  }
}
var allAnimatableKeys = objectKeys(allAnimatableProperties,);
function sequence(direction, transition, animation,) {
  const value = {};
  const from = {};
  allAnimatableKeys.forEach((property,) => {
    value[property] = allAnimatableProperties[property];
    from[property] = {
      ...animation,
      from: allAnimatableProperties[property],
    };
  },);
  if (transition) {
    Object.keys(transition,).forEach((property,) => {
      if (transition[property] === void 0) {
        return;
      }
      const transitionTo = transition[property];
      const transitionFrom = typeof transition[property] === 'string'
        ? `${asRecord(allAnimatableProperties,)[property]}%`
        : asRecord(allAnimatableProperties,)[property];
      asRecord(value,)[property] = direction === 'enter' ? transitionFrom : transitionTo;
      from[property] = {
        ...animation,
        from: direction === 'enter' ? transitionTo : transitionFrom,
        velocity: 0,
      };
    },);
  }
  return {
    ...value,
    transition: {
      ...from,
    },
  };
}
var NavigationConsumer = NavigationContext.Consumer;
var NavigationCallbackContext = React45.createContext(void 0,);
var NavigationCallbackProvider = NavigationCallbackContext.Provider;
var IsInitialNavigationContext = React45.createContext(void 0,);
var Navigation = class extends Component7 {
  constructor(props,) {
    var _a;
    super(props,);
    __publicField(this, 'lastEventTimeStamp', null,);
    __publicField(this, 'state', defaultState(),);
    __publicField(this, 'navigationAction', (action2,) => {
      if (!this.props.enabled && this.state.history.length > 0) {
        return;
      }
      const newState2 = reduceNavigationStateForAction(this.state, action2,);
      if (!newState2) {
        return;
      }
      const { skipLayoutAnimation, } = this.props;
      const historyItem = newState2.history[newState2.current];
      const withMagicMotion = action2.type === 'add' && action2.transition.withMagicMotion ||
        action2.type === 'forward' && (historyItem == null ? void 0 : historyItem.transition.withMagicMotion) ||
        action2.type === 'remove' && !!newState2.previousTransition;
      const updateState = () => {
        var _a2;
        this.setState(newState2,);
        if (historyItem == null ? void 0 : historyItem.key) {
          (_a2 = this.context) == null ? void 0 : _a2.call(this, historyItem.key,);
        }
      };
      if (skipLayoutAnimation && !withMagicMotion) {
        skipLayoutAnimation(updateState,);
      } else {
        updateState();
      }
    },);
    __publicField(this, 'goBack', () => {
      var _a2;
      if (this.isSameEventTransition()) {
        return;
      }
      this.lastEventTimeStamp = ((_a2 = globalThis.event) == null ? void 0 : _a2.timeStamp) || null;
      if (this.state.currentOverlay !== -1) {
        return this.navigationAction({ type: 'removeOverlay', },);
      }
      return this.navigationAction({ type: 'remove', },);
    },);
    const component = this.props.children;
    if (!component || !isReactChild(component,) || !isReactElement(component,)) {
      return;
    }
    const transition = { ...TransitionDefaults.Instant, };
    const key7 = ((_a = component.key) == null ? void 0 : _a.toString()) || `stack-${this.state.historyItemId + 1}`;
    const action = { type: 'add', key: key7, transition, component, };
    const newState = reduceNavigationStateForAction(this.state, action,);
    if (!newState) {
      return;
    }
    this.state = newState;
  }
  componentDidMount() {
    var _a;
    const historyItem = this.state.history[this.state.current];
    if (!historyItem) {
      return;
    }
    (_a = this.context) == null ? void 0 : _a.call(this, historyItem.key,);
  }
  UNSAFE_componentWillReceiveProps(props,) {
    var _a;
    const component = props['children'];
    if (!isReactChild(component,) || !isReactElement(component,)) {
      return;
    }
    const key7 = (_a = component.key) == null ? void 0 : _a.toString();
    if (!key7) {
      return;
    }
    if (this.state.history.length === 0) {
      this.transition(component, TransitionDefaults.Instant,);
    } else {
      this.navigationAction({ type: 'update', key: key7, component, },);
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).resetProjection) == null ? void 0 : _b.call(_a,);
  }
  getStackState(options,) {
    const { current, previous, currentOverlay, previousOverlay, } = this.state;
    if (options.overCurrentContext) {
      return {
        current: currentOverlay,
        previous: previousOverlay,
        history: this.state.overlayStack,
      };
    }
    return {
      current,
      previous,
      history: this.state.history,
    };
  }
  /**
   * To prevent bubbling events from triggering multiple transitions,
   * we ensure that the current event has a different timestamp then the event that triggered the last transition.
   * We use Window.event to ensure that even transitions invoked by code components - and may not pass a reference to the event - are caught.
   * This works better than measuring the time of transition calls with performance.now()
   * because the time between calls can get longer and longer as more screens are added to the stack,
   * preventing a deterministic time between transitions to be used to determine if they were triggered at the same time or not.
   */
  isSameEventTransition() {
    if (!globalThis.event) {
      return false;
    }
    return this.lastEventTimeStamp === globalThis.event.timeStamp;
  }
  transition(component, transitionTraits, transitionOptions,) {
    var _a, _b;
    if (this.isSameEventTransition()) {
      return;
    }
    this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;
    if (!component || !isReactChild(component,) || !isReactElement(component,)) {
      return;
    }
    const transition = { ...transitionTraits, ...transitionOptions, };
    const overCurrentContext = !!transition.overCurrentContext;
    if (overCurrentContext) {
      return this.navigationAction({ type: 'addOverlay', transition, component, },);
    }
    const key7 = ((_b = component.key) == null ? void 0 : _b.toString()) || `stack-${this.state.historyItemId + 1}`;
    this.navigationAction({ type: 'add', key: key7, transition, component, },);
  }
  instant(component,) {
    this.transition(component, TransitionDefaults.Instant, void 0,);
  }
  fade(component, options,) {
    this.transition(component, TransitionDefaults.Fade, options,);
  }
  push(component, options,) {
    this.transition(component, pushTransition(options,), options,);
  }
  modal(component, options,) {
    this.transition(component, TransitionDefaults.Modal, options,);
  }
  overlay(component, options,) {
    this.transition(component, overlayTransition(options,), options,);
  }
  flip(component, options,) {
    this.transition(component, flipTransition(options,), options,);
  }
  magicMotion(component, options,) {
    this.transition(component, TransitionDefaults.MagicMotion, options,);
  }
  customTransition(component, transition,) {
    this.transition(component, transition,);
  }
  render() {
    var _a, _b, _c, _d, _e;
    const stackState = this.getStackState({ overCurrentContext: false, },);
    const overlayStackState = this.getStackState({ overCurrentContext: true, },);
    const activeOverlay = activeOverlayItem(overlayStackState,);
    const isOverlayVisible = overlayStackState.current > -1;
    const isInitial = this.state.history.length === 1;
    const contentContainers = [];
    for (const [key7, component,] of Object.entries(this.state.containers,)) {
      const index = this.state.containerIndex[key7];
      assert(index !== void 0, 'Container\'s index must be registered',);
      const visualIndex = this.state.containerVisualIndex[key7];
      assert(visualIndex !== void 0, 'Container\'s visual index must be registered',);
      const removed = this.state.containerIsRemoved[key7];
      const historyItem = this.state.history[index];
      const transitionProps = this.state.transitionForContainer[key7];
      const isCurrent = index === this.state.current;
      const isPrevious = index === this.state.previous;
      const areMagicMotionLayersPresent = isCurrent ? false : removed;
      const withMagicMotion = ((_a = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _a.withMagicMotion) ||
        isCurrent && !!this.state.previousTransition;
      contentContainers.push(
        /* @__PURE__ */ React45.createElement(
          NavigationContainer,
          {
            key: key7,
            id: key7,
            index: visualIndex,
            isInitial,
            isCurrent,
            isPrevious,
            isOverlayed: isOverlayVisible,
            visible: isCurrent || isPrevious,
            position: (_b = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _b.position,
            instant: isInstantContainerTransition(index, stackState,),
            transitionProps,
            animation: animationPropsForContainer(index, stackState,),
            backfaceVisible: getBackfaceVisibleForScreen(index, stackState,),
            exitAnimation: (_c = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _c.animation,
            exitBackfaceVisible: (_d = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _d.backfaceVisible,
            exitProps: (_e = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _e.enter,
            withMagicMotion,
            areMagicMotionLayersPresent: areMagicMotionLayersPresent ? false : void 0,
          },
          /* @__PURE__ */ React45.createElement(
            MagicMotionCrossfadeRoot,
            null,
            containerContent({
              component,
              transition: historyItem == null ? void 0 : historyItem.transition,
            },),
          ),
        ),
      );
    }
    const overlayContainers = this.state.overlayStack.map((item, stackIndex,) => {
      return /* @__PURE__ */ React45.createElement(
        NavigationContainer,
        {
          isLayeredContainer: true,
          key: item.key,
          isCurrent: stackIndex === this.state.currentOverlay,
          position: item.transition.position,
          initialProps: initialPropsForOverlay(stackIndex, overlayStackState,),
          transitionProps: transitionPropsForOverlay(stackIndex, overlayStackState,),
          instant: isInstantContainerTransition(stackIndex, overlayStackState, true,),
          animation: animationPropsForContainer(stackIndex, overlayStackState,),
          exitProps: item.transition.enter,
          visible: containerIsVisible(stackIndex, overlayStackState,),
          backdropColor: backdropColorForTransition(item.transition,),
          backfaceVisible: getBackfaceVisibleForOverlay(stackIndex, overlayStackState,),
          onTapBackdrop: backdropTapAction(item.transition, this.goBack,),
          index: this.state.current + 1 + stackIndex,
        },
        containerContent({
          component: item.component,
          transition: item.transition,
        },),
      );
    },);
    return /* @__PURE__ */ React45.createElement(
      FrameWithMotion,
      {
        'data-framer-component-type': 'NavigationRoot',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        position: 'relative',
        style: { overflow: 'hidden', backgroundColor: 'unset', pointerEvents: void 0, ...this.props.style, },
      },
      /* @__PURE__ */ React45.createElement(
        NavigationContext.Provider,
        { value: this, },
        /* @__PURE__ */ React45.createElement(
          IsInitialNavigationContext.Provider,
          { value: isInitial, },
          /* @__PURE__ */ React45.createElement(
            NavigationContainer,
            {
              isLayeredContainer: true,
              position: void 0,
              initialProps: {},
              instant: false,
              transitionProps: transitionPropsForStackWrapper(activeOverlay,),
              animation: animationForStackWrapper(activeOverlay,),
              backfaceVisible: backfaceVisibleForStackWrapper(activeOverlay,),
              visible: true,
              backdropColor: void 0,
              onTapBackdrop: void 0,
              index: 0,
            },
            /* @__PURE__ */ React45.createElement(
              LayoutIdProvider,
              null,
              /* @__PURE__ */ React45.createElement(
                SharedLayoutRoot,
                null,
                /* @__PURE__ */ React45.createElement(AnimatePresence, { presenceAffectsLayout: false, }, contentContainers,),
              ),
            ),
          ),
          /* @__PURE__ */ React45.createElement(AnimatePresence, null, overlayContainers,),
        ),
      ),
    );
  }
};
__publicField(Navigation, 'defaultProps', {
  enabled: true,
},);
__publicField(Navigation, 'contextType', NavigationCallbackContext,);
var animationDefault = {
  stiffness: 500,
  damping: 50,
  restDelta: 1,
  type: 'spring',
};
function activeOverlayItem(overlayStack,) {
  let currentOverlayItem;
  let previousOverlayItem;
  if (overlayStack.current !== -1) {
    currentOverlayItem = overlayStack.history[overlayStack.current];
  } else {
    previousOverlayItem = overlayStack.history[overlayStack.previous];
  }
  return { currentOverlayItem, previousOverlayItem, };
}
function transitionPropsForStackWrapper({ currentOverlayItem, },) {
  return currentOverlayItem && currentOverlayItem.transition.exit;
}
function animationForStackWrapper({ currentOverlayItem, previousOverlayItem, },) {
  if (currentOverlayItem && currentOverlayItem.transition.animation) {
    return currentOverlayItem.transition.animation;
  }
  if (previousOverlayItem && previousOverlayItem.transition.animation) {
    return previousOverlayItem.transition.animation;
  }
  return animationDefault;
}
function backfaceVisibleForStackWrapper({ currentOverlayItem, previousOverlayItem, },) {
  if (currentOverlayItem) {
    return currentOverlayItem.transition.backfaceVisible;
  }
  return previousOverlayItem && previousOverlayItem.transition.backfaceVisible;
}
function backdropColorForTransition(transition,) {
  if (transition.backdropColor) {
    return transition.backdropColor;
  }
  if (transition.overCurrentContext) {
    return 'rgba(4,4,15,.4)';
  }
  return void 0;
}
function getBackfaceVisibleForOverlay(containerIndex, stackState,) {
  const { current, history, } = stackState;
  if (containerIndex === current) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else if (containerIndex < current) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  }
}
function initialPropsForOverlay(containerIndex, stackState,) {
  const navigationItem = stackState.history[containerIndex];
  if (navigationItem) {
    return navigationItem.transition.enter;
  }
}
function getBackfaceVisibleForScreen(screenIndex, stackState,) {
  var _a, _b, _c, _d;
  const { current, previous, history, } = stackState;
  if (screenIndex === previous && current > previous || screenIndex === current && current < previous) {
    return (_b = (_a = history[screenIndex + 1]) == null ? void 0 : _a.transition) == null ? void 0 : _b.backfaceVisible;
  }
  return (_d = (_c = history[screenIndex]) == null ? void 0 : _c.transition) == null ? void 0 : _d.backfaceVisible;
}
function transitionPropsForOverlay(overlayIndex, stackState,) {
  const { current, history, } = stackState;
  if (overlayIndex === current) {
    return;
  } else if (overlayIndex < current) {
    const navigationItem = history[overlayIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.exit;
    }
  } else {
    const navigationItem = history[overlayIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.enter;
    }
  }
}
function animationPropsForContainer(containerIndex, stackState,) {
  const { current, previous, history, } = stackState;
  const containerCurrent = previous > current ? previous : current;
  if (containerIndex < containerCurrent) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else if (containerIndex !== containerCurrent) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem == null ? void 0 : navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  }
  return animationDefault;
}
function isInstantContainerTransition(containerIndex, stackState, overCurrentContext,) {
  const { current, previous, history, } = stackState;
  if (overCurrentContext && history.length > 1) {
    return true;
  }
  if (containerIndex !== previous && containerIndex !== current) {
    return true;
  }
  if (current === previous) {
    return true;
  }
  return false;
}
function containerIsVisible(containerIndex, stackState,) {
  const { current, previous, } = stackState;
  if (containerIndex > current && containerIndex > previous) {
    return false;
  }
  if (containerIndex === current) {
    return true;
  }
  return false;
}
function containerContent(item,) {
  const content = React45.Children.map(
    item.component,
    (child,) => {
      var _a, _b;
      if (!isReactChild(child,) || !isReactElement(child,) || !child.props) {
        return child;
      }
      const props = {
        style: (_a = child.props.style) != null ? _a : {},
      };
      const position = (_b = item == null ? void 0 : item.transition) == null ? void 0 : _b.position;
      const shouldStretchWidth = !position || position.left !== void 0 && position.right !== void 0;
      const shouldStretchHeight = !position || position.top !== void 0 && position.bottom !== void 0;
      const canStretchStyle = 'style' in child.props ? isObject2(child.props.style,) : true;
      if (shouldStretchWidth) {
        const canStretchWidth = 'width' in child.props;
        if (canStretchWidth) {
          props.width = '100%';
        }
        if (canStretchStyle) {
          props.style.width = '100%';
        }
      }
      if (shouldStretchHeight) {
        const canStretchHeight = 'height' in child.props;
        if (canStretchHeight) {
          props.height = '100%';
        }
        if (canStretchStyle) {
          props.style.height = '100%';
        }
      }
      return React45.cloneElement(child, props,);
    },
  );
  return content;
}
function backdropTapAction(transition, goBackAction,) {
  if (transition.goBackOnTapOutside !== false) {
    return goBackAction;
  }
}
function NavigationStyleSheet() {
  React45.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  return null;
}
function NavigationWrapper(props,) {
  const resetProjection = useResetProjection();
  const skipLayoutAnimation = useInstantLayoutTransition();
  return /* @__PURE__ */ React45.createElement(
    Navigation,
    { ...props, resetProjection, skipLayoutAnimation, },
    props.children,
    /* @__PURE__ */ React45.createElement(NavigationStyleSheet, null,),
  );
}
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs(), 1,);
var NavigateTo = /* @__PURE__ */ ((NavigateTo2,) => {
  NavigateTo2['Previous'] = '@Previous';
  return NavigateTo2;
})(NavigateTo || {},);
var NavigationTransitionType = /* @__PURE__ */ ((NavigationTransitionType2,) => {
  NavigationTransitionType2['push'] = 'push';
  NavigationTransitionType2['instant'] = 'instant';
  NavigationTransitionType2['fade'] = 'fade';
  NavigationTransitionType2['modal'] = 'modal';
  NavigationTransitionType2['overlay'] = 'overlay';
  NavigationTransitionType2['flip'] = 'flip';
  NavigationTransitionType2['magicMotion'] = 'magicMotion';
  return NavigationTransitionType2;
})(NavigationTransitionType || {},);
function WithNavigator(BaseComponent, navigationTransition, navigationTransitionDirection, NavigationTarget, navigationTransitionOptions,) {
  const InternalWithNavigator = class extends React46.Component {
    render() {
      return /* @__PURE__ */ React46.createElement(NavigationContext.Consumer, null, (navigation,) => {
        const navigate = () => {
          if (navigationTransition === 'goBack') {
            navigation.goBack();
            return;
          }
          if (!NavigationTarget) {
            return;
          }
          const component = NavigationTarget();
          const appearsFrom = transitionDirectionToSide(navigationTransitionDirection,);
          switch (navigationTransition) {
            case 'instant':
              navigation.instant(component,);
              break;
            case 'fade':
              navigation.fade(component,);
              break;
            case 'modal':
              navigation.modal(component, navigationTransitionOptions,);
              break;
            case 'push':
              navigation.push(component, { appearsFrom, },);
              break;
            case 'overlay':
              navigation.overlay(component, {
                ...navigationTransitionOptions,
                appearsFrom,
              },);
              break;
            case 'flip':
              navigation.flip(component, { appearsFrom, },);
              break;
            case 'magicMotion':
              navigation.magicMotion(component, {},);
              break;
          }
        };
        const { onTap, ...props } = this.props;
        if (onTap) {
          props.onTap = (...args) => {
            onTap.apply(this, args,);
            navigate.apply(this, args,);
          };
        } else {
          props.onTap = navigate;
        }
        return /* @__PURE__ */ React46.createElement(BaseComponent, { ...props, },);
      },);
    }
  };
  (0, import_hoist_non_react_statics3.default)(InternalWithNavigator, BaseComponent,);
  return InternalWithNavigator;
}
function transitionDirectionToSide(direction,) {
  switch (direction) {
    case 'left':
      return 'right';
    case 'right':
      return 'left';
    case 'up':
      return 'bottom';
    case 'down':
      return 'top';
  }
}
var AnimateSharedLayout = (props,) => props.children;
var Draggable = /* @__PURE__ */ WithDragging(DeprecatedFrameWithEvents,);
var import_process3 = __toESM(require_browser(), 1,);
function debounce(fn, time22,) {
  let timeout;
  const debounced = (...args) => {
    safeWindow.clearTimeout(timeout,);
    timeout = safeWindow.setTimeout(fn, time22, ...args,);
  };
  const cancel = () => {
    safeWindow.clearTimeout(timeout,);
  };
  debounced.cancel = cancel;
  return debounced;
}
function useWheelScroll(ref, {
  enabled,
  initial,
  prev,
  direction,
  constraints,
  offsetX,
  offsetY,
  onScrollStart,
  onScroll,
  onScrollEnd,
},) {
  const isWheelScrollActive = useRef82(false,);
  const getPointData = useCallback52(() => {
    const point2 = getPoint(offsetX, offsetY,);
    const data2 = {
      point: point2,
      velocity: { x: offsetX.getVelocity(), y: offsetY.getVelocity(), },
      offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
      delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
    };
    prev.x = point2.x;
    prev.y = point2.y;
    return data2;
  }, [],);
  let handler;
  if (enabled) {
    let clampX = function (v,) {
        return constraints.current === null ? v : clamp2(v, constraints.current.left, constraints.current.right,);
      },
      clampY = function (v,) {
        return constraints.current === null ? v : clamp2(v, constraints.current.top, constraints.current.bottom,);
      },
      updateX = function (delta,) {
        offsetX.stop();
        offsetX.set(clampX(offsetX.get() - delta,),);
      },
      updateY = function (delta,) {
        offsetY.stop();
        offsetY.set(clampY(offsetY.get() - delta,),);
      };
    const debouncedOnScrollEnd = debounce(() => {
      onScrollEnd && onScrollEnd(getPointData(),);
      isWheelScrollActive.current = false;
    }, 200,);
    handler = (e,) => {
      e.preventDefault();
      if (!isWheelScrollActive.current) {
        const x = offsetX.get();
        const y = offsetY.get();
        initial.x = x;
        initial.y = y;
        prev.x = x;
        prev.y = y;
        onScrollStart && onScrollStart(getPointData(),);
        isWheelScrollActive.current = true;
      }
      switch (direction) {
        case 'horizontal':
          updateX(e.deltaX,);
          break;
        case 'vertical':
          updateY(e.deltaY,);
          break;
        default:
          updateX(e.deltaX,);
          updateY(e.deltaY,);
      }
      onScroll && onScroll(getPointData(),);
      debouncedOnScrollEnd();
    };
  }
  useDomEvent(ref, 'wheel', handler, { passive: false, },);
}
function getPoint(x, y,) {
  return { x: x.get(), y: y.get(), };
}
function hasPaddingPerSide(props,) {
  const { paddingPerSide, paddingTop, paddingBottom, paddingLeft, paddingRight, } = props;
  return paddingPerSide !== false &&
    (paddingTop !== void 0 || paddingBottom !== void 0 || paddingLeft !== void 0 || paddingRight !== void 0);
}
function paddingFromProps(props,) {
  const { padding = 0, paddingTop, paddingBottom, paddingLeft, paddingRight, } = props;
  if (hasPaddingPerSide(props,)) {
    return {
      top: paddingTop !== void 0 ? paddingTop : padding,
      bottom: paddingBottom !== void 0 ? paddingBottom : padding,
      left: paddingLeft !== void 0 ? paddingLeft : padding,
      right: paddingRight !== void 0 ? paddingRight : padding,
    };
  }
  return {
    top: padding,
    bottom: padding,
    left: padding,
    right: padding,
  };
}
function makePaddingString({
  top,
  left,
  bottom,
  right,
},) {
  return `${top}px ${right}px ${bottom}px ${left}px`;
}
function triggerStackReflow(element, display,) {
  if (!element) {
    return;
  }
  element.style.display = 'none';
  void element.offsetHeight;
  element.style.display = display;
}
var requiresPolyfill = Boolean(isSafari() && safariVersion() < 15.4,);
function useSafariGapFix(gap, ref, display,) {
  if (!requiresPolyfill) {
    return void 0;
  }
  const isInitialRender = React47.useRef(true,);
  const hasTriggeredReflow = React47.useRef(false,);
  const prevGapValue = React47.useRef(gap,);
  hasTriggeredReflow.current = false;
  React47.useLayoutEffect(() => {
    prevGapValue.current = gap;
    if (isInitialRender.current) {
      isInitialRender.current = false;
      return;
    }
    if (!hasTriggeredReflow.current) {
      triggerStackReflow(ref.current, display,);
      hasTriggeredReflow.current = true;
    }
  }, [gap, ref, prevGapValue, display,],);
  return React47.useCallback(() => {
    if (prevGapValue.current === gap) {
      return;
    }
    if (!hasTriggeredReflow.current) {
      triggerStackReflow(ref.current, display,);
    }
    hasTriggeredReflow.current = true;
  }, [gap, ref,],);
}
var Stack = /* @__PURE__ */ (() => {
  const StackInner = React48.forwardRef(
    function StackInner2(stackProps, forwardedRef,) {
      var _a, _b;
      const {
        as = 'div',
        direction = 'vertical',
        distribution = 'start',
        alignment = 'center',
        gap = 10,
        wrap: wrap2 = false,
        useFlexboxGap: externalUseFlexboxGap = true,
        children,
        style: styleProp,
        className,
        willChangeTransform,
        __fromCodeComponentNode,
        parentSize,
        __contentWrapperStyle,
        ...containerProps
      } = stackProps;
      const useFlexboxGap = Boolean(externalUseFlexboxGap || wrap2,);
      const stackRef = React48.useRef(null,);
      const onBeforeLayoutMeasure = useSafariGapFix(gap, stackRef, 'flex',);
      const flexDirection = toFlexDirection(direction,);
      const isReverse = isReverseDirection(flexDirection,);
      const justifyContent = toJustifyOrAlignment(distribution,);
      const padding = hasPaddingPerSide(containerProps,) || containerProps.padding
        ? makePaddingString(paddingFromProps(containerProps,),)
        : void 0;
      const style = { ...styleProp, };
      Layer.applyWillChange({ willChangeTransform, }, style, true,);
      if (__fromCodeComponentNode && !constraintsEnabled(unwrapFrameProps(containerProps,),)) {
        containerProps.width = '100%';
        containerProps.height = '100%';
        containerProps._constraints = { enabled: true, };
      }
      const layoutId = useLayoutId2(stackProps,);
      const { children: _children, props, } = processOverrideForwarding(containerProps, children,);
      const widthType = (_a = containerProps.widthType) != null ? _a : containerProps.width === 'auto' ? 2 : 0;
      const heightType = (_b = containerProps.heightType) != null ? _b : containerProps.height === 'auto' ? 2 : 0;
      const fractionChildren = handleFraction(_children, direction, widthType, heightType,);
      const gapChildren = wrapInGapElementForLegacyGap(
        fractionChildren,
        gap,
        flexDirection,
        justifyContent,
        useFlexboxGap,
        wrap2,
      );
      const content = useProvideParentSize(
        gapChildren,
        parentSize != null ? parentSize : 1,
        /* Disabled */
      );
      const attributes = {
        'data-framer-component-type': 'Stack',
      };
      const fromCanvasComponent = containerProps.__fromCanvasComponent;
      if (fromCanvasComponent) {
        attributes['data-framer-generated'] = true;
      }
      const alignItems = toJustifyOrAlignment(alignment,);
      const contentWrapperStyle = {
        display: 'flex',
        flexDirection,
        flexWrap: wrap2 ? 'wrap' : 'nowrap',
        justifyContent,
        alignItems,
        alignContent: alignItems,
        padding,
        ...__contentWrapperStyle,
      };
      const gapEnabled = isGapEnabled(gap, justifyContent, wrap2,);
      if (useFlexboxGap && gapEnabled) {
        const gapSupportedInMainAxis = isGapSupportedInMainAxis(justifyContent,);
        if (gapSupportedInMainAxis || direction !== 'horizontal') {
          asRecord(contentWrapperStyle,)['--stack-native-column-gap'] = `${gap}px`;
        }
        if (gapSupportedInMainAxis || direction !== 'vertical') {
          asRecord(contentWrapperStyle,)['--stack-native-row-gap'] = `${gap}px`;
        }
      }
      if (contentWrapperStyle.width === void 0) {
        contentWrapperStyle.width = widthType === 2 ? 'min-content' : '100%';
      }
      if (contentWrapperStyle.height === void 0) {
        contentWrapperStyle.height = heightType === 2 ? 'min-content' : '100%';
      }
      if (fromCanvasComponent) {
        if (styleProp == null ? void 0 : styleProp.width) {
          contentWrapperStyle.width = styleProp == null ? void 0 : styleProp.width;
        }
        if (styleProp == null ? void 0 : styleProp.height) {
          contentWrapperStyle.height = styleProp == null ? void 0 : styleProp.height;
        }
      }
      return /* @__PURE__ */ React48.createElement(
        FrameWithMotion,
        {
          as,
          background: fromCanvasComponent ? void 0 : 'none',
          ...props,
          layoutId,
          ref: useForwardedRef(forwardedRef, stackRef,),
          ...attributes,
          style,
          className,
          layoutScroll: true,
        },
        /* @__PURE__ */ React48.createElement(
          motion.div,
          {
            'data-framer-stack-content-wrapper': true,
            'data-framer-stack-direction-reverse': isReverse,
            'data-framer-stack-gap-enabled': gapEnabled,
            style: contentWrapperStyle,
            onBeforeLayoutMeasure,
          },
          content,
        ),
      );
    },
  );
  StackInner.defaultProps = {
    distribution: 'start',
  };
  StackInner.displayName = 'Stack';
  addPropertyControls(StackInner, {
    direction: {
      type: 'segmentedenum',
      options: ['horizontal', 'vertical',],
      title: 'Direction',
      defaultValue: 'vertical',
    },
    distribution: {
      type: 'enum',
      options: ['start', 'center', 'end', 'space-between', 'space-around', 'space-evenly',],
      optionTitles: ['Start', 'Center', 'End', 'Space Between', 'Space Around', 'Space Evenly',],
      title: 'Distribute',
      defaultValue: 'space-around',
    },
    alignment: {
      type: 'segmentedenum',
      options: ['start', 'center', 'end',],
      title: 'Align',
      defaultValue: 'center',
    },
    gap: {
      type: 'number',
      min: 0,
      title: 'Gap',
      hidden: (props,) => {
        return props.distribution !== void 0 && ['space-between', 'space-around', 'space-evenly',].includes(props.distribution,);
      },
      defaultValue: 10,
    },
    padding: {
      type: 'fusednumber',
      toggleKey: 'paddingPerSide',
      toggleTitles: ['Padding', 'Padding per side',],
      valueKeys: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',],
      valueLabels: ['t', 'r', 'b', 'l',],
      min: 0,
      title: 'Padding',
      defaultValue: 0,
    },
  },);
  return StackInner;
})();
function isFractionDimension(dimension,) {
  return typeof dimension === 'string' && dimension.endsWith('fr',);
}
function fraction(dimension,) {
  const value = parseFloat(dimension,);
  return isFiniteNumber(value,) ? value : 0;
}
function handleFraction(children, direction, widthType, heightType,) {
  return React48.Children.map(children, (child,) => {
    if (!isReactChild(child,) || !isReactElement(child,)) {
      return;
    }
    const isVertical = direction === 'vertical';
    const style = {};
    let hasFraction = false;
    const { style: propsStyle, size: size2, } = child.props;
    let { width, height, } = child.props;
    if (size2 !== void 0) {
      if (width === void 0) {
        width = size2;
      }
      if (height === void 0) {
        height = size2;
      }
    }
    let newWidth = width;
    let newHeight = height;
    if (isFractionDimension(width,)) {
      hasFraction = true;
      hasFraction = true;
      if (isVertical) {
        if (widthType === 2) {
          style.alignSelf = 'stretch';
          newWidth = 'auto';
        } else {
          newWidth = `${fraction(width,) * 100}%`;
        }
      } else {
        newWidth = 1;
        style.flexGrow = fraction(width,);
        style.flexBasis = 0;
      }
      style.width = newWidth;
    }
    if (isFractionDimension(height,)) {
      hasFraction = true;
      if (isVertical) {
        newHeight = 1;
        style.flexGrow = fraction(height,);
        style.flexBasis = 0;
      } else {
        if (heightType === 2) {
          style.alignSelf = 'stretch';
          newHeight = 'auto';
        } else {
          newHeight = `${fraction(height,) * 100}%`;
        }
      }
      style.height = newHeight;
    }
    if (!hasFraction) {
      return child;
    }
    const nextStyle = { ...propsStyle, ...style, };
    return React48.cloneElement(child, {
      width: newWidth,
      height: newHeight,
      style: nextStyle,
    },);
  },);
}
function isGapSupportedInMainAxis(justifyContent,) {
  if (!justifyContent) {
    return false;
  }
  return !['space-between', 'space-around', 'space-evenly', 'stretch',].includes(justifyContent,);
}
function isGapEnabled(gap, justifyContent, wrap2,) {
  if (!gap) {
    return false;
  }
  if (!wrap2 && !isGapSupportedInMainAxis(justifyContent,)) {
    return false;
  }
  return true;
}
function wrapInGapElementForLegacyGap(children, gap, direction, justifyContent, useFlexboxGap, wrap2,) {
  const gapStyle = {
    // We need the wrapper to have `display: contents` to prevent the child
    // margins from collapsing when using the fallback gap solution.
    // https://codesandbox.io/s/dreamy-haslett-01ie5?file=/src/styles.css
    display: 'contents',
  };
  const gapEnabled = isGapEnabled(gap, justifyContent, wrap2,);
  if (gapEnabled) {
    const isVertical = isVerticalDirection(direction,);
    asRecord(gapStyle,)['--stack-gap-x'] = `${isVertical ? 0 : gap}px`;
    asRecord(gapStyle,)['--stack-gap-y'] = `${isVertical ? gap : 0}px`;
  }
  return /* @__PURE__ */ React48.createElement(
    'div',
    {
      'data-framer-legacy-stack-gap-enabled': gapEnabled,
      'data-framer-stack-flexbox-gap': useFlexboxGap,
      style: gapStyle,
    },
    children,
  );
}
function toFlexDirection(direction,) {
  switch (direction) {
    case 'vertical':
      return 'column';
    case 'horizontal':
      return 'row';
    default:
      return direction;
  }
}
function isVerticalDirection(direction,) {
  return direction === 'column' || direction === 'column-reverse';
}
function isReverseDirection(direction,) {
  switch (direction) {
    case 'column-reverse':
    case 'row-reverse':
      return true;
    default:
      return false;
  }
}
function toJustifyOrAlignment(distribution,) {
  switch (distribution) {
    case 'start':
      return 'flex-start';
    case 'end':
      return 'flex-end';
    default:
      return distribution;
  }
}
function useForwardedRef(forwardedRef, innerRef,) {
  return (element,) => {
    innerRef.current = element;
    if (typeof forwardedRef === 'function') {
      forwardedRef(element,);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }
  };
}
var pageContentWrapperType = 'PageContentWrapper';
function PageContainer({
  children,
  effect,
  dragEnabled,
  direction,
  contentHeight,
  contentWidth,
  alignment,
  gap,
  isLastPage,
  contentOffsetRef,
  constraintsRef,
  directionLock,
  onDragStart,
  onDrag,
  onDragEnd,
  layoutId,
},) {
  const isHorizontalDirection = direction === 'horizontal';
  const dragAxis = isHorizontalDirection ? 'x' : 'y';
  const hasHorizontalGap = isHorizontalDirection && !isLastPage && gap;
  const hasVerticalGap = !isHorizontalDirection && !isLastPage && gap;
  const hasAutoWidth = contentWidth !== 'stretch' && isHorizontalDirection;
  const hasAutoHeight = contentHeight !== 'stretch' && !isHorizontalDirection;
  const wrapperWidth = hasAutoWidth ? 'auto' : '100%';
  const wrapperHeight = hasAutoHeight ? 'auto' : '100%';
  const containerWidth = hasHorizontalGap && wrapperWidth === '100%' ? `calc(100% + ${gap}px)` : wrapperWidth;
  const containerHeight = hasVerticalGap && wrapperHeight === '100%' ? `calc(100% + ${gap}px)` : wrapperHeight;
  return /* @__PURE__ */ React49.createElement(
    FrameWithMotion,
    {
      position: 'relative',
      'data-framer-component-type': 'PageContainer',
      width: containerWidth,
      height: containerHeight,
      layoutId: layoutId ? `${layoutId}-container` : void 0,
      backgroundColor: 'transparent',
      drag: dragEnabled ? dragAxis : false,
      dragDirectionLock: directionLock,
      _dragX: contentOffsetRef.current.x,
      _dragY: contentOffsetRef.current.y,
      dragConstraints: constraintsRef.current,
      onDrag,
      onDragStart,
      onDragEnd,
      preserve3d: true,
      style: {
        pointerEvents: void 0,
        paddingRight: hasHorizontalGap ? gap : 0,
        paddingBottom: hasVerticalGap ? gap : 0,
      },
    },
    /* @__PURE__ */ React49.createElement(
      FrameWithMotion,
      {
        position: 'relative',
        'data-framer-component-type': pageContentWrapperType,
        width: wrapperWidth,
        height: wrapperHeight,
        preserve3d: false,
        backgroundColor: 'transparent',
        key: effect ? Object.keys(effect,).join('',) : '',
        style: {
          ...effect,
          pointerEvents: void 0,
          display: 'flex',
          flexDirection: isHorizontalDirection ? 'row' : 'column',
          alignItems: alignment && toJustifyOrAlignment(alignment,),
        },
      },
      children,
    ),
  );
}
var Page = /* @__PURE__ */ React50.forwardRef(function Page2(props, forwardedRef,) {
  var _a;
  const {
    direction = 'horizontal',
    contentWidth = 'stretch',
    contentHeight = 'stretch',
    alignment = 'start',
    currentPage = 0,
    animateCurrentPageUpdate = true,
    gap: gapValue = 10,
    padding = 0,
    momentum = false,
    dragEnabled = true,
    defaultEffect = 'none',
    background = 'transparent',
    overflow = 'hidden',
    __fromCodeComponentNode,
    effect,
    children,
    contentOffsetX,
    contentOffsetY,
    onChangePage,
    onScrollStart,
    onScroll,
    onDragStart,
    onDrag,
    onDragEnd,
    directionLock,
    onScrollEnd,
    onDirectionLock,
    onUpdate,
    wheelEnabled = false,
    layoutId: specificLayoutId,
    ...rest
  } = props;
  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'page', },);
  const containerProps = { ...rest, background, };
  const hasMountedRef = React50.useRef(false,);
  const hasFixedSize = RenderTarget.hasRestrictions() && props.__fromCodeComponentNode && isFiniteNumber(containerProps.width,) &&
    isFiniteNumber(containerProps.height,);
  if (!hasFixedSize && __fromCodeComponentNode && !containerProps.__fromCanvasComponent) {
    containerProps.width = '100%';
    containerProps.height = '100%';
    containerProps._constraints = { enabled: true, };
  }
  const { initial, prev, } = React50.useRef({
    initial: { x: 0, y: 0, },
    prev: { x: 0, y: 0, },
  },).current;
  const isHorizontal = direction === 'horizontal';
  let gap = gapValue;
  if (gap < 0) {
    warnOnce2(`The 'gap' property of Page component can not be negative, but is ${gapValue}.`,);
    gap = 0;
  }
  React50.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  const pageCount = React50.Children.count(children,);
  const maxOffsetRef = React50.useRef(0,);
  const constraints = React50.useRef({ top: 0, left: 0, right: 0, bottom: 0, },);
  const fallbackContainerRef = React50.useRef(null,);
  const containerRef = forwardedRef || fallbackContainerRef;
  const scrollableRef = React50.useRef(null,);
  const pageEffectValuesRef = React50.useRef([],);
  const pageRectsRef = React50.useRef([],);
  const internalX = useMotionValue(isMotionValue2(contentOffsetX,) ? 0 : contentOffsetX != null ? contentOffsetX : 0,);
  const internalY = useMotionValue(isMotionValue2(contentOffsetY,) ? 0 : contentOffsetY != null ? contentOffsetY : 0,);
  const contentOffsetRef = React50.useRef({
    x: isMotionValue2(contentOffsetX,) ? contentOffsetX : internalX,
    y: isMotionValue2(contentOffsetY,) ? contentOffsetY : internalY,
  },);
  const currentContentPageRef = React50.useRef(currentPage,);
  const propsBoundedCurrentPageRef = React50.useRef(currentPage,);
  const latestPropsRef = React50.useRef(props,);
  latestPropsRef.current = props;
  const lastDirectionRef = React50.useRef(props.direction,);
  const snapToPage = useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal,);
  const [_, setForceUpdateCount,] = React50.useState(0,);
  const containerSizeRef = React50.useRef({ width: 200, height: 200, },);
  if (hasFixedSize && isFiniteNumber(containerProps.width,) && isFiniteNumber(containerProps.height,)) {
    containerSizeRef.current.width = containerProps.width;
    containerSizeRef.current.height = containerProps.height;
  }
  const updateOnResize = React50.useCallback(() => {
    if (!hasFixedSize) {
      setForceUpdateCount((v,) => v + 1);
    }
  }, [hasFixedSize,],);
  React50.useEffect(() => {
    if (RenderTarget.current() !== 'PREVIEW') {
      return;
    }
    globalThis.addEventListener('resize', updateOnResize,);
    return () => {
      globalThis.removeEventListener('resize', updateOnResize,);
    };
  }, [updateOnResize,],);
  const applyEffects = () => {
    pageEffectValuesRef.current.forEach((effectDictionary, index,) => {
      const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef,);
      if (!effectDictionary || !values) {
        return;
      }
      for (const [key7, value,] of Object.entries(values,)) {
        const effectValue = effectDictionary[key7];
        if (isMotionValue2(effectValue,)) {
          effectValue.set(value,);
        }
      }
    },);
  };
  const updateMaxOffsetFromPageContents = (containerSize,) => {
    const newPageContentRects = getPageContentRects(containerRef, containerSize, direction, gap,);
    if (newPageContentRects) {
      pageRectsRef.current = newPageContentRects;
    }
    const newMaxOffset = getMaxOffset(
      containerSizeRef.current,
      pageRectsRef.current,
      direction,
      latestPropsRef.current,
    );
    if (newMaxOffset !== maxOffsetRef.current) {
      maxOffsetRef.current = newMaxOffset;
      constraints.current.top = -newMaxOffset;
      constraints.current.left = -newMaxOffset;
      if (RenderTarget.current() === 'CANVAS') {
        setForceUpdateCount((v,) => v + 1);
      }
    }
  };
  const measureContainerSize = () => {
    const element = containerRef.current;
    if (!element) {
      return null;
    }
    const { offsetWidth, offsetHeight, } = element;
    const currentSize = containerSizeRef.current;
    if (offsetWidth !== currentSize.width || offsetHeight !== currentSize.height) {
      containerSizeRef.current = {
        width: offsetWidth,
        height: offsetHeight,
      };
      return containerSizeRef.current;
    }
    return null;
  };
  const updateAndSnapToPage = (newPage, mount = false,) => {
    const newBoundedCurrentPage = getBoundedCurrentPage(newPage, pageCount,);
    const boundedCurrentPageDidChange = newBoundedCurrentPage !== propsBoundedCurrentPageRef.current;
    if (boundedCurrentPageDidChange) {
      propsBoundedCurrentPageRef.current = newBoundedCurrentPage;
      updateCurrentPage(newBoundedCurrentPage, currentContentPageRef, !mount ? onChangePage : void 0,);
    }
    const offset = offsetForPage(newBoundedCurrentPage, pageCount, pageRectsRef, isHorizontal, maxOffsetRef,);
    const animated = animateCurrentPageUpdate && RenderTarget.current() !== 'CANVAS' && !mount;
    snapToPage(newBoundedCurrentPage, offset, { animated, },);
  };
  useIsomorphicLayoutEffect2(() => {
    if (hasMountedRef.current) {
      return;
    }
    requestAnimationFrame(() => {
      var _a2;
      currentContentPageRef.current = currentPage;
      const contentOffset = contentOffsetRef.current;
      contentOffset.x.on('change', applyEffects,);
      contentOffset.y.on('change', applyEffects,);
      applyEffects();
      hasMountedRef.current = true;
      const containerSize = (_a2 = measureContainerSize()) != null ? _a2 : containerSizeRef.current;
      updateMaxOffsetFromPageContents(containerSize,);
      updateAndSnapToPage(currentContentPageRef.current, true,);
    },);
  }, [],);
  React50.useEffect(() => {
    if (currentPage !== currentContentPageRef.current) {
      updateAndSnapToPage(currentPage,);
    }
  }, [currentPage,],);
  const handleMeasureLifecycle = () => {
    const newContainerSize = measureContainerSize();
    updateMaxOffsetFromPageContents(newContainerSize != null ? newContainerSize : containerSizeRef.current,);
    updateAndSnapToPage(currentContentPageRef.current,);
    if (newContainerSize || direction !== lastDirectionRef.current) {
      if (direction === 'horizontal') {
        contentOffsetRef.current.y.set(0,);
      } else {
        contentOffsetRef.current.x.set(0,);
      }
      lastDirectionRef.current = direction;
    }
  };
  useIsomorphicLayoutEffect2(() => {
    if (RenderTarget.current() !== 'CANVAS') {
      return;
    }
    handleMeasureLifecycle();
  },);
  const onDragStartHandler = (event, info,) => {
    if (onScrollStart) {
      onScrollStart(info,);
    }
    if (onDragStart) {
      onDragStart(event, info,);
    }
    prev.x = initial.x = info.point.x;
    prev.y = initial.y = info.point.y;
  };
  const onDragHandler = (event, info,) => {
    if (onScroll) {
      onScroll(info,);
    }
    if (onDrag) {
      onDrag(event, info,);
    }
    prev.x = info.point.x;
    prev.y = info.point.y;
  };
  const onDragTransitionEnd = () => {
    if (props.onDragTransitionEnd) {
      props.onDragTransitionEnd();
    }
    if (onScrollEnd) {
      const { x, y, } = contentOffsetRef.current;
      const point2 = { x: x.get(), y: y.get(), };
      onScrollEnd({
        point: point2,
        velocity: { x: x.getVelocity(), y: y.getVelocity(), },
        offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
        delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
      },);
    }
  };
  const onDragEndHandler = async (event, info,) => {
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    contentOffset.stop();
    const startPosition = contentOffset.get();
    const axis = isHorizontal ? 'x' : 'y';
    const velocity = info.velocity[axis];
    let index = nearestPageIndex(pageRectsRef.current, startPosition, startPosition, isHorizontal, momentum,);
    if (velocity) {
      animateValue({
        type: 'inertia',
        keyframes: [startPosition,],
        velocity,
        modifyTarget: (endPosition,) => {
          index = nearestPageIndex(pageRectsRef.current, startPosition, endPosition, isHorizontal, momentum,);
          return endPosition;
        },
      },).stop();
    }
    updateCurrentPage(index, currentContentPageRef, onChangePage,);
    const offset = offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef,);
    if (onDragEnd) {
      onDragEnd(event, info,);
    }
    const handler = contentOffsetRef.current[axis];
    handler.set(startPosition,);
    animate(handler, offset, {
      type: 'spring',
      velocity,
      stiffness: 500,
      damping: 50,
      onComplete: onDragTransitionEnd,
    },);
  };
  pageEffectValuesRef.current = [];
  const childComponents = React50.Children.map(children, (child, index,) => {
    var _a2;
    if (!isReactChild(child,) || !isReactElement(child,)) {
      return child;
    }
    const update = {
      right: void 0,
      bottom: void 0,
      top: void 0,
      left: void 0,
      _constraints: {
        enabled: false,
      },
    };
    if (containerProps.__fromCanvasComponent) {
      update.style = (_a2 = child.props.style) != null ? _a2 : {};
      if (contentWidth === 'stretch') {
        update.style.width = '100%';
      }
      if (contentHeight === 'stretch') {
        update.style.height = '100%';
      }
    } else {
      if (contentWidth === 'stretch') {
        update.width = '100%';
      }
      if (contentHeight === 'stretch') {
        update.height = '100%';
      }
    }
    let effectDictionary;
    const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef,);
    if (values) {
      effectDictionary = {};
      for (const key7 in values) {
        effectDictionary[key7] = motionValue(values[key7],);
      }
    }
    pageEffectValuesRef.current.push(effectDictionary,);
    return /* @__PURE__ */ React50.createElement(
      PageContainer,
      {
        key: index,
        effect: effectDictionary,
        dragEnabled,
        direction,
        contentHeight,
        contentWidth,
        alignment,
        gap,
        isLastPage: index === pageCount - 1,
        contentOffsetRef,
        constraintsRef: constraints,
        directionLock,
        onDragStart: onDragStartHandler,
        onDrag: onDragHandler,
        onDragEnd: onDragEndHandler,
        layoutId: layoutId ? `${layoutId}-${index}` : void 0,
      },
      React50.cloneElement(child, update,),
    );
  },);
  useWheelScroll(scrollableRef, {
    enabled: wheelEnabled,
    initial,
    prev,
    direction,
    constraints,
    offsetX: contentOffsetRef.current.x,
    offsetY: contentOffsetRef.current.y,
    onScrollStart,
    onScroll,
    onScrollEnd,
  },);
  return /* @__PURE__ */ React50.createElement(
    FrameWithMotion,
    {
      'data-framer-component-type': 'PageWrapper',
      preserve3d: false,
      perspective: hasEffect(props,) ? 1200 : void 0,
      ...containerProps,
      style: { pointerEvents: void 0, ...containerProps.style, overflow, },
      layoutId,
      ref: containerRef,
      onLayoutMeasure: handleMeasureLifecycle,
    },
    /* @__PURE__ */ React50.createElement(
      FrameWithMotion,
      {
        'data-framer-component-type': 'Page',
        ref: scrollableRef,
        background: null,
        x: contentOffsetRef.current.x,
        y: contentOffsetRef.current.y,
        width: '100%',
        height: '100%',
        preserve3d: true,
        layout: true,
        layoutId: layoutId !== void 0 ? layoutId + '-page' : void 0,
        style: {
          padding: makePaddingString(paddingFromProps(props,),),
          display: 'flex',
          flexDirection: isHorizontal ? 'row' : 'column',
          pointerEvents: (_a = props.style) == null ? void 0 : _a.pointerEvents,
        },
      },
      /* @__PURE__ */ React50.createElement(
        EmptyState,
        {
          title: 'Page',
          description: 'Click and drag the connector to any frame on the canvas \u2192',
          children,
          size: containerSizeRef.current,
          insideUserCodeComponent: !__fromCodeComponentNode,
        },
      ),
      childComponents,
    ),
  );
},);
function cubeEffect(info,) {
  const { normalizedOffset, direction, } = info;
  const isHorizontal = direction === 'horizontal';
  return {
    originX: normalizedOffset < 0 ? 1 : 0,
    originY: normalizedOffset < 0 ? 1 : 0,
    rotateY: isHorizontal ? Math.min(Math.max(-90, normalizedOffset * 90,), 90,) : 0,
    rotateX: isHorizontal ? 0 : Math.min(Math.max(-90, normalizedOffset * -90,), 90,),
    backfaceVisibility: 'hidden',
    WebkitBackfaceVisibility: 'hidden',
  };
}
function coverflowEffect(info,) {
  const { normalizedOffset, direction, size: size2, } = info;
  const isHorizontal = direction === 'horizontal';
  return {
    rotateY: isHorizontal ? Math.min(45, Math.max(-45, normalizedOffset * -45,),) : 0,
    rotateX: isHorizontal ? 0 : Math.min(45, Math.max(-45, normalizedOffset * 45,),),
    originX: isHorizontal ? normalizedOffset < 0 ? 0 : 1 : 0.5,
    originY: isHorizontal ? 0.5 : normalizedOffset < 0 ? 0 : 1,
    x: isHorizontal ? `${normalizedOffset * -25}%` : 0,
    y: isHorizontal ? 0 : `${normalizedOffset * -25}%`,
    z: -Math.abs(normalizedOffset,),
    scale: 1 - Math.abs(normalizedOffset / 10,),
  };
}
function calcPileAxisOffset(offset, length,) {
  return offset * length - offset * 8;
}
function pileEffect(info,) {
  const { normalizedOffset, direction, size: size2, } = info;
  const isHorizontal = direction === 'horizontal';
  const absoluteOffset = Math.abs(normalizedOffset,);
  return {
    x: normalizedOffset < 0 && isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.width,) : 0,
    y: normalizedOffset < 0 && !isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.height,) : 0,
    scale: normalizedOffset < 0 ? 1 - absoluteOffset / 50 : 1,
  };
}
function wheelEffect(info,) {
  const { normalizedOffset, direction, size: size2, } = info;
  const isHorizontal = direction === 'horizontal';
  const originZ = (isHorizontal ? size2.width : size2.height) * 18 / (2 * Math.PI);
  const rotateX = isHorizontal ? 0 : normalizedOffset * -20;
  const rotateY = isHorizontal ? normalizedOffset * 20 : 0;
  const y = isHorizontal ? 0 : normalizedOffset * -size2.height;
  const x = isHorizontal ? normalizedOffset * -size2.width : 0;
  return {
    opacity: 1 - Math.abs(normalizedOffset,) / 4,
    transform: `translate(${x}px, ${y}px) translateZ(-${originZ}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${originZ}px)`,
  };
}
function getDefaultEffect(type,) {
  switch (type) {
    case 'cube':
      return cubeEffect;
    case 'coverflow':
      return coverflowEffect;
    case 'pile':
      return pileEffect;
    case 'wheel':
      return wheelEffect;
    default:
      return null;
  }
}
function nearestPageIndex(pageRects, startPosition, endPosition, isHorizontalDirection, allowSkippingPages,) {
  const distanceToStart = function (rect,) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + startPosition,);
  };
  const distanceToEnd = function (rect,) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + endPosition,);
  };
  if (allowSkippingPages) {
    const closestPages = [...pageRects,].sort((a, b,) => distanceToEnd(a,) - distanceToEnd(b,));
    if (!closestPages[0]) {
      return -1;
    }
    return pageRects.indexOf(closestPages[0],);
  } else {
    const closestToStart = [...pageRects,].sort((a, b,) => distanceToStart(a,) - distanceToStart(b,));
    if (closestToStart.length === 1 && closestToStart[0]) {
      return pageRects.indexOf(closestToStart[0],);
    }
    const pageA = closestToStart[0];
    const pageB = closestToStart[1];
    if (!pageA || !pageB) {
      return -1;
    }
    const closestPages = [pageA, pageB,].sort((a, b,) => distanceToEnd(a,) - distanceToEnd(b,));
    if (!closestPages[0]) {
      return -1;
    }
    return pageRects.indexOf(closestPages[0],);
  }
}
function getPageContentRects(containerRef, containerSize, direction, gap,) {
  var _a;
  const containerElement = containerRef.current;
  if (!containerElement) {
    return;
  }
  const contentWrappers = [];
  (_a = containerElement.firstChild) == null ? void 0 : _a.childNodes.forEach((node,) => {
    const childNode = node.firstChild;
    if (!(childNode instanceof HTMLElement)) {
      return;
    }
    const componentType = childNode.getAttribute('data-framer-component-type',);
    if (componentType === pageContentWrapperType) {
      contentWrappers.push(childNode,);
    }
  },);
  const sizes = [];
  contentWrappers.forEach((contentWrapper,) => {
    if (contentWrapper instanceof HTMLElement && contentWrapper.firstChild instanceof HTMLElement) {
      let width = contentWrapper.firstChild.offsetWidth;
      let height = contentWrapper.firstChild.offsetHeight;
      if (import_process3.default.env.NODE_ENV === 'test') {
        width = 100;
        height = 100;
      }
      sizes.push({ width, height, },);
    } else {
      sizes.push(null,);
    }
  },);
  let maxX = 0;
  let maxY = 0;
  const isHorizontal = direction === 'horizontal';
  return sizes.map((queriedSize,) => {
    const size2 = queriedSize || containerSize;
    const x = maxX;
    const y = maxY;
    if (isHorizontal) {
      maxX += size2.width + gap;
    } else {
      maxY += size2.height + gap;
    }
    return { ...size2, x, y, };
  },);
}
function getMaxOffset(containerSize, pageContentRects, direction, paddingProps,) {
  const lastPageRect = pageContentRects[pageContentRects.length - 1];
  if (!lastPageRect) {
    return 0;
  }
  const paddingSides = paddingFromProps(paddingProps,);
  const isHorizontal = direction === 'horizontal';
  const paddingStart = isHorizontal ? paddingSides.left : paddingSides.top;
  const paddingEnd = isHorizontal ? paddingSides.right : paddingSides.bottom;
  const pageWidth = isHorizontal ? lastPageRect.width : lastPageRect.height;
  const containerWidth = isHorizontal ? containerSize.width : containerSize.height;
  const freeSpace = containerWidth - paddingStart - paddingEnd - pageWidth;
  const target = isHorizontal ? lastPageRect.x : lastPageRect.y;
  if (freeSpace <= 0) {
    return Math.max(target, 0,);
  }
  return Math.max(target - freeSpace, 0,);
}
function offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef,) {
  const pageIndex = Math.max(0, Math.min(pageCount - 1, index,),);
  const currentPageRect = pageRectsRef.current[pageIndex];
  if (!currentPageRect) {
    return 0;
  }
  if (isHorizontal) {
    return -Math.min(currentPageRect.x, maxOffsetRef.current,);
  } else {
    return -Math.min(currentPageRect.y, maxOffsetRef.current,);
  }
}
function useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal,) {
  return (pageIndex, offset, options,) => {
    currentContentPageRef.current = pageIndex;
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    if (!options || !options.animated) {
      contentOffset.set(offset,);
      return;
    }
    const axis = isHorizontal ? 'x' : 'y';
    const value = contentOffsetRef.current[axis];
    value.set(contentOffset.get(),);
    animate(value, offset, {
      type: 'spring',
      velocity: contentOffset.getVelocity(),
      stiffness: 500,
      damping: 50,
    },);
  };
}
function getBoundedCurrentPage(pageIndex, pageCount,) {
  return pageIndex >= 0 ? Math.min(pageIndex, pageCount - 1,) : (pageIndex % pageCount + pageCount) % pageCount;
}
function effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef,) {
  const {
    direction: latestDirection = 'horizontal',
    defaultEffect: latestDefaultEffect,
    effect: latestEffect,
    gap: latestGap = 10,
  } = latestPropsRef.current;
  const latestIsHorizontal = latestDirection === 'horizontal';
  const pageRect = pageRectsRef.current[index] || {
    x: latestIsHorizontal ? index * 200 + latestGap : 0,
    y: latestIsHorizontal ? 0 : index * 200 + latestGap,
    width: 200,
    height: 200,
  };
  const effectFunction = latestEffect || getDefaultEffect(latestDefaultEffect,);
  if (!effectFunction) {
    return null;
  }
  let offset;
  let normalizedOffset;
  const contentOffset = contentOffsetRef.current;
  const maxScrollOffset = maxOffsetRef.current;
  if (latestIsHorizontal) {
    offset = Math.min(pageRect.x, maxScrollOffset,) + (contentOffset ? contentOffset.x.get() : 0);
    normalizedOffset = offset / (pageRect.width + latestGap);
  } else {
    offset = Math.min(pageRect.y, maxScrollOffset,) + (contentOffset ? contentOffset.y.get() : 0);
    normalizedOffset = offset / (pageRect.height + latestGap);
  }
  const size2 = { width: pageRect.width, height: pageRect.height, };
  return effectFunction({
    offset,
    normalizedOffset,
    size: size2,
    index,
    direction: latestDirection,
    gap: latestGap,
    pageCount: pageRectsRef.current.length,
  },);
}
function hasEffect(props,) {
  return !!props.effect || !!getDefaultEffect(props.defaultEffect,);
}
function updateCurrentPage(newPageIndex, currentContentPageRef, onChangePage,) {
  if (currentContentPageRef.current === newPageIndex) {
    return;
  }
  if (onChangePage) {
    onChangePage(newPageIndex, currentContentPageRef.current,);
  }
  currentContentPageRef.current = newPageIndex;
}
var Page3 = /* @__PURE__ */ (() => {
  const ContentDimension = {
    Auto: 'auto',
    Stretch: 'stretch',
  };
  const pageContentDimensionOptions = [ContentDimension.Auto, ContentDimension.Stretch,];
  const pageContentDimensionTitles = /* @__PURE__ */ pageContentDimensionOptions.map((option,) => {
    switch (option) {
      case ContentDimension.Auto:
        return 'Auto';
      case ContentDimension.Stretch:
        return 'Stretch';
    }
  },);
  const pageEffectOptions = ['none', 'cube', 'coverflow', 'wheel', 'pile',];
  const pageEffectTitles = /* @__PURE__ */ pageEffectOptions.map((option,) => {
    switch (option) {
      case 'none':
        return 'None';
      case 'cube':
        return 'Cube';
      case 'coverflow':
        return 'Cover Flow';
      case 'wheel':
        return 'Wheel';
      case 'pile':
        return 'Pile';
    }
  },);
  const pageAlignmentOptions = ['start', 'center', 'end',];
  const genericAlignmentTitles = /* @__PURE__ */ pageAlignmentOptions.map((option,) => {
    switch (option) {
      case 'start':
        return 'Start';
      case 'center':
        return 'Center';
      case 'end':
        return 'End';
    }
  },);
  Page.defaultProps = {
    gap: 10,
    directionLock: false,
  };
  addPropertyControls(Page, {
    direction: {
      type: 'enum',
      options: ['horizontal', 'vertical',],
      title: 'Direction',
      defaultValue: 'horizontal',
      displaySegmentedControl: true,
      optionIcons: ['direction-horizontal', 'direction-vertical',],
    },
    directionLock: {
      type: 'boolean',
      title: 'Lock',
      enabledTitle: '1 Axis',
      disabledTitle: 'Off',
      defaultValue: true,
    },
    contentWidth: {
      type: 'enum',
      options: pageContentDimensionOptions,
      optionTitles: pageContentDimensionTitles,
      title: 'Width',
      defaultValue: ContentDimension.Stretch,
      displaySegmentedControl: true,
    },
    contentHeight: {
      type: 'enum',
      options: pageContentDimensionOptions,
      optionTitles: pageContentDimensionTitles,
      title: 'Height',
      defaultValue: ContentDimension.Stretch,
      displaySegmentedControl: true,
    },
    alignment: {
      type: 'enum',
      options: pageAlignmentOptions,
      optionTitles: genericAlignmentTitles,
      title: 'Align',
      hidden(props,) {
        const { direction, contentWidth, contentHeight, } = props;
        const isHorizontalDirection = direction === 'horizontal';
        const crossDimension = isHorizontalDirection ? contentHeight : contentWidth;
        return crossDimension === ContentDimension.Stretch;
      },
      defaultValue: 'start',
      displaySegmentedControl: true,
      optionIcons: {
        direction: {
          horizontal: ['align-top', 'align-middle', 'align-bottom',],
          vertical: ['align-left', 'align-center', 'align-right',],
        },
      },
    },
    gap: {
      type: 'number',
      min: 0,
      title: 'Gap',
      defaultValue: 0,
    },
    padding: {
      type: 'fusednumber',
      toggleKey: 'paddingPerSide',
      toggleTitles: ['Padding', 'Padding per side',],
      valueKeys: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',],
      valueLabels: ['T', 'R', 'B', 'L',],
      min: 0,
      title: 'Padding',
      defaultValue: 0,
    },
    overflow: {
      type: 'enum',
      title: 'Overflow',
      defaultValue: 'hidden',
      options: ['visible', 'hidden',],
      optionTitles: ['Visible', 'Hidden',],
      displaySegmentedControl: true,
    },
    currentPage: {
      type: 'number',
      min: 0,
      title: 'Current',
      displayStepper: true,
      defaultValue: 0,
    },
    momentum: {
      type: 'boolean',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      title: 'Momentum',
      defaultValue: false,
    },
    dragEnabled: {
      type: 'boolean',
      title: 'Drag',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      defaultValue: true,
    },
    wheelEnabled: {
      type: 'boolean',
      title: 'Wheel',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      defaultValue: false,
    },
    defaultEffect: {
      type: 'enum',
      options: pageEffectOptions,
      optionTitles: pageEffectTitles,
      title: 'Effect',
      defaultValue: 'none',
    },
    children: {
      type: 'array',
      title: 'Content',
      control: { type: 'componentinstance', title: 'Page', },
    },
  },);
  Page.supportsConstraints = true;
  return Page;
})();
function stateName(state,) {
  switch (state) {
    case 2:
      return 'Possible';
    case 4:
      return 'Began';
    case 8:
      return 'Changed';
    case 16:
      return 'Ended';
    case 32:
      return 'Failed';
    case 64:
      return 'Cancelled';
    case 128:
      return 'Recognized';
    default:
      return 'Unknown';
  }
}
function containsBitmask(value, bitmask,) {
  return (value & bitmask) !== 0;
}
var GestureRecognizer = class {
  constructor() {
    __publicField(
      this,
      '_state',
      2,
      /* Possible */
    );
    __publicField(this, 'handler',);
    __publicField(this, 'preventers', [],);
  }
  get state() {
    return this._state;
  }
  setState(state,) {
    this._state = state;
  }
  get isPrevented() {
    let prevented = false;
    for (const recognizer of this.preventers) {
      if (recognizer.state & (4 | 8 | 16)) {
        prevented = true;
        break;
      }
    }
    return prevented;
  }
  canBePreventedBy(recognizer,) {
    this.preventers.push(recognizer,);
  }
  hasState(bitmask,) {
    return containsBitmask(this.state, bitmask,);
  }
  stateSwitch(newState,) {
    let allowedStates;
    switch (this.state) {
      case 2:
        allowedStates = 4 | 128 | 32;
        break;
      case 4:
        allowedStates = 8 | 64 | 16;
        break;
      case 8:
        allowedStates = 8 | 64 | 16;
        break;
      case 128:
      case 16:
      case 64:
      case 32:
        allowedStates = 2;
        break;
      default:
        allowedStates = 0;
    }
    if (!containsBitmask(newState, allowedStates,)) {
      console.warn(`Unallowed state change from ${stateName(this.state,)} to ${stateName(newState,)}`,);
      return;
    }
    this.setState(newState,);
  }
  cancel() {
    if (
      this.hasState(
        4 | 8,
        /* Changed */
      )
    ) {
      this.setState(
        64,
        /* Cancelled */
      );
    }
    this.reset();
  }
  reset() {
    if (
      !this.hasState(
        2,
        /* Possible */
      )
    ) {
      this.stateSwitch(
        2,
        /* Possible */
      );
    }
  }
};
var MouseWheelGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments,);
    __publicField(this, 'startEvent',);
    __publicField(this, 'eventType', 'mousewheel',);
    __publicField(
      this,
      'onMouseWheelEnd',
      debounce((event,) => {
        if (this.handler && this.startEvent) {
          this.stateSwitch(
            16,
            /* Ended */
          );
          this.handler.gestureEnded(this.eventType, event, this.startEvent.target,);
          this.startEvent = null;
          this.reset();
        }
      }, 300,),
    );
  }
  pointerSessionBegan(session, event,) {
  }
  pointerSessionMoved(session, event,) {
  }
  pointerSessionEnded(session, event,) {
  }
  mouseWheel(session, event,) {
    if (!this.handler) {
      return;
    }
    if (
      this.hasState(
        2,
        /* Possible */
      )
    ) {
      this.startEvent = event;
      this.stateSwitch(
        4,
        /* Began */
      );
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target,);
      return;
    }
    if (
      this.hasState(
        4 | 8,
        /* Changed */
      ) && this.startEvent
    ) {
      this.stateSwitch(
        8,
        /* Changed */
      );
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target,);
    }
    this.onMouseWheelEnd(event,);
  }
};
var PanGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments,);
    __publicField(this, 'startEvent',);
    __publicField(this, 'eventType', 'pan',);
  }
  pointerSessionBegan(session, event,) {
    this.recognize(session, event,);
  }
  pointerSessionMoved(session, event,) {
    this.recognize(session, event,);
  }
  pointerSessionEnded(session, event,) {
    this.panend(event,);
  }
  recognize(session, event,) {
    if (Math.abs(event.delta.x,) > 0 || Math.abs(event.delta.y,) > 0) {
      if (this.startEvent) {
        this.pan(event,);
      } else {
        this.panstart(event,);
      }
    }
  }
  reset() {
    this.startEvent = null;
    super.reset();
  }
  panstart(event,) {
    if (
      !this.hasState(
        2,
        /* Possible */
      ) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick
    ) {
      return;
    }
    this.stateSwitch(
      4,
      /* Began */
    );
    this.startEvent = event;
    if (this.handler && this.startEvent.target) {
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target,);
    }
  }
  pan(event,) {
    if (
      !this.hasState(
        4 | 8,
        /* Changed */
      )
    ) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(
      8,
      /* Changed */
    );
    if (this.handler && this.startEvent.target) {
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target,);
    }
  }
  panend(event,) {
    if (
      !this.hasState(
        4 | 8,
        /* Changed */
      )
    ) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(
      16,
      /* Ended */
    );
    if (this.handler && this.startEvent.target) {
      this.handler.gestureEnded(this.eventType, event, this.startEvent.target,);
    }
  }
};
var TapGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments,);
    __publicField(this, 'eventType', 'tap',);
  }
  pointerSessionBegan(session, event,) {
    if (this.handler && (event.isLeftMouseClick === void 0 || event.isLeftMouseClick)) {
      this.handler.gestureBegan(this.eventType, event, null,);
    }
  }
  pointerSessionMoved(session, event,) {
  }
  pointerSessionEnded(session, event,) {
    if (this.isPrevented) {
      this.stateSwitch(
        32,
        /* Failed */
      );
    } else if (!session.startEvent || session.startEvent.target === event.target) {
      this.stateSwitch(
        128,
        /* Recognized */
      );
      if (this.handler) {
        this.handler.gestureChanged(this.eventType, event, null,);
      }
    } else {
      this.stateSwitch(
        32,
        /* Failed */
      );
    }
    if (this.handler) {
      this.handler.gestureEnded(this.eventType, event, null,);
    }
  }
};
var FramerEventSession = class {
  constructor(dispatcher, customOrigin,) {
    __publicField(this, 'events', [],);
    __publicField(this, 'recognizers', [],);
    __publicField(this, 'mouseWheelRecognizer', new MouseWheelGestureRecognizer(),);
    __publicField(this, 'dispatcher',);
    __publicField(this, 'originElement',);
    this.dispatcher = dispatcher;
    if (customOrigin) {
      this.originElement = customOrigin;
    } else {
      this.originElement = document.body;
    }
    const pan = new PanGestureRecognizer();
    const tap = new TapGestureRecognizer();
    pan.handler = this;
    tap.handler = this;
    this.mouseWheelRecognizer.handler = this;
    this.recognizers = [tap, pan,];
  }
  get isStarted() {
    return this.events.length !== 0;
  }
  get startEvent() {
    return this.isStarted ? this.events[0] : void 0;
  }
  get lastEvent() {
    return this.events[this.events.length - 1];
  }
  // Event handling
  processEvent(event,) {
    this.events.push(event,);
    return event;
  }
  pointerDown(event,) {
    if (this.isStarted) {
      return;
    }
    this.processEvent(event,);
    this.recognizers.map((r,) => {
      r.cancel();
      r.pointerSessionBegan(this, event,);
    },);
  }
  pointerMove(event,) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event,);
    this.recognizers.map((r,) => {
      r.pointerSessionMoved(this, event,);
    },);
  }
  pointerUp(event,) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event,);
    this.recognizers.map((r,) => {
      r.pointerSessionEnded(this, event,);
    },);
    this.clearEvents();
    this.recognizers.map((r,) => {
      r.reset();
    },);
  }
  mouseWheel(event,) {
    this.processEvent(event,);
    this.mouseWheelRecognizer.mouseWheel(this, event,);
    this.clearEvents();
  }
  clearEvents() {
    this.events = [];
  }
  dispatch(type, event, target = null,) {
    const dispatchTarget = target || this.startEvent && this.startEvent.target || event.target;
    if (dispatchTarget) {
      this.dispatcher(type, event, dispatchTarget,);
    }
  }
  // Gesture Handler
  gestureBegan(type, event, target,) {
    this.dispatch(`${type}start`, event, target,);
  }
  gestureChanged(type, event, target,) {
    this.dispatch(type, event, target,);
  }
  gestureEnded(type, event, target,) {
    this.dispatch(`${type}end`, event, target,);
  }
  // Calculatinos
  /**
   * Average velocity over last n seconds in pixels per second.
   * @param n - number of events to use for calculation
   */
  velocity(t = Loop.TimeStep * 2,) {
    var _a;
    if (!this.isStarted || this.events.length < 2) {
      return { x: 0, y: 0, };
    }
    const events2 = this.events;
    let i = events2.length - 1;
    let event = null;
    while (i >= 0) {
      event = (_a = events2[i]) != null ? _a : null;
      if (!event || MainLoop.time - event.loopTime > t) {
        break;
      }
      i--;
    }
    if (!event) {
      return { x: 0, y: 0, };
    }
    const current = events2[events2.length - 1];
    if (!current) {
      return { x: 0, y: 0, };
    }
    const time22 = (MainLoop.time - event.loopTime) * 1e3;
    if (time22 === 0) {
      return { x: 0, y: 0, };
    }
    const velocity = {
      x: (current.devicePoint.x - event.devicePoint.x) / time22,
      y: (current.devicePoint.y - event.devicePoint.y) / time22,
    };
    if (velocity.x === Infinity) {
      velocity.x = 0;
    }
    if (velocity.y === Infinity) {
      velocity.y = 0;
    }
    return velocity;
  }
  offset(event,) {
    if (!this.startEvent) {
      return { x: 0, y: 0, };
    }
    const subtract = (pointA, pointB,) => {
      return {
        x: pointA.x - pointB.x,
        y: pointA.y - pointB.y,
      };
    };
    return subtract(event.devicePoint, this.startEvent.devicePoint,);
  }
};
var MouseEventListener = class extends Component8 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'domMouseDown', (originalEvent,) => {
      safeWindow.addEventListener('mousemove', this.domMouseMove,);
      safeWindow.addEventListener('mouseup', this.domMouseUp,);
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerDown(event,);
    },);
    __publicField(this, 'domMouseMove', (originalEvent,) => {
      const leftMouseButtonOnlyDown = originalEvent.buttons === void 0 ? originalEvent.which === 1 : originalEvent.buttons === 1;
      if (!leftMouseButtonOnlyDown) {
        this.domMouseUp(originalEvent,);
        return;
      }
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerMove(event,);
    },);
    __publicField(this, 'domMouseUp', (originalEvent,) => {
      safeWindow.removeEventListener('mousemove', this.domMouseMove,);
      safeWindow.removeEventListener('mouseup', this.domMouseUp,);
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerUp(event,);
    },);
    __publicField(this, 'domMouseWheel', (originalEvent,) => {
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.mouseWheel(event,);
    },);
  }
  /**
   * @internal
   */
  render() {
    return this.props.children;
  }
  /**
   * @internal
   */
  componentDidMount() {
    safeWindow.addEventListener('mousedown', this.domMouseDown,);
    safeWindow.addEventListener('wheel', this.domMouseWheel,);
  }
  /**
   * @internal
   */
  componentWillUnmount() {
    safeWindow.removeEventListener('mousemove', this.domMouseMove,);
    safeWindow.removeEventListener('mousedown', this.domMouseDown,);
    safeWindow.removeEventListener('mouseup', this.domMouseUp,);
    safeWindow.removeEventListener('wheel', this.domMouseWheel,);
  }
};
var TouchEventListener = class extends Component9 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'domTouchStart', (originalEvent,) => {
      safeWindow.addEventListener('touchmove', this.domTouchMove,);
      safeWindow.addEventListener('touchend', this.domTouchEnd,);
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerDown(event,);
    },);
    __publicField(this, 'domTouchMove', (originalEvent,) => {
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerMove(event,);
    },);
    __publicField(this, 'domTouchEnd', (originalEvent,) => {
      safeWindow.removeEventListener('touchmove', this.domTouchMove,);
      safeWindow.removeEventListener('touchend', this.domTouchEnd,);
      const event = new FramerEvent(originalEvent, this.props.session,);
      this.props.session.pointerUp(event,);
    },);
  }
  /**
   * @internal
   */
  render() {
    return this.props.children;
  }
  /**
   * @internal
   */
  componentDidMount() {
    safeWindow.addEventListener('touchstart', this.domTouchStart,);
  }
  /**
   * @internal
   */
  componentWillUnmount() {
    safeWindow.removeEventListener('touchstart', this.domTouchStart,);
    safeWindow.removeEventListener('touchmove', this.domTouchMove,);
    safeWindow.removeEventListener('touchend', this.domTouchEnd,);
  }
};
var FramerEventListener = /* @__PURE__ */ environment.isTouch() ? TouchEventListener : MouseEventListener;
var directionMap = {
  horizontal: 'x',
  vertical: 'y',
  both: true,
};
function convertScrollDirectionToDrag(scrollDirection,) {
  return scrollDirection ? directionMap[scrollDirection] : scrollDirection;
}
var useUpdateChildSize = ({
  dragDirection,
  children,
  fromCanvasComponent,
},) => {
  return useMemo32(() => {
    return React522.Children.map(children, (child,) => {
      if (child === null || typeof child !== 'object' || typeof child.type === 'string') {
        return child;
      }
      const updatedSize = {};
      switch (dragDirection) {
        case 'vertical':
          updatedSize.width = '100%';
          break;
        case 'horizontal':
          updatedSize.height = '100%';
          break;
        default:
          return child;
      }
      const update = fromCanvasComponent ? { style: Object.assign({}, child.props.style, updatedSize,), } : updatedSize;
      return React522.cloneElement(child, update,);
    },);
  }, [dragDirection, children,],);
};
var numberFromOptionalMotionValue = (value,) => {
  return typeof value === 'number' ? value : value.get();
};
var EmulatedScroll = /* @__PURE__ */ React522.forwardRef(
  function EmulatedScroll2(props, forwardedRef,) {
    const {
      direction = 'vertical',
      directionLock = false,
      dragEnabled = true,
      dragElastic,
      dragMomentum,
      dragTransition,
      wheelEnabled = true,
      contentOffsetX = 0,
      contentOffsetY = 0,
      contentWidth,
      contentHeight,
      onScrollStart,
      onScroll,
      onScrollEnd,
      onDragStart,
      onDrag,
      onDragEnd,
      onUpdate,
      onDirectionLock,
      style,
      children,
      scrollAnimate,
      resetOffset,
      overdragEnabled = true,
      layoutId: specificLayoutId,
      native,
      ...containerProps
    } = props;
    const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'scroll', },);
    const defaultX = useMotionValue(typeof contentOffsetX === 'number' ? contentOffsetX : 0,);
    const defaultY = useMotionValue(typeof contentOffsetY === 'number' ? contentOffsetY : 0,);
    const x = isMotionValue2(contentOffsetX,) ? contentOffsetX : defaultX;
    const y = isMotionValue2(contentOffsetY,) ? contentOffsetY : defaultY;
    const measuredConstraints = useRef92(null,);
    const dragControls = useDragControls();
    const isInTarget = useIsInCurrentNavigationTarget();
    const wasInTargetRef = useRef92(true,);
    useInsertionEffect5(() => {
      injectComponentCSSRules();
    }, [],);
    function setMeasureDragConstraints(constraints,) {
      constraints = offsetToZero(constraints,);
      if (contentWidth !== void 0) {
        constraints.left = -contentWidth;
      }
      if (contentHeight !== void 0) {
        constraints.top = -contentHeight;
      }
      return measuredConstraints.current = constraints;
    }
    const { initial, prev, } = useRef92({
      initial: { x: 0, y: 0, },
      prev: { x: 0, y: 0, },
    },).current;
    const isPreview = RenderTarget.current() === 'PREVIEW';
    const containerFallbackRef = useRef92(null,);
    const containerRef = forwardedRef || containerFallbackRef;
    const contentRef = useRef92(null,);
    const lastOffsetRef = useRef92(null,);
    function shouldResetScroll(inTarget,) {
      const hasEnteredTarget = inTarget && wasInTargetRef.current === false;
      return resetOffset && hasEnteredTarget;
    }
    function measureAndUpdateScrollOffset() {
      if (!contentRef.current || !containerRef.current) {
        return;
      }
      const mustReset = shouldResetScroll(isInTarget,);
      wasInTargetRef.current = isInTarget;
      const previous = lastOffsetRef.current;
      if (previous === null && contentOffsetX === void 0 && contentOffsetY === void 0) {
        return;
      }
      const shouldUpdateOffset = previous === null || !isMotionValue2(contentOffsetX,) && contentOffsetX !== previous.offsetX ||
        !isMotionValue2(contentOffsetY,) && contentOffsetY !== previous.offsetY;
      const currentMaxXOffset = contentRef.current.offsetWidth - containerRef.current.offsetWidth;
      const currentMaxYOffset = contentRef.current.offsetHeight - containerRef.current.offsetHeight;
      const hasSizeChanged = currentMaxXOffset !== (previous == null ? void 0 : previous.maxXOffset) ||
        currentMaxYOffset !== (previous == null ? void 0 : previous.maxYOffset);
      const hasScrollOffsetChanged = (previous == null ? void 0 : previous.x) !== x.get() ||
        (previous == null ? void 0 : previous.y) !== y.get();
      const shouldStayPinned = hasSizeChanged && !hasScrollOffsetChanged;
      if (mustReset || shouldUpdateOffset || shouldStayPinned) {
        const currentOffsetX = direction !== 'vertical' ? numberFromOptionalMotionValue(contentOffsetX,) : 0;
        const currentOffsetY = direction !== 'horizontal' ? numberFromOptionalMotionValue(contentOffsetY,) : 0;
        const nextXOffset = -Math.min(currentOffsetX, currentMaxXOffset,);
        const nextYOffset = -Math.min(currentOffsetY, currentMaxYOffset,);
        x.set(nextXOffset,);
        y.set(nextYOffset,);
        lastOffsetRef.current = {
          maxXOffset: currentMaxXOffset,
          maxYOffset: currentMaxYOffset,
          offsetX: currentOffsetX,
          offsetY: currentOffsetY,
          x: nextXOffset,
          y: nextYOffset,
        };
      }
    }
    useIsomorphicLayoutEffect2(() => {
      if (RenderTarget.current() !== 'CANVAS') {
        return;
      }
      measureAndUpdateScrollOffset();
    },);
    useIsomorphicLayoutEffect2(() => {
      if (RenderTarget.current() === 'CANVAS') {
        return;
      }
      measureAndUpdateScrollOffset();
    }, [],);
    React522.useEffect(() => {
      if (shouldResetScroll(isInTarget,)) {
        measureAndUpdateScrollOffset();
      }
      if (isInTarget === false) {
        wasInTargetRef.current = false;
      }
    }, [isInTarget,],);
    const getLatestPoint = () => ({ x: x.get(), y: y.get(), });
    const resetInitialPoint = useCallback6(() => {
      const point2 = getLatestPoint();
      initial.x = point2.x;
      initial.y = point2.y;
      prev.x = point2.x;
      prev.y = point2.y;
    }, [],);
    const getPointData = useCallback6(() => {
      const point2 = getLatestPoint();
      const data2 = {
        point: point2,
        velocity: { x: x.getVelocity(), y: y.getVelocity(), },
        offset: { x: point2.x - initial.x, y: point2.y - initial.y, },
        delta: { x: point2.x - prev.x, y: point2.y - prev.y, },
      };
      prev.x = point2.x;
      prev.y = point2.y;
      return data2;
    }, [x, y,],);
    const updateScrollListeners = useCallback6(() => {
      onUpdate && onUpdate({ x: x.get(), y: y.get(), },);
      onScroll && onScroll(getPointData(),);
    }, [onScroll, onUpdate, getPointData, x, y,],);
    const scheduleUpdateScrollListeners = useCallback6(() => {
      frame.update(updateScrollListeners, false, true,);
    }, [updateScrollListeners,],);
    const onMotionDragStart = (event, info,) => {
      resetInitialPoint();
      onDragStart && onDragStart(event, info,);
      onScrollStart && onScrollStart(info,);
    };
    const onMotionDragTransitionEnd = () => onScrollEnd && onScrollEnd(getPointData(),);
    const onWheelScrollStart = (info,) => {
      onScrollStart == null ? void 0 : onScrollStart(info,);
    };
    useWheelScroll(containerRef, {
      enabled: wheelEnabled,
      initial,
      prev,
      direction,
      offsetX: x,
      offsetY: y,
      onScrollStart: onWheelScrollStart,
      onScroll,
      onScrollEnd,
      constraints: measuredConstraints,
    },);
    const overdragX = useMotionValue(0,);
    const overdragY = useMotionValue(0,);
    useIsomorphicLayoutEffect2(() => {
      const setScrollX = (xValue,) => {
        const element = containerRef.current;
        if (!(element instanceof HTMLDivElement)) {
          return;
        }
        element.scrollLeft = -xValue;
        const constraints = measuredConstraints.current;
        if (constraints && overdragEnabled) {
          let overdragXValue = 0;
          if (xValue > constraints.right) {
            overdragXValue = xValue;
          }
          if (xValue < constraints.left) {
            overdragXValue = xValue - constraints.left;
          }
          overdragX.set(overdragXValue,);
        }
        scheduleUpdateScrollListeners();
      };
      const currentX = x.get();
      if (currentX !== 0) {
        setScrollX(currentX,);
      }
      return x.on('change', setScrollX,);
    }, [x, overdragX, scheduleUpdateScrollListeners, overdragEnabled,],);
    useIsomorphicLayoutEffect2(() => {
      const setScrollY = (yValue,) => {
        const element = containerRef.current;
        if (!(element instanceof HTMLDivElement)) {
          return;
        }
        element.scrollTop = -yValue;
        const constraints = measuredConstraints.current;
        if (constraints && overdragEnabled) {
          let overdragYValue = 0;
          if (yValue > constraints.bottom) {
            overdragYValue = yValue;
          }
          if (yValue < constraints.top) {
            overdragYValue = yValue - constraints.top;
          }
          overdragY.set(overdragYValue,);
        }
        scheduleUpdateScrollListeners();
      };
      const currentY = y.get();
      if (currentY !== 0) {
        setScrollY(currentY,);
      }
      return y.on('change', setScrollY,);
    }, [y, overdragY, scheduleUpdateScrollListeners, overdragEnabled,],);
    const nativeOnScroll = React522.useCallback(() => {
      const element = containerRef.current;
      if (!(element instanceof HTMLDivElement)) {
        return;
      }
      const xDelta = Math.abs(x.get() + element.scrollLeft,);
      const yDelta = Math.abs(y.get() + element.scrollTop,);
      if (xDelta > 1) {
        x.set(-element.scrollLeft,);
      }
      if (yDelta > 1) {
        y.set(-element.scrollTop,);
      }
    }, [x, y,],);
    const isEmpty2 = React522.Children.count(children,) === 0;
    const width = direction !== 'vertical' && !isEmpty2 ? 'auto' : '100%';
    const height = direction !== 'horizontal' && !isEmpty2 ? 'auto' : '100%';
    const size2 = !containerProps.__fromCanvasComponent
      ? {
        width: containerProps.__fromCodeComponentNode ? '100%' : containerProps.width,
        height: containerProps.__fromCodeComponentNode ? '100%' : containerProps.height,
      }
      : {};
    return /* @__PURE__ */ React522.createElement(
      FrameWithMotion,
      {
        'data-framer-component-type': 'Scroll',
        background: 'none',
        ...containerProps,
        ...size2,
        style: {
          ...style,
          willChange: isPreview ? 'transform' : void 0,
          // allows the scroll content to be hardware accelerated
          overflow: 'hidden',
        },
        onScroll: nativeOnScroll,
        preserve3d: containerProps.preserve3d,
        ref: containerRef,
        layoutId,
        layoutScroll: true,
        onBeforeLayoutMeasure: measureAndUpdateScrollOffset,
      },
      /* @__PURE__ */ React522.createElement(
        FrameWithMotion,
        {
          'data-framer-component-type': 'ScrollContentWrapper',
          animate: scrollAnimate,
          drag: dragEnabled && convertScrollDirectionToDrag(direction,),
          dragDirectionLock: directionLock,
          dragElastic,
          dragMomentum,
          dragTransition,
          dragConstraints: containerRef,
          dragControls,
          onDragStart: onMotionDragStart,
          onDrag,
          onDragEnd,
          onDragTransitionEnd: onMotionDragTransitionEnd,
          onDirectionLock,
          onMeasureDragConstraints: setMeasureDragConstraints,
          width,
          height,
          _dragX: x,
          _dragY: y,
          position: 'relative',
          x: overdragEnabled ? overdragX : void 0,
          y: overdragEnabled ? overdragY : void 0,
          ref: contentRef,
          style: {
            display: isEmpty2 ? 'block' : 'inline-block',
            willChange: isPreview ? 'transform' : void 0,
            // makes the scroll content hardware accelerated
            backgroundColor: 'transparent',
            overflow: 'visible',
            minWidth: '100%',
            minHeight: '100%',
          },
          preserve3d: containerProps.preserve3d,
        },
        /* @__PURE__ */ React522.createElement(
          EmptyState,
          {
            children,
            size: {
              width: isFiniteNumber(containerProps.width,) ? containerProps.width : '100%',
              height: isFiniteNumber(containerProps.height,) ? containerProps.height : '100%',
            },
            insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
            title: 'Scroll',
            description: 'Click and drag the connector to any frame on the canvas \u2192',
          },
        ),
        useUpdateChildSize({
          dragDirection: direction,
          children,
          fromCanvasComponent: containerProps.__fromCanvasComponent,
        },),
      ),
    );
  },
);
function offsetToZero({ top, left, right, bottom, },) {
  const width = right - left;
  const height = bottom - top;
  return {
    top: -height,
    left: -width,
    right: 0,
    bottom: 0,
  };
}
function cx(...classNames) {
  return classNames.filter(Boolean,).join(' ',);
}
function isRunningAnimation(...phases) {
  let runningAny = false;
  let cancelledAny = false;
  phases.forEach((phase,) => {
    runningAny = runningAny || phase === 1;
    cancelledAny = cancelledAny || phase === 3;
  },);
  return runningAny && !cancelledAny;
}
function didFinishAnimations(...phases) {
  return phases.every(
    (phase,) => phase === 0 || phase === 2,
    /* Completed */
  );
}
var timeConstant = 400;
function animatePointWithInertia({
  from,
  velocity,
  onUpdate,
  onComplete,
  onStop,
},) {
  const latest = from;
  let animationPhaseX = 0;
  let animationPhaseY = 0;
  const animations2 = [];
  const updateHandler = () => {
    if (isRunningAnimation(animationPhaseX, animationPhaseY,)) {
      onUpdate(latest,);
    }
  };
  const completionHandler = () => {
    if (didFinishAnimations(animationPhaseX, animationPhaseY,)) {
      onComplete();
    }
  };
  if (velocity.x) {
    animationPhaseX = 1;
    animations2.push(
      animateValue({
        keyframes: [from.x,],
        velocity: -velocity.x,
        timeConstant,
        onUpdate: (value,) => {
          latest.x = value;
          frame.update(updateHandler, false, true,);
        },
        onComplete: () => {
          if (animationPhaseX !== 1) {
            throw Error('animation x should be running when completing',);
          }
          animationPhaseX = 2;
          completionHandler();
        },
      },),
    );
  }
  if (velocity.y) {
    animationPhaseY = 1;
    animations2.push(
      animateValue({
        keyframes: [from.y,],
        velocity: -velocity.y,
        timeConstant,
        onUpdate: (value,) => {
          latest.y = value;
          frame.update(updateHandler, false, true,);
        },
        onComplete: () => {
          if (animationPhaseY !== 1) {
            throw Error('animation y should be running when completing',);
          }
          animationPhaseY = 2;
          completionHandler();
        },
      },),
    );
  }
  if (!isRunningAnimation(animationPhaseX, animationPhaseY,)) {
    completionHandler();
  }
  return {
    stop: () => {
      if (!isRunningAnimation(animationPhaseX, animationPhaseY,)) {
        return;
      }
      animations2.forEach((animation,) => animation.stop());
      animationPhaseX = animationPhaseX === 1 ? 3 : animationPhaseX;
      animationPhaseY = animationPhaseY === 1 ? 3 : animationPhaseY;
      onStop();
    },
  };
}
var scrollThreshold = 3;
var isTouchDevice = /* @__PURE__ */ isTouch();
var isSafariBrowser = /* @__PURE__ */ isSafari();
function getTouchAction(element,) {
  if (!(element instanceof HTMLElement)) {
    return null;
  }
  return element.style.touchAction;
}
function canPanInDirection(element, direction,) {
  switch (direction) {
    case 'horizontal':
      return getTouchAction(element,) === 'pan-x';
    case 'vertical':
      return getTouchAction(element,) === 'pan-y';
    default:
      return false;
  }
}
function isInteractiveElement(element,) {
  const tag = element.tagName.toLowerCase();
  if (tag === 'input') {
    return true;
  }
  if (tag === 'text') {
    return true;
  }
  if (tag === 'textarea') {
    return true;
  }
  return false;
}
function canStartScrollFromElement(element, direction,) {
  if (!(element instanceof Element)) {
    return false;
  }
  if (isInteractiveElement(element,)) {
    return false;
  }
  if (element.hasAttribute('draggable',)) {
    if (!canPanInDirection(element, direction,)) {
      return false;
    }
  }
  return true;
}
function getEventPoint(event,) {
  return {
    x: event.pageX,
    y: event.pageY,
  };
}
function setPointerEvents(element, value,) {
  if (element == null ? void 0 : element.style) {
    element.style['pointerEvents'] = value;
  }
}
function getPointerEvents(element,) {
  var _a;
  return (_a = element == null ? void 0 : element.style) == null ? void 0 : _a['pointerEvents'];
}
var emptyObject = {};
Object.freeze(emptyObject,);
function useEmulateTouchScroll(ref, direction, enabled,) {
  if (isTouchDevice) {
    return emptyObject;
  }
  if (RenderTarget.current() !== 'PREVIEW') {
    return emptyObject;
  }
  const scrollAnimationControlsRef = React53.useRef(null,);
  useEffect72(() => {
    if (!ref.current) {
      return;
    }
    const element = ref.current;
    let phase = 0;
    let targets = null;
    let downPoint = null;
    let scrollOffsetStart = null;
    let mouseMoveEvents = [];
    function onMouseMove(event,) {
      var _a;
      switch (phase) {
        case 0:
        case 4:
        case 3:
          return;
      }
      if (event.metaKey) {
        return;
      }
      const point2 = getEventPoint(event,);
      if (!downPoint) {
        return;
      }
      const offset = Point.subtract(point2, downPoint,);
      if (phase === 1 || phase === 5) {
        const deltaX = Math.abs(offset.x,);
        const deltaY = Math.abs(offset.y,);
        if ((deltaX > scrollThreshold || deltaY > scrollThreshold) && deltaX !== deltaY) {
          const scrollDirection = deltaX > deltaY ? 'horizontal' : 'vertical';
          const shouldIgnoreBecauseOfDirectionLock = direction === 'horizontal' && scrollDirection === 'vertical' ||
            direction === 'vertical' && scrollDirection === 'horizontal';
          if (shouldIgnoreBecauseOfDirectionLock) {
            phase = 3;
            return;
          }
          phase = 2;
          targets == null ? void 0 : targets.forEach(([target,],) => setPointerEvents(target, 'none',));
        }
      }
      if (isSafariBrowser) {
        event.preventDefault();
      }
      if (phase !== 2) {
        return;
      }
      (_a = safeWindow.getSelection()) == null ? void 0 : _a.empty();
      mouseMoveEvents = getRecentEvents([...mouseMoveEvents, event,],);
      if (scrollOffsetStart) {
        if (direction !== 'vertical') {
          element.scrollLeft = scrollOffsetStart.x - offset.x;
        }
        if (direction !== 'horizontal') {
          element.scrollTop = scrollOffsetStart.y - offset.y;
        }
      }
    }
    function onMouseUp(event,) {
      safeWindow.removeEventListener('mousemove', onMouseMove, false,);
      safeWindow.removeEventListener('mouseup', onMouseUp,);
      if (phase === 2 && targets) {
        targets.forEach(
          ([target, originalPointerEventsValue,],) => setPointerEvents(target, originalPointerEventsValue || 'auto',),
        );
      }
      targets = null;
      const velocity = calculateVelocity({ mouseMoveEvents, mouseUpEvent: event, },);
      downPoint = null;
      if (phase === 2) {
        const shouldAnimateY = direction !== 'horizontal' && velocity.y !== 0;
        const shouldAnimateX = direction !== 'vertical' && velocity.x !== 0;
        if (!shouldAnimateY && !shouldAnimateX) {
          phase = 0;
          return;
        }
        phase = 4;
        scrollAnimationControlsRef.current = animatePointWithInertia({
          from: { x: element.scrollLeft, y: element.scrollTop, },
          velocity: {
            x: shouldAnimateX ? velocity.x : 0,
            y: shouldAnimateY ? velocity.y : 0,
          },
          onUpdate: (position,) => {
            if (shouldAnimateX) {
              element.scrollLeft = position.x;
            }
            if (shouldAnimateY) {
              element.scrollTop = position.y;
            }
          },
          onStop: () => {
            if (phase !== 5) {
              phase = 0;
            }
            scrollAnimationControlsRef.current = null;
          },
          onComplete: () => {
            if (phase !== 4) {
              throw Error('On animation completion we should still be in the animation phase',);
            }
            phase = 0;
            scrollAnimationControlsRef.current = null;
          },
        },);
      } else {
        phase = 0;
      }
    }
    function onMouseWheel() {
      var _a;
      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
    }
    function onMouseDown(event,) {
      var _a;
      if (!enabled) {
        return;
      }
      if (event.metaKey) {
        return;
      }
      if (!canStartScrollFromElement(event.target, direction,)) {
        if (phase === 4) {
          phase = 0;
          (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
        }
        return;
      }
      const previousPhase = phase;
      phase = previousPhase === 4 ? 5 : 1;
      downPoint = getEventPoint(event,);
      targets = document.elementsFromPoint(downPoint.x, downPoint.y,).filter(
        (targetEl,) => targetEl instanceof HTMLElement || targetEl instanceof SVGElement,
      ).map((targetEl,) => [targetEl, getPointerEvents(targetEl,),]);
      scrollOffsetStart = { x: element.scrollLeft, y: element.scrollTop, };
      mouseMoveEvents = [];
      if (scrollAnimationControlsRef.current) {
        if (previousPhase !== 4) {
          throw Error('When stopping a drag animation we need to be animating',);
        }
        scrollAnimationControlsRef.current.stop();
      }
      safeWindow.addEventListener('mousemove', onMouseMove,);
      safeWindow.addEventListener('mouseup', onMouseUp,);
      element.addEventListener('mousewheel', onMouseWheel,);
    }
    element.addEventListener('mousedown', onMouseDown,);
    return () => {
      var _a;
      element.removeEventListener('mousedown', onMouseDown,);
      element.removeEventListener('mousewheel', onMouseWheel,);
      safeWindow.removeEventListener('mousemove', onMouseMove,);
      safeWindow.removeEventListener('mouseup', onMouseUp,);
      phase = 5;
      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
    };
  }, [ref, direction, enabled,],);
  return React53.useMemo(() => {
    return {
      cancelEmulatedTouchScrollAnimation: () => {
        var _a;
        (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();
      },
    };
  }, [],);
}
var timeDelta = 4 / 60 * 1e3;
function getRecentEvents(events2,) {
  const currentTime = new CustomEvent('getTime',).timeStamp;
  const maxAge = currentTime - timeDelta;
  return events2.filter((event,) => event.timeStamp > maxAge);
}
var zeroPoint = { x: 0, y: 0, };
function calculateVelocity({
  mouseMoveEvents,
  mouseUpEvent,
},) {
  const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents,);
  const oldestMouseMoveEvent = recentMouseMoveEvents[0];
  if (!oldestMouseMoveEvent) {
    return zeroPoint;
  }
  const deltaX = mouseUpEvent.clientX - oldestMouseMoveEvent.clientX;
  const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;
  const time22 = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;
  if (time22 === 0) {
    return zeroPoint;
  }
  return {
    x: deltaX / time22 * 1e3,
    y: deltaY / time22 * 1e3,
  };
}
function useUpdateScrollOffset(ref, side, offset, cancelEmulatedTouchScrollAnimation,) {
  useIsomorphicLayoutEffect2(
    () => {
      if (isMotionValue2(offset,)) {
        const updateScrollLeft = () => {
          cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
          const element = ref.current;
          if (element) {
            element[side] = Math.abs(offset.get(),);
          }
        };
        updateScrollLeft();
        return offset.on('change', updateScrollLeft,);
      } else if (isFiniteNumber(offset,)) {
        const element = ref.current;
        if (!element) {
          return;
        }
        cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
        element[side] = Math.abs(offset,);
      }
    },
    // We only want to update on contentOffset changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [offset,],
  );
}
var NativeScroll = /* @__PURE__ */ React54.forwardRef(function NativeScroll2(props, forwardedRef,) {
  const {
    direction = 'vertical',
    scrollBarVisible = false,
    dragEnabled = true,
    contentOffsetX = 0,
    contentOffsetY = 0,
    contentWidth,
    contentHeight,
    children,
    resetOffset,
    onScroll,
    className,
    // Not (yet) supported
    directionLock = false,
    wheelEnabled = true,
    scrollAnimate,
    dragTransition,
    dragMomentum,
    dragElastic,
    overdragEnabled = true,
    onScrollStart,
    onScrollEnd,
    onDragStart,
    onDrag,
    onDragEnd,
    onUpdate,
    onDirectionLock,
    layoutId: specificLayoutId,
    native,
    // Rest
    ...containerProps
  } = props;
  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: 'scroll', },);
  const fallbackRef = React54.useRef(null,);
  const ref = forwardedRef || fallbackRef;
  const { cancelEmulatedTouchScrollAnimation, } = useEmulateTouchScroll(ref, direction, dragEnabled,);
  useInsertionEffect22(() => {
    injectComponentCSSRules();
  }, [],);
  const isInTarget = useIsInCurrentNavigationTarget();
  const previousIsInTargetRef = React54.useRef(isInTarget,);
  const updateScrollOffsetHandler = () => {
    if (!resetOffset) {
      return;
    }
    const previousIsTarget = previousIsInTargetRef.current;
    previousIsInTargetRef.current = isInTarget;
    const shouldResetOffset = isInTarget && !previousIsTarget;
    if (!shouldResetOffset) {
      return;
    }
    const element = ref.current;
    if (!element) {
      return;
    }
    if (direction !== 'vertical') {
      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
      element.scrollLeft = Math.abs(isMotionValue2(contentOffsetX,) ? contentOffsetX.get() : contentOffsetX,);
    }
    if (direction !== 'horizontal') {
      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();
      element.scrollTop = Math.abs(isMotionValue2(contentOffsetY,) ? contentOffsetY.get() : contentOffsetY,);
    }
  };
  useIsomorphicLayoutEffect2(updateScrollOffsetHandler, [isInTarget,],);
  useUpdateScrollOffset(ref, 'scrollLeft', contentOffsetX, cancelEmulatedTouchScrollAnimation,);
  useUpdateScrollOffset(ref, 'scrollTop', contentOffsetY, cancelEmulatedTouchScrollAnimation,);
  const size2 = !containerProps.__fromCanvasComponent
    ? {
      width: containerProps.__fromCodeComponentNode ? '100%' : containerProps.width,
      height: containerProps.__fromCodeComponentNode ? '100%' : containerProps.height,
    }
    : {};
  return /* @__PURE__ */ React54.createElement(
    FrameWithMotion,
    {
      ref,
      'data-framer-component-type': 'NativeScroll',
      background: 'none',
      ...containerProps,
      ...size2,
      onScroll,
      layoutId,
      onBeforeLayoutMeasure: updateScrollOffsetHandler,
      layoutScroll: true,
      className: cx(className, `direction-${direction}`, !scrollBarVisible && 'scrollbar-hidden',),
    },
    /* @__PURE__ */ React54.createElement(
      EmptyState,
      {
        children,
        size: {
          width: isFiniteNumber(containerProps.width,) ? containerProps.width : '100%',
          height: isFiniteNumber(containerProps.height,) ? containerProps.height : '100%',
        },
        insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
        title: 'Scroll',
        description: 'Click and drag the connector to any frame on the canvas \u2192',
      },
    ),
    children,
  );
},);
var Scroll = /* @__PURE__ */ (() => {
  const ScrollInner = React55.forwardRef(function ScrollInner2(props, forwardedRef,) {
    if (props.native) {
      return /* @__PURE__ */ React55.createElement(NativeScroll, { ref: forwardedRef, ...props, },);
    } else {
      return /* @__PURE__ */ React55.createElement(EmulatedScroll, { ref: forwardedRef, ...props, },);
    }
  },);
  ScrollInner.defaultProps = {
    directionLock: false,
  };
  addPropertyControls(ScrollInner, {
    native: {
      type: 'boolean',
      defaultValue: false,
    },
    direction: {
      type: 'segmentedenum',
      title: 'Direction',
      options: ['vertical', 'horizontal', 'both',],
      defaultValue: 'vertical',
    },
    contentOffsetX: {
      type: 'number',
      title: 'Offset X',
      defaultValue: 0,
      min: 0,
      step: 10,
      displayStepper: true,
      hidden: ({ direction, },) => direction === 'vertical',
    },
    contentOffsetY: {
      type: 'number',
      title: 'Offset Y',
      defaultValue: 0,
      min: 0,
      step: 10,
      displayStepper: true,
      hidden: ({ direction, },) => direction === 'horizontal',
    },
    directionLock: {
      type: 'boolean',
      title: 'Lock',
      enabledTitle: '1 Axis',
      disabledTitle: 'Off',
      defaultValue: true,
      hidden: ({ native, },) => native === true,
    },
    dragEnabled: {
      type: 'boolean',
      title: 'Drag',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      defaultValue: true,
    },
    overdragEnabled: {
      type: 'boolean',
      title: 'Overdrag',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      defaultValue: true,
      hidden: ({ native, },) => native === true,
    },
    wheelEnabled: {
      type: 'boolean',
      title: 'Wheel',
      enabledTitle: 'On',
      disabledTitle: 'Off',
      defaultValue: true,
      hidden: ({ native, },) => native === true,
    },
    scrollBarVisible: {
      type: 'boolean',
      title: 'Scroll Bar',
      enabledTitle: 'Visible',
      disabledTitle: 'Hidden',
      defaultValue: false,
      hidden: ({ native, },) => native === false,
    },
    resetOffset: {
      type: 'boolean',
      title: 'Reset',
      defaultValue: false,
    },
  },);
  ScrollInner.supportsConstraints = true;
  return ScrollInner;
})();
function useNavigation() {
  return useContext92(NavigationContext,);
}
var data = /* @__PURE__ */ (() => {
  function Data2(initial = {},) {
    const _data = ObservableObject(initial, false, false,);
    Data2.addData(_data,);
    return _data;
  }
  Data2._stores = [];
  Data2.addData = (_data,) => {
    Data2._stores.push(_data,);
  };
  Data2.reset = () => {
    Data2._stores.forEach((target,) => ObservableObject.resetObject(target,));
  };
  Data2.addObserver = (target, observer2,) => {
    return ObservableObject.addObserver(target, observer2,);
  };
  return Data2;
})();
var Data = data;
var PropertyStore = /* @__PURE__ */ (() => {
  function PropertyStore2(initial = {}, makeAnimatables = false,) {
    deprecationWarning('PropertyStore', '1.0.0', 'Data() or ObservableObject()',);
    return ObservableObject(initial, makeAnimatables,);
  }
  PropertyStore2.addObserver = (target, observer2,) => {
    return ObservableObject.addObserver(target, observer2,);
  };
  return PropertyStore2;
})();
function bindActionsToStore(get, set, actions,) {
  const boundActions = {};
  for (const key7 in actions) {
    const action = actions[key7];
    if (!action) {
      continue;
    }
    boundActions[key7] = (data2,) => set(action(get(), data2,),);
  }
  return boundActions;
}
function createStore(initialState2, unboundActions,) {
  let state = initialState2;
  let version2 = 0;
  const subscribers = /* @__PURE__ */ new Set();
  const notifySubscriber = (sub,) => sub(version2,);
  const get = () => state;
  const set = (latestState,) => {
    version2++;
    state = latestState;
    subscribers.forEach(notifySubscriber,);
  };
  const actions = unboundActions ? bindActionsToStore(get, set, unboundActions,) : set;
  return {
    get,
    set,
    getVersion: () => version2,
    getActions: () => actions,
    subscribe: (sub,) => {
      subscribers.add(sub,);
      return () => subscribers.delete(sub,);
    },
  };
}
var defaultId = /* @__PURE__ */ Symbol('default',);
var DataContext = /* @__PURE__ */ createContext32(defaultId,);
function createData(defaultState2, actions,) {
  const stores = /* @__PURE__ */ new Map();
  const useData2 = (id3, initialState2,) => {
    const contextId = useContext102(DataContext,);
    id3 = id3 || contextId;
    const store = useMemo42(() => {
      if (!stores.has(id3,)) {
        stores.set(id3, createStore(initialState2 || defaultState2, actions,),);
      }
      return stores.get(id3,);
    }, [id3,],);
    const [, notifyUpdates,] = useState8(store.getVersion(),);
    const storeValueAtHookCallTime = useMemo42(() => store.get(), [store,],);
    useEffect82(() => {
      const unsubscribe = store.subscribe(notifyUpdates,);
      if (storeValueAtHookCallTime !== store.get()) {
        notifyUpdates(store.getVersion(),);
      }
      return unsubscribe;
    }, [store, storeValueAtHookCallTime,],);
    return [store.get(), store.getActions(),];
  };
  return useData2;
}
var initialState = { update: 0, };
var DataObserverContext = /* @__PURE__ */ React56.createContext({ update: NaN, },);
function useObserveData() {
  const context = React56.useContext(DataObserverContext,);
  return !isNaN(context.update,);
}
var DataObserver = class extends Component11 {
  constructor() {
    super(...arguments,);
    __publicField(this, 'observers', [],);
    __publicField(this, 'state', initialState,);
    __publicField(this, 'taskAdded', false,);
    __publicField(this, 'frameTask', () => {
      this.setState({ update: this.state.update + 1, },);
      this.taskAdded = false;
    },);
    __publicField(this, 'observer', () => {
      if (this.taskAdded) {
        return;
      }
      this.taskAdded = true;
      MainLoop.addFrameTask(this.frameTask,);
    },);
  }
  componentWillUnmount() {
    this.observers.map((cancel,) => cancel());
    Data.reset();
  }
  render() {
    const { children, } = this.props;
    this.observers.map((cancel,) => cancel());
    this.observers = [];
    Data._stores.forEach((d,) => {
      const observer2 = Data.addObserver(d, this.observer,);
      this.observers.push(observer2,);
    },);
    return /* @__PURE__ */ React56.createElement(DataObserverContext.Provider, { value: { ...this.state, }, }, children,);
  }
};
var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs(), 1,);
function convertColorObject(prop,) {
  if (typeof prop === 'string' || isMotionValue2(prop,)) {
    return prop;
  } else if (LinearGradient.isLinearGradient(prop,)) {
    return LinearGradient.toCSS(prop,);
  } else if (RadialGradient.isRadialGradient(prop,)) {
    return RadialGradient.toCSS(prop,);
  } else if (Color.isColorObject(prop,)) {
    return Color.toRgbString(prop,);
  }
  return prop;
}
function convertColorProps(props,) {
  if (props.background || props.color) {
    const converted = Object.assign({}, props,);
    if (props.background) {
      converted.background = convertColorObject(props.background,);
    }
    if (props.color) {
      converted.color = convertColorObject(props.color,);
    }
    return converted;
  }
  return props;
}
function WithOverride(Component15, override,) {
  const useOverride = typeof override === 'function'
    ? (props,) => override(convertColorProps(props,),)
    : () => convertColorProps(override,);
  const ComponentWithOverride = function (props,) {
    useContext112(DataObserverContext,);
    const overrideProps = useOverride(props,);
    const { style, ...rest } = props;
    return /* @__PURE__ */ React57.createElement(Component15, { ...rest, ...overrideProps, _initialStyle: style, },);
  };
  (0, import_hoist_non_react_statics4.default)(ComponentWithOverride, Component15,);
  ComponentWithOverride['displayName'] = `WithOverride(${Component15.displayName || Component15.name})`;
  return ComponentWithOverride;
}
var prefix = '__framer__';
var prefixLength = prefix.length;
function extractPrefixedProps(props, keys3,) {
  const result = {};
  const rest = {};
  for (const key7 in props) {
    const strippedKey = stripPrefixFromPrefixedKey(key7,);
    if (strippedKey && keys3.has(strippedKey,)) {
      result[strippedKey] = props[key7];
      continue;
    }
    rest[key7] = props[key7];
  }
  return [result, rest,];
}
function stripPrefixFromPrefixedKey(key7,) {
  if (key7.startsWith(prefix,)) {
    return key7.substr(prefixLength,);
  }
  return void 0;
}
var effectValuesKeys = [
  'opacity',
  'x',
  'y',
  'scale',
  'rotate',
  'rotateX',
  'rotateY',
  'transformPerspective',
];
var makeFXValues = (defaults,) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    x: motionValue((_a = defaults == null ? void 0 : defaults.x) != null ? _a : 0,),
    y: motionValue((_b = defaults == null ? void 0 : defaults.y) != null ? _b : 0,),
    opacity: motionValue((_c = defaults == null ? void 0 : defaults.opacity) != null ? _c : 1,),
    scale: motionValue((_d = defaults == null ? void 0 : defaults.scale) != null ? _d : 1,),
    rotate: motionValue((_e = defaults == null ? void 0 : defaults.rotate) != null ? _e : 0,),
    rotateX: motionValue((_f = defaults == null ? void 0 : defaults.rotateX) != null ? _f : 0,),
    rotateY: motionValue((_g = defaults == null ? void 0 : defaults.rotateY) != null ? _g : 0,),
    transformPerspective: motionValue((_h = defaults == null ? void 0 : defaults.transformPerspective) != null ? _h : 0,),
  };
};
var defaultFXValues = {
  x: 0,
  y: 0,
  scale: 1,
  opacity: 1,
  transformPerspective: 0,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
};
function useFXValues(values, enabled,) {
  const effect = useConstant2(() => ({ values: makeFXValues(enabled ? values : void 0,), }));
  React58.useEffect(() => {
    if (enabled) {
      return;
    }
    for (const key7 of effectValuesKeys) {
      const value = defaultFXValues[key7];
      if (isUndefined(value,)) {
        continue;
      }
      effect.values[key7].set(value,);
    }
  }, [effect, enabled,],);
  return effect;
}
var loopOptionsKeys = /* @__PURE__ */ new Set([
  'loopEffectEnabled',
  'loopTransition',
  'loop',
  'loopRepeatType',
  'loopRepeatDelay',
],);
var useDelay = () => {
  const timeoutRef = useRef102();
  useEffect92(() => {
    return () => {
      clearTimeout(timeoutRef.current,);
    };
  }, [],);
  return async (d,) =>
    new Promise((resolve,) => {
      timeoutRef.current = setTimeout(() => {
        resolve(true,);
      }, d * 1e3,);
    },);
};
function useLoop({
  loopEffectEnabled,
  loopRepeatDelay,
  loopTransition,
  loopRepeatType,
  loop,
},) {
  const shouldReduceMotion = useReducedMotionConfig();
  const effect = useConstant2(() => ({ values: makeFXValues(), }));
  const mirrorStateRef = React59.useRef(false,);
  const delay2 = useDelay();
  const animateValues = async () => {
    if (!loop) {
      return;
    }
    const transition = loopTransition || void 0;
    const mirror = mirrorStateRef.current && loopRepeatType === 'mirror';
    const to = mirror ? defaultFXValues : loop;
    const from = mirror ? loop : defaultFXValues;
    mirrorStateRef.current = !mirrorStateRef.current;
    return Promise.all(
      effectValuesKeys.map((key7,) => {
        var _a;
        if (shouldReduceMotion && key7 !== 'opacity') {
          return;
        }
        effect.values[key7].set((_a = from[key7]) != null ? _a : defaultFXValues[key7],);
        return new Promise((resolve,) => {
          var _a2;
          const opts = {
            ...transition,
            onComplete: () => resolve(),
          };
          animate(effect.values[key7], (_a2 = to[key7]) != null ? _a2 : from[key7], opts,);
        },);
      },),
    );
  };
  const start = async () => {
    if (!loopEffectEnabled) {
      return;
    }
    await animateValues();
    await delay2(loopRepeatDelay != null ? loopRepeatDelay : 0,);
    await start();
  };
  const stop = useCallback7(() => {
    effectValuesKeys.forEach((key7,) => {
      effect.values[key7].stop();
    },);
    effectValuesKeys.forEach((key7,) => {
      effect.values[key7].set(defaultFXValues[key7],);
    },);
    mirrorStateRef.current = false;
  }, [effect,],);
  React59.useEffect(() => {
    if (loopEffectEnabled && loop) {
      start();
    } else {
      stop();
    }
    return () => stop();
  }, [loopEffectEnabled,],);
  return effect;
}
function parallaxTransform(scrollY, originalPosition, speed, offset, adjustPosition,) {
  const speedFactor = speed / 100 - 1;
  const initialPosition = adjustPosition ? (originalPosition - offset) * speedFactor : 0;
  const scrollOffset = -scrollY * speedFactor;
  return initialPosition + scrollOffset;
}
var parallaxOptionsKeys = /* @__PURE__ */ new Set([
  'speed',
  'adjustPosition',
  'offset',
  'parallaxTransformEnabled',
],);
function useParallax(options, ref, visibilityStyle,) {
  const { speed = 100, offset = 0, adjustPosition = false, parallaxTransformEnabled, } = options;
  const originalPosition = React60.useRef(null,);
  const shouldReduceMotion = useReducedMotionConfig();
  const transform2 = React60.useCallback(
    (yValue,) => {
      if (originalPosition.current === null) {
        return 0;
      }
      if (speed === 100) {
        return 0;
      }
      return parallaxTransform(yValue, originalPosition.current, speed, offset, adjustPosition,);
    },
    [originalPosition, speed, offset, adjustPosition,],
  );
  React60.useLayoutEffect(() => {
    frame.read(() => {
      var _a, _b, _c;
      originalPosition.current =
        (_c = (_b = (_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) == null ? void 0 : _b.top) != null ? _c : 0;
    },);
    frame.update(() => {
      parallaxY.set(transform2(scrollY.get(),),);
      if (adjustPosition) {
        visibility.set(visibilityStyle != null ? visibilityStyle : 'initial',);
      }
    },);
  }, [ref, originalPosition, adjustPosition,],);
  const { scrollY, } = useScroll();
  const parallaxY = useTransform(scrollY, transform2,);
  const visibility = useMotionValue(adjustPosition && originalPosition.current === null ? 'hidden' : visibilityStyle,);
  const defaultValue = useMotionValue(0,);
  return {
    values: {
      y: shouldReduceMotion || !parallaxTransformEnabled ? defaultValue : parallaxY,
    },
    style: parallaxTransformEnabled
      ? {
        visibility,
      }
      : void 0,
  };
}
function getTransition(value,) {
  if (isString22(value,) || !isObject2(value,)) {
    return void 0;
  }
  return value == null ? void 0 : value.transition;
}
async function runEffectAnimation(target, effect, shouldReduceMotion, ref, appearId,) {
  const transition = getTransition(target,);
  return Promise.all(
    effectValuesKeys.map((key7,) => {
      return new Promise((resolve,) => {
        var _a;
        if (shouldReduceMotion && key7 !== 'opacity') {
          return resolve();
        }
        const motionValue2 = effect.values[key7];
        motionValue2.stop();
        let value = !isObject2(target,)
          ? defaultFXValues[key7]
          : (_a = target == null ? void 0 : target[key7]) != null
          ? _a
          : defaultFXValues[key7];
        if (isMotionValue(value,)) {
          value = value.get();
        }
        if (!isNumber2(value,)) {
          return resolve();
        }
        const visualElement = visualElementStore.get(ref.current,);
        if (visualElement) {
          visualElement.setBaseTarget(key7, value,);
        }
        const handoff =
          isString22(appearId,) && !(motionValue2 == null ? void 0 : motionValue2.hasAnimated) && safeWindow.HandoffAppearAnimations
            ? {
              elapsed: safeWindow.HandoffAppearAnimations(appearId, key7, motionValue2, frame,),
            }
            : void 0;
        const opts = {
          ...transition,
          velocity: 0,
          elapsed: 0,
          ...handoff,
          onComplete: () => resolve(),
        };
        animate(motionValue2, value, opts,);
      },);
    },),
  );
}
var presenceOptionsKeys = /* @__PURE__ */ new Set([
  'presenceInitial',
  'presenceAnimate',
  'presenceExit',
],);
function usePresenceAnimation(
  {
    initial: motionInitial,
    animate: motionAnimate,
    exit: motionExit,
    presenceInitial,
    presenceAnimate,
    presenceExit,
  },
  ref,
  enabled,
  appearId,
) {
  const initial = presenceInitial != null ? presenceInitial : motionInitial;
  const animateConfig = presenceAnimate != null ? presenceAnimate : motionAnimate;
  const exit = presenceExit != null ? presenceExit : motionExit;
  const effect = useConstant2(() => {
    var _a;
    if (!isObject2(initial,)) {
      return { values: makeFXValues(), };
    }
    const defaults = {};
    for (const key7 in initial) {
      let value = isObject2(initial,) ? (_a = asRecord(initial,)) == null ? void 0 : _a[key7] : void 0;
      if (isMotionValue(value,)) {
        value = value.get();
      }
      if (!isNumber2(value,)) {
        continue;
      }
      defaults[key7] = value;
    }
    return { values: makeFXValues(defaults,), };
  },);
  const [isPresent2, safeToRemove,] = usePresence();
  const shouldReduceMotion = useReducedMotionConfig();
  useLayoutEffect22(() => {
    if (!enabled) {
      safeToRemove == null ? void 0 : safeToRemove();
      return;
    }
    if (isPresent2) {
      if (initial && animateConfig) {
        runEffectAnimation(animateConfig, effect, shouldReduceMotion, ref, appearId,);
      }
    } else {
      if (exit) {
        runEffectAnimation(exit, effect, shouldReduceMotion, ref,).then(() => safeToRemove());
      } else {
        safeToRemove();
      }
    }
  }, [isPresent2,],);
  return effect;
}
function calcOffsetTop(element, container,) {
  let top = 0;
  let current = element;
  while (current && current !== container) {
    if (!(current instanceof HTMLElement)) {
      break;
    }
    top += current.offsetTop;
    current = current.offsetParent;
  }
  return top;
}
var scrollObserverOffset = 1;
function createTransformInputRange(transformTargets, threshold = 0, callback,) {
  var _a, _b, _c;
  const starts = [];
  const inputRange = [];
  for (let index = transformTargets.length; index >= 0; index--) {
    const { ref: targetRef, offset, } = (_a = transformTargets[index]) != null ? _a : {};
    if (!targetRef || !targetRef.current) {
      continue;
    }
    const offsetTop = calcOffsetTop(targetRef.current, document.documentElement,);
    const top = offsetTop - scrollObserverOffset - (offset != null ? offset : 0) - threshold;
    const height = (_c = (_b = targetRef.current) == null ? void 0 : _b.clientHeight) != null ? _c : 0;
    const previousTop = starts[starts.length - 1];
    const end = Math.max(top + height, 0,);
    starts.push(top,);
    inputRange.unshift(
      Math.max(top, 0,),
      previousTop === void 0 ? end : Math.min(end, Math.max(previousTop - 1, 0,),),
    );
    callback == null ? void 0 : callback(index,);
  }
  return inputRange;
}
function currentScrollDirection(offset, lastOffset = 0,) {
  if (offset < lastOffset) {
    return 'up';
  }
  return 'down';
}
var scrollDirectionThreshold = 4;
function useScrollDirectionChange(scrollDirection, cb, options = {},) {
  const { direction, target, } = scrollDirection != null ? scrollDirection : {};
  const { repeat = true, enabled = true, } = options;
  React61.useEffect(() => {
    if (!direction || !enabled) {
      return;
    }
    let lastOffset = void 0;
    let directionChangeOffset = 0;
    let lastDirection = void 0;
    let currentTarget = void 0;
    return scrollInfo(({ y: scrollY, },) => {
      if (!repeat && currentTarget === target) {
        return;
      }
      if (scrollY.current > scrollY.scrollLength) {
        return;
      }
      if (scrollY.current < 0) {
        return;
      }
      const d = currentScrollDirection(scrollY.current, lastOffset,);
      lastOffset = scrollY.current;
      const hasDirectionChanged = d !== lastDirection;
      lastDirection = d;
      if (hasDirectionChanged) {
        directionChangeOffset = scrollY.current;
      } else {
        const delta = Math.abs(scrollY.current - directionChangeOffset,);
        if (delta < scrollDirectionThreshold) {
          return;
        }
        const nextTarget = d === direction ? target : void 0;
        if (nextTarget !== currentTarget) {
          cb(nextTarget,);
        }
        currentTarget = nextTarget;
      }
    },);
  }, [direction, repeat, target, enabled, cb,],);
}
var styleAppearOptionsKeys = /* @__PURE__ */ new Set([
  'threshold',
  'animateOnce',
  'opacity',
  'targetOpacity',
  'x',
  'y',
  'scale',
  'transition',
  'rotate',
  'rotateX',
  'rotateY',
  'perspective',
  'enter',
  'exit',
  'animate',
  'styleAppearEffectEnabled',
  'targets',
  'scrollDirection',
],);
var defaultOutputRange = ['animate', 'animate',];
var defaultRanges = { inputRange: [], outputRange: [], };
function createInputOutputRange(targets, threshold, hasExit,) {
  const inputRange = createTransformInputRange(targets, threshold,);
  const outputRange = [...defaultOutputRange,];
  const firstRange = inputRange[0];
  if (!isNumber2(firstRange,)) {
    return defaultRanges;
  }
  if (firstRange > 1) {
    inputRange.unshift(0, firstRange - 1,);
    outputRange.unshift('initial', 'initial',);
  }
  if (hasExit) {
    const idx = inputRange.length - 1;
    const last = inputRange[idx];
    if (!isNumber2(last,)) {
      return defaultRanges;
    }
    inputRange.push(last + 1,);
    outputRange.push('exit',);
  }
  return {
    inputRange,
    outputRange,
  };
}
function makeStyle(defaults,) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  return {
    x: (_a = defaults == null ? void 0 : defaults.x) != null ? _a : defaultFXValues.x,
    y: (_b = defaults == null ? void 0 : defaults.y) != null ? _b : defaultFXValues.y,
    scale: (_c = defaults == null ? void 0 : defaults.scale) != null ? _c : defaultFXValues.scale,
    opacity: (_d = defaults == null ? void 0 : defaults.opacity) != null ? _d : defaultFXValues.opacity,
    transformPerspective: (_e = defaults == null ? void 0 : defaults.transformPerspective) != null
      ? _e
      : defaultFXValues.transformPerspective,
    rotate: (_f = defaults == null ? void 0 : defaults.rotate) != null ? _f : defaultFXValues.rotate,
    rotateX: (_g = defaults == null ? void 0 : defaults.rotateX) != null ? _g : defaultFXValues.rotateX,
    rotateY: (_h = defaults == null ? void 0 : defaults.rotateY) != null ? _h : defaultFXValues.rotateY,
    transition: (_i = defaults == null ? void 0 : defaults.transition) != null ? _i : void 0,
  };
}
function useAnimationVariants({
  opacity,
  targetOpacity,
  perspective: transformPerspective,
  enter,
  exit,
  animate: animateVariant2,
  ...defaultStyles
},) {
  return React622.useMemo(
    () => {
      var _a;
      return {
        initial: enter != null ? enter : makeStyle({
          ...defaultStyles,
          opacity: (_a = opacity != null ? opacity : targetOpacity) != null ? _a : 1,
          transformPerspective,
        },),
        animate: animateVariant2 != null ? animateVariant2 : makeStyle({
          opacity: targetOpacity,
        },),
        exit: exit != null ? exit : makeStyle(),
      };
    },
    [animateVariant2, defaultStyles, enter, exit, opacity, targetOpacity, transformPerspective,],
  );
}
function useStyleAppearEffect(options, ref,) {
  const shouldReduceMotion = useReducedMotionConfig();
  const variants = useAnimationVariants(options,);
  const enabled = options.styleAppearEffectEnabled;
  const effect = useFXValues(enabled ? variants.initial : variants.animate, enabled,);
  const playState = React622.useRef({
    isPlaying: false,
    scheduledAppearState: void 0,
    lastAppearState: !options.styleAppearEffectEnabled,
  },);
  const animation = React622.useRef();
  const runAnimation = React622.useCallback(
    async ({ transition, ...target }, fromInitial,) => {
      var _a;
      const transitionWithFallback = (_a = transition != null ? transition : variants.animate.transition) != null ? _a : options.transition;
      await animation.current;
      animation.current = Promise.all(
        effectValuesKeys.map((key7,) => {
          var _a2, _b;
          if (fromInitial) {
            effect.values[key7].set((_a2 = variants.initial[key7]) != null ? _a2 : defaultFXValues[key7],);
          }
          const toValue = (_b = target[key7]) != null ? _b : defaultFXValues[key7];
          const visualElement = visualElementStore.get(ref.current,);
          if (visualElement && typeof toValue !== 'object') {
            visualElement.setBaseTarget(key7, toValue,);
          }
          return new Promise((resolve,) => {
            if (shouldReduceMotion && key7 !== 'opacity') {
              resolve();
            } else {
              const opts = {
                restDelta: key7 === 'scale' ? 1e-3 : void 0,
                ...transitionWithFallback,
                onComplete: () => resolve(),
              };
              animate(effect.values[key7], toValue, opts,);
            }
          },);
        },),
      );
    },
    // All dependencies are object values or stable.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );
  const hasAnimatedOnce = options.animateOnce && playState.current.lastAppearState === true;
  const animateWithIntersectionObserver = !options.targets && options.styleAppearEffectEnabled && !options.scrollDirection &&
    !hasAnimatedOnce;
  useAppearEffect(
    ref,
    (appears,) => {
      const { isPlaying, lastAppearState, } = playState.current;
      if (isPlaying) {
        playState.current.scheduledAppearState = appears;
        return;
      }
      playState.current.scheduledAppearState = void 0;
      playState.current.lastAppearState = appears;
      if (lastAppearState === appears) {
        return;
      }
      runAnimation(appears ? variants.animate : variants.exit, appears,);
    },
    {
      enabled: animateWithIntersectionObserver,
      animateOnce: !!options.animateOnce,
      threshold: {
        y: options.threshold,
      },
    },
  );
  const animateWithScrollInfo = options.targets && enabled && !options.scrollDirection;
  React622.useEffect(() => {
    if (!animateWithScrollInfo) {
      return;
    }
    const playedState = { initial: true, };
    let lastVariant = 'initial';
    return scrollInfo(({ y: scrollY, },) => {
      var _a;
      const { targets, } = options;
      if (!targets) {
        return;
      }
      if (!targets[0] || targets[0].ref && !targets[0].ref.current) {
        return;
      }
      const { inputRange, outputRange, } = createInputOutputRange(
        targets,
        ((_a = options.threshold) != null ? _a : 0) * scrollY.containerLength,
        !!options.exit,
      );
      if (inputRange.length === 0 || inputRange.length !== outputRange.length) {
        return;
      }
      const variant = transform(scrollY.current, inputRange, outputRange,);
      if (options.animateOnce && playedState[variant]) {
        return;
      }
      playedState[variant] = true;
      if (lastVariant === variant) {
        return;
      }
      lastVariant = variant;
      const variantAnimation = asRecord(variants,)[variant];
      if (!variantAnimation) {
        return;
      }
      runAnimation(variantAnimation,);
    },);
  }, [animateWithScrollInfo,],);
  useScrollDirectionChange(options.scrollDirection, (target,) => runAnimation(target != null ? target : variants.animate,), {
    enabled,
    repeat: !options.animateOnce,
  },);
  return effect;
}
var styleTransformOptionsKeys = /* @__PURE__ */ new Set([
  'transformViewportThreshold',
  'styleTransformEffectEnabled',
  'transformTargets',
  'spring',
  'transformTrigger',
],);
var defaultValues = (transformTargets, shouldReduceMotion,) => {
  var _a, _b;
  const initial = (_a = transformTargets == null ? void 0 : transformTargets[0]) == null ? void 0 : _a.target;
  return shouldReduceMotion ? { opacity: (_b = initial == null ? void 0 : initial.opacity) != null ? _b : 1, } : initial;
};
var defaultRanges2 = () => ({
  opacity: [],
  x: [],
  y: [],
  scale: [],
  rotate: [],
  rotateX: [],
  rotateY: [],
  transformPerspective: [],
});
function useAttachOptionalSpring(values, spring2,) {
  const springs = React63.useRef({},);
  React63.useEffect(() => {
    if (spring2 === void 0) {
      return;
    }
    for (const key7 of objectKeys(values,)) {
      const m2 = values[key7];
      m2.attach((v, set,) => {
        const active = springs.current[key7];
        if (active) {
          active.stop();
        }
        springs.current[key7] = animateValue({
          keyframes: [m2.get(), v,],
          velocity: m2.getVelocity(),
          ...spring2,
          restDelta: 1e-3,
          onUpdate: set,
        },);
        if (!frameData.isProcessing) {
          const delta = performance.now() - frameData.timestamp;
          if (delta < 40) {
            springs.current[key7].time = delta / 1e3;
          }
        }
        return m2.get();
      },);
    }
  }, [JSON.stringify(spring2,),],);
}
function createInputOutputRanges(transformTargets, threshold,) {
  const effectKeyOutputRange = defaultRanges2();
  const inputRange = createTransformInputRange(transformTargets, threshold, (index,) => {
    var _a, _b, _c, _d, _e;
    const previousTarget = (_a = transformTargets[index - 1]) == null ? void 0 : _a.target;
    const currentTarget = (_b = transformTargets[index]) == null ? void 0 : _b.target;
    for (const key7 of effectValuesKeys) {
      (_e = effectKeyOutputRange[key7]) == null
        ? void 0
        : _e.unshift(
          (_c = previousTarget == null ? void 0 : previousTarget[key7]) != null ? _c : 0,
          (_d = currentTarget == null ? void 0 : currentTarget[key7]) != null ? _d : 0,
        );
    }
  },);
  return { inputRange, effectKeyOutputRange, };
}
function createPageOutputRange(transformTargets,) {
  var _a;
  const keyOutputRange = defaultRanges2();
  for (const { target, } of transformTargets) {
    for (const key7 of effectValuesKeys) {
      (_a = keyOutputRange[key7]) == null ? void 0 : _a.push(target[key7],);
    }
  }
  return keyOutputRange;
}
var pageInputRange = [0, 1,];
function useStyleTransform({
  transformTrigger,
  styleTransformEffectEnabled,
  transformTargets,
  spring: spring2,
  transformViewportThreshold = 0,
}, ref,) {
  const shouldReduceMotion = useReducedMotionConfig();
  const effect = useFXValues(defaultValues(transformTargets, shouldReduceMotion,), styleTransformEffectEnabled,);
  React63.useLayoutEffect(() => {
    var _a;
    if (!styleTransformEffectEnabled || !transformTargets) {
      return;
    }
    if (transformTrigger !== 'onScrollTarget') {
      const outputRange = createPageOutputRange(transformTargets,);
      return scrollInfo(
        ({ y: scrollY, },) => {
          for (const key7 of effectValuesKeys) {
            if (shouldReduceMotion && key7 !== 'opacity') {
              continue;
            }
            if (pageInputRange.length !== outputRange[key7].length) {
              continue;
            }
            effect.values[key7].set(transform(scrollY.progress, pageInputRange, outputRange[key7],),);
          }
        },
        transformTrigger === 'onInView'
          ? {
            target: (_a = ref.current) != null ? _a : void 0,
            offset: [`start end`, `end end`,],
          }
          : void 0,
      );
    } else {
      return scrollInfo(({ y: scrollY, },) => {
        if (!transformTargets[0] || transformTargets[0].ref && !transformTargets[0].ref.current) {
          return;
        }
        const { inputRange: scrollYInputRange, effectKeyOutputRange, } = createInputOutputRanges(
          transformTargets,
          transformViewportThreshold * scrollY.containerLength,
        );
        if (scrollYInputRange.length === 0) {
          return;
        }
        for (const key7 of effectValuesKeys) {
          if (shouldReduceMotion && key7 !== 'opacity') {
            continue;
          }
          if (scrollYInputRange.length !== effectKeyOutputRange[key7].length) {
            continue;
          }
          effect.values[key7].set(transform(scrollY.current, scrollYInputRange, effectKeyOutputRange[key7],),);
        }
      },);
    }
  }, [
    shouldReduceMotion,
    transformTrigger,
    ref,
    transformViewportThreshold,
    styleTransformEffectEnabled,
    effect,
    transformTargets,
  ],);
  useAttachOptionalSpring(effect.values, spring2,);
  return effect;
}
var groups = {
  parallax: parallaxOptionsKeys,
  styleAppear: styleAppearOptionsKeys,
  styleTransform: styleTransformOptionsKeys,
  loop: loopOptionsKeys,
  presence: presenceOptionsKeys,
};
var groupValues = /* @__PURE__ */ objectKeys(groups,);
function backwardsCompatibleEnabledCheck(key7, secondaryKey, object,) {
  return !(key7 in object) && secondaryKey in object || object[key7] === true;
}
function extractFXOptions(props,) {
  const result = {
    parallax: {},
    styleAppear: {},
    styleTransform: {},
    presence: {
      animate: props.animate,
      initial: props.initial,
      exit: props.exit,
    },
    loop: {},
    forwardedProps: {},
  };
  for (const key7 in props) {
    const strippedKey = stripPrefixFromPrefixedKey(key7,);
    if (strippedKey) {
      for (const group of groupValues) {
        const keys3 = groups[group];
        if (keys3 == null ? void 0 : keys3.has(strippedKey,)) {
          result[group][strippedKey] = asRecord(props,)[key7];
          break;
        }
      }
    } else {
      result.forwardedProps[key7] = asRecord(props,)[key7];
    }
  }
  result.parallax.parallaxTransformEnabled = backwardsCompatibleEnabledCheck(
    'parallaxTransformEnabled',
    'speed',
    result.parallax,
  );
  result.styleAppear.styleAppearEffectEnabled = backwardsCompatibleEnabledCheck(
    'styleAppearEffectEnabled',
    'animateOnce',
    result.styleAppear,
  );
  return result;
}
var add2 = (values,) => values.reduce((sum, value,) => sum += value, 0,);
var multiply = (values,) => values.reduce((sum, value,) => sum = sum * value, 1,);
var reactRefObjectKey = 'current';
function isReactRefObject(value,) {
  return isObject2(value,) && reactRefObjectKey in value;
}
function addMotionValueStyle(style, values,) {
  if (!style || !isObject2(style,)) {
    return values;
  }
  for (const key7 in style) {
    const value = style[key7];
    if (!isMotionValue(value,) || !isFXValuesKey(key7,)) {
      continue;
    }
    if (!isNumber2(value.get(),)) {
      continue;
    }
    values[key7].push(value,);
  }
}
function isVariantOrVariantList(value,) {
  return isString22(value,) || Array.isArray(value,);
}
function isFXValuesKey(key7,) {
  return key7 in defaultFXValues;
}
var withFX = (Component15,) =>
  React64.forwardRef((props, forwardedRef,) => {
    if (props.__withFX) {
      return /* @__PURE__ */ React64.createElement(Component15, {
        ...props,
        animate: void 0,
        initial: void 0,
        exit: void 0,
        ref: forwardedRef,
      },);
    }
    if (RenderTarget.current() === 'CANVAS') {
      const animate4 = isVariantOrVariantList(props.animate,) ? props.animate : void 0;
      const initial2 = isVariantOrVariantList(props.initial,) ? props.initial : void 0;
      return /* @__PURE__ */ React64.createElement(Component15, {
        ...props,
        animate: animate4,
        initial: initial2,
        exit: void 0,
        ref: forwardedRef,
      },);
    }
    const fallbackRef = React64.useRef(null,);
    const ref = forwardedRef != null ? forwardedRef : fallbackRef;
    const {
      parallax = {},
      styleAppear = {},
      styleTransform = {},
      presence = {},
      loop = {},
      forwardedProps,
    } = extractFXOptions(props,);
    const {
      __targetOpacity: targetOpacityValue,
      __perspectiveFX: withPerspective,
      __smartComponentFX: inSmartComponent = false,
    } = props;
    const targetOpacity = useMotionValue(targetOpacityValue != null ? targetOpacityValue : 1,);
    const { values: presenceEffectValues, } = usePresenceAnimation(
      presence,
      ref,
      inSmartComponent,
      props[optimizedAppearDataAttribute],
    );
    const { values: parallaxValues, style: parallaxStyle, } = useParallax(parallax, ref,);
    const { values: transformValues2, } = useStyleTransform(styleTransform, ref,);
    const { values: appearEffectValues, } = useStyleAppearEffect(styleAppear, ref,);
    const { values: loopValues, } = useLoop(loop,);
    const fxValues = React64.useMemo(() => {
      return {
        scale: [appearEffectValues.scale, loopValues.scale, presenceEffectValues.scale, transformValues2.scale,],
        opacity: [
          appearEffectValues.opacity,
          loopValues.opacity,
          presenceEffectValues.opacity,
          // Ensure that the layers opacity is always represented.
          targetOpacity,
          transformValues2.opacity,
        ],
        x: [appearEffectValues.x, loopValues.x, presenceEffectValues.x, transformValues2.x,],
        y: [appearEffectValues.y, loopValues.y, parallaxValues.y, presenceEffectValues.y, transformValues2.y,],
        rotate: [
          appearEffectValues.rotate,
          loopValues.rotate,
          presenceEffectValues.rotate,
          transformValues2.rotate,
        ],
        rotateX: [
          appearEffectValues.rotateX,
          loopValues.rotateX,
          presenceEffectValues.rotateX,
          transformValues2.rotateX,
        ],
        rotateY: [
          appearEffectValues.rotateY,
          loopValues.rotateY,
          presenceEffectValues.rotateY,
          transformValues2.rotateY,
        ],
        transformPerspective: [
          transformValues2.transformPerspective,
          appearEffectValues.transformPerspective,
          // We stopped animating transformPerspective with `withFX`
          // before introducing `useLoop`, so it does not have a value
          // here on purpose.
        ],
      };
    }, [targetOpacity, transformValues2, parallaxValues, appearEffectValues, loopValues, presenceEffectValues,],);
    addMotionValueStyle(props.style, fxValues,);
    const scale2 = useTransform(fxValues.scale, multiply,);
    const opacity = useTransform(fxValues.opacity, multiply,);
    const x = useTransform(fxValues.x, add2,);
    const y = useTransform(fxValues.y, add2,);
    const rotate = useTransform(fxValues.rotate, add2,);
    const rotateX = useTransform(fxValues.rotateX, add2,);
    const rotateY = useTransform(fxValues.rotateY, add2,);
    const transformPerspective = useTransform(fxValues.transformPerspective, add2,);
    const { drag: drag2, dragConstraints, } = forwardedProps;
    useRerenderOnResize(drag2 && isReactRefObject(dragConstraints,) ? dragConstraints : void 0,);
    const motionValueStyle = {
      opacity,
      scale: scale2,
      x,
      y,
      rotate,
      rotateX,
      rotateY,
    };
    if (isUndefined(withPerspective,)) {
      motionValueStyle.transformPerspective = transformPerspective;
    }
    const animate3 = isVariantOrVariantList(props.animate,) ? props.animate : void 0;
    const initial = isVariantOrVariantList(props.initial,) ? props.initial : void 0;
    const exit = isVariantOrVariantList(props.exit,) ? props.exit : void 0;
    const motionGestures = inSmartComponent && !presence.presenceInitial ? { initial, animate: animate3, exit, } : {};
    return /* @__PURE__ */ React64.createElement(
      Component15,
      {
        ...forwardedProps,
        ...motionGestures,
        __withFX: true,
        style: {
          ...props.style,
          ...parallaxStyle,
          ...motionValueStyle,
        },
        values: presenceEffectValues,
        ref,
      },
    );
  },);
var withParallaxTransform = withFX;
var withStyleAppearEffect = withFX;
var Context = /* @__PURE__ */ createContext42({},);
function ComponentPresetsProvider({ presets, children, },) {
  const lastPresets = useRef112(presets,);
  if (!isEqual(presets, lastPresets.current, false,)) {
    lastPresets.current = presets;
  }
  return /* @__PURE__ */ React65.createElement(Context.Provider, { value: lastPresets.current, }, children,);
}
function ComponentPresetsConsumer({ componentIdentifier, children, },) {
  var _a;
  const componentPresets = useContext122(Context,);
  const presetProps = (_a = componentPresets[componentIdentifier]) != null ? _a : {};
  return children(presetProps,);
}
var cloneChildrenWithPropsAndRef = (children, props, ref,) => {
  if (React66.Children.count(children,) > 1 && ref) {
    if (false) {
      throw new ReferenceError(
        'cloneChildrenWithPropsAndRef: Only one child should be passed when using refs. Ref assignment will be ignored.',
      );
    }
    ref = void 0;
  }
  return React66.Children.map(children, (child,) => {
    if (React66.isValidElement(child,)) {
      const hasOwnRef = 'ref' in child && child.ref;
      const shouldAssign = ref && !hasOwnRef;
      const newProps = shouldAssign ? { ...props, ref, } : props;
      return React66.cloneElement(child, newProps,);
    }
    return child;
  },);
};
var ComponentViewportContext = /* @__PURE__ */ React67.createContext({},);
function useComponentViewport() {
  return React67.useContext(ComponentViewportContext,);
}
var ComponentViewportProvider = /* @__PURE__ */ React67.forwardRef(
  ({ width, children, ...rest }, ref,) => {
    const componentViewport = React67.useMemo(() => {
      return { width, };
    }, [width,],);
    return /* @__PURE__ */ React67.createElement(
      ComponentViewportContext.Provider,
      { value: componentViewport, },
      cloneChildrenWithPropsAndRef(children, rest, ref,),
    );
  },
);
var withGeneratedLayoutId = (Component15,) =>
  React68.forwardRef((props, ref,) => {
    const layoutId = useLayoutId2(props,);
    return /* @__PURE__ */ React68.createElement(Component15, { layoutId, ...props, layoutIdKey: void 0, duplicatedFrom: void 0, ref, },);
  },);
var Providers = /* @__PURE__ */ React69.forwardRef(
  ({ children, layoutId, ...props }, ref,) => {
    const outerLayoutId = useConstant2(() => layoutId ? `${layoutId}-container` : void 0);
    return /* @__PURE__ */ React69.createElement(
      motion.div,
      { layoutId: outerLayoutId, ...props, ref, },
      /* @__PURE__ */ React69.createElement(
        ComponentContainerContext.Provider,
        { value: true, },
        /* @__PURE__ */ React69.createElement(
          AutomaticLayoutIds,
          { enabled: false, },
          /* @__PURE__ */ React69.createElement(
            LayoutGroup,
            { id: layoutId != null ? layoutId : '', inherit: 'id', },
            React69.Children.map(children, (child,) => {
              return React69.isValidElement(child,) ? React69.cloneElement(child, { layoutId, },) : child;
            },),
          ),
        ),
      ),
    );
  },
);
var Container = /* @__PURE__ */ withGeneratedLayoutId(Providers,);
var StyleSheetContext = /* @__PURE__ */ React70.createContext(void 0,);
if (isBrowser2()) {
  for (const node of document.querySelectorAll('style[data-framer-css-ssr]',)) {
    document.head.appendChild(node,);
  }
}
var componentsWithServerRenderedStyles = /* @__PURE__ */ (() => {
  var _a;
  if (!isBrowser2()) {
    return /* @__PURE__ */ new Set();
  }
  const componentsWithSSRStylesAttr = (_a = document.querySelector('style[data-framer-css-ssr-minified]',)) == null
    ? void 0
    : _a.getAttribute('data-framer-components',);
  if (!componentsWithSSRStylesAttr) {
    return /* @__PURE__ */ new Set();
  }
  return new Set(componentsWithSSRStylesAttr.split(' ',),);
})();
var styleTagSSRMarker = { 'data-framer-css-ssr': true, };
var withCSS = (Component15, escapedCSS, componentSerializationId,) =>
  React71.forwardRef((props, ref,) => {
    var _a;
    const { sheet, cache: cache3, } = (_a = React71.useContext(StyleSheetContext,)) != null ? _a : {};
    if (!isBrowser2()) {
      const concatenatedCSS = Array.isArray(escapedCSS,) ? escapedCSS.join('\n',) : escapedCSS;
      return /* @__PURE__ */ React71.createElement(
        React71.Fragment,
        null,
        /* @__PURE__ */ React71.createElement(
          'style',
          {
            ...styleTagSSRMarker,
            'data-framer-component': componentSerializationId,
            dangerouslySetInnerHTML: { __html: concatenatedCSS, },
          },
        ),
        /* @__PURE__ */ React71.createElement(Component15, { ...props, ref, },),
      );
    }
    React71.useInsertionEffect(() => {
      if (componentSerializationId && componentsWithServerRenderedStyles.has(componentSerializationId,)) {
        return;
      }
      const css = Array.isArray(escapedCSS,) ? escapedCSS : escapedCSS.split('\n',);
      css.forEach((rule,) => rule && injectCSSRule(rule, sheet, cache3,));
    }, [],);
    return /* @__PURE__ */ React71.createElement(Component15, { ...props, ref, },);
  },);
var CustomCursorContext = /* @__PURE__ */ React722.createContext({
  onRegisterCursors: () => () => {
  },
  registerCursors: () => {
  },
},);
var replaceCursorClassName = 'framer-cursor-none';
var cursorComponentClassName = 'framer-pointer-events-none';
var CustomCursorContextProvider = /* @__PURE__ */ React722.memo(function CustomCursorList({
  children,
},) {
  const value = useConstant2(() => {
    const events2 = /* @__PURE__ */ new Set();
    let allCursors = {};
    return {
      onRegisterCursors: (callback,) => {
        callback(allCursors,);
        events2.add(callback,);
        return () => events2.delete(callback,);
      },
      registerCursors: (cursors,) => {
        var _a;
        const nextCursors = {};
        for (const key7 in cursors) {
          const cursor = (_a = allCursors[key7]) != null ? _a : cursors[key7];
          if (cursor) {
            nextCursors[key7] = cursor;
          }
        }
        allCursors = nextCursors;
        for (const callback of events2) {
          callback(allCursors,);
        }
      },
    };
  },);
  const shouldReduceMotion = useReducedMotionConfig();
  return /* @__PURE__ */ React722.createElement(
    CustomCursorContext.Provider,
    { value, },
    children,
    !shouldReduceMotion && /* @__PURE__ */ React722.createElement(CustomCursorComponent, null,),
  );
},);
var CustomCursorHost = /* @__PURE__ */ withCSS(CustomCursorContextProvider, [
  `.${replaceCursorClassName}, .${replaceCursorClassName} * { cursor: none !important; }`,
  `.${cursorComponentClassName}, .${cursorComponentClassName} * { pointer-events: none !important; }`,
],);
var staticCursorStyle = {
  position: 'fixed',
  top: 0,
  left: 0,
  zIndex: 12 + 1,
  // Max framer z-index + 1
  pointerEvents: 'none',
};
function customCursorReplacesNativeCursor(cursor,) {
  if (!cursor) {
    return false;
  }
  if (cursor.placement || cursor.alignment) {
    return false;
  }
  return true;
}
function valueForCursorAlignment(alignment,) {
  switch (alignment) {
    case 'start':
      return '0%';
    case 'center':
      return '-50%';
    case 'end':
      return '-100%';
    default:
      assertNever(alignment,);
  }
}
function getCenteringTransform(placement, alignment = 'center',) {
  switch (placement) {
    case 'top':
      return `${valueForCursorAlignment(alignment,)}, -100%`;
    case 'right':
      return `0%, ${valueForCursorAlignment(alignment,)}`;
    case 'bottom':
      return `${valueForCursorAlignment(alignment,)}, 0%`;
    case 'left':
      return `-100%, ${valueForCursorAlignment(alignment,)}`;
    default:
      return '-50%, -50%';
  }
}
var portalIdAttribute = 'data-framer-portal-id';
function getCursorHash(x, y,) {
  var _a;
  let el = document.elementFromPoint(x, y,);
  while (el) {
    if (el === document.body) {
      return void 0;
    }
    const value = el.getAttribute('data-framer-cursor',);
    if (value) {
      return value;
    }
    if (el.hasAttribute(portalIdAttribute,)) {
      const id3 = el.getAttribute(portalIdAttribute,);
      el = el.parentElement;
      if (id3) {
        el = (_a = document.getElementById(id3,)) != null ? _a : el;
      }
    } else {
      el = el.parentElement;
    }
  }
  return void 0;
}
function isEmptyObject(object,) {
  for (const _ in object) {
    return false;
  }
  return true;
}
var CustomCursorComponent = /* @__PURE__ */ React722.memo(function CustomCursorComponent2() {
  var _a;
  const { onRegisterCursors, } = useContext132(CustomCursorContext,);
  const pointerX = useMotionValue(0,);
  const pointerY = useMotionValue(0,);
  const opacity = useMotionValue(0,);
  const cursorRef = React722.useRef(null,);
  const internalState = React722.useRef({ cursors: {}, cursorHash: void 0, },);
  const forceRender = useForceUpdate3();
  const hasCursors = !isEmptyObject(internalState.current.cursors,);
  React722.useEffect(() => {
    let x2 = 0;
    let y2 = 0;
    function updateValues() {
      pointerX.set(x2,);
      pointerY.set(y2,);
      animate(opacity, 1, { type: 'tween', duration: 0.2, },);
    }
    function updateCursor(e,) {
      if (e.pointerType === 'touch') {
        return;
      }
      x2 = e.clientX;
      y2 = e.clientY;
      frame.update(updateValues,);
    }
    const updateVariant = () => {
      if (!hasCursors) {
        return;
      }
      const hash2 = getCursorHash(x2, y2,);
      if (hash2 !== internalState.current.cursorHash) {
        internalState.current.cursorHash = hash2;
        frame.update(() => forceRender());
      }
    };
    frame.read(updateVariant, true,);
    function fireEventToTarget(e,) {
      if (e.target === cursorRef.current || !cursorRef.current) {
        return;
      }
      const event = new PointerEvent(e.type, {
        bubbles: true,
        cancelable: e.cancelable,
        pointerType: e.pointerType,
        pointerId: e.pointerId,
        composed: e.composed,
        isPrimary: e.isPrimary,
        buttons: e.buttons,
        button: e.button,
      },);
      frame.update(() => {
        var _a2;
        (_a2 = cursorRef.current) == null ? void 0 : _a2.dispatchEvent(event,);
      },);
    }
    safeWindow.addEventListener('pointermove', updateCursor,);
    document.addEventListener('pointerdown', fireEventToTarget,);
    document.addEventListener('pointerup', fireEventToTarget,);
    return () => {
      safeWindow.removeEventListener('pointermove', updateCursor,);
      document.removeEventListener('pointerdown', fireEventToTarget,);
      document.removeEventListener('pointerup', fireEventToTarget,);
      cancelFrame(updateVariant,);
    };
  }, [opacity, pointerX, pointerY, hasCursors, forceRender,],);
  React722.useEffect(() => {
    function hideCursor() {
      animate(opacity, 0, { type: 'tween', duration: 0.2, },);
    }
    document.addEventListener('mouseleave', hideCursor,);
    safeWindow.addEventListener('blur', hideCursor,);
    return () => {
      document.removeEventListener('mouseleave', hideCursor,);
      safeWindow.removeEventListener('blur', hideCursor,);
    };
  }, [opacity,],);
  React722.useLayoutEffect(() => {
    function updateCursors(newCursors,) {
      internalState.current.cursors = newCursors;
      internalState.current.cursorHash = getCursorHash(pointerX.get(), pointerY.get(),);
      forceRender();
    }
    const unregister = onRegisterCursors(updateCursors,);
    return () => {
      unregister();
      document.body.classList.toggle(replaceCursorClassName, false,);
    };
  }, [pointerX, pointerY, onRegisterCursors, forceRender,],);
  const { cursors, cursorHash, } = internalState.current;
  const cursor = cursorHash ? cursors[cursorHash] : null;
  const replaceNativeCursor = customCursorReplacesNativeCursor(cursor,);
  React722.useLayoutEffect(() => {
    document.body.classList.toggle(replaceCursorClassName, replaceNativeCursor,);
  }, [replaceNativeCursor,],);
  const Cursor = cursor == null ? void 0 : cursor.component;
  const spring2 = (_a = cursor == null ? void 0 : cursor.transition) != null ? _a : { duration: 0, };
  const sprungX = useSpring(pointerX, spring2,);
  const sprungY = useSpring(pointerY, spring2,);
  const x = useTransform(() => {
    var _a2, _b;
    return sprungX.get() + ((_b = (_a2 = cursor == null ? void 0 : cursor.offset) == null ? void 0 : _a2.x) != null ? _b : 0);
  },);
  const y = useTransform(() => {
    var _a2, _b;
    return sprungY.get() + ((_b = (_a2 = cursor == null ? void 0 : cursor.offset) == null ? void 0 : _a2.y) != null ? _b : 0);
  },);
  const alignment = cursor == null ? void 0 : cursor.alignment;
  const placement = cursor == null ? void 0 : cursor.placement;
  const transformTemplate2 = React722.useCallback(
    (_, t,) => `translate(${getCenteringTransform(placement, alignment,)}) ${t}`,
    [alignment, placement,],
  );
  if (!cursor || !Cursor) {
    return null;
  }
  return /* @__PURE__ */ React722.createElement(
    Cursor,
    {
      transformTemplate: transformTemplate2,
      style: {
        ...staticCursorStyle,
        x,
        y,
        opacity,
      },
      globalTapTarget: true,
      variant: cursor == null ? void 0 : cursor.variant,
      ref: cursorRef,
      className: cursorComponentClassName,
    },
  );
},);
function useCustomCursors(webPageCursors,) {
  const { registerCursors, } = useContext132(CustomCursorContext,);
  const cursors = useConstant2(() => webPageCursors);
  React722.useLayoutEffect(() => {
    registerCursors(cursors,);
  }, [cursors, registerCursors,],);
}
function invertPlacement(placement,) {
  switch (placement) {
    case 'top':
      return 'bottom';
    case 'right':
      return 'left';
    case 'bottom':
      return 'top';
    case 'left':
      return 'right';
    default:
      assertNever(placement,);
  }
}
function preferredOffset(point2, length, max, collisionDetectionPadding = 0,) {
  const min = Math.max(point2, collisionDetectionPadding,);
  if (point2 < min) {
    return min;
  }
  const size2 = length + collisionDetectionPadding;
  if (min + size2 > max) {
    return max - size2;
  }
  return min;
}
function collisionAxis(placement, rect, windowSize,) {
  switch (placement) {
    case 'top':
    case 'bottom':
      if (rect.y < 0 || rect.y + rect.height > windowSize.height) {
        return 'y';
      }
      return void 0;
    case 'left':
    case 'right':
      if (rect.x < 0 || rect.x + rect.width > windowSize.width) {
        return 'x';
      }
      return void 0;
    default:
      assertNever(placement,);
  }
}
function getPlacementAndOffsetAvoidingScreenCollision(rect, placement, offset, windowSize,) {
  switch (collisionAxis(placement, rect, windowSize,)) {
    case 'x':
      return {
        placement: invertPlacement(placement,),
        x: offset.x * -1,
        y: offset.y,
      };
    case 'y':
      return {
        placement: invertPlacement(placement,),
        x: offset.x,
        y: offset.y * -1,
      };
    default:
      return {
        placement,
        x: offset.x,
        y: offset.y,
      };
  }
}
function getSafePlacementFloatingPositionRect(
  anchor,
  element,
  placement,
  alignment,
  offset,
  collisionDetectionSize,
  collisionDetectionPadding,
) {
  const rebasedRect = Rect.rebaseRectOnto(element, anchor, placement, alignment,);
  const preferredRect = {
    x: rebasedRect.x + offset.x,
    y: rebasedRect.y + offset.y,
    width: element.width,
    height: element.height,
  };
  if (!collisionDetectionSize) {
    return [placement, preferredRect,];
  }
  const {
    x,
    y,
    placement: safePlacement,
  } = getPlacementAndOffsetAvoidingScreenCollision(preferredRect, placement, offset, collisionDetectionSize,);
  const rebasedCollisionRect = Rect.rebaseRectOnto(element, anchor, safePlacement, alignment,);
  return [
    safePlacement,
    {
      x: preferredOffset(
        rebasedCollisionRect.x + x,
        element.width,
        collisionDetectionSize.width,
        collisionDetectionPadding,
      ),
      y: preferredOffset(
        rebasedCollisionRect.y + y,
        element.height,
        collisionDetectionSize.height,
        collisionDetectionPadding,
      ),
      width: element.width,
      height: element.height,
    },
  ];
}
function preferredPoint(a, b, points,) {
  if (Point.insidePoints(a, [b, ...points,],)) {
    return b;
  }
  return a;
}
var minInset = 5;
function safeAreaPolygonConstraints(rect,) {
  return {
    constrainX: (value,) => Math.min(Math.max(value, rect.x + minInset,), rect.x + rect.width - minInset,),
    constrainY: (value,) => Math.min(Math.max(value, rect.y + minInset,), rect.y + rect.height - minInset,),
  };
}
var mouseOffset = 4;
function polygonPoints({ x, y, }, placement, rect, { constrainX, constrainY, },) {
  const [tl, bl, tr, br,] = Rect.points(rect,);
  switch (placement) {
    case 'left': {
      const mousePoint = { x: constrainX(x - mouseOffset,), y, };
      return [mousePoint, preferredPoint(br, bl, [mousePoint, tr,],), preferredPoint(tr, tl, [mousePoint, br,],),];
    }
    case 'right': {
      const mousePoint = { x: constrainX(x + mouseOffset,), y, };
      return [mousePoint, preferredPoint(bl, br, [mousePoint, tl,],), preferredPoint(tl, tr, [mousePoint, bl,],),];
    }
    case 'top': {
      const mousePoint = { x, y: constrainY(y - mouseOffset,), };
      return [mousePoint, preferredPoint(bl, tl, [mousePoint, br,],), preferredPoint(br, tr, [mousePoint, bl,],),];
    }
    case 'bottom': {
      const mousePoint = { x, y: constrainY(y + mouseOffset,), };
      return [mousePoint, preferredPoint(tl, bl, [mousePoint, tr,],), preferredPoint(tr, br, [mousePoint, tl,],),];
    }
    default:
      assertNever(placement,);
  }
}
function safeAreaInset(placement, delta,) {
  switch (placement) {
    case 'left':
      return `${Math.min(delta.y, 0,)}px auto auto 0px`;
    case 'right':
      return `${Math.min(delta.y, 0,)}px 0px auto auto`;
    case 'top':
      return `0px auto auto ${Math.min(delta.x, 0,)}px`;
    case 'bottom':
      return `auto auto 0px ${Math.min(delta.x, 0,)}px`;
    default:
      assertNever(placement,);
  }
}
function floatingPositionSafeAreaStyle(x, y, placement, anchorRect, floatingRect,) {
  const minX = Math.min(floatingRect.x, anchorRect.x,);
  const minY = Math.min(floatingRect.y, anchorRect.y,);
  const rect = Rect.merge(anchorRect, floatingRect,);
  const points = polygonPoints({ x, y, }, placement, floatingRect, safeAreaPolygonConstraints(anchorRect,),).map((point2,) =>
    `${point2.x - minX}px ${point2.y - minY}px`
  ).join(', ',);
  return {
    height: `${rect.height}px`,
    width: `${rect.width}px`,
    clipPath: `polygon(${points})`,
    inset: safeAreaInset(placement, Rect.delta(anchorRect, floatingRect,),),
  };
}
function valueForFloatingAlignment(alignment,) {
  switch (alignment) {
    case 'start':
      return 0;
    case 'center':
      return 0.5;
    case 'end':
      return 1;
    default:
      assertNever(alignment,);
  }
}
function motionOriginFromFloatingPosition(placement = 'bottom', alignment = 'center',) {
  switch (placement) {
    case 'top':
      return { originX: valueForFloatingAlignment(alignment,), originY: 1, };
    case 'right':
      return { originX: 0, originY: valueForFloatingAlignment(alignment,), };
    case 'bottom':
      return { originX: valueForFloatingAlignment(alignment,), originY: 0, };
    case 'left':
      return { originX: 1, originY: valueForFloatingAlignment(alignment,), };
    default:
      assertNever(placement,);
  }
}
function isRef(value,) {
  return isObject2(value,) && 'current' in value;
}
function getAncestorInfo(anchorRef,) {
  var _a;
  let el = anchorRef.current;
  const info = {
    position: 'absolute',
    scrolls: false,
  };
  while (el) {
    if ((el == null ? void 0 : el.tagName) === 'BODY') {
      return info;
    }
    if (((_a = getComputedStyle(el,)) == null ? void 0 : _a.position) === 'fixed') {
      info.position = 'fixed';
    }
    if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
      info.scrolls = true;
    }
    if (info.scrolls && info.position === 'fixed') {
      return info;
    }
    el = el.parentElement;
  }
  return info;
}
function createAnimationFrameLoop(cb,) {
  let frame2;
  function loop() {
    frame2 = requestAnimationFrame(() => {
      cb();
      loop();
    },);
  }
  return [loop, () => cancelAnimationFrame(frame2,),];
}
function createUpdateSafeArea(safeAreaRef,) {
  let x = 0;
  let y = 0;
  return (anchorRect, calculatedRect, placement, event,) => {
    var _a, _b, _c;
    if (!((_a = safeAreaRef.current) == null ? void 0 : _a.style)) {
      return;
    }
    x = (_b = event == null ? void 0 : event.clientX) != null ? _b : x;
    y = (_c = event == null ? void 0 : event.clientY) != null ? _c : y;
    Object.assign(
      safeAreaRef.current.style,
      floatingPositionSafeAreaStyle(x, y, placement, anchorRect, calculatedRect,),
    );
  };
}
function updatePosition(floatingPositionRef, position, rect,) {
  var _a, _b;
  if (!floatingPositionRef.current) {
    return;
  }
  Object.assign(floatingPositionRef.current.style, {
    position,
    visibility: 'visible',
    // Append "px" because we are assigning this object straight to style.
    left: ((_a = rect == null ? void 0 : rect.x) != null ? _a : 0) + (position === 'fixed' ? 0 : safeWindow.scrollX) + 'px',
    top: ((_b = rect == null ? void 0 : rect.y) != null ? _b : 0) + (position === 'fixed' ? 0 : safeWindow.scrollY) + 'px',
  },);
}
var FloatingStackingContext = /* @__PURE__ */ React73.createContext(/* @__PURE__ */ new Set(),);
function useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, { safeArea, onDismiss, },) {
  const descendantStackingContext = useConstant2(() => /* @__PURE__ */ new Set());
  const ancestorStackingContext = React73.useContext(FloatingStackingContext,);
  const [isPresent2, safeToRemove,] = usePresence();
  React73.useEffect(() => {
    if (isPresent2) {
      if (!floatingPositionRef.current) {
        return;
      }
      floatingPositionRef.current.style.pointerEvents = '';
      ancestorStackingContext.add(floatingPositionRef.current,);
    } else {
      if (!floatingPositionRef.current) {
        return;
      }
      floatingPositionRef.current.style.pointerEvents = 'none';
      ancestorStackingContext.delete(floatingPositionRef.current,);
      safeToRemove();
    }
  }, [isPresent2, floatingPositionRef, ancestorStackingContext,],);
  React73.useEffect(() => {
    if (!safeArea) {
      const handleEscape = (e,) => {
        if (e.key !== 'Escape') {
          return;
        }
        onDismiss();
      };
      safeWindow.addEventListener('keyup', handleEscape,);
      return () => safeWindow.removeEventListener('keyup', handleEscape,);
    }
    function maybeDismiss(event,) {
      if (descendantStackingContext.size !== 0) {
        return;
      }
      for (const element of document.elementsFromPoint(event.x, event.y,)) {
        if (element === anchorRef.current) {
          return;
        }
        if (element === floatingPositionRef.current) {
          return;
        }
        if (element === safeAreaRef.current) {
          return;
        }
      }
      onDismiss();
    }
    safeWindow.addEventListener('mousemove', maybeDismiss,);
    return () => {
      safeWindow.removeEventListener('mousemove', maybeDismiss,);
    };
  }, [
    onDismiss,
    safeArea,
    anchorRef,
    safeAreaRef,
    floatingPositionRef,
    safeToRemove,
    ancestorStackingContext,
    descendantStackingContext,
  ],);
  return descendantStackingContext;
}
function makeGetSafePlacementFloatingPositionRect({
  placement,
  alignment,
  offset,
  collisionDetectionSize,
  collisionDetectionPadding,
},) {
  return (anchor, element,) =>
    getSafePlacementFloatingPositionRect(
      anchor,
      element,
      placement,
      alignment,
      offset,
      collisionDetectionSize,
      collisionDetectionPadding,
    );
}
function useDynamicMotionOrigin(initialPlacement, alignment,) {
  return useConstant2(() => {
    const { originX, originY, } = motionOriginFromFloatingPosition(initialPlacement, alignment,);
    const origin = { x: motionValue(originX,), y: motionValue(originY,), };
    return [
      origin,
      (placement,) => {
        const values = motionOriginFromFloatingPosition(placement, alignment,);
        origin.x.set(values.originX,);
        origin.y.set(values.originY,);
      },
    ];
  },);
}
function childrenWithOrigin(child, { x, y, },) {
  if (!child || !isReactChild(child,) || !isReactElement(child,)) {
    return null;
  }
  if (!isObject2(child.props.style,) && !isUndefined(child.props.style,)) {
    return null;
  }
  const style = {
    ...child.props.style,
    originX: x,
    originY: y,
  };
  return React73.cloneElement(child, { style, },);
}
function Floating({
  alignment,
  placement,
  safeArea,
  offsetX,
  offsetY,
  anchorRef,
  className,
  children,
  portalSelector,
  zIndex,
  collisionDetection = false,
  collisionDetectionPadding,
  onDismiss,
  ...rest
},) {
  var _a;
  const floatingPositionRef = React73.useRef(null,);
  const safeAreaRef = React73.useRef(null,);
  const contentRef = React73.useRef(null,);
  const [origin, updateOrigin,] = useDynamicMotionOrigin(placement, alignment,);
  React73.useLayoutEffect(() => {
    if (!isRef(anchorRef,) || !contentRef.current || !placement || !alignment) {
      return;
    }
    const { position, scrolls, } = getAncestorInfo(anchorRef,);
    const elementRect = contentRef.current.getBoundingClientRect();
    const initialAnchorRect = anchorRef.current.getBoundingClientRect();
    const offset = {
      x: offsetX != null ? offsetX : 0,
      y: offsetY != null ? offsetY : 0,
    };
    const getSafePlacementRect = makeGetSafePlacementFloatingPositionRect({
      placement,
      alignment,
      offset,
      collisionDetectionSize: collisionDetection ? { width: safeWindow.innerWidth, height: safeWindow.innerHeight, } : void 0,
      collisionDetectionPadding,
    },);
    const [initialSafePlacement, initialCalculatedRect,] = getSafePlacementRect(initialAnchorRect, elementRect,);
    updatePosition(floatingPositionRef, position, initialCalculatedRect,);
    updateOrigin(initialSafePlacement,);
    const updateSafeArea = createUpdateSafeArea(safeAreaRef,);
    const [loop, cancelAnimationFrameLoop,] = createAnimationFrameLoop(() => {
      const anchorRect = anchorRef.current.getBoundingClientRect();
      const [safePlacement, calculatedRect,] = getSafePlacementRect(anchorRect, elementRect,);
      updatePosition(floatingPositionRef, position, calculatedRect,);
      updateOrigin(safePlacement,);
      if (safeArea) {
        updateSafeArea(anchorRect, calculatedRect, safePlacement,);
      }
    },);
    if (scrolls) {
      loop == null ? void 0 : loop();
    }
    if (!safeArea) {
      return () => cancelAnimationFrameLoop == null ? void 0 : cancelAnimationFrameLoop();
    }
    const handleMouseMove = (event,) => {
      const rect = anchorRef.current.getBoundingClientRect();
      const [safePlacement, calculatedRect,] = getSafePlacementRect(rect, elementRect,);
      updateSafeArea(rect, calculatedRect, safePlacement, event,);
    };
    const anchor = anchorRef.current;
    anchor.addEventListener('mousemove', handleMouseMove,);
    return () => {
      cancelAnimationFrameLoop == null ? void 0 : cancelAnimationFrameLoop();
      anchor.removeEventListener('mousemove', handleMouseMove,);
    };
  }, [
    safeArea,
    placement,
    alignment,
    offsetX,
    offsetY,
    anchorRef,
    collisionDetection,
    collisionDetectionPadding,
    updateOrigin,
  ],);
  const descendantContext = useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, {
    safeArea,
    onDismiss,
  },);
  return ReactDOM.createPortal(
    /* @__PURE__ */ React73.createElement(
      'div',
      {
        ref: floatingPositionRef,
        className,
        style: {
          // Initially rendered as hidden, but the layout effect will set
          // to visible when the position is calculated.
          visibility: 'hidden',
          width: 'auto',
          height: 'auto',
          position: 'absolute',
          zIndex,
        },
        ...rest,
      },
      safeArea
        ? /* @__PURE__ */ React73.createElement('div', { ref: safeAreaRef, style: { position: 'absolute', }, 'data-safearea': true, },)
        : /* @__PURE__ */ React73.createElement('div', {
          style: { position: 'fixed', inset: 0, },
          'aria-hidden': true,
          onMouseDown: onDismiss,
        },),
      /* @__PURE__ */ React73.createElement(
        FloatingStackingContext.Provider,
        { value: descendantContext, },
        /* @__PURE__ */ React73.createElement('div', { ref: contentRef, }, childrenWithOrigin(children, origin,),),
      ),
    ),
    (_a = document.querySelector(portalSelector,)) != null ? _a : document.body,
  );
}
var GeneratedComponentContext = /* @__PURE__ */ React74.createContext(
  void 0,
);
var LazyValue = class {
  constructor(resolver,) {
    this.resolver = resolver;
    __publicField(this, 'status',);
  }
  static is(value,) {
    return value instanceof LazyValue;
  }
  /** Preload the value so it can be read() later. */
  preload() {
    if (this.status) {
      const status = this.status;
      if (status.type !== 'pending') {
        return;
      }
      return status.promise;
    }
    const promise = this.resolver().then(
      (value,) => {
        this.status = {
          type: 'fulfilled',
          value,
        };
      },
      (error,) => {
        this.status = {
          type: 'rejected',
          error,
        };
      },
    );
    this.status = {
      type: 'pending',
      promise,
    };
    return promise;
  }
  /** Synchronously read the value after calling preload() before. */
  read() {
    const status = this.status;
    if (!status) {
      throw new Error('Need to call preload() before read()',);
    }
    switch (status.type) {
      case 'pending':
        throw new Error('Need to wait for preload() to resolve',);
      case 'fulfilled':
        return status.value;
      case 'rejected':
        throw status.error;
      default:
        assertNever(status,);
    }
  }
};
function findAnchorElement(target, withinElement,) {
  if (target instanceof HTMLAnchorElement) {
    return target;
  }
  if (target instanceof Element) {
    if (target === withinElement) {
      return null;
    }
    return findAnchorElement(target.parentElement, withinElement,);
  }
  return null;
}
var elementKey = 'element';
var collectionKey = 'collection';
var collectionItemIdKey = 'collectionItemId';
var pathVariablesKey = 'pathVariables';
var mediaType = 'framer/page-link,';
function isFramerPageLink(value,) {
  return isString22(value,) && value.startsWith(`data:${mediaType}`,);
}
function createFramerPageLink(targetId = null, options = {},) {
  const target = targetId ? targetId : 'none';
  const link = new URL(`data:${mediaType}${target}`,);
  if (options.element) {
    link.searchParams.append(elementKey, options.element,);
  }
  if (options.collectionItem) {
    link.searchParams.append(collectionKey, options.collectionItem.collection,);
    link.searchParams.append(collectionItemIdKey, options.collectionItem.collectionItemId,);
    link.searchParams.append(pathVariablesKey, new URLSearchParams(options.collectionItem.pathVariables,).toString(),);
  }
  return link.href;
}
function parseFramerPageLink(link,) {
  if (!isFramerPageLink(link,)) {
    return;
  }
  try {
    const url = new URL(link,);
    const target = url.pathname.substring(mediaType.length,);
    const searchParams = url.searchParams;
    const element = searchParams.has(elementKey,) ? searchParams.get(elementKey,) : void 0;
    let collectionItem;
    const collection = searchParams.get(collectionKey,);
    const collectionItemId = searchParams.get(collectionItemIdKey,);
    const pathVariablesValue = searchParams.get(pathVariablesKey,);
    if (collection && collectionItemId && pathVariablesValue) {
      const pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesValue,).entries(),);
      collectionItem = {
        collection,
        collectionItemId,
        pathVariables,
      };
    }
    return {
      target: target === 'none' ? null : target,
      /**
       * For historical reason we used to set "element=none" into the
       * datalink, we no longer do that today, but we still keep this code
       * so we could parse legacy links correctly.
       */
      element: element === 'none' ? void 0 : element,
      collectionItem,
    };
  } catch {
    return;
  }
}
function shouldOpenLinkInNewTab(link,) {
  return !isFramerPageLink(link,);
}
function navigateFromAttributes(navigate, element, implicitPathVariables,) {
  var _a, _b, _c;
  let routeId = element.getAttribute(
    'data-framer-page-link-target',
    /* Page */
  );
  let elementId;
  let pathVariables;
  if (routeId) {
    elementId = (_a = element.getAttribute(
        'data-framer-page-link-element',
        /* Element */
      )) != null
      ? _a
      : void 0;
    const pathVariablesRaw = element.getAttribute(
      'data-framer-page-link-path-variables',
      /* PathVariables */
    );
    if (pathVariablesRaw) {
      pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesRaw,).entries(),);
    }
  } else {
    const href = element.getAttribute('href',);
    if (!href) {
      return false;
    }
    const link = parseFramerPageLink(href,);
    if (!link || !link.target) {
      return false;
    }
    routeId = link.target;
    elementId = (_b = link.element) != null ? _b : void 0;
    pathVariables = (_c = link.collectionItem) == null ? void 0 : _c.pathVariables;
  }
  const smoothScroll = elementId ? element.dataset.framerSmoothScroll !== void 0 : void 0;
  navigate(routeId, elementId, Object.assign({}, implicitPathVariables, pathVariables,), smoothScroll,);
  return true;
}
var noLocale = {};
var resolveSlugCache = /* @__PURE__ */ new WeakMap();
function resolveSlug(unresolvedSlug, utilsByCollectionId, activeLocale,) {
  var _a, _b, _c, _d;
  const cache3 =
    (_b = (_a = resolveSlugCache == null ? void 0 : resolveSlugCache.get(activeLocale != null ? activeLocale : noLocale,)) == null
        ? void 0
        : _a.get(unresolvedSlug.collectionId,)) == null
      ? void 0
      : _b.get(unresolvedSlug.collectionItemId,);
  if (cache3) {
    return cache3;
  }
  const collectionCache = (_c = resolveSlugCache.get(activeLocale != null ? activeLocale : noLocale,)) != null
    ? _c
    : /* @__PURE__ */ new Map();
  resolveSlugCache.set(activeLocale != null ? activeLocale : noLocale, collectionCache,);
  const collectionItemCache = (_d = collectionCache.get(unresolvedSlug.collectionId,)) != null ? _d : /* @__PURE__ */ new Map();
  collectionCache.set(unresolvedSlug.collectionId, collectionItemCache,);
  const lazyValue = new LazyValue(async () => {
    try {
      const getUtils = utilsByCollectionId[unresolvedSlug.collectionId];
      if (!getUtils) {
        throw new Error(`Key not found in collection utils for collection id: "${unresolvedSlug.collectionId}`,);
      }
      const utils = await getUtils();
      if (!utils) {
        throw new Error('Collection does not contain utility functions',);
      }
      const slug = await utils.getSlugByRecordId(unresolvedSlug.collectionItemId, activeLocale != null ? activeLocale : void 0,);
      return slug;
    } catch (error) {
      console.warn(`Failed to resolve slug: ${error instanceof Error ? error.message : 'Unknown error'}`,);
      return void 0;
    }
  },);
  collectionItemCache.set(unresolvedSlug.collectionItemId, lazyValue,);
  return lazyValue;
}
var linkKey = 'webPageId';
function isLinkToWebPage(link,) {
  return Boolean(link && typeof link === 'object' && linkKey in link,);
}
function createVariablesFromPageLinkCollectionItem(collectionItem,) {
  if (!collectionItem) {
    return void 0;
  }
  const variables = {};
  for (const pathVariablesKey2 in collectionItem.pathVariables) {
    const value = collectionItem.pathVariables[pathVariablesKey2];
    if (value) {
      variables[pathVariablesKey2] = value;
    }
  }
  return variables;
}
function linkFromFramerPageLink(link,) {
  if (!isFramerPageLink(link,)) {
    return link;
  }
  const parsed = parseFramerPageLink(link,);
  if (!parsed) {
    return void 0;
  }
  const { target, element, collectionItem, } = parsed;
  if (!target) {
    return void 0;
  }
  return {
    webPageId: target,
    hash: element != null ? element : void 0,
    pathVariables: createVariablesFromPageLinkCollectionItem(collectionItem,),
  };
}
var pathVariablesRegExp2 = /:([a-z]\w*)/gi;
var PathVariablesContext = React75.createContext(void 0,);
function useImplicitPathVariables() {
  var _a;
  const contextPathVariables = React75.useContext(PathVariablesContext,);
  const currentPathVariables = (_a = useCurrentRoute()) == null ? void 0 : _a.pathVariables;
  const pathVariables = contextPathVariables || currentPathVariables;
  return pathVariables;
}
function linkMatchesRoute(route, { webPageId, hash: hash2, pathVariables, }, implicitPathVariables,) {
  if (webPageId !== route.id) {
    return false;
  }
  if (hash2) {
    return false;
  }
  if (route.path && route.pathVariables) {
    const combinedPathVariable = Object.assign({}, implicitPathVariables, pathVariables,);
    for (const [, key7,] of route.path.matchAll(pathVariablesRegExp2,)) {
      if (!key7) {
        return false;
      }
      if (route.pathVariables[key7] !== combinedPathVariable[key7]) {
        return false;
      }
    }
  }
  return true;
}
function useLinkMatchesRoute(link,) {
  const route = useCurrentRoute();
  const contextPathVariables = React75.useContext(PathVariablesContext,);
  if (!route) {
    return false;
  }
  const pageLink = isString22(link,) ? linkFromFramerPageLink(link,) : link;
  return isLinkToWebPage(pageLink,) ? linkMatchesRoute(route, pageLink, contextPathVariables,) : false;
}
function isInternalURL(href,) {
  if (href === void 0) {
    return false;
  }
  if (href.startsWith('#',) || href.startsWith('/',) || href.startsWith('.',)) {
    return true;
  }
  return false;
}
function isValidURL(href, isInternal,) {
  try {
    const url = new URL(href,);
    return Boolean(url.protocol,);
  } catch {
  }
  return isInternal;
}
var AnchorLinkTarget = /* @__PURE__ */ ((AnchorLinkTarget2,) => {
  AnchorLinkTarget2['_blank'] = '_blank';
  AnchorLinkTarget2['_self'] = '_self';
  return AnchorLinkTarget2;
})(AnchorLinkTarget || {},);
function getTargetAttrValue(openInNewTab, isInternal,) {
  if (openInNewTab !== void 0) {
    return openInNewTab ? '_blank' : void 0;
  }
  return isInternal ? void 0 : '_blank';
}
function propsForLink(href, openInNewTab = void 0,) {
  const isInternal = isInternalURL(href,);
  const anchorTarget = getTargetAttrValue(openInNewTab, isInternal,);
  return {
    href: isValidURL(href, isInternal,) ? href : `https://${href}`,
    target: anchorTarget,
    rel: !isInternal ? 'noopener' : void 0,
  };
}
function createOnClickLinkHandler(router, routeId, elementId, combinedPathVariables, smoothScroll,) {
  return async (event,) => {
    var _a, _b;
    if (event.metaKey) {
      return;
    }
    const anchorElement = findAnchorElement(event.target,);
    if (!anchorElement || anchorElement.getAttribute('target',) === '_blank') {
      return;
    }
    event.preventDefault();
    const route = (_a = router.getRoute) == null ? void 0 : _a.call(router, routeId,);
    if (route && isLazyComponentType(route == null ? void 0 : route.page,)) {
      await route.page.preload();
    }
    (_b = router.navigate) == null ? void 0 : _b.call(router, routeId, elementId, combinedPathVariables, smoothScroll,);
  };
}
function propsForRoutePath(href, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll,) {
  const isInternal = isInternalURL(href,);
  if (!router.routes || !router.getRoute || !currentRoute || !isInternal) {
    return propsForLink(href, openInNewTab,);
  }
  try {
    const [pathnameWithQueryParams, hash2,] = href.split('#', 2,);
    assert(pathnameWithQueryParams !== void 0, 'A href must have a defined pathname.',);
    const [pathname,] = pathnameWithQueryParams.split('?', 2,);
    assert(pathname !== void 0, 'A href must have a defined pathname.',);
    const { routeId, pathVariables, } = inferInitialRouteFromPath(router.routes, pathname,);
    const route = router.getRoute(routeId,);
    if (route) {
      preloadComponent(route.page,);
      const combinedPathVariables = Object.assign({}, implicitPathVariables, pathVariables,);
      const path = getPathForRoute(route, {
        currentRoutePath: currentRoute.path,
        currentPathVariables: currentRoute.pathVariables,
        // The hash value is already fully resolved so we don't need to
        // provide any hashVariables.
        hash: hash2 || void 0,
        pathVariables: combinedPathVariables,
        preserveQueryParams: router.preserveQueryParams,
      },);
      const anchorTarget = getTargetAttrValue(openInNewTab, true,);
      return {
        href: path,
        target: anchorTarget,
        onClick: createOnClickLinkHandler(
          router,
          routeId,
          hash2 || void 0,
          combinedPathVariables,
          smoothScroll,
        ),
      };
    }
  } catch {
  }
  return propsForLink(href, openInNewTab,);
}
function resolveSlugsWithSuspense(unresolvedPathSlugs, unresolvedHashSlugs, collectionUtils, activeLocale,) {
  const promises = [];
  function handleSlugs(unresolvedSlugs,) {
    if (!unresolvedSlugs || !collectionUtils) {
      return void 0;
    }
    const result2 = {};
    for (const slugKey in unresolvedSlugs) {
      const unresolvedSlug = unresolvedSlugs[slugKey];
      assert(unresolvedSlug, 'unresolvedSlug should be defined',);
      const lazyValue = resolveSlug(unresolvedSlug, collectionUtils, activeLocale,);
      const promise = lazyValue.preload();
      if (promise) {
        promises.push(promise,);
      } else {
        const value = lazyValue.read();
        if (value) {
          result2[slugKey] = value;
        }
      }
    }
    return result2;
  }
  const result = {
    path: handleSlugs(unresolvedPathSlugs,),
    hash: handleSlugs(unresolvedHashSlugs,),
  };
  if (promises.length) {
    throw Promise.allSettled(promises,);
  }
  return result;
}
var Link = /* @__PURE__ */ React75.forwardRef(
  ({ children, href, openInNewTab, smoothScroll, ...restProps }, forwardedRef,) => {
    const router = useRouter();
    const currentRoute = useCurrentRoute();
    const implicitPathVariables = useImplicitPathVariables();
    const { activeLocale, } = useLocaleInfo();
    const props = React75.useMemo(() => {
      var _a;
      if (!href) {
        return {};
      }
      const pageLink = isLinkToWebPage(href,) ? href : linkFromFramerPageLink(href,);
      if (!pageLink) {
        return {};
      }
      if (isString22(pageLink,)) {
        return propsForRoutePath(
          pageLink,
          openInNewTab,
          router,
          currentRoute,
          implicitPathVariables,
          smoothScroll,
        );
      }
      const { webPageId, hash: hash2, pathVariables, hashVariables, unresolvedHashSlugs, unresolvedPathSlugs, } = pageLink;
      const route = (_a = router.getRoute) == null ? void 0 : _a.call(router, webPageId,);
      const resolvedSlugs = resolveSlugsWithSuspense(
        unresolvedPathSlugs,
        unresolvedHashSlugs,
        router.collectionUtils,
        activeLocale,
      );
      if (route) {
        preloadComponent(route.page,);
      }
      const combinedPathVariable = Object.assign(
        {},
        implicitPathVariables,
        pathVariables,
        resolvedSlugs == null ? void 0 : resolvedSlugs.path,
      );
      const combinedHashVariable = Object.assign(
        {},
        implicitPathVariables,
        hashVariables,
        resolvedSlugs == null ? void 0 : resolvedSlugs.hash,
      );
      const anchorTarget = getTargetAttrValue(openInNewTab, true,);
      const resolvedHref = getPathForRoute(route, {
        currentRoutePath: currentRoute == null ? void 0 : currentRoute.path,
        currentPathVariables: currentRoute == null ? void 0 : currentRoute.pathVariables,
        hash: hash2,
        pathVariables: combinedPathVariable,
        hashVariables: combinedHashVariable,
        preserveQueryParams: router.preserveQueryParams,
      },);
      const resolvedHash = resolvedHref.split('#', 2,)[1];
      return {
        href: resolvedHref,
        target: anchorTarget,
        onClick: createOnClickLinkHandler(router, webPageId, resolvedHash, combinedPathVariable, smoothScroll,),
        'data-framer-page-link-current': currentRoute && linkMatchesRoute(currentRoute, pageLink, implicitPathVariables,) || void 0,
      };
    }, [href, router, activeLocale, implicitPathVariables, openInNewTab, currentRoute, smoothScroll,],);
    if (!children) {
      return null;
    }
    const child = React75.Children.only(children,);
    if (!React75.isValidElement(child,)) {
      return null;
    }
    return React75.cloneElement(child, { ...restProps, ...props, ref: forwardedRef != null ? forwardedRef : restProps.ref, },);
  },
);
function resolveLink(href, router, implicitPathVariables,) {
  return resolveLinkInternal(href, router, implicitPathVariables,);
}
function resolveLinkInternal(href, router, implicitPathVariables, resolveSlugs,) {
  const pageLink = isLinkToWebPage(href,) ? href : linkFromFramerPageLink(href,);
  if (!isLinkToWebPage(pageLink,)) {
    return isString22(href,) ? propsForLink(href,).href : void 0;
  }
  if (!router.getRoute || !router.currentRouteId) {
    return void 0;
  }
  const currentRoute = router.getRoute(router.currentRouteId,);
  const { webPageId, hash: hash2, pathVariables, hashVariables, unresolvedHashSlugs, unresolvedPathSlugs, } = pageLink;
  const route = router.getRoute(webPageId,);
  const resolvedSlugs = unresolvedPathSlugs || unresolvedHashSlugs
    ? resolveSlugs == null ? void 0 : resolveSlugs(unresolvedPathSlugs, unresolvedHashSlugs,)
    : void 0;
  const combinedPathVariables = Object.assign(
    {},
    router.currentPathVariables,
    implicitPathVariables,
    pathVariables,
    resolvedSlugs == null ? void 0 : resolvedSlugs.path,
  );
  const combinedHashVariables = Object.assign(
    {},
    router.currentPathVariables,
    implicitPathVariables,
    hashVariables,
    resolvedSlugs == null ? void 0 : resolvedSlugs.hash,
  );
  return getPathForRoute(route, {
    currentRoutePath: currentRoute == null ? void 0 : currentRoute.path,
    currentPathVariables: router.currentPathVariables,
    hash: hash2,
    pathVariables: combinedPathVariables,
    hashVariables: combinedHashVariables,
    relative: false,
    preserveQueryParams: router.preserveQueryParams,
  },);
}
function resolvePageScope(pageLink, router,) {
  if (!router.getRoute || !router.currentRouteId) {
    return void 0;
  }
  const currentRoute = router.getRoute(router.currentRouteId,);
  const { webPageId, } = pageLink;
  const route = router.getRoute(webPageId,);
  return getPathForRoute(route, {
    currentRoutePath: currentRoute == null ? void 0 : currentRoute.path,
    currentPathVariables: router.currentPathVariables,
    relative: false,
    preserveQueryParams: router.preserveQueryParams,
  },);
}
function PageRoot({
  RootComponent,
  isWebsite,
  routeId,
  pathVariables,
  routes,
  collectionUtils,
  notFoundPage,
  isReducedMotion = false,
  includeDataObserver = false,
  localeId,
  locales,
  preserveQueryParams,
  enableSuspenseThatPreservesDom,
  shouldMarkHydrationEnd = false,
},) {
  React76.useLayoutEffect(() => {
    if (shouldMarkHydrationEnd) {
      performance.mark('framer-hydration-end',);
      performance.measure('framer-hydration', 'framer-hydration-start', 'framer-hydration-end',);
    }
  }, [],);
  React76.useEffect(() => {
    if (isWebsite) {
      return;
    }
    MainLoop.start();
  }, [],);
  if (isWebsite) {
    return /* @__PURE__ */ React76.createElement(
      MotionConfig,
      { reducedMotion: isReducedMotion ? 'user' : 'never', },
      /* @__PURE__ */ React76.createElement(
        CustomCursorHost,
        null,
        /* @__PURE__ */ React76.createElement(
          Router,
          {
            initialRoute: routeId,
            initialPathVariables: pathVariables,
            initialLocaleId: localeId,
            routes,
            collectionUtils,
            notFoundPage,
            locales,
            defaultPageStyle: { minHeight: '100vh', width: 'auto', },
            preserveQueryParams,
            enableSuspenseThatPreservesDom,
          },
        ),
      ),
    );
  } else {
    const Wrapper = includeDataObserver ? DataObserver : React76.Fragment;
    return /* @__PURE__ */ React76.createElement(
      Wrapper,
      null,
      /* @__PURE__ */ React76.createElement(
        RoutesProvider,
        { routes, },
        /* @__PURE__ */ React76.createElement(
          NavigationWrapper,
          null,
          React76.isValidElement(RootComponent,) ? RootComponent : React76.createElement(
            // @ts-expect-error to figure out how to type this properly, as tests are using different
            // $$typeof symbol and isValidElement fails
            RootComponent,
            { key: routeId, },
          ),
        ),
      ),
    );
  }
}
var SSRParentVariantsContext = /* @__PURE__ */ React77.createContext(void 0,);
var SSRVariantClassName = 'ssr-variant';
function propsForClonedChild(child, props, ref,) {
  var _a;
  if ('ref' in child) {
    return { ...props, ref: (_a = child.ref) != null ? _a : ref, };
  }
  return { ...props, ref, };
}
function childrenWithForwardedProps(children, props, ref,) {
  return /* @__PURE__ */ React77.createElement(
    React77.Fragment,
    null,
    React77.Children.map(children, (child,) => {
      if (!child || !isReactChild(child,) || !isReactElement(child,)) {
        return null;
      }
      return React77.cloneElement(child, propsForClonedChild(child, props, ref,),);
    },),
  );
}
function renderBranchedChildrenFromPropertyOverrides(
  overrides,
  children,
  props,
  ref,
  variantClassNames,
  primaryVariantId,
  parentVariants,
  type,
) {
  const childrenArray = React77.Children.toArray(children,);
  const child = childrenArray[0];
  if (childrenArray.length !== 1 || !React77.isValidElement(child,)) {
    console.warn(type + ': expected exactly one React element for a child', children,);
    return childrenWithForwardedProps(children, props, ref,);
  }
  const branches = [];
  const nonOverriddenVariants = [];
  for (const [variantId,] of Object.entries(variantClassNames,)) {
    if (variantId === primaryVariantId) {
      continue;
    }
    const propOverrides = overrides[variantId];
    if (!propOverrides || !arePropOverridesEffectivelyDifferent(child.props, propOverrides,)) {
      nonOverriddenVariants.push(variantId,);
      continue;
    }
    const effectiveVariants = intersection([variantId,], parentVariants,);
    if (effectiveVariants.length) {
      branches.push({ variants: effectiveVariants, propOverrides, },);
    }
  }
  if (branches.length === 0) {
    return React77.cloneElement(child, { ...props, ref, },);
  }
  const remainingVariants = [primaryVariantId, ...nonOverriddenVariants,];
  const effectiveRemainingVariants = intersection(remainingVariants, parentVariants,);
  if (effectiveRemainingVariants.length) {
    branches.unshift({ variants: effectiveRemainingVariants, },);
  }
  const displayContents = `.${SSRVariantClassName} { display: contents }`;
  return /* @__PURE__ */ React77.createElement(
    React77.Fragment,
    null,
    !parentVariants && /* @__PURE__ */ React77.createElement('style', { ...styleTagSSRMarker, }, displayContents,),
    branches.map(({ variants, propOverrides, },) => {
      const key7 = variants.join('+',);
      let element = (
        // We could omit the SSRParentVariantsContext if variants is
        // the same as parentVariants, but that'd require comparing
        // arrays, so it might not really be an optimization. And
        // since it's just a context, it doesn't affect the size of
        // the generated HTML.
        /* @__PURE__ */ React77.createElement(
          SSRParentVariantsContext.Provider,
          { key: key7, value: new Set(variants,), },
          React77.cloneElement(child, { ...props, ...propOverrides, ref, },),
        )
      );
      const hiddenClassNames = generateHiddenClassNames(variants, parentVariants, variantClassNames,);
      if (hiddenClassNames.length) {
        assert(branches.length > 1, 'Must branch out when there are hiddenClassNames',);
        element = /* @__PURE__ */ React77.createElement('div', {
          key: key7,
          className: `${SSRVariantClassName} ${hiddenClassNames.join(' ',)}`,
        }, element,);
      } else {
        assert(branches.length === 1, 'Cannot branch out when hiddenClassNames is empty',);
      }
      return element;
    },),
  );
}
var SSRVariants = /* @__PURE__ */ React77.forwardRef(
  function SSRVariants2({ id: nodeId, children, ...props }, ref,) {
    if (isBrowser2()) {
      return childrenWithForwardedProps(children, props, ref,);
    }
    const generatedComponentContext = React77.useContext(GeneratedComponentContext,);
    if (!generatedComponentContext || !generatedComponentContext.variantProps) {
      console.warn('SSRVariants is missing GeneratedComponentContext',);
      return childrenWithForwardedProps(children, props, ref,);
    }
    const parentVariants = React77.useContext(SSRParentVariantsContext,);
    const { primaryVariantId, variantClassNames, variantProps: variantProps2, } = generatedComponentContext;
    const overrides = React77.useMemo(() => {
      const nextOverrides = {};
      for (const [variant, values,] of Object.entries(variantProps2,)) {
        nextOverrides[variant] = values[nodeId];
      }
      return nextOverrides;
    }, [nodeId, variantProps2,],);
    return renderBranchedChildrenFromPropertyOverrides(
      overrides,
      children,
      props,
      ref,
      variantClassNames,
      primaryVariantId,
      parentVariants,
      'SSRVariants',
    );
  },
);
function generateHiddenClassNames(showOnlyInVariantIds, parentVariants, variantClassNames,) {
  const classNames = [];
  for (const [variantId, variantClassName,] of Object.entries(variantClassNames,)) {
    const alreadyHiddenInParent = parentVariants && !parentVariants.has(variantId,);
    if (showOnlyInVariantIds.includes(variantId,) || alreadyHiddenInParent) {
      continue;
    }
    const variantHash = variantClassName.split('-',)[2];
    classNames.push(`hidden-${variantHash}`,);
  }
  return classNames;
}
function intersection(variants, parentVariants,) {
  if (!parentVariants) {
    return variants;
  }
  return variants.filter((variant,) => parentVariants.has(variant,));
}
function propertyKeyDifferenceShouldBeIgnored(key7,) {
  switch (key7) {
    case 'transformTemplate':
      return false;
    default:
      return false;
  }
}
function arePropOverridesEffectivelyDifferent(props, propOverrides,) {
  for (const key7 of Object.keys(propOverrides,)) {
    if (propertyKeyDifferenceShouldBeIgnored(key7,)) {
      continue;
    }
    if (!isEqual(props[key7], propOverrides[key7], true,)) {
      return true;
    }
  }
  return false;
}
function propsForBreakpoint(variant, props, overrides,) {
  if (!overrides || !variant) {
    return props;
  }
  return { ...props, ...overrides[variant], };
}
var PropertyOverrides = /* @__PURE__ */ React77.forwardRef(
  function PropertyOverrides2({ breakpoint, overrides, children, ...props }, ref,) {
    if (isBrowser2()) {
      return childrenWithForwardedProps(children, propsForBreakpoint(breakpoint, props, overrides,), ref,);
    }
    const generatedComponentContext = React77.useContext(GeneratedComponentContext,);
    if (!generatedComponentContext) {
      console.warn('PropertyOverrides is missing GeneratedComponentContext',);
      return childrenWithForwardedProps(children, props, ref,);
    }
    const { primaryVariantId, variantClassNames, } = generatedComponentContext;
    const parentVariants = React77.useContext(SSRParentVariantsContext,);
    return renderBranchedChildrenFromPropertyOverrides(
      overrides,
      children,
      props,
      ref,
      variantClassNames,
      primaryVariantId,
      parentVariants,
      'PropertyOverrides',
    );
  },
);
var ResolveLinks = /* @__PURE__ */ React78.forwardRef(function ResolveLinksInner({ links, children, ...rest }, ref,) {
  const router = useRouter();
  const { activeLocale, } = useLocaleInfo();
  const promises = [];
  const resolvedLinks = links.map((link,) => {
    return resolveLinkInternal(
      link.href,
      router,
      link.implicitPathVariables,
      (unresolvedPathSlugs, unresolvedHashslugs,) => {
        function handleSlugs(slugs,) {
          const result = {};
          for (const slugKey in slugs) {
            const unresolvedSlug = slugs[slugKey];
            assert(router.collectionUtils, 'collectionUtils should be defined',);
            assert(unresolvedSlug, 'unresolvedSlug be defined',);
            const lazyValue = resolveSlug(unresolvedSlug, router.collectionUtils, activeLocale,);
            const promise = lazyValue.preload();
            if (promise) {
              promises.push(promise,);
            } else {
              const resolvedValue = lazyValue.read();
              if (resolvedValue) {
                result[slugKey] = resolvedValue;
              }
            }
          }
          return result;
        }
        return {
          path: handleSlugs(unresolvedPathSlugs,),
          hash: handleSlugs(unresolvedHashslugs,),
        };
      },
    );
  },);
  if (promises.length > 0) {
    throw Promise.allSettled(promises,);
  }
  const childrenWithLinks = children(resolvedLinks,);
  return /* @__PURE__ */ React78.createElement(React78.Fragment, null, cloneChildrenWithPropsAndRef(childrenWithLinks, rest, ref,),);
},);
var callEach = (...fns) => fns.forEach((fn,) => fn && fn());
var import_archy = __toESM(require_archy(), 1,);
function getLogger(name,) {
  return {
    trace(...args) {
      var _a;
      return (_a = runtime.getLogger(name,)) == null ? void 0 : _a.trace(...args,);
    },
    debug(...args) {
      var _a;
      return (_a = runtime.getLogger(name,)) == null ? void 0 : _a.debug(...args,);
    },
    info(...args) {
      var _a;
      return (_a = runtime.getLogger(name,)) == null ? void 0 : _a.info(...args,);
    },
    warn(...args) {
      var _a;
      return (_a = runtime.getLogger(name,)) == null ? void 0 : _a.warn(...args,);
    },
    error(...args) {
      var _a;
      return (_a = runtime.getLogger(name,)) == null ? void 0 : _a.error(...args,);
    },
  };
}
function isLegacyCollectionModule(value,) {
  return isArray(value,) && value.every(isObject2,);
}
function isLegacyLocalizedCollectionModule(value,) {
  return isObject2(value,) && isFunction(value.read,) && isFunction(value.preload,);
}
function isDatabaseCollectionModule(value,) {
  return isObject2(value,) && isObject2(value.collectionByLocaleId,);
}
var DatabaseValue = {
  /**
   * Checks if the left value is equal to the right value. Returns false if
   * the values are not of the same type.
   */
  equal(left, right, collation,) {
    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
      return false;
    }
    return compare(left, right, collation,) === 0;
  },
  /**
   * Checks if the left value is less than the right value. Returns false if
   * the values are not of the same type.
   */
  lessThan(left, right, collation,) {
    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
      return false;
    }
    return compare(left, right, collation,) < 0;
  },
  /**
   * Checks if the left value is less than or equal to the right value.
   * Returns false if the values are not of the same type.
   */
  lessThanOrEqual(left, right, collation,) {
    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
      return false;
    }
    return compare(left, right, collation,) <= 0;
  },
  /**
   * Checks if the left value is greater than the right value. Returns false
   * if the values are not of the same type.
   */
  greaterThan(left, right, collation,) {
    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
      return false;
    }
    return compare(left, right, collation,) > 0;
  },
  /**
   * Checks if the left value is greater than or equal to the right value.
   * Returns false if the values are not of the same type.
   */
  greaterThanOrEqual(left, right, collation,) {
    if ((left == null ? void 0 : left.type) !== (right == null ? void 0 : right.type)) {
      return false;
    }
    return compare(left, right, collation,) >= 0;
  },
  stringify(value,) {
    if (value === null) {
      return 'null';
    }
    switch (value.type) {
      case 'boolean':
      case 'number':
        return String(value.value,);
      case 'string':
        return `'${value.value}'`;
      case 'enum':
        return `'${value.value}' /* Enum */`;
      case 'color':
        return `'${value.value}' /* Color */`;
      case 'date':
        return `'${value.value}' /* Date */`;
      case 'richtext':
        return 'RichText';
      case 'responsiveimage':
        return 'ResponsiveImage';
      case 'file':
        return 'File';
      case 'link':
        return isString22(value.value,) ? `'${value.value}' /* Link */` : 'Link';
      default:
        assertNever(value,);
    }
  },
};
function compare(left, right, collation,) {
  if (isNull(left,) || isNull(right,)) {
    assert(left === right,);
    return 0;
  }
  switch (left.type) {
    case 'boolean': {
      assert(left.type === right.type,);
      if (left.value < right.value) {
        return -1;
      }
      if (left.value > right.value) {
        return 1;
      }
      return 0;
    }
    case 'color': {
      assert(left.type === right.type,);
      if (left.value < right.value) {
        return -1;
      }
      if (left.value > right.value) {
        return 1;
      }
      return 0;
    }
    case 'date': {
      assert(left.type === right.type,);
      const leftDate = new Date(left.value,);
      const rightDate = new Date(right.value,);
      if (leftDate < rightDate) {
        return -1;
      }
      if (leftDate > rightDate) {
        return 1;
      }
      return 0;
    }
    case 'enum': {
      assert(left.type === right.type,);
      if (left.value < right.value) {
        return -1;
      }
      if (left.value > right.value) {
        return 1;
      }
      return 0;
    }
    case 'file': {
      assert(left.type === right.type,);
      if (left.value < right.value) {
        return -1;
      }
      if (left.value > right.value) {
        return 1;
      }
      return 0;
    }
    case 'responsiveimage': {
      assert(left.type === right.type,);
      const leftEncoded = JSON.stringify(left.value,);
      const rightEncoded = JSON.stringify(right.value,);
      if (leftEncoded < rightEncoded) {
        return -1;
      }
      if (leftEncoded > rightEncoded) {
        return 1;
      }
      return 0;
    }
    case 'link': {
      assert(left.type === right.type,);
      const leftEncoded = JSON.stringify(left.value,);
      const rightEncoded = JSON.stringify(right.value,);
      if (leftEncoded < rightEncoded) {
        return -1;
      }
      if (leftEncoded > rightEncoded) {
        return 1;
      }
      return 0;
    }
    case 'number': {
      assert(left.type === right.type,);
      if (left.value < right.value) {
        return -1;
      }
      if (left.value > right.value) {
        return 1;
      }
      return 0;
    }
    case 'richtext': {
      assert(left.type === right.type,);
      const leftValue = left.value;
      const rightValue = right.value;
      if (leftValue < rightValue) {
        return -1;
      }
      if (leftValue > rightValue) {
        return 1;
      }
      return 0;
    }
    case 'string': {
      assert(left.type === right.type,);
      let leftValue = left.value;
      let rightValue = right.value;
      if (collation.type === 0) {
        leftValue = left.value.toLowerCase();
        rightValue = right.value.toLowerCase();
      }
      if (leftValue < rightValue) {
        return -1;
      }
      if (leftValue > rightValue) {
        return 1;
      }
      return 0;
    }
    default: {
      assertNever(left,);
    }
  }
}
var INDEX_IDENTIFIER = 'index';
var ScalarExpression = class {
  static from(expression, schema,) {
    const scalarExpression = convertExpression(expression, schema,);
    const isLiteralValue = scalarExpression instanceof ScalarLiteralValue;
    if (scalarExpression.canEvaluate() && !isLiteralValue) {
      const value = scalarExpression.evaluate();
      return new ScalarLiteralValue(scalarExpression.definition, value,);
    }
    return scalarExpression;
  }
};
var ScalarIdentifier = class extends ScalarExpression {
  constructor(schema, name,) {
    super();
    this.schema = schema;
    this.name = name;
    __publicField(this, 'definition',);
    if (name === INDEX_IDENTIFIER) {
      this.definition = {
        type: 'number',
        isNullable: false,
      };
    } else {
      const definition = schema[name];
      if (isUndefined(definition,)) {
        throw new Error(`Missing definition for identifier: ${name}`,);
      }
      this.definition = definition;
    }
  }
  stringify() {
    return this.name;
  }
  equals(other,) {
    return other instanceof ScalarIdentifier && isEqual(this.definition, other.definition,) && isEqual(other.name, this.name,);
  }
  evaluate(item,) {
    var _a;
    const name = this.name;
    if (isUndefined(item,) || name === INDEX_IDENTIFIER) {
      throw new Error(`Can't evaluate identifier: ${name}`,);
    }
    return (_a = item.data[name]) != null ? _a : null;
  }
  canEvaluate() {
    return false;
  }
};
var ScalarLiteralValue = class extends ScalarExpression {
  constructor(definition, value,) {
    super();
    this.definition = definition;
    this.value = value;
  }
  stringify() {
    return DatabaseValue.stringify(this.value,);
  }
  static fromNull() {
    return new ScalarLiteralValue(null, null,);
  }
  static fromBoolean(value,) {
    return new ScalarLiteralValue(
      { type: 'boolean', isNullable: false, },
      { type: 'boolean', value, },
    );
  }
  static fromDate(value,) {
    return new ScalarLiteralValue(
      { type: 'date', isNullable: false, },
      { type: 'date', value: value.toISOString(), },
    );
  }
  static fromNumber(value,) {
    return new ScalarLiteralValue(
      { type: 'number', isNullable: false, },
      { type: 'number', value, },
    );
  }
  static fromString(value,) {
    return new ScalarLiteralValue(
      { type: 'string', isNullable: false, },
      { type: 'string', value, },
    );
  }
  equals(other,) {
    return other instanceof ScalarLiteralValue && isEqual(this.definition, other.definition,) && isEqual(other.value, this.value,);
  }
  evaluate() {
    return this.value;
  }
  canEvaluate() {
    return true;
  }
};
var ScalarFunctionCall = class extends ScalarExpression {
  constructor(argumentExpressions,) {
    super();
    this.argumentExpressions = argumentExpressions;
    __publicField(this, 'collation', {
      type: 0,
      /* CaseInsensitive */
    },);
  }
  getArgumentExpression(index,) {
    const argument = this.argumentExpressions[index];
    if (isUndefined(argument,)) {
      throw new Error('Missing argument in function call',);
    }
    return argument;
  }
  equals(other,) {
    return other instanceof ScalarFunctionCall && isEqual(this.constructor, other.constructor,) &&
      isEqual(this.argumentExpressions, other.argumentExpressions,);
  }
  canEvaluate() {
    return this.argumentExpressions.every((expression,) => {
      return expression.canEvaluate();
    },);
  }
};
var ScalarFunctionCallContains = class extends ScalarFunctionCall {
  constructor() {
    super(...arguments,);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
    __publicField(this, 'sourceExpression', this.getArgumentExpression(0,),);
    __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
  }
  stringify() {
    return `CONTAINS(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
  }
  getValue(source, target,) {
    if (isNull(source,) || source.type !== 'string') {
      return false;
    }
    if (isNull(target,) || target.type !== 'string') {
      return false;
    }
    let sourceValue = source.value;
    let targetValue = target.value;
    if (this.collation.type === 0) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.includes(targetValue,);
  }
  evaluate(item,) {
    const source = this.sourceExpression.evaluate(item,);
    const target = this.targetExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: this.getValue(source, target,),
    };
  }
};
var ScalarFunctionCallStartsWith = class extends ScalarFunctionCall {
  constructor() {
    super(...arguments,);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
    __publicField(this, 'sourceExpression', this.getArgumentExpression(0,),);
    __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
  }
  stringify() {
    return `STARTS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
  }
  getValue(source, target,) {
    if (isNull(source,) || source.type !== 'string') {
      return false;
    }
    if (isNull(target,) || target.type !== 'string') {
      return false;
    }
    let sourceValue = source.value;
    let targetValue = target.value;
    if (this.collation.type === 0) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.startsWith(targetValue,);
  }
  evaluate(item,) {
    const source = this.sourceExpression.evaluate(item,);
    const target = this.targetExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: this.getValue(source, target,),
    };
  }
};
var ScalarFunctionCallEndsWith = class extends ScalarFunctionCall {
  constructor() {
    super(...arguments,);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
    __publicField(this, 'sourceExpression', this.getArgumentExpression(0,),);
    __publicField(this, 'targetExpression', this.getArgumentExpression(1,),);
  }
  stringify() {
    return `ENDS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})`;
  }
  getValue(source, target,) {
    if (isNull(source,) || source.type !== 'string') {
      return false;
    }
    if (isNull(target,) || target.type !== 'string') {
      return false;
    }
    let sourceValue = source.value;
    let targetValue = target.value;
    if (this.collation.type === 0) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.endsWith(targetValue,);
  }
  evaluate(item,) {
    const source = this.sourceExpression.evaluate(item,);
    const target = this.targetExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: this.getValue(source, target,),
    };
  }
};
var ScalarCase = class extends ScalarExpression {
  constructor(valueExpression, conditions, elseExpression,) {
    super();
    this.valueExpression = valueExpression;
    this.conditions = conditions;
    this.elseExpression = elseExpression;
    __publicField(this, 'definition',);
    __publicField(this, 'collation', {
      type: 0,
      /* CaseInsensitive */
    },);
    const definitions = [];
    for (const { thenExpression, } of conditions) {
      if (thenExpression.definition) {
        definitions.push(thenExpression.definition,);
      }
    }
    if (elseExpression && elseExpression.definition) {
      definitions.push(elseExpression.definition,);
    }
    const [firstDefinition, ...otherDefinitions] = definitions;
    if (firstDefinition) {
      for (const definition of otherDefinitions) {
        if (definition.type !== firstDefinition.type) {
          throw new Error('Incompatible types in CASE expression',);
        }
      }
    }
    this.definition = firstDefinition != null ? firstDefinition : null;
  }
  stringify() {
    let result = 'CASE';
    if (this.valueExpression) {
      result += ` ${this.valueExpression.stringify()}`;
    }
    for (const { whenExpression, thenExpression, } of this.conditions) {
      result += ` WHEN ${whenExpression.stringify()} THEN ${thenExpression.stringify()}`;
    }
    if (this.elseExpression) {
      result += ` ELSE ${this.elseExpression.stringify()}`;
    }
    result += ' END';
    return result;
  }
  equals(other,) {
    return other instanceof ScalarCase && isEqual(this.valueExpression, other.valueExpression,) &&
      isEqual(this.conditions, other.conditions,) && isEqual(this.elseExpression, other.elseExpression,);
  }
  evaluate(item,) {
    var _a, _b, _c, _d;
    const value = (_b = (_a = this.valueExpression) == null ? void 0 : _a.evaluate(item,)) != null ? _b : null;
    for (const { whenExpression, thenExpression, } of this.conditions) {
      const when = whenExpression.evaluate(item,);
      const isMatching = this.valueExpression ? DatabaseValue.equal(when, value, this.collation,) : convertToBoolean(when,);
      if (isMatching) {
        return thenExpression.evaluate(item,);
      }
    }
    return (_d = (_c = this.elseExpression) == null ? void 0 : _c.evaluate(item,)) != null ? _d : null;
  }
  canEvaluate() {
    const expressions = [];
    if (this.valueExpression) {
      expressions.push(this.valueExpression,);
    }
    for (const condition of this.conditions) {
      expressions.push(condition.whenExpression,);
      expressions.push(condition.thenExpression,);
    }
    if (this.elseExpression) {
      expressions.push(this.elseExpression,);
    }
    return expressions.every((expression,) => {
      return expression.canEvaluate();
    },);
  }
};
var ScalarCaseCondition = class {
  constructor(whenExpression, thenExpression,) {
    this.whenExpression = whenExpression;
    this.thenExpression = thenExpression;
  }
};
var ScalarUnaryOperation = class extends ScalarExpression {
  constructor(valueExpression,) {
    super();
    this.valueExpression = valueExpression;
  }
  equals(other,) {
    return other instanceof ScalarUnaryOperation && isEqual(this.constructor, other.constructor,) &&
      isEqual(this.valueExpression, other.valueExpression,);
  }
  canEvaluate() {
    return this.valueExpression.canEvaluate();
  }
};
var ScalarUnaryOperationNot = class extends ScalarUnaryOperation {
  constructor() {
    super(...arguments,);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
  }
  stringify() {
    return `NOT ${this.valueExpression.stringify()}`;
  }
  evaluate(item,) {
    const value = this.valueExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: !convertToBoolean(value,),
    };
  }
};
var ScalarLogicalOperation = class extends ScalarExpression {
  constructor(operandExpressions,) {
    super();
    this.operandExpressions = operandExpressions;
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
  }
  stringify() {
    return this.operandExpressions.map((expression,) => expression.stringify()).join(' AND ',);
  }
  equals(other,) {
    return other instanceof ScalarLogicalOperation && isEqual(this.constructor, other.constructor,) &&
      isEqual(this.operandExpressions, other.operandExpressions,);
  }
  canEvaluate() {
    return this.operandExpressions.every((expression,) => {
      return expression.canEvaluate();
    },);
  }
};
var ScalarLogicalOperationAnd = class extends ScalarLogicalOperation {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', 'AND',);
  }
  evaluate(item,) {
    const result = this.operandExpressions.every((expression,) => {
      const value = expression.evaluate(item,);
      return convertToBoolean(value,);
    },);
    return {
      type: 'boolean',
      value: result,
    };
  }
};
var ScalarLogicalOperationOr = class extends ScalarLogicalOperation {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', 'OR',);
  }
  evaluate(item,) {
    const result = this.operandExpressions.some((expression,) => {
      const value = expression.evaluate(item,);
      return convertToBoolean(value,);
    },);
    return {
      type: 'boolean',
      value: result,
    };
  }
};
var ScalarComparison = class extends ScalarExpression {
  constructor(leftExpression, rightExpression,) {
    super();
    this.leftExpression = leftExpression;
    this.rightExpression = rightExpression;
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
    __publicField(this, 'collation', {
      type: 0,
      /* CaseInsensitive */
    },);
  }
  stringify() {
    return `${this.leftExpression.stringify()} ${this.operator} ${this.rightExpression.stringify()}`;
  }
  equals(other,) {
    return other instanceof ScalarComparison && isEqual(this.constructor, other.constructor,) &&
      isEqual(this.leftExpression, other.leftExpression,) && isEqual(this.rightExpression, other.rightExpression,);
  }
  canEvaluate() {
    return this.leftExpression.canEvaluate() && this.rightExpression.canEvaluate();
  }
};
var ScalarComparisonEquals = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '=',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: DatabaseValue.equal(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarComparisonNotEquals = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '!=',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: !DatabaseValue.equal(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarComparisonLessThan = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '<',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: DatabaseValue.lessThan(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarComparisonLessThanOrEqual = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '<=',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: DatabaseValue.lessThanOrEqual(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarComparisonGreaterThan = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '>',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: DatabaseValue.greaterThan(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarComparisonGreaterThanOrEqual = class extends ScalarComparison {
  constructor() {
    super(...arguments,);
    __publicField(this, 'operator', '>=',);
  }
  evaluate(item,) {
    const leftValue = this.leftExpression.evaluate(item,);
    const rightValue = this.rightExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: DatabaseValue.greaterThanOrEqual(leftValue, rightValue, this.collation,),
    };
  }
};
var ScalarTypeCast = class extends ScalarExpression {
  constructor(valueExpression,) {
    super();
    this.valueExpression = valueExpression;
  }
  stringify() {
    return `CAST(${this.valueExpression.stringify()} AS ${this.dataType})`;
  }
  equals(other,) {
    return other instanceof ScalarTypeCast && isEqual(this.constructor, other.constructor,) &&
      isEqual(this.valueExpression, other.valueExpression,);
  }
  canEvaluate() {
    return this.valueExpression.canEvaluate();
  }
};
var ScalarTypeCastBoolean = class extends ScalarTypeCast {
  constructor() {
    super(...arguments,);
    __publicField(this, 'dataType', 'BOOLEAN',);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: false,
    },);
  }
  evaluate(item,) {
    const value = this.valueExpression.evaluate(item,);
    return {
      type: 'boolean',
      value: convertToBoolean(value,),
    };
  }
};
function convertToBoolean(value,) {
  if (isNull(value,)) {
    return false;
  }
  switch (value.type) {
    case 'boolean':
    case 'number':
    case 'string': {
      return Boolean(value.value,);
    }
  }
  return false;
}
var ScalarTypeCastDate = class extends ScalarTypeCast {
  constructor() {
    super(...arguments,);
    __publicField(this, 'dataType', 'DATE',);
    __publicField(this, 'definition', {
      type: 'date',
      isNullable: true,
    },);
  }
  evaluate(item,) {
    const value = this.valueExpression.evaluate(item,);
    const date = convertToDate(value,);
    if (isNull(date,)) {
      return null;
    }
    return {
      type: 'date',
      value: date.toISOString(),
    };
  }
};
function convertToDate(value,) {
  if (isNull(value,)) {
    return null;
  }
  switch (value.type) {
    case 'date':
    case 'number':
    case 'string': {
      const date = new Date(value.value,);
      if (isValidDate(date,)) {
        return date;
      }
      return null;
    }
  }
  return null;
}
var ScalarTypeCastNumber = class extends ScalarTypeCast {
  constructor() {
    super(...arguments,);
    __publicField(this, 'dataType', 'NUMBER',);
    __publicField(this, 'definition', {
      type: 'number',
      isNullable: true,
    },);
  }
  evaluate(item,) {
    const value = this.valueExpression.evaluate(item,);
    const number2 = convertToNumber(value,);
    if (isNull(number2,)) {
      return null;
    }
    return {
      type: 'number',
      value: number2,
    };
  }
};
function convertToNumber(value,) {
  if (isNull(value,)) {
    return null;
  }
  switch (value.type) {
    case 'number':
    case 'string': {
      const number2 = Number(value.value,);
      if (Number.isFinite(number2,)) {
        return number2;
      }
      return null;
    }
  }
  return null;
}
var ScalarTypeCastString = class extends ScalarTypeCast {
  constructor() {
    super(...arguments,);
    __publicField(this, 'dataType', 'STRING',);
    __publicField(this, 'definition', {
      type: 'boolean',
      isNullable: true,
    },);
  }
  evaluate(item,) {
    const value = this.valueExpression.evaluate(item,);
    const string = convertToString(value,);
    if (isNull(string,)) {
      return null;
    }
    return {
      type: 'string',
      value: string,
    };
  }
};
function convertToString(value,) {
  if (isNull(value,)) {
    return null;
  }
  switch (value.type) {
    case 'string':
    case 'number': {
      return String(value.value,);
    }
  }
  return null;
}
function convertExpression(expression, schema,) {
  switch (expression.type) {
    case 'Identifier':
      return convertIdentifier(expression, schema,);
    case 'LiteralValue':
      return convertLiteralValue(expression,);
    case 'FunctionCall':
      return convertFunctionCall(expression, schema,);
    case 'Case':
      return convertCase(expression, schema,);
    case 'UnaryOperation':
      return convertUnaryOperation(expression, schema,);
    case 'BinaryOperation':
      return convertBinaryOperation(expression, schema,);
    case 'TypeCast':
      return convertTypeCast(expression, schema,);
    default:
      throw new Error(`Unsupported expression: ${JSON.stringify(expression,)}`,);
  }
}
function convertIdentifier(expression, schema,) {
  return new ScalarIdentifier(schema, expression.name,);
}
function convertLiteralValue(expression,) {
  const value = expression.value;
  if (isBoolean(value,)) {
    return ScalarLiteralValue.fromBoolean(value,);
  }
  if (isValidDate(value,)) {
    return ScalarLiteralValue.fromDate(value,);
  }
  if (isNumber2(value,)) {
    return ScalarLiteralValue.fromNumber(value,);
  }
  if (isString22(value,)) {
    return ScalarLiteralValue.fromString(value,);
  }
  return ScalarLiteralValue.fromNull();
}
function convertFunctionCall(expression, schema,) {
  const argumentExpressions = expression.arguments.map((argument,) => {
    return ScalarExpression.from(argument, schema,);
  },);
  switch (expression.functionName) {
    case 'CONTAINS':
      return new ScalarFunctionCallContains(argumentExpressions,);
    case 'STARTS_WITH':
      return new ScalarFunctionCallStartsWith(argumentExpressions,);
    case 'ENDS_WITH':
      return new ScalarFunctionCallEndsWith(argumentExpressions,);
    default:
      throw new Error(`Unsupported function: ${expression.functionName}`,);
  }
}
function convertCase(expression, schema,) {
  const valueExpression = expression.value && ScalarExpression.from(expression.value, schema,);
  const conditions = expression.conditions.map((condition,) => {
    const whenExpression = ScalarExpression.from(condition.when, schema,);
    const thenExpression = ScalarExpression.from(condition.then, schema,);
    return new ScalarCaseCondition(whenExpression, thenExpression,);
  },);
  const elseExpression = expression.else && ScalarExpression.from(expression.else, schema,);
  return new ScalarCase(valueExpression, conditions, elseExpression,);
}
function convertUnaryOperation(expression, schema,) {
  const valueExpression = ScalarExpression.from(expression.value, schema,);
  switch (expression.operator) {
    case 'not':
      return createScalarUnaryOperationNot(valueExpression,);
    default:
      throw new Error(`Unsupported unary operator: ${expression.operator}`,);
  }
}
function createScalarUnaryOperationNot(valueExpression,) {
  var _a;
  if (valueExpression instanceof ScalarUnaryOperationNot) {
    const innerExpression = valueExpression.valueExpression;
    if (((_a = innerExpression.definition) == null ? void 0 : _a.type) === 'boolean') {
      return innerExpression;
    }
    return new ScalarTypeCastBoolean(innerExpression,);
  }
  if (valueExpression instanceof ScalarComparisonEquals) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonNotEquals(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarComparisonNotEquals) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonEquals(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarComparisonLessThan) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarComparisonLessThanOrEqual) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonGreaterThan(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarComparisonGreaterThan) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonLessThanOrEqual(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarComparisonGreaterThanOrEqual) {
    const { leftExpression, rightExpression, } = valueExpression;
    return new ScalarComparisonLessThan(leftExpression, rightExpression,);
  }
  if (valueExpression instanceof ScalarLogicalOperationAnd) {
    const { operandExpressions, } = valueExpression;
    const notExpressions = operandExpressions.map(createScalarUnaryOperationNot,);
    return new ScalarLogicalOperationOr(notExpressions,);
  }
  if (valueExpression instanceof ScalarLogicalOperationAnd) {
    const { operandExpressions, } = valueExpression;
    const notExpressions = operandExpressions.map(createScalarUnaryOperationNot,);
    return new ScalarLogicalOperationAnd(notExpressions,);
  }
  return new ScalarUnaryOperationNot(valueExpression,);
}
function convertBinaryOperation(expression, schema,) {
  const leftExpression = ScalarExpression.from(expression.left, schema,);
  const rightExpression = ScalarExpression.from(expression.right, schema,);
  switch (expression.operator) {
    case 'and':
      return createScalarLogicalOperationAnd(leftExpression, rightExpression,);
    case 'or':
      return createScalarLogicalOperationOr(leftExpression, rightExpression,);
    case '==':
      return createScalarComparisonEquals(leftExpression, rightExpression,);
    case '!=':
      return createScalarComparisonNotEquals(leftExpression, rightExpression,);
    case '<':
      return createScalarComparisonLessThan(leftExpression, rightExpression,);
    case '<=':
      return convertScalarComparisonLessThanOrEqual(leftExpression, rightExpression,);
    case '>':
      return convertScalarComparisonGreaterThan(leftExpression, rightExpression,);
    case '>=':
      return convertScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,);
    default:
      throw new Error(`Unsupported binary operator: ${expression.operator}`,);
  }
}
function createScalarLogicalOperationAnd(leftExpression, rightExpression,) {
  const operandExpressions = [];
  if (leftExpression instanceof ScalarLogicalOperationAnd) {
    operandExpressions.push(...leftExpression.operandExpressions,);
  } else {
    operandExpressions.push(leftExpression,);
  }
  if (rightExpression instanceof ScalarLogicalOperationAnd) {
    operandExpressions.push(...rightExpression.operandExpressions,);
  } else {
    operandExpressions.push(rightExpression,);
  }
  return new ScalarLogicalOperationAnd(operandExpressions,);
}
function createScalarLogicalOperationOr(leftExpression, rightExpression,) {
  const operandExpressions = [];
  if (leftExpression instanceof ScalarLogicalOperationOr) {
    operandExpressions.push(...leftExpression.operandExpressions,);
  } else {
    operandExpressions.push(leftExpression,);
  }
  if (rightExpression instanceof ScalarLogicalOperationOr) {
    operandExpressions.push(...rightExpression.operandExpressions,);
  } else {
    operandExpressions.push(rightExpression,);
  }
  return new ScalarLogicalOperationOr(operandExpressions,);
}
function createScalarComparisonEquals(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonEquals(rightExpression, leftExpression,);
  }
  return new ScalarComparisonEquals(leftExpression, rightExpression,);
}
function createScalarComparisonNotEquals(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonNotEquals(rightExpression, leftExpression,);
  }
  return new ScalarComparisonNotEquals(leftExpression, rightExpression,);
}
function createScalarComparisonLessThan(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonGreaterThan(rightExpression, leftExpression,);
  }
  return new ScalarComparisonLessThan(leftExpression, rightExpression,);
}
function convertScalarComparisonLessThanOrEqual(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonGreaterThanOrEqual(rightExpression, leftExpression,);
  }
  return new ScalarComparisonLessThanOrEqual(leftExpression, rightExpression,);
}
function convertScalarComparisonGreaterThan(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonLessThan(rightExpression, leftExpression,);
  }
  return new ScalarComparisonGreaterThan(leftExpression, rightExpression,);
}
function convertScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,) {
  const isLeftIdentifier = leftExpression instanceof ScalarIdentifier;
  const isRightIdentifier = rightExpression instanceof ScalarIdentifier;
  if (isRightIdentifier && !isLeftIdentifier) {
    return new ScalarComparisonLessThanOrEqual(rightExpression, leftExpression,);
  }
  return new ScalarComparisonGreaterThanOrEqual(leftExpression, rightExpression,);
}
function convertTypeCast(expression, schema,) {
  const valueExpression = ScalarExpression.from(expression.value, schema,);
  switch (expression.dataType) {
    case 'BOOLEAN':
      return createScalarTypeCastBoolean(valueExpression,);
    case 'DATE':
      return createScalarTypeCastDate(valueExpression,);
    case 'NUMBER':
      return createScalarTypeCastNumber(valueExpression,);
    case 'STRING':
      return createScalarTypeCastString(valueExpression,);
    default:
      throw new Error(`Unsupported data type: ${expression.dataType}`,);
  }
}
function createScalarTypeCastBoolean(valueExpression,) {
  var _a;
  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'boolean') {
    return valueExpression;
  }
  return new ScalarTypeCastBoolean(valueExpression,);
}
function createScalarTypeCastDate(valueExpression,) {
  var _a;
  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'date') {
    return valueExpression;
  }
  return new ScalarTypeCastDate(valueExpression,);
}
function createScalarTypeCastNumber(valueExpression,) {
  var _a;
  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'number') {
    return valueExpression;
  }
  return new ScalarTypeCastNumber(valueExpression,);
}
function createScalarTypeCastString(valueExpression,) {
  var _a;
  if (((_a = valueExpression.definition) == null ? void 0 : _a.type) === 'string') {
    return valueExpression;
  }
  return new ScalarTypeCastString(valueExpression,);
}
function stringifyExecutionTime(self, total,) {
  return `(self: ${self}ms${total ? `, total: ${total}ms` : ''})`;
}
function stringifyItems(items,) {
  return `(items: ${items})`;
}
var QueryPlan = class {
  constructor() {
    __publicField(this, 'executionTime', 0,);
    __publicField(this, 'itemCount', 0,);
  }
  async execute() {
    const start = performance.now();
    const result = await this._execute();
    this.executionTime = performance.now() - start;
    this.itemCount = result.length;
    return result;
  }
};
var ScanCollectionPlan = class extends QueryPlan {
  constructor(collection,) {
    super();
    this.collection = collection;
  }
  inspect() {
    return {
      label: `ScanCollectionPlan ${stringifyExecutionTime(this.executionTime,)} ${stringifyItems(this.itemCount,)}`,
    };
  }
  async _execute() {
    return this.collection.scanItems();
  }
};
var LookupIndexPlan = class extends QueryPlan {
  constructor(index, query,) {
    super();
    this.index = index;
    this.query = query;
  }
  inspect() {
    const name = this.index.fields.map((field,) => {
      if (field.type === 'Identifier') {
        return `"${field.name}"`;
      }
      return field.type;
    },);
    const lookup = this.query.map((indexLookup,) => {
      switch (indexLookup.type) {
        case 'All':
          return indexLookup.type;
        case 'Equals':
        case 'NotEquals':
        case 'LessThan':
        case 'GreaterThan':
        case 'Contains':
        case 'StartsWith':
        case 'EndsWith':
          return `${indexLookup.type}, ${DatabaseValue.stringify(indexLookup.value,)}`;
        default: {
          assertNever(indexLookup,);
        }
      }
    },);
    return {
      label: `LookupIndexPlan(${name}, ${lookup}) ${stringifyExecutionTime(this.executionTime,)} ${
        stringifyItems(
          this.itemCount,
        )
      }`,
    };
  }
  async _execute() {
    return this.index.lookupItems(this.query,);
  }
};
var UnionPlan = class extends QueryPlan {
  constructor(childPlans,) {
    super();
    this.childPlans = childPlans;
  }
  inspect() {
    const childPlansTime = Math.max(...this.childPlans.map((childPlan,) => {
      var _a;
      return (_a = childPlan.executionTime) != null ? _a : 0;
    },),);
    return {
      label: `UnionPlan ${
        stringifyExecutionTime(
          this.executionTime - childPlansTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)}`,
      nodes: this.childPlans.map((childPlan,) => childPlan.inspect()),
    };
  }
  async _execute() {
    var _a;
    const childItemMaps = await Promise.all(
      this.childPlans.map(async (childPlan,) => {
        const items = await childPlan.execute();
        return new DatabaseItemMap(items,);
      },),
    );
    let result;
    for (const itemMap of childItemMaps) {
      if (result) {
        result = result.union(itemMap,);
      } else {
        result = itemMap;
      }
    }
    return (_a = result == null ? void 0 : result.items()) != null ? _a : [];
  }
};
var IntersectionPlan = class extends QueryPlan {
  constructor(childPlans,) {
    super();
    this.childPlans = childPlans;
  }
  inspect() {
    const childPlansTime = Math.max(...this.childPlans.map((childPlan,) => {
      var _a;
      return (_a = childPlan.executionTime) != null ? _a : 0;
    },),);
    return {
      label: `IntersectionPlan ${
        stringifyExecutionTime(
          this.executionTime - childPlansTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)} ${stringifyItems(this.itemCount,)}`,
      nodes: this.childPlans.map((childPlan,) => childPlan.inspect()),
    };
  }
  async _execute() {
    var _a;
    const childItemMaps = await Promise.all(
      this.childPlans.map(async (childPlan,) => {
        const items = await childPlan.execute();
        return new DatabaseItemMap(items,);
      },),
    );
    let result;
    for (const itemMap of childItemMaps) {
      if (result) {
        result = result.intersection(itemMap,);
      } else {
        result = itemMap;
      }
    }
    return (_a = result == null ? void 0 : result.items()) != null ? _a : [];
  }
};
var ResolveItemsPlan = class extends QueryPlan {
  constructor(childPlan, collection,) {
    super();
    this.childPlan = childPlan;
    this.collection = collection;
  }
  inspect() {
    return {
      label: `ResolveItemsPlan ${
        stringifyExecutionTime(
          this.executionTime - this.childPlan.executionTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)} ${stringifyItems(this.itemCount,)}`,
      nodes: [this.childPlan.inspect(),],
    };
  }
  async _execute() {
    const childItems = await this.childPlan.execute();
    const childPointers = childItems.map((item,) => item.pointer);
    return this.collection.resolveItems(childPointers,);
  }
};
var FilterItemsPlan = class extends QueryPlan {
  constructor(childPlan, filterExpression,) {
    super();
    this.childPlan = childPlan;
    this.filterExpression = filterExpression;
  }
  inspect() {
    return {
      label: `FilterItemsPlan(${this.filterExpression.stringify()}) ${
        stringifyExecutionTime(
          this.executionTime - this.childPlan.executionTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)} ${stringifyItems(this.itemCount,)}`,
      nodes: [this.childPlan.inspect(),],
    };
  }
  async _execute() {
    const childItems = await this.childPlan.execute();
    return childItems.filter((item,) => {
      const result = this.filterExpression.evaluate(item,);
      return convertToBoolean(result,);
    },);
  }
};
var SortItemsPlan = class extends QueryPlan {
  constructor(childPlan, orderExpressions, collection,) {
    super();
    this.childPlan = childPlan;
    this.orderExpressions = orderExpressions;
    this.collection = collection;
  }
  inspect() {
    const order = this.orderExpressions.map((expression,) => `${expression.expression.stringify()} ${expression.direction.toUpperCase()}`)
      .join(', ',);
    return {
      label: `SortItemsPlan(${order}) ${
        stringifyExecutionTime(
          this.executionTime - this.childPlan.executionTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)}`,
      nodes: [this.childPlan.inspect(),],
    };
  }
  async _execute() {
    const childItems = await this.childPlan.execute();
    return childItems.sort((leftItem, rightItem,) => {
      for (const { expression, direction, collation, } of this.orderExpressions) {
        const isAscending = direction === 'asc';
        if (expression instanceof ScalarIdentifier && expression.name === INDEX_IDENTIFIER) {
          const order = this.collection.compareItems(leftItem, rightItem,);
          return isAscending ? order : -order;
        }
        const left = expression.evaluate(leftItem,);
        const right = expression.evaluate(rightItem,);
        if (DatabaseValue.equal(left, right, collation,)) {
          continue;
        }
        if (DatabaseValue.lessThan(left, right, collation,) || isNullish(left,)) {
          return isAscending ? -1 : 1;
        }
        if (DatabaseValue.greaterThan(left, right, collation,) || isNullish(right,)) {
          return isAscending ? 1 : -1;
        }
        throw new Error('Invalid comparison result.',);
      }
      return this.collection.compareItems(leftItem, rightItem,);
    },);
  }
};
var ScalarOrderExpression = class {
  constructor(expression, direction, collation,) {
    this.expression = expression;
    this.direction = direction;
    this.collation = collation;
  }
};
var SliceItemsPlan = class extends QueryPlan {
  constructor(childPlan, offsetExpression, limitExpression,) {
    super();
    this.childPlan = childPlan;
    this.offsetExpression = offsetExpression;
    this.limitExpression = limitExpression;
  }
  inspect() {
    var _a, _b, _c, _d;
    return {
      label: `SliceItemsPlan(LIMIT ${
        (_b = (_a = this.limitExpression) == null ? void 0 : _a.stringify()) != null ? _b : 'Infinity'
      }, OFFSET ${(_d = (_c = this.offsetExpression) == null ? void 0 : _c.stringify()) != null ? _d : '0'}) ${
        stringifyExecutionTime(
          this.executionTime - this.childPlan.executionTime,
          this.executionTime,
        )
      } ${stringifyItems(this.itemCount,)}`,
      nodes: [this.childPlan.inspect(),],
    };
  }
  getOffset() {
    var _a;
    const value = (_a = this.offsetExpression) == null ? void 0 : _a.evaluate();
    if (isNullish(value,) || value.type !== 'number') {
      return;
    }
    return value.value;
  }
  getLimit() {
    var _a;
    const value = (_a = this.limitExpression) == null ? void 0 : _a.evaluate();
    if (isNullish(value,) || value.type !== 'number') {
      return;
    }
    return value.value;
  }
  async _execute() {
    var _a, _b;
    const childItems = await this.childPlan.execute();
    const offset = (_a = this.getOffset()) != null ? _a : 0;
    const limit = (_b = this.getLimit()) != null ? _b : Infinity;
    return childItems.slice(offset, offset + limit,);
  }
};
var DatabaseItemMap = class extends Map {
  constructor(items = [],) {
    super();
    for (const item of items) {
      this.set(item.pointer, item,);
    }
  }
  union(other,) {
    const result = new DatabaseItemMap();
    for (const [pointer, item,] of this) {
      result.set(pointer, item,);
    }
    for (const [pointer, item,] of other) {
      result.set(pointer, item,);
    }
    return result;
  }
  intersection(other,) {
    const result = new DatabaseItemMap();
    for (const [pointer, item,] of this) {
      if (other.has(pointer,)) {
        result.set(pointer, item,);
      }
    }
    return result;
  }
  items() {
    const values = this.values();
    return [...values,];
  }
};
function stringifyIdentifier(data2, expression,) {
  var _a;
  if (isDatabaseCollectionModule(data2,)) {
    const propertyControls = getPropertyControls(data2,);
    const title = (_a = propertyControls == null ? void 0 : propertyControls[expression.name]) == null ? void 0 : _a.title;
    if (title) {
      return `"${expression.name}" /* ${title} */`;
    }
  }
  return `"${expression.name}"`;
}
function stringifyLiteralValue(expression,) {
  if (typeof expression.value === 'string') {
    return `'${expression.value}'`;
  }
  return expression.value;
}
function stringifyFunctionCall(data2, expression,) {
  return `${expression.functionName}(${expression.arguments.map((argument,) => stringifyExpression(data2, argument,)).join(', ',)})`;
}
function stringifyCaseExpression(data2, expression,) {
  let caseString = 'CASE';
  if (expression.value) {
    caseString += ` ${stringifyExpression(data2, expression.value,)}`;
  }
  for (const condition of expression.conditions) {
    caseString += ` WHEN ${stringifyExpression(data2, condition.when,)} THEN ${
      stringifyExpression(
        data2,
        condition.then,
      )
    }`;
  }
  if (expression.else) {
    caseString += ` ELSE ${expression.else}`;
  }
  caseString += ' END';
  return caseString;
}
function stringifyUnaryOperation(data2, expression,) {
  const value = stringifyExpression(data2, expression.value,);
  const operator = expression.operator.toUpperCase();
  return `${operator} ${value}`;
}
function stringifyBinaryOperation(data2, expression,) {
  const left = stringifyExpression(data2, expression.left,);
  const right = stringifyExpression(data2, expression.right,);
  const operator = expression.operator.toUpperCase();
  return `${left} ${operator} ${right}`;
}
function stringifyTypeCast(data2, expression,) {
  return `CAST(${stringifyExpression(data2, expression.value,)} as ${expression.dataType})`;
}
function stringifyExpression(data2, expression,) {
  switch (expression.type) {
    case 'Identifier':
      return stringifyIdentifier(data2, expression,);
    case 'LiteralValue':
      return stringifyLiteralValue(expression,);
    case 'FunctionCall':
      return stringifyFunctionCall(data2, expression,);
    case 'Case':
      return stringifyCaseExpression(data2, expression,);
    case 'UnaryOperation':
      return stringifyUnaryOperation(data2, expression,);
    case 'BinaryOperation':
      return stringifyBinaryOperation(data2, expression,);
    case 'TypeCast':
      return stringifyTypeCast(data2, expression,);
    default: {
      assertNever(expression,);
    }
  }
}
function autoIndentSql(sql,) {
  let formattedSql = '';
  const tokens = sql.split(/\s+/u,);
  tokens.forEach((token,) => {
    if (token === '') {
      return;
    }
    if (['SELECT', 'FROM', 'WHERE', 'ORDER', 'LIMIT', 'OFFSET',].includes(token,)) {
      formattedSql += `
${token}`;
    } else if (['AND', 'OR',].includes(token,)) {
      formattedSql += `
	${token}`;
    } else {
      formattedSql += ` ${token}`;
    }
  },);
  return formattedSql.trim();
}
function stringifyQuery(query,) {
  let queryString = '';
  queryString += `SELECT ${
    query.select.map((selectExpression,) => {
      const expressionString = stringifyExpression(query.from.data, selectExpression,);
      if (selectExpression.alias) {
        return `${expressionString} AS ${selectExpression.alias}`;
      }
      return expressionString;
    },).join(', ',)
  }`;
  if (isDatabaseCollectionModule(query.from.data,)) {
    queryString += ` FROM ${query.from.data.displayName}`;
  } else {
    queryString += ` FROM ${query.from.data.displayName}`;
  }
  if (query.where) {
    queryString += ` WHERE ${stringifyExpression(query.from.data, query.where,)}`;
  }
  if (query.orderBy) {
    queryString += ` ORDER BY ${
      query.orderBy.map((orderExpression,) => {
        var _a;
        return `${stringifyExpression(query.from.data, orderExpression,)} ${(_a = orderExpression.direction) != null ? _a : 'asc'}`;
      },).join(', ',)
    }`;
  }
  if (query.limit) {
    queryString += ` LIMIT ${stringifyExpression(query.from.data, query.limit,)}`;
  }
  if (query.offset) {
    queryString += ` OFFSET ${stringifyExpression(query.from.data, query.offset,)}`;
  }
  return autoIndentSql(queryString,);
}
var log = getLogger('query-engine',);
function getDatabaseCollection({ data: data2, }, locale,) {
  if (isDatabaseCollectionModule(data2,)) {
    while (locale) {
      const collection = data2.collectionByLocaleId[locale.id];
      if (collection) {
        return collection;
      }
      locale = locale.fallback;
    }
    return data2.collectionByLocaleId.default;
  }
  throw new Error('Unsupported collection type',);
}
var QueryEngine = class {
  async query(query, locale,) {
    const [collection, plan,] = this.createQueryPlan(query, locale,);
    const items = await this.executeQueryPlan(collection, query, plan,);
    log.debug(`Query:
${stringifyQuery(query,)}

${(0, import_archy.default)(plan.inspect(),)}`,);
    return items;
  }
  createQueryPlan(query, locale,) {
    var _a;
    const collection = getDatabaseCollection(query.from, locale,);
    let plan = new ScanCollectionPlan(collection,);
    if (query.where) {
      const filterExpression = ScalarExpression.from(query.where, collection.schema,);
      plan = createPlanForWhereClause(collection, filterExpression,);
      plan = new ResolveItemsPlan(plan, collection,);
    }
    const sortExpressions = (_a = query.orderBy) == null ? void 0 : _a.map(
      (expression,) => {
        var _a2;
        return new ScalarOrderExpression(
          ScalarExpression.from(expression, collection.schema,),
          (_a2 = expression.direction) != null ? _a2 : 'asc',
          {
            type: 0,
            /* CaseInsensitive */
          },
        );
      },
    );
    plan = new SortItemsPlan(plan, sortExpressions != null ? sortExpressions : [], collection,);
    let offsetExpression;
    if (query.offset) {
      offsetExpression = ScalarExpression.from(query.offset, collection.schema,);
    }
    let limitExpression;
    if (query.limit) {
      limitExpression = ScalarExpression.from(query.limit, collection.schema,);
    }
    if (offsetExpression || limitExpression) {
      plan = new SliceItemsPlan(plan, offsetExpression, limitExpression,);
    }
    return [collection, plan,];
  }
  async executeQueryPlan(collection, query, plan,) {
    const items = await plan.execute();
    return Promise.all(
      items.map(async (item,) => {
        const data2 = {};
        for (const expression of query.select) {
          const scalarExpression = ScalarExpression.from(expression, collection.schema,);
          const key7 = getSelectKey(expression,);
          const value = scalarExpression.evaluate(item,);
          data2[key7] = await resolveValue(collection, value,);
        }
        return data2;
      },),
    );
  }
};
function getSelectKey(expression,) {
  if (expression.alias) {
    return expression.alias;
  }
  if (expression.type === 'Identifier') {
    return expression.name;
  }
  throw new Error('Can\'t serialize expression',);
}
async function resolveValue(collection, value,) {
  if (isNullish(value,)) {
    return null;
  }
  if (value.type === 'richtext') {
    return collection.resolveRichText(value.value,);
  }
  return value.value;
}
function createPlanForWhereClause(collection, expression,) {
  var _a;
  if (expression instanceof ScalarLogicalOperationAnd) {
    const childPlans = expression.operandExpressions.map(
      (expression2,) => createPlanForWhereClause(collection, expression2,),
    );
    return new IntersectionPlan(childPlans,);
  }
  if (expression instanceof ScalarLogicalOperationOr) {
    const childPlans = expression.operandExpressions.map(
      (expression2,) => createPlanForWhereClause(collection, expression2,),
    );
    return new UnionPlan(childPlans,);
  }
  return (_a = findLookupIndexPlan(collection, expression,)) != null ? _a : createScanCollectionPlan(collection, expression,);
}
function findLookupIndexPlan(collection, expression,) {
  if (expression instanceof ScalarComparison) {
    return findLookupIndexPlanForComparison(collection, expression,);
  }
  if (expression instanceof ScalarFunctionCall) {
    return findLookupIndexPlanForFunctionCall(collection, expression,);
  }
}
function findLookupIndexPlanForComparison(collection, expression,) {
  const leftExpression = expression.leftExpression;
  const rightExpression = expression.rightExpression;
  if (!(rightExpression instanceof ScalarLiteralValue)) {
    return;
  }
  for (const index of collection.indexes) {
    if (index.fields.length !== 1) {
      continue;
    }
    const field = index.fields[0];
    if (isUndefined(field,)) {
      continue;
    }
    const fieldExpression = ScalarExpression.from(field, collection.schema,);
    if (!leftExpression.equals(fieldExpression,)) {
      continue;
    }
    if (
      expression instanceof ScalarComparisonEquals && index.supportedLookupTypes.includes(
        'Equals',
        /* Equals */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'Equals',
          value: rightExpression.evaluate(),
        },
      ],);
    }
    if (
      expression instanceof ScalarComparisonNotEquals && index.supportedLookupTypes.includes(
        'NotEquals',
        /* NotEquals */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'NotEquals',
          value: rightExpression.evaluate(),
        },
      ],);
    }
    if (
      expression instanceof ScalarComparisonLessThan && index.supportedLookupTypes.includes(
        'LessThan',
        /* LessThan */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'LessThan',
          value: rightExpression.evaluate(),
          inclusive: false,
        },
      ],);
    }
    if (
      expression instanceof ScalarComparisonLessThanOrEqual && index.supportedLookupTypes.includes(
        'LessThan',
        /* LessThan */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'LessThan',
          value: rightExpression.evaluate(),
          inclusive: true,
        },
      ],);
    }
    if (
      expression instanceof ScalarComparisonGreaterThan && index.supportedLookupTypes.includes(
        'GreaterThan',
        /* GreaterThan */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'GreaterThan',
          value: rightExpression.evaluate(),
          inclusive: false,
        },
      ],);
    }
    if (
      expression instanceof ScalarComparisonGreaterThanOrEqual && index.supportedLookupTypes.includes(
        'GreaterThan',
        /* GreaterThan */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'GreaterThan',
          value: rightExpression.evaluate(),
          inclusive: true,
        },
      ],);
    }
  }
}
function findLookupIndexPlanForFunctionCall(collection, expression,) {
  if (expression.argumentExpressions.length !== 2) {
    return;
  }
  const sourceExpression = expression.argumentExpressions[0];
  const targetExpression = expression.argumentExpressions[1];
  if (isUndefined(sourceExpression,)) {
    return;
  }
  if (isUndefined(targetExpression,)) {
    return;
  }
  if (!(targetExpression instanceof ScalarLiteralValue)) {
    return;
  }
  for (const index of collection.indexes) {
    if (index.fields.length !== 1) {
      continue;
    }
    const field = index.fields[0];
    if (isUndefined(field,)) {
      continue;
    }
    const fieldExpression = ScalarExpression.from(field, collection.schema,);
    if (!sourceExpression.equals(fieldExpression,)) {
      continue;
    }
    if (
      expression instanceof ScalarFunctionCallContains && index.supportedLookupTypes.includes(
        'Contains',
        /* Contains */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'Contains',
          value: targetExpression.evaluate(),
        },
      ],);
    }
    if (
      expression instanceof ScalarFunctionCallStartsWith && index.supportedLookupTypes.includes(
        'StartsWith',
        /* StartsWith */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'StartsWith',
          value: targetExpression.evaluate(),
        },
      ],);
    }
    if (
      expression instanceof ScalarFunctionCallEndsWith && index.supportedLookupTypes.includes(
        'EndsWith',
        /* EndsWith */
      )
    ) {
      return new LookupIndexPlan(index, [
        {
          type: 'EndsWith',
          value: targetExpression.evaluate(),
        },
      ],);
    }
  }
}
function createScanCollectionPlan(collection, expression,) {
  const plan = new ScanCollectionPlan(collection,);
  return new FilterItemsPlan(plan, expression,);
}
var AnimationCollector = class {
  constructor() {
    __publicField(this, 'entries', /* @__PURE__ */ new Map(),);
  }
  set(nodeId, prop, value, variantHash,) {
    const nodeEntry = this.entries.get(nodeId,);
    switch (prop) {
      case 'transformTemplate': {
        assert(typeof value === 'string', `transformTemplate must be a string, received: ${value}`,);
        if (nodeEntry) {
          nodeEntry.transformTemplate = value;
        } else {
          this.entries.set(nodeId, { transformTemplate: value, },);
        }
        break;
      }
      case 'initial':
      case 'animate': {
        assert(typeof value === 'object', `${prop} must be a valid object, received: ${value}`,);
        if (nodeEntry) {
          nodeEntry[prop] = value;
          if (!nodeEntry.variantHash) {
            nodeEntry.variantHash = variantHash;
          }
        } else {
          this.entries.set(nodeId, { [prop]: value, variantHash, },);
        }
        break;
      }
      default:
        break;
    }
  }
  clear() {
    this.entries.clear();
  }
  toObject() {
    return Object.fromEntries(this.entries,);
  }
};
var framerAppearEffects = /* @__PURE__ */ new AnimationCollector();
var optimizeAppear = (prop, id3, animateTargetAndTransition, variantHash,) => {
  if (!isBrowser2()) {
    framerAppearEffects.set(id3, prop, animateTargetAndTransition, variantHash,);
  }
  return animateTargetAndTransition;
};
var framerAppearTransformTemplateToken = '__Appear_Animation_Transform__';
var optimizeAppearTransformTemplate = (id3, fn,) => {
  if (!isBrowser2()) {
    const template = fn == null ? void 0 : fn({}, framerAppearTransformTemplateToken,);
    if (template === void 0) {
      return fn;
    }
    framerAppearEffects.set(id3, 'transformTemplate', template,);
  }
  return fn;
};
var framerAppearIdKey = 'data-framer-appear-id';
var framerAppearAnimationScriptKey = 'data-framer-appear-animation';
function rejectPending(pendingTimers, pendingPromises,) {
  pendingTimers.forEach((t,) => clearTimeout(t,));
  pendingTimers.clear();
  pendingPromises.forEach((reject,) => reject && reject('Callback cancelled by variant change',));
  pendingPromises.clear();
}
function createSet() {
  return /* @__PURE__ */ new Set();
}
function useActiveVariantCallback(baseVariant,) {
  const pendingPromises = useConstant2(createSet,);
  const pendingTimers = useConstant2(createSet,);
  useOnCurrentTargetChange(() => {
    return () => rejectPending(pendingTimers, pendingPromises,);
  },);
  React79.useEffect(() => {
    return () => rejectPending(pendingTimers, pendingPromises,);
  }, [pendingPromises, pendingTimers,],);
  React79.useEffect(() => {
    rejectPending(pendingTimers, pendingPromises,);
  }, [baseVariant, pendingPromises, pendingTimers,],);
  return React79.useRef({
    /**
     * Create a callback that can be cancelled if the base variant changes.
     */
    activeVariantCallback: (callback,) => (...args) => {
      return new Promise((resolve, reject,) => {
        pendingPromises.add(reject,);
        callback(...args,).then(resolve,);
      },).catch(() => {
      },);
    },
    /**
     * Execute a callback after a defined period of time. The callback will not
     * be called if pending events are cancelled because the timeout will be
     * cancelled.
     */
    delay: async (callback, msDelay,) => {
      await new Promise((resolve,) => pendingTimers.add(globalThis.setTimeout(() => resolve(true,), msDelay,),));
      callback();
    },
  },).current;
}
function useActiveTargetCallback() {
  const value = useActiveVariantCallback(void 0,);
  return React79.useRef({
    activeTargetCallback: value.activeVariantCallback,
    delay: value.delay,
  },).current;
}
function useAddVariantProps(baseVariant, gestureVariant, variantProps2,) {
  return React80.useCallback(
    (id3,) => {
      var _a, _b, _c;
      if (!variantProps2) {
        return {};
      }
      if (!baseVariant) {
        return {};
      }
      if (gestureVariant) {
        return Object.assign(
          {},
          (_a = variantProps2[baseVariant]) == null ? void 0 : _a[id3],
          (_b = variantProps2[gestureVariant]) == null ? void 0 : _b[id3],
        );
      }
      return ((_c = variantProps2[baseVariant]) == null ? void 0 : _c[id3]) || {};
    },
    [baseVariant, gestureVariant, variantProps2,],
  );
}
function createMediaQueriesFromBreakpoints(breakpoints,) {
  const mediaQueries = {};
  for (const [variant, query,] of Object.entries(breakpoints,)) {
    const { min = 0, max, } = query;
    const mediaQuery = [];
    if (min) {
      mediaQuery.push(`(min-width: ${min}px)`,);
    }
    if (max) {
      mediaQuery.push(`(max-width: ${max}px)`,);
    }
    if (mediaQuery.length) {
      mediaQueries[variant] = mediaQuery.join(' and ',);
    }
  }
  return mediaQueries;
}
function activeMediaQueryFromWindow(mediaQueries,) {
  for (const [variant, query,] of Object.entries(mediaQueries,)) {
    const mql = safeWindow.matchMedia(query,);
    if (mql.matches) {
      return variant;
    }
  }
}
function useHydratedBreakpointVariants(initial, mediaQueries, hydratedWithInitial = true,) {
  var _a;
  const isInitialNavigation = useContext142(IsInitialNavigationContext,);
  const baseVariant = useRef122(isBrowser2() ? (_a = activeMediaQueryFromWindow(mediaQueries,)) != null ? _a : initial : initial,);
  const basePropsVariant = useRef122(hydratedWithInitial && isInitialNavigation ? initial : baseVariant.current,);
  const forceUpdate = useForceUpdate3();
  const instantTransition = useInstantTransition();
  const setActiveVariantInstant = useCallback8(
    (variant,) => {
      if (variant !== baseVariant.current || variant !== basePropsVariant.current) {
        instantTransition(() => {
          baseVariant.current = basePropsVariant.current = variant;
          startTransition22(() => {
            forceUpdate();
          },);
        },);
      }
    },
    [instantTransition, forceUpdate,],
  );
  useIsomorphicLayoutEffect2(() => {
    if (!hydratedWithInitial || isInitialNavigation !== true) {
      return;
    }
    setActiveVariantInstant(baseVariant.current,);
  }, [],);
  useEffect102(() => {
    const callbacks2 = [];
    for (const [variant, query,] of Object.entries(mediaQueries,)) {
      const mql = safeWindow.matchMedia(query,);
      const callback = (event,) => {
        if (event.matches) {
          setActiveVariantInstant(variant,);
        }
      };
      addMQLCallback(mql, callback,);
      callbacks2.push([mql, callback,],);
    }
    return () => callbacks2.forEach(([mql, callback,],) => removeMQLCallback(mql, callback,));
  }, [mediaQueries, setActiveVariantInstant,],);
  return [baseVariant.current, basePropsVariant.current,];
}
function addMQLCallback(mql, callback,) {
  if (mql.addEventListener) {
    mql.addEventListener('change', callback,);
  } else {
    mql.addListener(callback,);
  }
}
function removeMQLCallback(mql, callback,) {
  if (mql.removeEventListener) {
    mql.removeEventListener('change', callback,);
  } else {
    mql.removeListener(callback,);
  }
}
function useBreakpointVariants(initial, _width, breakpoints,) {
  const mediaQueries = useConstant2(() => createMediaQueriesFromBreakpoints(breakpoints,));
  const [initialVariant,] = useHydratedBreakpointVariants(initial, mediaQueries, true,);
  return initialVariant;
}
function removeHiddenBreakpointLayers(_initial, _mediaQueries, _variantClassNames,) {
}
function useDataRecord(collection, variables,) {
  return useMemo52(() => {
    if (!Array.isArray(collection,)) {
      return null;
    }
    if (!variables) {
      return null;
    }
    const pageRecord = collection.find((record2,) => {
      return Object.entries(variables,).every(([key7, value,],) => {
        const recordValue = record2[key7];
        if (value === void 0 || recordValue === void 0 || isObject2(value,) || isObject2(recordValue,)) {
          return false;
        }
        return String(value,) === String(recordValue,);
      },);
    },);
    return pageRecord != null ? pageRecord : null;
  }, [collection, variables,],);
}
function useDynamicRefs() {
  const map = useConstant2(() => /* @__PURE__ */ new Map());
  return React81.useCallback(
    (key7,) => {
      const existing = map.get(key7,);
      if (existing) {
        return existing;
      }
      const ref = createRef();
      map.set(key7, ref,);
      return ref;
    },
    [map,],
  );
}
function isFramerGamepadKeydownData(value,) {
  return isObject2(value,) && value.mapping !== void 0;
}
function gamepadInputsHaveChanged(previous, current,) {
  if (previous.length !== current.length) {
    return true;
  }
  if (!previous.every((item, i,) => current[i] === item)) {
    return true;
  }
  return false;
}
function createGamepadPoller() {
  const handlers = /* @__PURE__ */ new Set();
  let isConnected = false;
  let isPolling = null;
  let lastKeys = [];
  const startPolling = () => {
    const input = getGamepadInputs();
    if (!input) {
      return;
    }
    const { gamepad, inputs, } = input;
    const { mapping, id: id3, } = gamepad;
    if (gamepadInputsHaveChanged(lastKeys, inputs,)) {
      handlers.forEach((handler,) => handler({ inputs, mapping, id: id3, },));
    }
    lastKeys = inputs;
    isPolling = safeWindow.requestAnimationFrame(startPolling,);
  };
  const handleConnection = () => {
    if (isConnected || isPolling) {
      return;
    }
    startPolling();
    isConnected = true;
  };
  const stopPolling = () => {
    if (!isPolling) {
      return;
    }
    safeWindow.cancelAnimationFrame(isPolling,);
    isPolling = null;
  };
  const handleDisconnection = () => {
    if (!isConnected) {
      return;
    }
    stopPolling();
    isConnected = false;
  };
  const setupAndStartPolling = () => {
    if (isPolling) {
      return;
    }
    const gamepad = getGamepadInputs();
    if (!gamepad) {
      safeWindow.addEventListener('gamepadconnected', handleConnection,);
      return;
    }
    safeWindow.addEventListener('gamepaddisconnected', handleDisconnection,);
    isConnected = true;
    startPolling();
  };
  const cleanupAndStopPolling = () => {
    if (!isPolling) {
      return;
    }
    safeWindow.removeEventListener('gamepadconnected', handleConnection,);
    safeWindow.removeEventListener('gamepaddisconnected', handleDisconnection,);
    stopPolling();
  };
  return {
    register(callback,) {
      if (handlers.size === 0) {
        setupAndStartPolling();
      }
      handlers.add(callback,);
    },
    unregister(callback,) {
      handlers.delete(callback,);
      if (handlers.size === 0) {
        cleanupAndStopPolling();
      }
    },
  };
}
var gamepadPoller = /* @__PURE__ */ createGamepadPoller();
var GamepadContext = /* @__PURE__ */ React822.createContext(gamepadPoller,);
function getGamepadInputs() {
  let firstConnectedGamepad = null;
  const gamepads = navigator.getGamepads();
  for (const gamepad of gamepads) {
    if (!gamepad) {
      continue;
    }
    if (!firstConnectedGamepad) {
      firstConnectedGamepad = gamepad;
    }
    const inputs = [...scanPressedAxis(gamepad,), ...scanPressedButtons(gamepad,),];
    if (inputs.length > 0) {
      return { gamepad, inputs, };
    }
  }
  if (firstConnectedGamepad) {
    return { gamepad: firstConnectedGamepad, inputs: [], };
  }
  return null;
}
function scanPressedAxis(gamepad,) {
  const axes = [];
  for (const [idx, axis,] of gamepad.axes.entries()) {
    if (idx > 3) {
      continue;
    }
    if (axis <= -0.5) {
      axes.push(`Axis ${idx}-`,);
    }
    if (axis > 0.5) {
      axes.push(`Axis ${idx}+`,);
    }
  }
  return axes;
}
function scanPressedButtons(gamepad,) {
  const buttons = [];
  for (const [idx, button,] of gamepad.buttons.entries()) {
    if (isButtonPressed(button,)) {
      buttons.push(`Button ${idx}`,);
    }
  }
  return buttons;
}
function isButtonPressed(button,) {
  return button.pressed === true || button.value > 0;
}
function useGamepad(input, callback, { mapping, on, } = {},) {
  const context = React822.useContext(GamepadContext,);
  const settings = useConstant2(() => ({
    mapping: mapping != null ? mapping : 'standard',
    on: on != null ? on : 'keydown',
  }));
  const stateRef = React822.useRef({
    pressed: false,
    handler: callback,
  },);
  const cb = React822.useCallback(
    (gamepad,) => {
      const { pressed, handler, } = stateRef.current;
      if (gamepad.inputs.includes(input,) && settings.mapping === gamepad.mapping) {
        settings.on === 'keydown' && handler();
        stateRef.current.pressed = true;
      } else if (pressed) {
        settings.on === 'keyup' && handler();
        stateRef.current.pressed = false;
      }
    },
    [input, settings,],
  );
  useOnCurrentTargetChange((isInTarget, isOverlayed,) => {
    const isActive = isInTarget && !isOverlayed;
    if (isActive) {
      context.register(cb,);
    } else {
      context.unregister(cb,);
    }
    return () => context.unregister(cb,);
  }, [],);
  React822.useEffect(() => {
    return () => context.unregister(cb,);
  }, [cb, context,],);
  React822.useEffect(() => {
    stateRef.current.handler = callback;
  }, [callback,],);
}
var modifierDefaults = {
  altKey: false,
  ctrlKey: false,
  metaKey: false,
  shiftKey: false,
};
function createShortcutDefinition(shortcut,) {
  const keys3 = shortcut.split('+',);
  const key7 = keys3.pop();
  if (!key7) {
    return void 0;
  }
  const modifiers = {};
  for (const modifier of keys3) {
    modifiers[`${modifier}Key`] = true;
  }
  return {
    ...modifierDefaults,
    ...modifiers,
    key: key7,
  };
}
function useHotkey(shortcut, callback,) {
  const inTarget = React83.useRef(true,);
  const shortcutDefinition = useConstant2(() => createShortcutDefinition(shortcut,));
  useOnCurrentTargetChange((isCurrentTarget, isOverlayed,) => {
    inTarget.current = isCurrentTarget && !isOverlayed;
    return () => inTarget.current = false;
  },);
  const eventHandler = React83.useCallback(
    (event,) => {
      if (!shortcutDefinition) {
        return;
      }
      if (!inTarget.current) {
        return;
      }
      if (!Object.keys(shortcutDefinition,).every((key7,) => shortcutDefinition[key7] === asRecord(event,)[key7])) {
        return;
      }
      event.preventDefault();
      callback();
    },
    [shortcutDefinition, callback,],
  );
  React83.useEffect(() => {
    document.addEventListener('keydown', eventHandler,);
    return () => document.removeEventListener('keydown', eventHandler,);
  }, [eventHandler,],);
}
function useIsOnFramerCanvas() {
  return RenderTarget.current() === 'CANVAS';
}
function useNavigate() {
  const { navigate, } = useRouter();
  const onCanvas = useIsOnFramerCanvas();
  if (!navigate) {
    return () => {
    };
  }
  return (target,) => {
    if (onCanvas) {
      return;
    }
    navigate(target,);
    return false;
  };
}
function callbackForVariant(map, variant,) {
  if (map[variant]) {
    return map[variant];
  }
  if (variant in map) {
    return void 0;
  }
  return map.default;
}
function useOnVariantChange(variant, callbackMap,) {
  const isOnFramerCanvas = useIsOnFramerCanvas();
  if (isOnFramerCanvas) {
    return;
  }
  const isActiveScreenRef = React84.useRef(true,);
  const callbackMapRef = React84.useRef(callbackMap,);
  useOnCurrentTargetChange((isCurrent, isOverlayed,) => {
    const isActiveScreen = isCurrent && !isOverlayed;
    if (!isActiveScreenRef.current && isActiveScreen) {
      const callback = callbackForVariant(callbackMapRef.current, variant,);
      if (callback) {
        callback();
      }
    }
    isActiveScreenRef.current = isActiveScreen;
  }, [],);
  React84.useEffect(() => {
    if (isActiveScreenRef.current) {
      const callback = callbackForVariant(callbackMapRef.current, variant,);
      if (callback) {
        callback();
      }
    }
  }, [variant,],);
}
function useOnAppear(callback,) {
  useOnVariantChange('default', { default: callback, },);
}
function useOverlayState({ blockDocumentScrolling = true, } = {},) {
  const [showOverlay, setShowOverlay,] = React85.useState(false,);
  const callback = React85.useCallback(
    (show,) => {
      setShowOverlay(show,);
      if (blockDocumentScrolling === false) {
        return;
      }
      if (show) {
        document.documentElement.style.setProperty('overflow', 'hidden',);
      } else {
        document.documentElement.style.removeProperty('overflow',);
      }
    },
    [blockDocumentScrolling,],
  );
  React85.useEffect(
    () => () => {
      if (blockDocumentScrolling === false) {
        return;
      }
      document.documentElement.style.removeProperty('overflow',);
    },
    [blockDocumentScrolling,],
  );
  return [showOverlay, callback,];
}
async function componentForRoute(route,) {
  if (!isRoute(route,)) {
    return;
  }
  const { page: routeComponent, } = route;
  if (!routeComponent) {
    return;
  }
  if (React86.isValidElement(routeComponent,)) {
    return routeComponent;
  }
  if (withPreload(routeComponent,)) {
    await routeComponent.preload();
  }
  return React86.createElement(routeComponent, { key: route.path, },);
}
var preloadKey2 = 'preload';
function withPreload(component,) {
  return !!component && isObject2(component,) && preloadKey2 in component;
}
function usePrototypeNavigate({ preload, } = {},) {
  const navigation = useNavigation();
  const { getRoute, } = useRouter();
  const onCanvas = useIsOnFramerCanvas();
  React86.useEffect(() => {
    if (!navigation || onCanvas) {
      return;
    }
    preload == null ? void 0 : preload.forEach((componentOrRoute,) => {
      let component;
      if (isString22(componentOrRoute,)) {
        const route = getRoute == null ? void 0 : getRoute(componentOrRoute,);
        if (isRoute(route,)) {
          component = route.page;
        }
      } else {
        component = componentOrRoute;
      }
      if (component && withPreload(component,)) {
        component.preload();
      }
    },);
  }, [],);
  if (!navigation) {
    return () => {
    };
  }
  return async (target, options = {},) => {
    if (onCanvas) {
      return;
    }
    if (target === 'previous') {
      navigation.goBack();
      return false;
    }
    const Component15 = typeof target === 'string'
      ? await componentForRoute(getRoute == null ? void 0 : getRoute(target,),).catch(() => {
      },)
      : React86.isValidElement(target,)
      ? target
      : null;
    if (!Component15) {
      return;
    }
    const { appearsFrom, backdropColor, animation, } = options;
    const transitionType = options.transition || 'instant';
    switch (transitionType) {
      case 'instant':
        navigation.instant(Component15,);
        break;
      case 'fade':
        navigation.fade(Component15, { animation, },);
        break;
      case 'push':
        navigation.push(Component15, { appearsFrom, animation, },);
        break;
      case 'flip':
        navigation.flip(Component15, { appearsFrom, animation, },);
        break;
      case 'magicMotion':
        navigation.magicMotion(Component15, { animation, },);
        break;
      case 'modal':
        navigation.modal(Component15, { backdropColor, animation, },);
        break;
      case 'overlay':
        navigation.overlay(Component15, { appearsFrom, backdropColor, animation, },);
        break;
    }
    return false;
  };
}
var QueryCache = class {
  constructor(queryEngine2,) {
    this.queryEngine = queryEngine2;
    __publicField(this, 'cache', /* @__PURE__ */ new Map(),);
  }
  get(query, locale,) {
    const key7 = getCacheKey(query, locale,);
    const existing = this.cache.get(key7,);
    if (existing) {
      return existing;
    }
    const resolver = () => this.queryEngine.query(query, locale,);
    const value = new LazyValue(resolver,);
    this.cache.set(key7, value,);
    return value;
  }
};
var collectionIds = /* @__PURE__ */ new WeakMap();
function getCollectionId(collection,) {
  const existing = collectionIds.get(collection,);
  if (existing) {
    return existing;
  }
  const id3 = Math.random().toString(16,).slice(2,);
  collectionIds.set(collection, id3,);
  return id3;
}
function getCacheKey({ from, ...query }, locale,) {
  var _a;
  const fromId = getCollectionId(from.data,);
  const localeId = (_a = locale == null ? void 0 : locale.id) != null ? _a : 'default';
  return fromId + JSON.stringify(query,) + localeId;
}
function use(promise,) {
  throw promise;
}
var DeepWeakMap = class {
  constructor() {
    __publicField(this, 'map1', /* @__PURE__ */ new WeakMap(),);
  }
  get(key1, key22,) {
    const map2 = this.map1.get(key1,);
    return map2 == null ? void 0 : map2.get(key22,);
  }
  set(key1, key22, value,) {
    var _a;
    const map2 = (_a = this.map1.get(key1,)) != null ? _a : /* @__PURE__ */ new WeakMap();
    this.map1.set(key1, map2,);
    return map2.set(key22, value,);
  }
};
function useData({ data: data2, },) {
  const { activeLocale, } = useLocaleInfo();
  if (isLegacyCollectionModule(data2,)) {
    return data2;
  }
  if (isLegacyLocalizedCollectionModule(data2,)) {
    const promise = data2.preload(activeLocale,);
    if (promise) {
      use(promise,);
    }
    return data2.read(activeLocale,);
  }
  throw new Error('Unsupported collection module',);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function useInsertIndex(data2,) {
  const cached = indexCache.get(data2,);
  if (cached) {
    return cached;
  }
  const result = data2.map((item, index,) => {
    return { ...item, index, };
  },);
  indexCache.set(data2, result,);
  return result;
}
var whereCache = /* @__PURE__ */ new DeepWeakMap();
function useExecuteWhere(data2, where,) {
  if (!where) {
    return data2;
  }
  const cached = whereCache.get(data2, where,);
  if (cached) {
    return cached;
  }
  const result = data2.filter((item,) => {
    return evaluateExpression(where, {
      resolveIdentifier(identifier,) {
        return item[identifier];
      },
    },);
  },);
  whereCache.set(data2, where, result,);
  return result;
}
var orderByCache = /* @__PURE__ */ new DeepWeakMap();
function useExecuteOrderBy(data2, orderBy,) {
  if (!orderBy) {
    return data2;
  }
  const cached = orderByCache.get(data2, orderBy,);
  if (cached) {
    return cached;
  }
  const result = [...data2,].sort((leftItem, rightItem,) => {
    let order = 0;
    for (const expression of orderBy) {
      const leftValue = evaluateExpression(expression, {
        resolveIdentifier(identifier,) {
          return leftItem[identifier];
        },
      },);
      const rightValue = evaluateExpression(expression, {
        resolveIdentifier(identifier,) {
          return rightItem[identifier];
        },
      },);
      if (isNumber2(leftValue,) && isNumber2(rightValue,)) {
        order = leftValue - rightValue;
      }
      if (isString22(leftValue,) && isString22(rightValue,)) {
        order = leftValue.localeCompare(rightValue, 'en',);
      }
      if (order !== 0) {
        return expression.direction === 'desc' ? -order : order;
      }
    }
    if (isNumber2(leftItem.index,) && isNumber2(rightItem.index,)) {
      return leftItem.index - rightItem.index;
    }
    return 0;
  },);
  orderByCache.set(data2, orderBy, result,);
  return result;
}
var offsetCache = /* @__PURE__ */ new DeepWeakMap();
function useExecuteOffset(data2, offset,) {
  if (!offset) {
    return data2;
  }
  const cached = offsetCache.get(data2, offset,);
  if (cached) {
    return cached;
  }
  const offsetValue = evaluateExpression(offset, {
    resolveIdentifier() {
      throw new Error('Can\'t resolve identifier',);
    },
  },);
  const result = isNumber2(offsetValue,) ? data2.slice(offsetValue,) : data2;
  offsetCache.set(data2, offset, result,);
  return result;
}
var limitCache = /* @__PURE__ */ new DeepWeakMap();
function useExecuteLimit(data2, limit,) {
  if (!limit) {
    return data2;
  }
  const cached = limitCache.get(data2, limit,);
  if (cached) {
    return cached;
  }
  const limitValue = evaluateExpression(limit, {
    resolveIdentifier() {
      throw new Error('Can\'t resolve identifier',);
    },
  },);
  const result = isNumber2(limitValue,) ? data2.slice(0, limitValue,) : data2;
  limitCache.set(data2, limit, result,);
  return result;
}
var selectCache = /* @__PURE__ */ new DeepWeakMap();
function useExecuteSelect(data2, select,) {
  const cached = selectCache.get(data2, select,);
  if (cached) {
    return cached;
  }
  const preloadPromise = preloadExpressions(select, data2,);
  if (preloadPromise) {
    use(preloadPromise,);
  }
  const result = data2.map((item,) => {
    var _a;
    const selected = {};
    for (const expression of select) {
      const name = (_a = expression.alias) != null ? _a : stringifyExpression2(expression,);
      selected[name] = evaluateExpression(expression, {
        resolveIdentifier(identifier,) {
          const value = item[identifier];
          if (LazyValue.is(value,)) {
            return value.read();
          }
          return value;
        },
      },);
    }
    return selected;
  },);
  selectCache.set(data2, select, result,);
  return result;
}
function preloadExpressions(expressions, data2,) {
  const identifiers = [];
  for (const expression of expressions) {
    extractIdentifiers(identifiers, expression,);
  }
  if (identifiers.length === 0) {
    return;
  }
  const preloadPromises = [];
  for (const item of data2) {
    for (const identifier of identifiers) {
      const value = item[identifier];
      if (!LazyValue.is(value,)) {
        continue;
      }
      const promise = value.preload();
      if (!promise) {
        continue;
      }
      preloadPromises.push(promise,);
    }
  }
  if (preloadPromises.length === 0) {
    return;
  }
  return Promise.all(preloadPromises,);
}
function extractIdentifiers(identifiers, expression,) {
  if (expression.type === 'Identifier') {
    identifiers.push(expression.name,);
  }
  if (expression.type === 'FunctionCall') {
    for (const argument of expression.arguments) {
      extractIdentifiers(identifiers, argument,);
    }
  }
  if (expression.type === 'Case') {
    if (expression.value) {
      extractIdentifiers(identifiers, expression.value,);
    }
    for (const condition of expression.conditions) {
      extractIdentifiers(identifiers, condition.when,);
      extractIdentifiers(identifiers, condition.then,);
    }
    if (expression.else) {
      extractIdentifiers(identifiers, expression.else,);
    }
  }
  if (expression.type === 'UnaryOperation') {
    extractIdentifiers(identifiers, expression.value,);
  }
  if (expression.type === 'BinaryOperation') {
    extractIdentifiers(identifiers, expression.left,);
    extractIdentifiers(identifiers, expression.right,);
  }
  if (expression.type === 'TypeCast') {
    extractIdentifiers(identifiers, expression.value,);
  }
}
var queryEngine = /* @__PURE__ */ new QueryEngine();
var queryCache = /* @__PURE__ */ new QueryCache(queryEngine,);
function useQueryDataWithQueryEngine(query,) {
  const { activeLocale, } = useLocaleInfo();
  const cached = queryCache.get(query, activeLocale,);
  const promise = cached.preload();
  if (promise) {
    use(promise,);
  }
  return cached.read();
}
function useQueryData(query,) {
  if (isDatabaseCollectionModule(query.from.data,)) {
    return useQueryDataWithQueryEngine(query,);
  }
  const queryRef = useRef132();
  if (queryRef.current && isEqual(queryRef.current, query,)) {
    query = queryRef.current;
  } else {
    queryRef.current = query;
  }
  let result = useData(query.from,);
  result = useInsertIndex(result,);
  result = useExecuteWhere(result, query.where,);
  result = useExecuteOrderBy(result, query.orderBy,);
  result = useExecuteOffset(result, query.offset,);
  result = useExecuteLimit(result, query.limit,);
  result = useExecuteSelect(result, query.select,);
  return result;
}
function evaluateExpression(expression, context,) {
  switch (expression.type) {
    case 'Identifier':
      return context.resolveIdentifier(expression.name,);
    case 'LiteralValue':
      return expression.value;
    case 'FunctionCall':
      return evaluateFunctionCall(expression, context,);
    case 'Case':
      return evaluateCase(expression, context,);
    case 'UnaryOperation':
      return evaluateUnaryOperation(expression, context,);
    case 'BinaryOperation':
      return evaluateBinaryOperation(expression, context,);
    case 'TypeCast':
      return evaluateTypeCast(expression, context,);
    default:
      throw new Error(`Unsupported expression: ${JSON.stringify(expression,)}`,);
  }
}
function evaluateFunctionCall(expression, context,) {
  function getArgument(index,) {
    const argument = expression.arguments[index];
    if (argument) {
      return evaluateExpression(argument, context,);
    }
  }
  switch (expression.functionName) {
    case 'CONTAINS': {
      const value = getArgument(0,);
      const search = getArgument(1,);
      if (isString22(value,) && isString22(search,)) {
        return value.toLowerCase().includes(search.toLowerCase(),);
      }
      return false;
    }
    case 'STARTS_WITH': {
      const value = getArgument(0,);
      const search = getArgument(1,);
      if (isString22(value,) && isString22(search,)) {
        return value.toLowerCase().startsWith(search.toLowerCase(),);
      }
      return false;
    }
    case 'ENDS_WITH': {
      const value = getArgument(0,);
      const search = getArgument(1,);
      if (isString22(value,) && isString22(search,)) {
        return value.toLowerCase().endsWith(search.toLowerCase(),);
      }
      return false;
    }
    default: {
      throw new Error(`Unsupported function: ${expression.functionName}`,);
    }
  }
}
function evaluateCase(expression, context,) {
  const value = expression.value && evaluateExpression(expression.value, context,);
  for (const condition of expression.conditions) {
    const when = evaluateExpression(condition.when, context,);
    if (expression.value ? isLooseEqual(when, value,) : when) {
      return evaluateExpression(condition.then, context,);
    }
  }
  if (expression.else) {
    return evaluateExpression(expression.else, context,);
  }
}
function evaluateUnaryOperation(expression, context,) {
  const value = evaluateExpression(expression.value, context,);
  switch (expression.operator) {
    case 'not': {
      return !value;
    }
    default: {
      throw new Error(`Unsupported unary operation: ${expression.operator}`,);
    }
  }
}
function evaluateBinaryOperation(expression, context,) {
  const left = evaluateExpression(expression.left, context,);
  const right = evaluateExpression(expression.right, context,);
  switch (expression.operator) {
    case 'and': {
      return Boolean(left && right,);
    }
    case 'or': {
      return Boolean(left || right,);
    }
    case '==': {
      return isLooseEqual(left, right,);
    }
    case '!=': {
      return !isLooseEqual(left, right,);
    }
    case '<': {
      if (isNumber2(left,) && isNumber2(right,)) {
        return left < right;
      }
      if (isValidDate(left,) && isValidDate(right,)) {
        return left < right;
      }
      return false;
    }
    case '<=': {
      if (isNumber2(left,) && isNumber2(right,)) {
        return left <= right;
      }
      if (isValidDate(left,) && isValidDate(right,)) {
        return left <= right;
      }
      return false;
    }
    case '>': {
      if (isNumber2(left,) && isNumber2(right,)) {
        return left > right;
      }
      if (isValidDate(left,) && isValidDate(right,)) {
        return left > right;
      }
      return false;
    }
    case '>=': {
      if (isNumber2(left,) && isNumber2(right,)) {
        return left >= right;
      }
      if (isValidDate(left,) && isValidDate(right,)) {
        return left >= right;
      }
      return false;
    }
    default: {
      throw new Error(`Unsupported binary operation: ${expression.operator}`,);
    }
  }
}
function evaluateTypeCast(expression, context,) {
  const value = evaluateExpression(expression.value, context,);
  switch (expression.dataType) {
    case 'BOOLEAN': {
      return Boolean(value,);
    }
    case 'NUMBER': {
      if (isNumber2(value,) && isFinite(value,)) {
        return value;
      }
      if (isString22(value,)) {
        const parsed = parseFloat(value,);
        if (isFinite(parsed,)) {
          return parsed;
        }
      }
      return 0;
    }
    case 'DATE': {
      if (value instanceof Date) {
        return value;
      }
      if (!isString22(value,) && !isNumber2(value,)) {
        return void 0;
      }
      return new Date(value,);
    }
    case 'STRING': {
      return String(value,);
    }
    default: {
      throw new Error(`Unsupported type cast: ${expression.dataType}`,);
    }
  }
}
function stringifyExpression2(expression,) {
  switch (expression.type) {
    case 'Identifier': {
      return expression.name;
    }
    default: {
      throw new Error(`Can't stringify expression: ${JSON.stringify(expression,)}`,);
    }
  }
}
function isLooseEqual(left, right,) {
  if (left == null && right == null) {
    return true;
  }
  if (isString22(left,) && isString22(right,)) {
    return left.toLowerCase() === right.toLowerCase();
  }
  if (isValidDate(left,) && isValidDate(right,)) {
    return left.getTime() === right.getTime();
  }
  return left === right;
}
function getWhereExpressionFromPathVariables(pathVariables,) {
  const entries = Object.entries(pathVariables,).filter(([, value,],) => {
    if (isUndefined(value,)) {
      return false;
    }
    if (isObject2(value,)) {
      return false;
    }
    return true;
  },);
  const expressions = entries.map(
    ([name, value,],) => ({
      type: 'BinaryOperation',
      operator: '==',
      left: {
        type: 'TypeCast',
        value: {
          type: 'Identifier',
          name,
        },
        dataType: 'STRING',
        /* String */
      },
      right: {
        type: 'LiteralValue',
        value: String(value,),
      },
    }),
  );
  if (expressions.length === 0) {
    return {
      type: 'LiteralValue',
      value: false,
    };
  }
  return expressions.reduce(
    (result, expression,) => ({
      type: 'BinaryOperation',
      operator: 'and',
      left: result,
      right: expression,
    }),
  );
}
function createGestureVariant(variant, type,) {
  return `${variant}-${type}`;
}
function nextVariant(allVariants, currentVariant,) {
  const index = allVariants.indexOf(currentVariant,);
  let nextIndex = index + 1;
  if (nextIndex >= allVariants.length) {
    nextIndex = 0;
  }
  const nextVariant2 = allVariants[nextIndex];
  assert(nextVariant2 !== void 0, 'nextVariant should be defined',);
  return nextVariant2;
}
function activeTransition(transitions, variant,) {
  if (!transitions) {
    return void 0;
  }
  if (variant) {
    const variantTransition = transitions[variant];
    if (variantTransition) {
      return variantTransition;
    }
  }
  return transitions.default;
}
var VariantSelector = /* @__PURE__ */ ((VariantSelector2,) => {
  VariantSelector2['Variant'] = 'v';
  return VariantSelector2;
})(VariantSelector || {},);
function getGesture(enabledGestures, isHovered, isPressed,) {
  const { hover, pressed, } = enabledGestures || {};
  if (pressed && isPressed) {
    return 'pressed';
  }
  if (hover && isHovered) {
    return 'hover';
  }
}
function createVariantClassName(baseVariant, variantClassNames,) {
  const mappedClassName = variantClassNames[baseVariant];
  if (mappedClassName) {
    return mappedClassName;
  }
  return `framer-${'v'}-${baseVariant}`;
}
function safeBaseVariant(targetVariant, fallbackVariant, validBaseVariants,) {
  if (!targetVariant) {
    return fallbackVariant;
  }
  if (validBaseVariants.has(targetVariant,)) {
    return targetVariant;
  }
  return fallbackVariant;
}
var CycleVariantState = /* @__PURE__ */ Symbol('cycle',);
function useVariantState({
  variant,
  defaultVariant: externalDefaultVariant,
  transitions: externalTransitions,
  enabledGestures: externalEnabledGestures,
  cycleOrder: externalCycleOrder = [],
  variantProps: variantProps2 = {},
  variantClassNames = {},
},) {
  const forceUpdate = useForceUpdate3();
  const validBaseVariants = useConstant2(() => new Set(externalCycleOrder,));
  const internalState = React87.useRef({
    isHovered: false,
    isPressed: false,
    baseVariant: safeBaseVariant(variant, externalDefaultVariant, validBaseVariants,),
    lastVariant: variant,
    gestureVariant: void 0,
    // When used in generated components, these are static values defined
    // outside of the component function that also need to not result in
    // memoized values being recalculated, so we dump them into the ref.
    defaultVariant: externalDefaultVariant,
    enabledGestures: externalEnabledGestures,
    cycleOrder: externalCycleOrder,
    transitions: externalTransitions,
  },);
  const resolveNextVariant = React87.useCallback(
    (targetBaseVariant,) => {
      const { isHovered: isHovered2, isPressed: isPressed2, enabledGestures: enabledGestures2, defaultVariant: defaultVariant2, } =
        internalState.current;
      const nextBaseVariant = safeBaseVariant(targetBaseVariant, defaultVariant2, validBaseVariants,);
      const gesture = getGesture(enabledGestures2 == null ? void 0 : enabledGestures2[nextBaseVariant], isHovered2, isPressed2,);
      const nextGestureVariant = gesture ? createGestureVariant(nextBaseVariant, gesture,) : void 0;
      return [nextBaseVariant, nextGestureVariant,];
    },
    [validBaseVariants,],
  );
  const setGestureState = React87.useCallback(
    ({ isHovered: isHovered2, isPressed: isPressed2, },) => {
      if (isHovered2 !== void 0) {
        internalState.current.isHovered = isHovered2;
      }
      if (isPressed2 !== void 0) {
        internalState.current.isPressed = isPressed2;
      }
      const { baseVariant: baseVariant2, gestureVariant: gestureVariant2, defaultVariant: defaultVariant2, } = internalState.current;
      const [nextBase, nextGesture,] = resolveNextVariant(baseVariant2,);
      if (nextBase !== baseVariant2 || nextGesture !== gestureVariant2) {
        internalState.current.baseVariant = nextBase || defaultVariant2;
        internalState.current.gestureVariant = nextGesture;
        forceUpdate();
      }
    },
    [resolveNextVariant, forceUpdate,],
  );
  const setVariant = React87.useCallback(
    (proposedVariant,) => {
      const { defaultVariant: defaultVariant2, cycleOrder, baseVariant: baseVariant2, gestureVariant: gestureVariant2, } =
        internalState.current;
      const nextBaseVariant = proposedVariant === CycleVariantState
        ? nextVariant(cycleOrder || [], baseVariant2 || defaultVariant2,)
        : proposedVariant;
      const [nextBase, nextGesture,] = resolveNextVariant(nextBaseVariant,);
      if (nextBase !== baseVariant2 || nextGesture !== gestureVariant2) {
        internalState.current.baseVariant = nextBase || defaultVariant2;
        internalState.current.gestureVariant = nextGesture;
        forceUpdate();
      }
    },
    [resolveNextVariant, forceUpdate,],
  );
  if (variant !== internalState.current.lastVariant) {
    const [nextBase, nextGesture,] = resolveNextVariant(variant,);
    internalState.current.lastVariant = nextBase;
    if (nextBase !== internalState.current.baseVariant || nextGesture !== internalState.current.gestureVariant) {
      internalState.current.baseVariant = nextBase;
      internalState.current.gestureVariant = nextGesture;
    }
  }
  const { baseVariant, gestureVariant, defaultVariant, enabledGestures, isHovered, isPressed, } = internalState.current;
  const addVariantProps = useAddVariantProps(
    internalState.current.baseVariant,
    internalState.current.gestureVariant,
    variantProps2,
  );
  return React87.useMemo(() => {
    const variants = [];
    if (baseVariant !== defaultVariant) {
      variants.push(baseVariant,);
    }
    if (gestureVariant) {
      variants.push(gestureVariant,);
    }
    return {
      variants,
      baseVariant,
      gestureVariant,
      transition: activeTransition(internalState.current.transitions, baseVariant,),
      setVariant,
      setGestureState,
      addVariantProps,
      classNames: cx(
        createVariantClassName(baseVariant, variantClassNames,),
        getGesture(enabledGestures == null ? void 0 : enabledGestures[baseVariant], isHovered, isPressed,),
      ),
    };
  }, [
    baseVariant,
    gestureVariant,
    isHovered,
    isPressed,
    addVariantProps,
    setVariant,
    defaultVariant,
    enabledGestures,
    setGestureState,
    variantClassNames,
  ],);
}
function extractMappingFromInfo(info,) {
  var _a;
  const json = (_a = info.__FramerMetadata__.exports.default.annotations) == null ? void 0 : _a.framerVariables;
  if (!json) {
    return void 0;
  }
  try {
    return JSON.parse(json,);
  } catch {
    return void 0;
  }
}
function withMappedReactProps(Component15, info,) {
  return (rawProps,) => {
    var _a;
    const props = {};
    const mapping = extractMappingFromInfo(info,);
    for (const key7 in rawProps) {
      asRecord(props,)[(_a = mapping == null ? void 0 : mapping[key7]) != null ? _a : key7] = rawProps[key7];
    }
    return /* @__PURE__ */ React88.createElement(Component15, { ...props, },);
  };
}
var keys2 = /* @__PURE__ */ new Set([
  'visibleVariantId',
  'obscuredVariantId',
  'threshold',
  'animateOnce',
  'variantAppearEffectEnabled',
  'targets',
  'exitTarget',
  'scrollDirection',
],);
var defaultRanges3 = { inputRange: [], outputRange: [], };
function createInputOutputRanges2(transformTargets, threshold, exitTarget,) {
  const outputRange = [];
  const inputRange = createTransformInputRange(
    transformTargets,
    threshold,
    (index,) => outputRange.unshift(index, index,),
  );
  if (exitTarget) {
    const lastInputRange = inputRange[inputRange.length - 1];
    if (!isNumber2(lastInputRange,)) {
      return defaultRanges3;
    }
    inputRange.push(lastInputRange + 1,);
    outputRange.push(-1,);
  }
  const firstItem = inputRange[0];
  if (!isNumber2(firstItem,)) {
    return defaultRanges3;
  }
  if (firstItem <= 1) {
    return { inputRange, outputRange, };
  }
  return { inputRange: [0, Math.max(firstItem - 1, 0,), ...inputRange,], outputRange: [-1, -1, ...outputRange,], };
}
var withVariantAppearEffect = (Component15,) =>
  React89.forwardRef(
    (props, forwardedRef,) => {
      if (RenderTarget.current() === 'CANVAS') {
        return /* @__PURE__ */ React89.createElement(Component15, { ...props, ref: forwardedRef, },);
      }
      const fallbackRef = React89.useRef(null,);
      const ref = forwardedRef != null ? forwardedRef : fallbackRef;
      const [options, rest,] = extractPrefixedProps(props, keys2,);
      const {
        visibleVariantId,
        obscuredVariantId,
        animateOnce,
        threshold,
        variantAppearEffectEnabled,
        targets,
        exitTarget,
        scrollDirection,
      } = options;
      const [activeVariant, setVariant,] = React89.useState(obscuredVariantId,);
      const animateState = React89.useRef(false,);
      useAppearEffect(
        ref,
        (appears,) => {
          if (options.targets) {
            return;
          }
          if (options.scrollDirection) {
            return;
          }
          if (animateOnce && animateState.current === true) {
            return;
          }
          if (animateState.current === appears) {
            return;
          }
          animateState.current = appears;
          if (appears) {
            setVariant(visibleVariantId,);
          } else {
            setVariant(obscuredVariantId,);
          }
        },
        {
          enabled: variantAppearEffectEnabled,
          animateOnce,
          threshold: {
            y: threshold,
          },
        },
      );
      React89.useEffect(() => {
        if (scrollDirection) {
          return;
        }
        if (!targets) {
          return;
        }
        const playedState = {};
        let currentVariant = void 0;
        return scrollInfo(({ y: scrollY, },) => {
          var _a, _b;
          if (!targets[0] || targets[0].ref && !targets[0].ref.current) {
            return;
          }
          const { inputRange, outputRange, } = createInputOutputRanges2(
            targets,
            (threshold != null ? threshold : 0) * scrollY.containerLength,
            exitTarget,
          );
          if (inputRange.length === 0 || inputRange.length !== outputRange.length) {
            return;
          }
          const index = Math.floor(transform(scrollY.current, inputRange, outputRange,),);
          if (animateOnce && playedState[index]) {
            return;
          }
          playedState[index] = true;
          const variant = (_b = (_a = targets[index]) == null ? void 0 : _a.target) != null ? _b : void 0;
          if (variant === currentVariant) {
            return;
          }
          currentVariant = variant;
          setVariant(variant,);
        },);
      }, [animateOnce, threshold, targets, props.variant,],);
      useScrollDirectionChange(scrollDirection, setVariant, {
        enabled: variantAppearEffectEnabled,
        repeat: !animateOnce,
      },);
      if (!('variantAppearEffectEnabled' in options) || variantAppearEffectEnabled === true) {
        return /* @__PURE__ */ React89.createElement(Component15, {
          ...rest,
          variant: activeVariant != null ? activeVariant : props.variant,
          ref,
        },);
      } else {
        return /* @__PURE__ */ React89.createElement(Component15, { ...rest, },);
      }
    },
  );
var withVariantFX = (Component15,) =>
  React90.forwardRef(
    ({ initial, animate: animate3, exit, ...props }, forwardedRef,) => {
      const ref = useRef14();
      const effect = usePresenceAnimation(
        {
          initial,
          animate: animate3,
          exit,
        },
        forwardedRef != null ? forwardedRef : ref,
        true,
      );
      return /* @__PURE__ */ React90.createElement(Component15, {
        ...props,
        style: { ...props == null ? void 0 : props.style, ...effect.values, },
        ref: forwardedRef != null ? forwardedRef : ref,
      },);
    },
  );
function isDesignDefinition(d,) {
  return d.type === 'master';
}
function isOverride(d,) {
  return d.type === 'override';
}
function isReactDefinition(d,) {
  return d.type !== 'master';
}
var DeprecatedComponentContainer = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    constructor() {
      super(...arguments,);
      __publicField(this, 'state', {},);
      __publicField(this, 'setElement', (element,) => {
        if (this.props.innerRef) {
          this.props.innerRef.current = element;
        }
        this.setLayerElement(element,);
      },);
    }
    componentDidCatch(error, info,) {
      let stack = info.componentStack.split('\n',).filter((line,) => line.length !== 0);
      let currentIndex = 0;
      for (const line of stack) {
        if (line.startsWith(`    in ${this.constructor.name}`,)) {
          break;
        }
        currentIndex++;
      }
      stack = stack.slice(0, currentIndex,);
      this.setState({
        lastError: {
          children: this.props.children,
          name: error.name,
          message: error.message,
          componentStack: stack,
        },
      },);
    }
    renderErrorPlaceholder(file, error,) {
      const { RenderPlaceholder, } = runtime;
      return /* @__PURE__ */ React91.createElement(
        FrameWithMotion,
        { ...this.props, background: null, },
        /* @__PURE__ */ React91.createElement(RenderPlaceholder, { error: { error, file, }, },),
      );
    }
    render() {
      var _a2, _b;
      countNodeRender();
      let { children, } = this.props;
      const { componentIdentifier, } = this.props;
      const { lastError: error, } = this.state;
      const noChildren = !children || Array.isArray(children,) && children.filter((c,) => c).length === 0;
      if (noChildren) {
        const errorComponent = runtime.componentLoader.errorForIdentifier(componentIdentifier,);
        if (errorComponent) {
          return this.renderErrorPlaceholder(errorComponent.file, errorComponent.error,);
        }
      }
      if (error && error.children === children) {
        const component = runtime.componentLoader.componentForIdentifier(componentIdentifier,);
        const file = component ? component.file : '???';
        return this.renderErrorPlaceholder(file, error.message,);
      }

      (_b = (_a2 = asRecord(safeWindow,))['__checkComponentBudget__']) == null ? void 0 : _b.call(_a2,);
      let frameProps = this.props;
      if (RenderTarget.current() !== 'CANVAS') {
        const {
          left,
          right,
          top,
          bottom,
          center,
          centerX,
          centerY,
          aspectRatio: aspectRatio2,
          parentSize,
          width,
          height,
          rotation,
          opacity,
          visible,
          _constraints,
          _initialStyle,
          name,
          positionSticky,
          positionStickyTop,
          positionStickyRight,
          positionStickyBottom,
          positionStickyLeft,
          // Remove the children and the componentIdentifier from the props passed into the component
          componentIdentifier: originalComponentIdentifier,
          children: originalChildren,
          style,
          duplicatedFrom,
          widthType,
          heightType,
          ...childProps
        } = frameProps;
        children = React91.Children.map(originalChildren, (child,) => {
          if (!isReactChild(child,) || !isReactElement(child,)) {
            return child;
          }
          if (!isPageOrScroll(originalComponentIdentifier,)) {
            return /* @__PURE__ */ React91.createElement(
              LayoutGroup,
              { inherit: false, id: this.props.__layoutId, },
              /* @__PURE__ */ React91.createElement(AutomaticLayoutIds, { enabled: false, }, React91.cloneElement(child, childProps,),),
            );
          }
          return React91.cloneElement(child, childProps,);
        },);
        frameProps = {
          style,
          _constraints,
          _initialStyle,
          left,
          right,
          top,
          bottom,
          center,
          centerX,
          centerY,
          aspectRatio: aspectRatio2,
          parentSize,
          width,
          height,
          rotation,
          visible,
          name,
          duplicatedFrom,
          id: frameProps.id,
          layoutId: this.props.__layoutId,
          widthType,
          heightType,
          positionSticky,
          positionStickyTop,
          positionStickyRight,
          positionStickyBottom,
          positionStickyLeft,
        };
      }
      return (
        /* The background should come before the frameProps. It looks like there never should be a background in frameProps,
         * but published design components can contain an old version of the presentation tree that expects the background
         * that is passed to be rendered here
         * See the stackBackgroundTest.tsx integration test for an example of such a case
         */
        /* @__PURE__ */ React91.createElement(
          ComponentContainerContext.Provider,
          { value: true, },
          /* @__PURE__ */ React91.createElement(
            FrameWithMotion,
            {
              'data-framer-component-container': true,
              background: null,
              overflow: 'visible',
              ref: this.setElement,
              ...frameProps,
            },
            children,
          ),
        )
      );
    }
  },
    __publicField(_a, 'supportsConstraints', true,),
    __publicField(_a, 'defaultComponentContainerProps', {
      style: {},
      visible: true,
      componentIdentifier: '',
    },),
    __publicField(_a, 'defaultProps', {
      ...Layer.defaultProps,
      ..._a.defaultComponentContainerProps,
    },),
    __publicField(_a, 'contextType', ComponentContainerContext,),
    _a;
})();
function isPageOrScroll(identifier,) {
  if (!identifier) {
    return false;
  }
  if (identifier === 'framer/Page') {
    return true;
  }
  if (identifier === 'framer/Scroll') {
    return true;
  }
  return false;
}
var Line = /* @__PURE__ */ (() => {
  function Line2(a, b,) {
    return { a, b, };
  }
  Line2.intersection = (lineA, lineB,) => {
    const x1 = lineA.a.x;
    const y1 = lineA.a.y;
    const x2 = lineA.b.x;
    const y2 = lineA.b.y;
    const x3 = lineB.a.x;
    const y3 = lineB.a.y;
    const x4 = lineB.b.x;
    const y4 = lineB.b.y;
    const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d === 0) {
      return null;
    }
    const xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
    const yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
    return { x: xi, y: yi, };
  };
  Line2.intersectionAngle = (lineA, lineB,) => {
    const deltaAX = lineA.b.x - lineA.a.x;
    const deltaAY = lineA.b.y - lineA.a.y;
    const deltaBX = lineB.b.x - lineB.a.x;
    const deltaBY = lineB.b.y - lineB.a.y;
    const angle = Math.atan2(deltaAX * deltaBY - deltaAY * deltaBX, deltaAX * deltaBX + deltaAY * deltaBY,);
    return angle * (180 / Math.PI);
  };
  Line2.isOrthogonal = (line,) => {
    return line.a.x === line.b.x || line.a.y === line.b.y;
  };
  Line2.perpendicular = (line, pointOnLine,) => {
    const deltaX = line.a.x - line.b.x;
    const deltaY = line.a.y - line.b.y;
    const pointB = Point(pointOnLine.x - deltaY, pointOnLine.y + deltaX,);
    return Line2(pointB, pointOnLine,);
  };
  Line2.projectPoint = (line, point2,) => {
    const perp = Line2.perpendicular(line, point2,);
    return Line2.intersection(line, perp,);
  };
  Line2.pointAtPercentDistance = (line, distance2,) => {
    const hypotenuse = Line2.distance(line,);
    const r = distance2 * hypotenuse / hypotenuse;
    return {
      x: r * line.b.x + (1 - r) * line.a.x,
      y: r * line.b.y + (1 - r) * line.a.y,
    };
  };
  Line2.distance = (line,) => {
    return Point.distance(line.a, line.b,);
  };
  return Line2;
})();
function linearGradientLine(angle,) {
  var _a, _b;
  const rad = angle * Math.PI / 180;
  const offset = {
    x: -Math.sin(rad,) * 100,
    y: Math.cos(rad,) * 100,
  };
  const anglePoint = Point(offset.x, offset.y,);
  const angleLine = Line(Point(0.5, 0.5,), anglePoint,);
  const points = Rect.points({ x: 0, y: 0, width: 1, height: 1, },);
  const sortedPoints = points.map((point2,) => ({ point: point2, distance: Point.distance(anglePoint, point2,), })).sort((a2, b2,) =>
    a2.distance - b2.distance
  );
  const a = (_a = sortedPoints[0]) == null ? void 0 : _a.point;
  const b = (_b = sortedPoints[1]) == null ? void 0 : _b.point;
  assert(a && b, 'linearGradientLine: Must have 2 closest points.',);
  const [c, d,] = points.filter((point2,) => !Point.isEqual(point2, a,) && !Point.isEqual(point2, b,));
  assert(c && d, 'linearGradientLine: Must have 2 opposing points.',);
  const start = Line.intersection(angleLine, Line(a, b,),);
  const end = Line.intersection(angleLine, Line(c, d,),);
  assert(start && end, 'linearGradientLine: Must have a start and end point.',);
  return Line(start, end,);
}
function elementPropertiesForLinearGradient(gradient, id3,) {
  var _a, _b, _c, _d;
  const line = linearGradientLine(gradient.angle,);
  const stops = gradientColorStops(gradient,);
  const startPosition = (_b = (_a = stops[0]) == null ? void 0 : _a.position) != null ? _b : 0;
  const endPosition = (_d = (_c = stops[stops.length - 1]) == null ? void 0 : _c.position) != null ? _d : 1;
  const startPoint = Line.pointAtPercentDistance(line, startPosition,);
  const endPoint = Line.pointAtPercentDistance(line, endPosition,);
  const interpolator = interpolate([startPosition, endPosition,], [0, 1,],);
  return {
    id: `id${id3}g${LinearGradient.hash(gradient,)}`,
    x1: startPoint.x,
    y1: startPoint.y,
    x2: endPoint.x,
    y2: endPoint.y,
    stops: stops.map((stop,) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value,) * gradient.alpha,
      position: interpolator(stop.position,),
    })),
  };
}
function elementPropertiesForRadialGradient(gradient, id3,) {
  return {
    id: `id${id3}g${RadialGradient.hash(gradient,)}`,
    widthFactor: gradient.widthFactor,
    heightFactor: gradient.heightFactor,
    centerAnchorX: gradient.centerAnchorX,
    centerAnchorY: gradient.centerAnchorY,
    stops: gradientColorStops(gradient,).map((stop,) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value,) * gradient.alpha,
      position: stop.position,
    })),
  };
}
function isRelativeNumber(value,) {
  if (!isString22(value,)) {
    return false;
  }
  const lastChar = value.charAt(value.length - 1,);
  if (lastChar !== '%') {
    return false;
  }
  const withoutLastChar = value.slice(0, -1,);
  const float = parseFloat(withoutLastChar,);
  return isNumber2(float,);
}
function getRelativeNumberValue(value,) {
  const withoutLastChar = value.slice(0, -1,);
  const float = parseFloat(withoutLastChar,);
  return isNumber2(float,) ? float : 50;
}
function getPositionXFraction(positionX,) {
  if (isRelativeNumber(positionX,)) {
    return getRelativeNumberValue(positionX,) / 100;
  }
  if (positionX === 'left') {
    return 0;
  }
  if (positionX === 'right') {
    return 1;
  }
  return 0.5;
}
function getPositionYFraction(positionY,) {
  if (isRelativeNumber(positionY,)) {
    return getRelativeNumberValue(positionY,) / 100;
  }
  if (positionY === 'top') {
    return 0;
  }
  if (positionY === 'bottom') {
    return 1;
  }
  return 0.5;
}
function imagePatternPropsForFill(fill, frame2, id3, includeTransform,) {
  var _a, _b, _c, _d;
  fill = Animatable.get(fill, '#09F',);
  if (!BackgroundImage.isImageObject(fill,)) {
    return void 0;
  }
  if (!fill.pixelWidth || !fill.pixelHeight) {
    return void 0;
  }
  const imageWidth = fill.pixelWidth;
  const imageHeight = fill.pixelHeight;
  let transform2;
  const { fit, } = fill;
  let width = 1, height = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (fit === 'fill' || fit === 'fit' || fit === 'tile' || !fit) {
    let scaleX = 1;
    let scaleY = 1;
    const imageRatio = imageWidth / imageHeight;
    const realWidth = frame2.height * imageRatio;
    const realHeight = frame2.width / imageRatio;
    const validScaleX = realWidth / frame2.width;
    const validScaleY = realHeight / frame2.height;
    if (fit === 'tile') {
      (_a = fill.backgroundSize) != null ? _a : fill.backgroundSize = 1;
      width = Math.round(fill.backgroundSize * (imageWidth / 2),);
      height = Math.round(fill.backgroundSize * (imageHeight / 2),);
      const layerPositionX = (_b = frame2.x) != null ? _b : 0;
      const layerPositionY = (_c = frame2.y) != null ? _c : 0;
      let extraOffsetX = 0;
      let extraOffsetY = 0;
      if (includeTransform) {
        extraOffsetX = layerPositionX;
        extraOffsetY = layerPositionY;
      }
      offsetX = (frame2.width - width) * getPositionXFraction(fill.positionX,) + extraOffsetX;
      offsetY = (frame2.height - height) * getPositionYFraction(fill.positionY,) + extraOffsetY;
      transform2 = `translate(${offsetX + layerPositionX}, ${offsetY + layerPositionY})`;
    } else {
      if (fit === 'fill' || !fit ? validScaleY > validScaleX : validScaleY < validScaleX) {
        scaleY = validScaleY;
        offsetY = (1 - validScaleY) * getPositionYFraction(fill.positionY,);
      } else {
        scaleX = validScaleX;
        offsetX = (1 - validScaleX) * getPositionXFraction(fill.positionX,);
      }
      transform2 = `translate(${offsetX}, ${offsetY}) scale(${scaleX}, ${scaleY})`;
    }
  }
  const imageId = `id${id3}g${'-fillImage'}`;
  return { id: imageId, path: (_d = fill.src) != null ? _d : '', transform: transform2, width, height, offsetX, offsetY, };
}
var WindowContext = /* @__PURE__ */ React922.createContext(
  void 0,
);
var useProvidedWindow = () => React922.useContext(WindowContext,);
var mediaType2 = 'framer/asset-reference,';
function isAssetReference(value,) {
  return value.startsWith(`data:${mediaType2}`,);
}
function imageUrlForAsset(asset, pixelSize,) {
  var _a;
  if (/^\w+:/.test(asset,) && !isAssetReference(asset,)) {
    return asset;
  }
  if (typeof pixelSize !== 'number') {
    pixelSize = void 0;
  } else if (pixelSize <= 512) {
    pixelSize = 512;
  } else if (pixelSize <= 1024) {
    pixelSize = 1024;
  } else if (pixelSize <= 2048) {
    pixelSize = 2048;
  } else {
    pixelSize = 4096;
  }
  const isExport = RenderTarget.current() === 'EXPORT';
  return (_a = runtime.assetResolver(asset, { pixelSize, isExport, },)) != null ? _a : '';
}
var ImagePatternElement = ({
  id: id3,
  path,
  transform: transform2,
  repeat,
  width,
  height,
  offsetX,
  offsetY,
},) => {
  const href = imageUrlForAsset(path,);
  return /* @__PURE__ */ React93.createElement(
    'pattern',
    {
      id: id3,
      width: repeat ? width : '100%',
      height: repeat ? height : '100%',
      patternContentUnits: repeat ? void 0 : 'objectBoundingBox',
      patternUnits: repeat ? 'userSpaceOnUse' : void 0,
      x: repeat ? offsetX : void 0,
      y: repeat ? offsetY : void 0,
    },
    /* @__PURE__ */ React93.createElement(
      'image',
      {
        key: href,
        width: repeat ? width : 1,
        height: repeat ? height : 1,
        href,
        preserveAspectRatio: 'none',
        transform: repeat ? void 0 : transform2,
        x: repeat ? 0 : void 0,
        y: repeat ? 0 : void 0,
      },
    ),
  );
};
var useDOM = isBrowser2();
var SharedSVGEntry = class {
  constructor(id3, svg, innerHTML, viewBox, count = 0,) {
    this.id = id3;
    this.svg = svg;
    this.innerHTML = innerHTML;
    this.viewBox = viewBox;
    this.count = count;
  }
};
var SharedSVGManager = class {
  constructor() {
    __publicField(this, 'entries', /* @__PURE__ */ new Map(),);
  }
  debugGetEntries() {
    return this.entries;
  }
  /** Request to render a svg, this will ensure there is a global instance and will return a
   * template referencing the image. Must be balanced with `unsubscribe()` calls using the same
   * svg. If called multiple times while the shared SVG exists, the generateUniqueIds and
   * contentId parameters are ignored. */
  subscribe(svg, generateUniqueIds, contentId,) {
    if (!svg || svg === '') {
      return '';
    }
    let entry = this.entries.get(svg,);
    if (!entry) {
      if (!contentId) {
        contentId = 'svg' + String(hash(svg,),) + '_' + String(svg.length,);
      }
      let uniqueSVG = svg;
      let svgSize;
      const svgDom = parseSVG(svg,);
      if (svgDom) {
        if (generateUniqueIds) {
          prefixIdsInSVG(svgDom, contentId,);
        }
        svgDom.id = contentId;
        svgSize = getSVGSize(svgDom,);
        uniqueSVG = svgDom.outerHTML;
      }
      entry = this.createDOMElementFor(uniqueSVG, contentId, svgSize,);
      this.entries.set(svg, entry,);
    }
    entry.count += 1;
    return entry.innerHTML;
  }
  /** Returns the viewBox for the svg, or undefined if there is no viewBox. */
  getViewBox(svg,) {
    if (!svg || svg === '') {
      return;
    }
    const entry = this.entries.get(svg,);
    return entry == null ? void 0 : entry.viewBox;
  }
  /** When no longer rendering an svg it must be unsubscribed from so resources can be cleaned up.
   * Pass in the same svg as used with `subscribe()`. */
  unsubscribe(svg,) {
    if (!svg || svg === '') {
      return;
    }
    const entry = this.entries.get(svg,);
    if (!entry) {
      return;
    }
    entry.count -= 1;
    if (entry.count > 0) {
      return;
    }
    setTimeout(() => this.maybeRemoveEntry(svg,), 5e3,);
  }
  maybeRemoveEntry(svg,) {
    const entry = this.entries.get(svg,);
    if (!entry) {
      return;
    }
    if (entry.count > 0) {
      return;
    }
    this.entries.delete(svg,);
    this.removeDOMElement(entry,);
  }
  removeDOMElement(entry,) {
    const containerId = 'container_' + entry.id;
    if (useDOM) {
      const container = document == null ? void 0 : document.querySelector('#' + containerId,);
      container == null ? void 0 : container.remove();
    }
  }
  createDOMElementFor(svg, id3, size2,) {
    const containerId = 'container_' + id3;
    if (useDOM) {
      let svgTemplates = document.querySelector('#svg-templates',);
      if (!svgTemplates) {
        svgTemplates = document.createElement('div',);
        svgTemplates.id = 'svg-templates';
        svgTemplates.style.position = 'absolute';
        svgTemplates.style.top = '0';
        svgTemplates.style.left = '0';
        svgTemplates.style.width = '0';
        svgTemplates.style.height = '0';
        svgTemplates.style.overflow = 'hidden';
        document.body.appendChild(svgTemplates,);
      }
      if (!document.querySelector('#' + containerId,)) {
        const container = document.createElement('div',);
        container.id = containerId;
        container.innerHTML = svg;
        if (container.firstElementChild) {
          container.firstElementChild.id = id3;
        }
        svgTemplates.appendChild(container,);
      }
    }
    const box = size2 ? `0 0 ${size2.width} ${size2.height}` : void 0;
    const viewBox = box ? ` viewBox="${box}"` : '';
    const innerHTML =
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="width: 100%; height: 100%"${viewBox}><use href="#${id3}"></use></svg>`;
    return new SharedSVGEntry(id3, svg, innerHTML, box,);
  }
  clear() {
    this.entries.clear();
  }
  /** Returns a string containing a div#svg-templates and all the current svg templates. Can be
   * used after running `ReactDOMServer.renderToString()` */
  generateTemplates() {
    const output = [];
    const style = 'position: absolute; overflow: hidden; top: 0; left: 0; width: 0; height: 0';
    output.push(`<div id="svg-templates" style="${style}">`,);
    for (const value of this.entries.values()) {
      const containerId = 'container_' + value.id;
      output.push(`  <div id="${containerId}">`,);
      output.push(`    ${value.svg}`,);
      output.push('  </div>',);
    }
    output.push('</div>',);
    return output.join('\n',);
  }
};
var sharedSVGManager = /* @__PURE__ */ new SharedSVGManager();
function parseSVG(svg,) {
  if (typeof DOMParser === 'undefined') {
    console.warn('unable to find DOMParser',);
    return;
  }
  try {
    const domParser = new DOMParser();
    const doc = domParser.parseFromString(svg, 'text/html',);
    const node = doc.getElementsByTagName('svg',)[0];
    if (!node) {
      throw Error('no svg element found',);
    }
    return node;
  } catch {
    return;
  }
}
function prefixIdsInSVG(svg, prefix2,) {
  const sanitizedPrefix = sanitizeString(prefix2,);
  recursivelyPrefixId(svg, sanitizedPrefix,);
}
function sanitizeString(str,) {
  return str.replace(/[^\w\-:.]|^[^a-z]+/gi, '',);
}
function recursivelyPrefixId(el, prefix2,) {
  prefixId(el, prefix2,);
  const childNodes = Array.from(el.children,);
  childNodes.forEach((node,) => {
    recursivelyPrefixId(node, prefix2,);
  },);
}
function prefixId(el, prefix2,) {
  const attributes = el.getAttributeNames();
  attributes.forEach((attr,) => {
    const value = el.getAttribute(attr,);
    if (!value) {
      return;
    }
    if (attr === 'id') {
      el.setAttribute(attr, `${prefix2}_${value}`,);
    }
    if (attr === 'href' || attr === 'xlink:href') {
      const [base, fragmentIdentifier,] = value.split('#',);
      if (base) {
        return;
      }
      el.setAttribute(attr, `#${prefix2}_${fragmentIdentifier}`,);
      return;
    }
    const URL_REF = 'url(#';
    if (value.includes(URL_REF,)) {
      const prefixedValue = value.replace(URL_REF, `${URL_REF}${prefix2}_`,);
      el.setAttribute(attr, prefixedValue,);
    }
  },);
}
var unitsToPixels = {
  cm: 96 / 2.54,
  mm: 96 / 2.54 / 10,
  Q: 96 / 2.54 / 40,
  in: 96,
  pc: 96 / 6,
  pt: 96 / 72,
  px: 1,
  // A few assumptions about relative units.
  em: 16,
  ex: 8,
  ch: 8,
  rem: 16,
};
function parseLength(value,) {
  var _a;
  if (!value) {
    return;
  }
  const m2 = /(-?[\d.]+)([a-z%]*)/.exec(value,);
  if ((m2 == null ? void 0 : m2[1]) === void 0 || (m2 == null ? void 0 : m2[2]) === void 0) {
    return;
  }
  if ((_a = m2[2]) == null ? void 0 : _a.startsWith('%',)) {
    return;
  }
  return Math.round(parseFloat(m2[1],) * (unitsToPixels[m2[2]] || 1),);
}
function getSVGSize(svg,) {
  const width = parseLength(svg.getAttribute('width',),);
  const height = parseLength(svg.getAttribute('height',),);
  if (typeof width !== 'number' || typeof height !== 'number') {
    return;
  }
  if (width <= 0 || height <= 0) {
    return;
  }
  return { width, height, };
}
function SVG(props,) {
  const parentSize = useParentSize();
  const layoutId = useLayoutId2(props,);
  const layoutRef = React94.useRef(null,);
  const providedWindow = useProvidedWindow();
  useMeasureLayout(props, layoutRef,);
  return /* @__PURE__ */ React94.createElement(
    SVGComponent,
    {
      ...props,
      innerRef: layoutRef,
      parentSize,
      layoutId,
      providedWindow,
    },
  );
}
var MAX_BACKGROUND_SVG_TEXT_LENGTH = 5e4;
function containsImageReference(svg,) {
  return svg.indexOf('image',) >= 0;
}
function containsCustomPropertyReference(svg,) {
  return svg.indexOf('var(--',) >= 0;
}
function hasBorderRadius(style,) {
  return !!(style.borderRadius || style.borderBottomLeftRadius || style.borderBottomRightRadius || style.borderTopLeftRadius ||
    style.borderTopRightRadius);
}
function sizeSVG(container, props,) {
  var _a, _b, _c;
  const div = container.current;
  if (!div) {
    return;
  }
  const localWindow = (_a = props.providedWindow) != null ? _a : safeWindow;
  const svg = div.firstElementChild;
  if (!svg || !(svg instanceof localWindow.SVGSVGElement)) {
    return;
  }
  if (!svg.getAttribute('viewBox',)) {
    const viewBox = sharedSVGManager.getViewBox(props.svg,);
    if (viewBox) {
      svg.setAttribute('viewBox', viewBox,);
    }
  }
  const { withExternalLayout, parentSize, } = props;
  const canUseCalculatedOnCanvasSize = !withExternalLayout && constraintsEnabled(props,) && parentSize !== 1 && parentSize !== 2;
  if (canUseCalculatedOnCanvasSize) {
    return;
  }
  const { intrinsicWidth, intrinsicHeight, _constraints, } = props;
  if (
    ((_b = svg.viewBox.baseVal) == null ? void 0 : _b.width) === 0 && ((_c = svg.viewBox.baseVal) == null ? void 0 : _c.height) === 0 &&
    isFiniteNumber(intrinsicWidth,) && isFiniteNumber(intrinsicHeight,)
  ) {
    svg.setAttribute('viewBox', `0 0 ${intrinsicWidth} ${intrinsicHeight}`,);
  }
  if (_constraints && _constraints.aspectRatio) {
    svg.setAttribute('preserveAspectRatio', '',);
  } else {
    svg.setAttribute('preserveAspectRatio', 'none',);
  }
  svg.setAttribute('width', '100%',);
  svg.setAttribute('height', '100%',);
}
function SVGStyleSheet() {
  React94.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  return null;
}
var SVGComponent = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    constructor() {
      super(...arguments,);
      __publicField(this, 'container', React94.createRef(),);
      __publicField(this, 'svgElement', null,);
      __publicField(this, 'setSVGElement', (element,) => {
        this.svgElement = element;
        this.setLayerElement(element,);
      },);
      __publicField(this, 'previouslyRenderedSVG', '',);
      __publicField(this, 'unmountedSVG', '',);
    }
    static frame(props,) {
      return calculateRect(
        props,
        props.parentSize || 0,
        /* Unknown */
      );
    }
    get frame() {
      return calculateRect(
        this.props,
        this.props.parentSize || 0,
        /* Unknown */
      );
    }
    componentDidMount() {
      if (this.unmountedSVG) {
        const { svgContentId, } = this.props;
        const contentid = svgContentId ? 'svg' + svgContentId : null;
        sharedSVGManager.subscribe(this.unmountedSVG, !svgContentId, contentid,);
        this.previouslyRenderedSVG = this.unmountedSVG;
      }
      if (this.props.svgContentId) {
        return;
      }
      sizeSVG(this.container, this.props,);
    }
    componentWillUnmount() {
      sharedSVGManager.unsubscribe(this.previouslyRenderedSVG,);
      this.unmountedSVG = this.previouslyRenderedSVG;
      this.previouslyRenderedSVG = '';
    }
    componentDidUpdate(prevProps,) {
      super.componentDidUpdate(prevProps,);
      if (this.props.svgContentId) {
        return;
      }
      const { fill, } = this.props;
      if (BackgroundImage.isImageObject(fill,) && BackgroundImage.isImageObject(prevProps.fill,) && fill.src !== prevProps.fill.src) {
        resetSetStyle(this.svgElement, 'fill', null, false,);
      }
      sizeSVG(this.container, this.props,);
    }
    collectLayout(style, innerStyle,) {
      if (this.props.withExternalLayout) {
        innerStyle.width = '100%';
        innerStyle.height = '100%';
        innerStyle.aspectRatio = 'inherit';
        return;
      }
      const frame2 = this.frame;
      const { rotation, intrinsicWidth, intrinsicHeight, width, height, } = this.props;
      const rotate = Animatable.getNumber(rotation,);
      style.opacity = isFiniteNumber(this.props.opacity,) ? this.props.opacity : 1;
      if (RenderTarget.hasRestrictions() && frame2) {
        Object.assign(style, {
          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4,)}deg)`,
          width: `${frame2.width}px`,
          height: `${frame2.height}px`,
        },);
        if (constraintsEnabled(this.props,)) {
          style.position = 'absolute';
        }
        const xFactor = frame2.width / (intrinsicWidth || 1);
        const yFactor = frame2.height / (intrinsicHeight || 1);
        innerStyle.transformOrigin = 'top left';
        const { zoom, target, } = RenderEnvironment;
        if (target === 'EXPORT') {
          const zoomFactor = zoom > 1 ? zoom : 1;
          innerStyle.transform = `scale(${xFactor * zoomFactor}, ${yFactor * zoomFactor})`;
          innerStyle.zoom = 1 / zoomFactor;
        } else {
          innerStyle.transform = `scale(${xFactor}, ${yFactor})`;
        }
        if (intrinsicWidth && intrinsicHeight) {
          innerStyle.width = intrinsicWidth;
          innerStyle.height = intrinsicHeight;
        }
      } else {
        const { left, right, top, bottom, } = this.props;
        Object.assign(style, {
          left,
          right,
          top,
          bottom,
          width,
          height,
          rotate,
        },);
        Object.assign(innerStyle, {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          position: 'absolute',
        },);
      }
    }
    render() {
      var _a2;
      countNodeRender();
      const {
        id: id3,
        visible,
        style,
        fill,
        svg,
        intrinsicHeight,
        intrinsicWidth,
        title,
        description,
        layoutId,
        className,
        variants,
        withExternalLayout,
        innerRef,
        svgContentId,
        height,
        opacity,
        width,
        ...rest
      } = this.props;
      if (!withExternalLayout && (!visible || !id3)) {
        return null;
      }
      const identifier = (_a2 = id3 != null ? id3 : layoutId) != null ? _a2 : 'svg';
      const frame2 = this.frame;
      const size2 = frame2 || { width: intrinsicWidth || 100, height: intrinsicHeight || 100, };
      const outerStyle = { ...style, imageRendering: 'pixelated', flexShrink: 0, };
      const innerStyle = {};
      this.collectLayout(outerStyle, innerStyle,);
      collectOpacityFromProps(this.props, outerStyle,);
      collectFiltersFromProps(this.props, outerStyle,);
      Layer.applyWillChange(this.props, outerStyle, false,);
      let fillElement = null;
      if (typeof fill === 'string' || Color.isColorObject(fill,)) {
        const fillColor = Color.isColorObject(fill,) ? fill.initialValue || Color.toRgbString(fill,) : fill;
        outerStyle.fill = fillColor;
        outerStyle.color = fillColor;
      } else if (LinearGradient.isLinearGradient(fill,)) {
        const gradient = fill;
        const gradientId = `${encodeURI(id3 || '',)}g${LinearGradient.hash(gradient,)}`;
        outerStyle.fill = `url(#${gradientId})`;
        const { stops, x1, x2, y1, y2, } = elementPropertiesForLinearGradient(gradient, identifier,);
        fillElement = /* @__PURE__ */ React94.createElement(
          'svg',
          {
            ref: this.setSVGElement,
            xmlns: 'http://www.w3.org/2000/svg',
            width: '100%',
            height: '100%',
            style: { position: 'absolute', },
          },
          /* @__PURE__ */ React94.createElement(
            'linearGradient',
            { id: gradientId, x1, x2, y1, y2, },
            stops.map((stop, idx,) => {
              return /* @__PURE__ */ React94.createElement(
                'stop',
                {
                  key: idx,
                  offset: stop.position,
                  stopColor: stop.color,
                  stopOpacity: stop.alpha,
                },
              );
            },),
          ),
        );
      } else if (RadialGradient.isRadialGradient(fill,)) {
        const gradient = fill;
        const gradientId = `${encodeURI(id3 || '',)}g${RadialGradient.hash(gradient,)}`;
        outerStyle.fill = `url(#${gradientId})`;
        const elementProperties = elementPropertiesForRadialGradient(gradient, identifier,);
        fillElement = /* @__PURE__ */ React94.createElement(
          'svg',
          {
            ref: this.setSVGElement,
            xmlns: 'http://www.w3.org/2000/svg',
            width: '100%',
            height: '100%',
            style: { position: 'absolute', },
          },
          /* @__PURE__ */ React94.createElement(
            'radialGradient',
            {
              id: gradientId,
              cy: gradient.centerAnchorY,
              cx: gradient.centerAnchorX,
              r: gradient.widthFactor,
            },
            elementProperties.stops.map((stop, idx,) => {
              return /* @__PURE__ */ React94.createElement(
                'stop',
                {
                  key: idx,
                  offset: stop.position,
                  stopColor: stop.color,
                  stopOpacity: stop.alpha,
                },
              );
            },),
          ),
        );
      } else if (BackgroundImage.isImageObject(fill,)) {
        const imagePattern = imagePatternPropsForFill(fill, size2, identifier,);
        if (imagePattern) {
          outerStyle.fill = `url(#${imagePattern.id})`;
          fillElement = /* @__PURE__ */ React94.createElement(
            'svg',
            {
              ref: this.setSVGElement,
              xmlns: 'http://www.w3.org/2000/svg',
              xmlnsXlink: 'http://www.w3.org/1999/xlink',
              width: '100%',
              height: '100%',
              style: { position: 'absolute', },
            },
            /* @__PURE__ */ React94.createElement(
              'defs',
              null,
              /* @__PURE__ */ React94.createElement(ImagePatternElement, { ...imagePattern, },),
            ),
          );
        }
      }
      const dataProps = {
        'data-framer-component-type': 'SVG',
      };
      const hasTransformTemplate = !frame2;
      if (hasTransformTemplate) {
        Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center,),);
      }
      const svgAsBackgroundImage = !fillElement && !outerStyle.fill && !outerStyle.background && !outerStyle.backgroundImage &&
        svg.length < MAX_BACKGROUND_SVG_TEXT_LENGTH && !containsImageReference(svg,) && !containsCustomPropertyReference(svg,);
      let content = null;
      if (svgAsBackgroundImage) {
        outerStyle.backgroundSize = '100% 100%';
        outerStyle.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svg,)}')`;
        sharedSVGManager.unsubscribe(this.previouslyRenderedSVG,);
        this.previouslyRenderedSVG = '';
      } else {
        const contentid = svgContentId ? 'svg' + svgContentId : null;
        const __html = sharedSVGManager.subscribe(svg, !svgContentId, contentid,);
        sharedSVGManager.unsubscribe(this.previouslyRenderedSVG,);
        this.previouslyRenderedSVG = svg;
        if (hasBorderRadius(outerStyle,)) {
          outerStyle.overflow = 'hidden';
        }
        content = /* @__PURE__ */ React94.createElement(
          React94.Fragment,
          null,
          fillElement,
          /* @__PURE__ */ React94.createElement(
            'div',
            {
              key: BackgroundImage.isImageObject(fill,) ? fill.src : '',
              className: 'svgContainer',
              style: innerStyle,
              ref: this.container,
              dangerouslySetInnerHTML: { __html, },
            },
          ),
        );
      }
      const MotionComponent = htmlElementAsMotionComponent(this.props.as,);
      const { href, target, rel, onClick, } = this.props;
      return /* @__PURE__ */ React94.createElement(
        MotionComponent,
        {
          ...dataProps,
          ...rest,
          layoutId,
          transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center,) : void 0,
          id: id3,
          ref: innerRef,
          style: outerStyle,
          className,
          variants,
          tabIndex: this.props.tabIndex,
          role: title || description ? 'img' : void 0,
          'aria-label': title,
          'aria-description': description,
          ...{ href, target, rel, onClick, },
        },
        content,
        /* @__PURE__ */ React94.createElement(SVGStyleSheet, null,),
      );
    }
  },
    __publicField(_a, 'supportsConstraints', true,),
    __publicField(_a, 'defaultSVGProps', {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0,
      style: void 0,
      _constraints: {
        enabled: true,
        aspectRatio: null,
      },
      parentSize: 0,
      rotation: 0,
      visible: true,
      svg: '',
      shadows: [],
    },),
    __publicField(_a, 'defaultProps', {
      ...Layer.defaultProps,
      ..._a.defaultSVGProps,
    },),
    _a;
})();
var htmlRegExp = /[&<>'"]/g;
var escapeHTML = (str,) =>
  str.replace(
    htmlRegExp,
    (tag,) =>
      ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '\'': '&#39;',
        '"': '&quot;',
      })[tag] || tag,
  );
var regex =
  /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
function replaceFramerPageLinks(rawHTML, getRoute, currentRoute, implicitPathVariables,) {
  return rawHTML.replace(
    regex,
    (original, pre1, tag, pre2, value1, value2, post,) => {
      var _a, _b, _c;
      if (tag.toLowerCase() !== 'a') {
        return original;
      }
      const href = value1 || value2;
      const pageLink = parseFramerPageLink(href.replace(/&amp;/g, '&',),);
      if (!pageLink || !pageLink.target) {
        return original;
      }
      const targetRoute = getRoute(pageLink.target,);
      if (!isRoute(targetRoute,) || !isRoute(currentRoute,)) {
        return original;
      }
      const targetPath = targetRoute.path;
      const currentPath = currentRoute.path;
      if (!targetPath || !currentPath) {
        return original;
      }
      let attributes = ` ${'data-framer-page-link-target'}="${pageLink.target}"`;
      const elementId = getRouteElementId(targetRoute, (_a = pageLink.element) != null ? _a : void 0,);
      if (elementId) {
        attributes += ` ${'data-framer-page-link-element'}="${pageLink.element}"`;
      }
      const link = linkFromFramerPageLink(href,);
      if (!link || isString22(link,)) {
        return original;
      }
      if (linkMatchesRoute(currentRoute, link, implicitPathVariables,)) {
        attributes += ` ${'data-framer-page-link-current'}`;
      }
      let relativePath = targetPath;
      const pathVariables = Object.assign({}, implicitPathVariables, (_b = pageLink.collectionItem) == null ? void 0 : _b.pathVariables,);
      if (Object.keys(pathVariables,).length > 0) {
        relativePath = relativePath.replace(pathVariablesRegExp2, (_, key7,) => '' + pathVariables[key7],);
      }
      if ((_c = pageLink.collectionItem) == null ? void 0 : _c.pathVariables) {
        const params = new URLSearchParams(pageLink.collectionItem.pathVariables,);
        attributes += ` ${'data-framer-page-link-path-variables'}="${params}"`;
      }
      relativePath = computeRelativePath(currentPath, relativePath,);
      return pre1 + pre2 + `"${escapeHTML(relativePath + (elementId ? `#${elementId}` : ''),)}"` + attributes + post;
    },
  );
}
var import_process4 = __toESM(require_browser(), 1,);
var FontSourceNames = /* @__PURE__ */ ((FontSourceNames2,) => {
  FontSourceNames2['Google'] = 'google';
  FontSourceNames2['Fontshare'] = 'fontshare';
  FontSourceNames2['Framer'] = 'framer';
  FontSourceNames2['Local'] = 'local';
  FontSourceNames2['Custom'] = 'custom';
  return FontSourceNames2;
})(FontSourceNames || {},);
var customFontSelectorPrefix = 'CUSTOM;';
function getCustomFontName(fileName, properties,) {
  if (!properties) {
    return fileName.substring(0, fileName.lastIndexOf('.',),);
  }
  const fontFamily = properties.font.preferredFamily === '' ? properties.font.fontFamily : properties.font.preferredFamily;
  const variant = properties.font.preferredSubFamily === '' ? properties.font.fontSubFamily : properties.font.preferredSubFamily;
  return `${fontFamily} ${variant}`;
}
var CustomFontSource = class {
  constructor() {
    __publicField(
      this,
      'name',
      'custom',
      /* Custom */
    );
    __publicField(this, 'fontFamilies', [],);
    __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
    __publicField(this, 'assetsByFamily', /* @__PURE__ */ new Map(),);
  }
  importFonts(assets,) {
    var _a;
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    this.assetsByFamily.clear();
    const fonts = [];
    for (const asset of assets) {
      if (!this.isValidCustomFontAsset(asset,)) {
        continue;
      }
      const fontName = getCustomFontName(asset.name, asset.properties,);
      const fontFamily = this.createFontFamily(fontName,);
      const font = {
        family: fontFamily,
        selector: `${customFontSelectorPrefix}${fontName}`,
        variant: this.inferVariantName(fontName,),
        postscriptName: (_a = asset.properties) == null ? void 0 : _a.font.postscriptName,
        file: asset.url,
      };
      fontFamily.fonts.push(font,);
      fontFamily.owner = asset.ownerType === 'team' ? 'team' : 'project';
      this.assetsByFamily.set(fontName, asset,);
      fonts.push(...fontFamily.fonts,);
    }
    return fonts;
  }
  isValidCustomFontAsset(asset,) {
    var _a;
    if (!asset.mimeType.startsWith('font/',)) {
      return false;
    }
    if (((_a = asset.properties) == null ? void 0 : _a.kind) !== 'font') {
      return false;
    }
    if (!asset.properties.font) {
      return false;
    }
    return 'fontFamily' in asset.properties.font;
  }
  inferVariantName(family,) {
    const possibleValues = [
      'thin',
      'ultra light',
      'extra light',
      'light',
      'normal',
      'medium',
      'semi bold',
      'bold',
      'extra bold',
      'black',
    ];
    const possibleValuesWithItalics = [...possibleValues.map((value,) => `${value} italic`), ...possibleValues,];
    const lowerCaseFamily = family.toLowerCase();
    const tokens = [...lowerCaseFamily.split(' ',), ...lowerCaseFamily.split('-',), ...lowerCaseFamily.split('_',),];
    const foundToken = possibleValuesWithItalics.find(
      (value,) => tokens.includes(value,) || tokens.includes(value.replace(/\s+/g, '',),),
    );
    if (foundToken) {
      return foundToken.replace(/^\w|\s\w/g, (char,) => char.toUpperCase(),);
    }
    return 'Regular';
  }
  createFontFamily(family,) {
    const existingFontFamily = this.byFamilyName.get(family,);
    if (existingFontFamily) {
      return existingFontFamily;
    }
    const fontFamily = {
      source: this.name,
      name: family,
      fonts: [],
    };
    this.addFontFamily(fontFamily,);
    return fontFamily;
  }
  addFontFamily(fontFamily,) {
    this.fontFamilies.push(fontFamily,);
    this.byFamilyName.set(fontFamily.name, fontFamily,);
  }
  parseSelector(selector,) {
    if (!selector.startsWith(customFontSelectorPrefix,)) {
      return null;
    }
    const tokens = selector.split(customFontSelectorPrefix,);
    if (tokens[1] === void 0) {
      return null;
    }
    const locator = { source: 'custom', name: tokens[1], };
    return locator;
  }
  getFontBySelector(selector, createFont = true,) {
    const locator = this.parseSelector(selector,);
    if (!locator) {
      return;
    }
    if (!createFont && !this.byFamilyName.get(locator.name,)) {
      return;
    }
    const fonts = this.getFontFamilyByName(locator.name,).fonts;
    const woff2Font = fonts.find((font,) => {
      var _a;
      return (_a = font.file) == null ? void 0 : _a.endsWith('.woff2',);
    },);
    return woff2Font || fonts[0];
  }
  getFontFamilyByName(family,) {
    const foundFontFamily = this.byFamilyName.get(family,);
    if (foundFontFamily) {
      return foundFontFamily;
    }
    const fontFamily = {
      source: 'custom',
      name: family,
      fonts: [],
    };
    fontFamily.fonts.push({
      selector: `${customFontSelectorPrefix}${family}`,
      variant: this.inferVariantName(family,),
      family: fontFamily,
    },);
    return fontFamily;
  }
};
function getFontVariants(currentVariant, variants, parseVariant,) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  if (variants.length === 0) {
    return {};
  }
  const currentVariantInfo = parseVariant(currentVariant,);
  if (!currentVariantInfo) {
    return {};
  }
  const { weight: currentWeight, style: currentStyle, } = currentVariantInfo;
  const variantByWeightAndStyle = /* @__PURE__ */ new Map();
  const boldVariantByStyle = /* @__PURE__ */ new Map();
  variants.forEach((variant,) => {
    const variantName = isString22(variant,) ? variant : variant.name.toLocaleLowerCase();
    const variantInfo = parseVariant(variantName,);
    if (!variantInfo) {
      return;
    }
    variantByWeightAndStyle.set(`${variantInfo.weight}-${variantInfo.style}`, variantName,);
    if (variantInfo.weight <= currentWeight) {
      return;
    }
    if (!boldVariantByStyle.has(variantInfo.style,)) {
      boldVariantByStyle.set(variantInfo.style, variantName,);
    }
  },);
  let variantBold = boldVariantByStyle.get(currentStyle,);
  let variantBoldItalic = (_a = boldVariantByStyle.get('italic',)) != null ? _a : boldVariantByStyle.get('oblique',);
  if (currentVariantInfo.weight <= 300) {
    variantBold = (_b = variantByWeightAndStyle.get(`400-${currentStyle}`,)) != null ? _b : variantBold;
    variantBoldItalic =
      (_d = (_c = variantByWeightAndStyle.get('400-italic',)) != null ? _c : variantByWeightAndStyle.get('400-oblique',)) != null
        ? _d
        : variantBoldItalic;
  } else if (currentVariantInfo.weight <= 500) {
    variantBold = (_e = variantByWeightAndStyle.get(`700-${currentStyle}`,)) != null ? _e : variantBold;
    variantBoldItalic =
      (_g = (_f = variantByWeightAndStyle.get('700-italic',)) != null ? _f : variantByWeightAndStyle.get('700-oblique',)) != null
        ? _g
        : variantBoldItalic;
  } else {
    variantBold = (_h = variantByWeightAndStyle.get(`900-${currentStyle}`,)) != null ? _h : variantBold;
    variantBoldItalic =
      (_j = (_i = variantByWeightAndStyle.get('900-italic',)) != null ? _i : variantByWeightAndStyle.get('900-oblique',)) != null
        ? _j
        : variantBoldItalic;
  }
  const variantItalic = (_k = variantByWeightAndStyle.get(`${currentWeight}-italic`,)) != null
    ? _k
    : variantByWeightAndStyle.get(`${currentWeight}-oblique`,);
  return { variantBold, variantItalic, variantBoldItalic, };
}
var knownFontshareCategories = ['display', 'sans', 'serif', 'slab', 'handwritten', 'script',];
function parseFontshareCategories(categoriesField,) {
  return categoriesField.split(',',).map((category,) => category.trim().toLowerCase()).filter(isKnownFontshareCategory,);
}
function isKnownFontshareCategory(category,) {
  return knownFontshareCategories.includes(category,);
}
var fontsharePrefix = 'FS;';
var weightNameToNumber = {
  thin: 100,
  hairline: 100,
  // Alternative name for "thin".
  extralight: 200,
  light: 300,
  regular: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  extrabold: 800,
  ultra: 800,
  // Alternative name for "extrabold".
  black: 900,
  heavy: 900,
  // Alternative name for "black".
};
var weightNames = Object.keys(weightNameToNumber,);
var allowedVariantsRegex = new RegExp(`^(?:${[...weightNames, 'italic',].join('|',)})`, 'u',);
var FontshareSource = class {
  constructor() {
    __publicField(
      this,
      'name',
      'fontshare',
      /* Fontshare */
    );
    __publicField(this, 'fontFamilies', [],);
    __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
  }
  getFontFamilyByName(family,) {
    var _a;
    return (_a = this.byFamilyName.get(family,)) != null ? _a : null;
  }
  /**
   * Parses variant a string into a weight number and style, defaulting to a
   * weight of `400` and/or a style of `"normal"` depending on what isn't
   * present in the variant string.
   *
   * E.g:
   *   - `"bold"` becomes `{ weight: 700, style: "normal" }`
   *   - `"bold italic"` becomes `{ weight: 700, style: "italic" }`
   *   - `"italic"` becomes `{ weight: 400, style: "italic" }`
   */
  static parseVariant(variant,) {
    const variantSplit = variant.split(' ',);
    const weightName = weightNames.find((weightName2,) => {
      return variantSplit.includes(weightName2,);
    },);
    const styleName = variant.includes('italic',) ? 'italic' : 'normal';
    const weight = weightName && weightNameToNumber[weightName] || 400;
    const style = styleName === 'italic' ? styleName : 'normal';
    return {
      weight,
      style,
    };
  }
  parseSelector(selector,) {
    if (!selector.startsWith(fontsharePrefix,)) {
      return null;
    }
    const tokens = selector.split('-',);
    if (tokens.length !== 2) {
      return null;
    }
    const [family, variant,] = tokens;
    if (!family || !variant) {
      return null;
    }
    return { name: family.replace(fontsharePrefix, '',), variant, source: this.name, };
  }
  static createSelector(family, variant,) {
    return `${fontsharePrefix}${family}-${variant}`;
  }
  addFontFamily(fontFamily,) {
    this.fontFamilies.push(fontFamily,);
    this.byFamilyName.set(fontFamily.name, fontFamily,);
  }
  importFonts(fontshareFonts,) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fonts = [];
    for (const fontshareFont of fontshareFonts) {
      const fontStyles = fontshareFont.font_styles.filter((fontStyle,) => {
        const variant = fontStyle.name.toLowerCase();
        const allowedVariantMatch = allowedVariantsRegex.exec(variant,);
        if (!allowedVariantMatch || variant.endsWith('wide',)) {
          return false;
        }
        return true;
      },);
      for (const fontStyle of fontStyles) {
        const { name: family, } = fontshareFont;
        const variant = fontStyle.name.toLowerCase();
        let fontFamily = this.getFontFamilyByName(family,);
        if (!fontFamily) {
          fontFamily = { name: family, fonts: [], source: this.name, };
          this.addFontFamily(fontFamily,);
        }
        const selector = FontshareSource.createSelector(family, variant,);
        const variantInfo = FontshareSource.parseVariant(variant,) || {
          weight: void 0,
          style: void 0,
        };
        const { weight, style, } = variantInfo;
        const { variantBold, variantBoldItalic, variantItalic, } = getFontVariants(
          variant,
          fontStyles,
          FontshareSource.parseVariant,
        );
        const font = {
          family: fontFamily,
          variant,
          selector,
          selectorBold: variantBold ? FontshareSource.createSelector(family, variantBold,) : void 0,
          selectorBoldItalic: variantBoldItalic ? FontshareSource.createSelector(family, variantBoldItalic,) : void 0,
          selectorItalic: variantItalic ? FontshareSource.createSelector(family, variantItalic,) : void 0,
          weight,
          style,
          file: fontStyle.file,
          category: mapToKnownCategory(fontshareFont.category,),
        };
        fontFamily.fonts.push(font,);
        fonts.push(font,);
      }
    }
    return fonts;
  }
};
function mapToKnownCategory(categoryString,) {
  const categoryMapping = {
    serif: 'serif',
    sans: 'sans-serif',
    slab: 'slab',
    display: 'display',
    // As of Nov 2023, these two look similar enough – so we can map them into the same category.
    handwritten: 'handwriting',
    script: 'handwriting',
  };
  const category = parseFontshareCategories(categoryString,)[0];
  return category && categoryMapping[category];
}
var framerFontPrefix = 'Inter';
var weightNameToNumber2 = {
  Thin: 100,
  ExtraLight: 200,
  Light: 300,
  '': 400,
  // Regular weights have a selector like "Inter" or "Inter-Italic", with no mention of weight.
  Medium: 500,
  SemiBold: 600,
  Bold: 700,
  ExtraBold: 800,
  Black: 900,
};
var FramerFontSource = class {
  constructor() {
    __publicField(
      this,
      'name',
      'framer',
      /* Framer */
    );
    __publicField(this, 'fontFamilies', [],);
    __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
  }
  getFontFamilyByName(family,) {
    var _a;
    return (_a = this.byFamilyName.get(family,)) != null ? _a : null;
  }
  addFontFamily(familyName,) {
    const fontFamily = { name: familyName, fonts: [], source: this.name, };
    this.fontFamilies.push(fontFamily,);
    this.byFamilyName.set(fontFamily.name, fontFamily,);
    return fontFamily;
  }
  static getDraftFontPropertiesBySelector(selector,) {
    if (!selector.startsWith(framerFontPrefix,)) {
      return null;
    }
    const tokens = selector.split('-',);
    const [family, weightAndStyleInfo = '',] = tokens;
    if (!family) {
      return null;
    }
    const style = weightAndStyleInfo.includes('Italic',) ? 'italic' : 'normal';
    const weightName = weightAndStyleInfo.replace('Italic', '',);
    const weight = weightName && weightNameToNumber2[weightName] || 400;
    return {
      family,
      style,
      weight,
      source: 'framer',
      variant: void 0,
      category: 'sans-serif',
    };
  }
  importFonts(framerFonts,) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fonts = [];
    framerFonts.forEach((framerFont,) => {
      const { familyName, ...rest } = framerFont;
      let fontFamily = this.getFontFamilyByName(familyName,);
      if (!fontFamily) {
        fontFamily = this.addFontFamily(familyName,);
      }
      const font = {
        ...rest,
        family: fontFamily,
      };
      fontFamily.fonts.push(font,);
      fonts.push(font,);
    },);
    return fonts;
  }
};
var googleFontSelectorPrefix = 'GF;';
var GoogleFontSource = class {
  constructor() {
    __publicField(
      this,
      'name',
      'google',
      /* Google */
    );
    __publicField(this, 'fontFamilies', [],);
    __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
  }
  getFontFamilyByName(family,) {
    var _a;
    return (_a = this.byFamilyName.get(family,)) != null ? _a : null;
  }
  static parseVariant(variant,) {
    if (variant === 'regular') {
      return { style: 'normal', weight: 400, };
    }
    const match = /(\d*)(normal|italic)?/.exec(variant,);
    if (!match) {
      return null;
    }
    const weight = parseInt(match[1] || '400',);
    const style = match[2] === 'italic' ? 'italic' : 'normal';
    return { weight, style, };
  }
  parseSelector(selector,) {
    if (!selector.startsWith(googleFontSelectorPrefix,)) {
      return null;
    }
    const tokens = selector.split('-',);
    if (tokens.length !== 2) {
      return null;
    }
    const [family, variant,] = tokens;
    if (!family || !variant) {
      return null;
    }
    return { name: family.replace(googleFontSelectorPrefix, '',), variant, source: this.name, };
  }
  static createSelector(family, variant,) {
    return `${googleFontSelectorPrefix}${family}-${variant}`;
  }
  addFontFamily(family,) {
    const fontFamily = { name: family, fonts: [], source: this.name, };
    this.fontFamilies.push(fontFamily,);
    this.byFamilyName.set(fontFamily.name, fontFamily,);
    return fontFamily;
  }
  importFonts(webFonts,) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fonts = [];
    webFonts.forEach((webFont,) => {
      webFont.variants.forEach((variant,) => {
        var _a, _b;
        const family = webFont.family;
        let fontFamily = this.getFontFamilyByName(family,);
        if (!fontFamily) {
          fontFamily = this.addFontFamily(family,);
        }
        const variantInfo = (_a = GoogleFontSource.parseVariant(variant,)) != null ? _a : {};
        const { weight, style, } = variantInfo;
        const selector = GoogleFontSource.createSelector(family, variant,);
        const { variantBold, variantItalic, variantBoldItalic, } = getFontVariants(
          variant,
          webFont.variants,
          GoogleFontSource.parseVariant,
        );
        const font = {
          family: fontFamily,
          variant,
          selector,
          selectorBold: variantBold ? GoogleFontSource.createSelector(family, variantBold,) : void 0,
          selectorBoldItalic: variantBoldItalic ? GoogleFontSource.createSelector(family, variantBoldItalic,) : void 0,
          selectorItalic: variantItalic ? GoogleFontSource.createSelector(family, variantItalic,) : void 0,
          weight,
          style,
          category: mapToKnownCategory2(webFont.category,),
          file: (_b = webFont.files[variant]) == null ? void 0 : _b.replace('http://', 'https://',),
        };
        fontFamily.fonts.push(font,);
        fonts.push(font,);
      },);
    },);
    return fonts;
  }
};
function mapToKnownCategory2(category,) {
  const categoryMapping = {
    serif: 'serif',
    'sans-serif': 'sans-serif',
    display: 'display',
    handwriting: 'handwriting',
    monospace: 'monospace',
  };
  if (!category) {
    return void 0;
  }
  return categoryMapping[category];
}
var import_fontfaceobserver = __toESM(require_fontfaceobserver_standalone(), 1,);
var FONT_LOADING_TIMEOUT = 5e3;
var MAX_RETRIES = 3;
var FontLoadingError = class extends Error {
  constructor(message,) {
    super(message,);
    this.name = 'FontLoadingError';
  }
};
var fontRequests = /* @__PURE__ */ new Map();
var fontReadyPromises = /* @__PURE__ */ new Map();
var loadFont = (data2, doc,) => loadFontWithRetries(data2, doc,);
async function loadFontWithRetries(data2, doc, attempt = 0,) {
  const { family, url, stretch, unicodeRange, } = data2;
  const weight = data2.weight || 500;
  const style = data2.style || 'normal';
  const requestId = `${family}-${style}-${weight}-${url}`;
  if (!fontRequests.has(requestId,) || attempt > 0) {
    const fontFace = new FontFace(family, `url(${url})`, {
      weight: isString22(weight,) ? weight : weight == null ? void 0 : weight.toString(),
      style,
      stretch,
      unicodeRange,
    },);
    const readyPromise = fontFace.load().then(() => {
      doc.fonts.add(fontFace,);
      return isFontReady(family, style, weight,);
    },).catch((e,) => {
      if (e.name !== 'NetworkError') {
        throw e;
      }
      if (attempt < MAX_RETRIES) {
        return loadFontWithRetries(data2, doc, attempt + 1,);
      }
      throw new FontLoadingError(
        `Font loading failed after ${attempt} retries due to network error: ${
          JSON.stringify({
            family,
            style,
            weight,
            url,
            stretch,
            unicodeRange,
          },)
        }`,
      );
    },);
    fontRequests.set(requestId, readyPromise,);
  }
  await fontRequests.get(requestId,);
}
async function isFontReady(family, style, weight,) {
  const readyPromiseId = `${family}-${style}-${weight}`;
  if (!fontReadyPromises.has(readyPromiseId,)) {
    const observer2 = new import_fontfaceobserver.default(family, {
      style,
      weight,
    },);
    const readyPromise = observer2.load(null, FONT_LOADING_TIMEOUT,);
    fontReadyPromises.set(readyPromiseId, readyPromise,);
  }
  try {
    await fontReadyPromises.get(readyPromiseId,);
  } catch (e) {
    throw new FontLoadingError(
      `Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${
        JSON.stringify({
          family,
          style,
          weight,
        },)
      }`,
    );
  }
}
var safeFonts = {
  Arial: {
    Regular: { selector: 'Arial', weight: void 0, },
    Black: { selector: 'Arial-Black', weight: void 0, },
    Narrow: { selector: 'Arial Narrow', weight: void 0, },
    'Rounded Bold': { selector: 'Arial Rounded MT Bold', weight: void 0, },
  },
  Avenir: {
    Book: { selector: 'Avenir', weight: void 0, },
    Light: { selector: 'Avenir-Light', weight: void 0, },
    Medium: { selector: 'Avenir-Medium', weight: void 0, },
    Heavy: { selector: 'Avenir-Heavy', weight: void 0, },
    Black: { selector: 'Avenir-Black', weight: void 0, },
  },
  'Avenir Next': {
    Regular: { selector: 'Avenir Next', weight: void 0, },
    'Ultra Light': { selector: 'AvenirNext-UltraLight', weight: void 0, },
    Medium: { selector: 'AvenirNext-Medium', weight: void 0, },
    'Demi Bold': { selector: 'AvenirNext-DemiBold', weight: void 0, },
    Heavy: { selector: 'AvenirNext-Heavy', weight: void 0, },
  },
  'Avenir Next Condensed': {
    Regular: { selector: 'Avenir Next Condensed', weight: void 0, },
    'Ultra Light': { selector: 'AvenirNextCondensed-UltraLight', weight: void 0, },
    Medium: { selector: 'AvenirNextCondensed-Medium', weight: void 0, },
    'Demi Bold': { selector: 'AvenirNextCondensed-DemiBold', weight: void 0, },
    Heavy: { selector: 'AvenirNextCondensed-Heavy', weight: void 0, },
  },
  Baskerville: {
    Regular: { selector: 'Baskerville', weight: void 0, },
    'Semi Bold': { selector: 'Baskerville-SemiBold', weight: void 0, },
  },
  'Bodoni 72': {
    Book: { selector: 'Bodoni 72', weight: void 0, },
    Oldstyle: { selector: 'Bodoni 72 Oldstyle', weight: void 0, },
    Smallcaps: { selector: 'Bodoni 72 Smallcaps', weight: void 0, },
  },
  Courier: { Regular: { selector: 'Courier', weight: void 0, }, },
  'Courier New': { Regular: { selector: 'Courier New', weight: void 0, }, },
  Futura: {
    Medium: { selector: 'Futura', weight: void 0, },
    Condensed: { selector: 'Futura-CondensedMedium', weight: void 0, },
    'Condensed ExtraBold': { selector: 'Futura-CondensedExtraBold', weight: void 0, },
  },
  Georgia: { Regular: { selector: 'Georgia', weight: void 0, }, },
  'Gill Sans': {
    Regular: { selector: 'Gill Sans', weight: void 0, },
    Light: { selector: 'GillSans-Light', weight: void 0, },
    SemiBold: { selector: 'GillSans-SemiBold', weight: void 0, },
    UltraBold: { selector: 'GillSans-UltraBold', weight: void 0, },
  },
  Helvetica: {
    Regular: { selector: 'Helvetica', weight: void 0, },
    Light: { selector: 'Helvetica-Light', weight: void 0, },
    Bold: { selector: 'Helvetica-Bold', weight: void 0, },
    Oblique: { selector: 'Helvetica-Oblique', weight: void 0, },
    'Light Oblique': { selector: 'Helvetica-LightOblique', weight: void 0, },
    'Bold Oblique': { selector: 'Helvetica-BoldOblique', weight: void 0, },
  },
  'Helvetica Neue': {
    Regular: { selector: 'Helvetica Neue', weight: void 0, },
    UltraLight: { selector: 'HelveticaNeue-UltraLight', weight: void 0, },
    Thin: { selector: 'HelveticaNeue-Thin', weight: void 0, },
    Light: { selector: 'HelveticaNeue-Light', weight: void 0, },
    Medium: { selector: 'HelveticaNeue-Medium', weight: void 0, },
    Bold: { selector: 'HelveticaNeue-Bold', weight: void 0, },
    Italic: { selector: 'HelveticaNeue-Italic', weight: void 0, },
    'UltraLight Italic': { selector: 'HelveticaNeue-UltraLightItalic', weight: void 0, },
    'Thin Italic': { selector: 'HelveticaNeue-ThinItalic', weight: void 0, },
    'Light Italic': { selector: 'HelveticaNeue-LightItalic', weight: void 0, },
    'Medium Italic': { selector: 'HelveticaNeue-MediumItalic', weight: void 0, },
    'Bold Italic': { selector: 'HelveticaNeue-BoldItalic', weight: void 0, },
    'Condensed Bold': { selector: 'HelveticaNeue-CondensedBold', weight: void 0, },
    'Condensed Black': { selector: 'HelveticaNeue-CondensedBlack', weight: void 0, },
  },
  'Hoefler Text': { Regular: { selector: 'Hoefler Text', weight: void 0, }, },
  Impact: { Regular: { selector: 'Impact', weight: void 0, }, },
  'Lucida Grande': { Regular: { selector: 'Lucida Grande', weight: void 0, }, },
  Menlo: { Regular: { selector: 'Menlo', weight: void 0, }, },
  Monaco: { Regular: { selector: 'Monaco', weight: void 0, }, },
  Optima: {
    Regular: { selector: 'Optima', weight: void 0, },
    ExtraBlack: { selector: 'Optima-ExtraBlack', weight: void 0, },
  },
  Palatino: { Regular: { selector: 'Palatino', weight: void 0, }, },
  'SF Pro Display': {
    Regular: { selector: '__SF-UI-Display-Regular__', weight: 400, },
    Ultralight: { selector: '__SF-UI-Display-Ultralight__', weight: 100, },
    Thin: { selector: '__SF-UI-Display-Thin__', weight: 200, },
    Light: { selector: '__SF-UI-Display-Light__', weight: 300, },
    Medium: { selector: '__SF-UI-Display-Medium__', weight: 500, },
    Semibold: { selector: '__SF-UI-Display-Semibold__', weight: 600, },
    Bold: { selector: '__SF-UI-Display-Bold__', weight: 700, },
    Heavy: { selector: '__SF-UI-Display-Heavy__', weight: 800, },
    Black: { selector: '__SF-UI-Display-Black__', weight: 900, },
    Italic: { selector: '__SF-UI-Display-Italic__', weight: 400, },
    'Ultralight Italic': { selector: '__SF-UI-Display-Ultralight-Italic__', weight: 100, },
    'Thin Italic': { selector: '__SF-UI-Display-Thin-Italic__', weight: 200, },
    'Light Italic': { selector: '__SF-UI-Display-Light-Italic__', weight: 300, },
    'Medium Italic': { selector: '__SF-UI-Display-Medium-Italic__', weight: 500, },
    'Semibold Italic': { selector: '__SF-UI-Display-Semibold-Italic__', weight: 600, },
    'Bold Italic': { selector: '__SF-UI-Display-Bold-Italic__', weight: 700, },
    'Heavy Italic': { selector: '__SF-UI-Display-Heavy-Italic__', weight: 800, },
    'Black Italic': { selector: '__SF-UI-Display-Black-Italic__', weight: 900, },
  },
  'SF Pro Display Condensed': {
    Regular: { selector: '__SF-UI-Display-Condensed-Regular__', weight: 400, },
    Ultralight: { selector: '__SF-UI-Display-Condensed-Ultralight__', weight: 100, },
    Thin: { selector: '__SF-UI-Display-Condensed-Thin__', weight: 200, },
    Light: { selector: '__SF-UI-Display-Condensed-Light__', weight: 300, },
    Medium: { selector: '__SF-UI-Display-Condensed-Medium__', weight: 500, },
    Semibold: { selector: '__SF-UI-Display-Condensed-Semibold__', weight: 600, },
    Bold: { selector: '__SF-UI-Display-Condensed-Bold__', weight: 700, },
    Heavy: { selector: '__SF-UI-Display-Condensed-Heavy__', weight: 800, },
    Black: { selector: '__SF-UI-Display-Condensed-Black__', weight: 900, },
  },
  'SF Pro Text': {
    Regular: { selector: '__SF-UI-Text-Regular__', weight: 400, },
    Light: { selector: '__SF-UI-Text-Light__', weight: 200, },
    Medium: { selector: '__SF-UI-Text-Medium__', weight: 500, },
    Semibold: { selector: '__SF-UI-Text-Semibold__', weight: 600, },
    Bold: { selector: '__SF-UI-Text-Bold__', weight: 700, },
    Heavy: { selector: '__SF-UI-Text-Heavy__', weight: 800, },
    Italic: { selector: '__SF-UI-Text-Italic__', weight: 400, },
    'Light Italic': { selector: '__SF-UI-Text-Light-Italic__', weight: 200, },
    'Medium Italic': { selector: '__SF-UI-Text-Medium-Italic__', weight: 500, },
    'Semibold Italic': { selector: '__SF-UI-Text-Semibold-Italic__', weight: 600, },
    'Bold Italic': { selector: '__SF-UI-Text-Bold-Italic__', weight: 700, },
    'Heavy Italic': { selector: '__SF-UI-Text-Heavy-Italic__', weight: 800, },
  },
  'SF Pro Text Condensed': {
    Regular: { selector: '__SF-UI-Text-Condensed-Regular__', weight: 400, },
    Light: { selector: '__SF-UI-Text-Condensed-Light__', weight: 200, },
    Medium: { selector: '__SF-UI-Text-Condensed-Medium__', weight: 500, },
    Semibold: { selector: '__SF-UI-Text-Condensed-Semibold__', weight: 600, },
    Bold: { selector: '__SF-UI-Text-Condensed-Bold__', weight: 700, },
    Heavy: { selector: '__SF-UI-Text-Condensed-Heavy__', weight: 800, },
  },
  Tahoma: { Regular: { selector: 'Tahoma', weight: void 0, }, },
  Times: { Regular: { selector: 'Times', weight: void 0, }, },
  'Times New Roman': { Regular: { selector: 'Times New Roman', weight: void 0, }, },
  Trebuchet: { Regular: { selector: 'Trebuchet MS', weight: void 0, }, },
  Verdana: { Regular: { selector: 'Verdana', weight: void 0, }, },
};
var fontAliases = {
  '__SF-Compact-Display-Regular__': 'SFCompactDisplay-Regular|.SFCompactDisplay-Regular',
  '__SF-Compact-Display-Ultralight__': 'SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight',
  '__SF-Compact-Display-Thin__': 'SFCompactDisplay-Thin|.SFCompactDisplay-Thin',
  '__SF-Compact-Display-Light__': 'SFCompactDisplay-Light|.SFCompactDisplay-Light',
  '__SF-Compact-Display-Medium__': 'SFCompactDisplay-Medium|.SFCompactDisplay-Medium',
  '__SF-Compact-Display-Semibold__': 'SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold',
  '__SF-Compact-Display-Heavy__': 'SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy',
  '__SF-Compact-Display-Black__': 'SFCompactDisplay-Black|.SFCompactDisplay-Black',
  '__SF-Compact-Display-Bold__': 'SFCompactDisplay-Bold|.SFCompactDisplay-Bold',
  '__SF-UI-Text-Regular__': '.SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText',
  '__SF-UI-Text-Light__': '.SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light',
  '__SF-UI-Text-Medium__': '.SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium',
  '__SF-UI-Text-Semibold__': '.SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold',
  '__SF-UI-Text-Bold__': '.SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold',
  '__SF-UI-Text-Heavy__': '.SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy',
  '__SF-UI-Text-Italic__': '.SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic',
  '__SF-UI-Text-Light-Italic__': '.SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic',
  '__SF-UI-Text-Medium-Italic__': '.SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic',
  '__SF-UI-Text-Semibold-Italic__': '.SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic',
  '__SF-UI-Text-Bold-Italic__': '.SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic',
  '__SF-UI-Text-Heavy-Italic__': '.SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic',
  '__SF-Compact-Text-Regular__': 'SFCompactText-Regular|.SFCompactText-Regular',
  '__SF-Compact-Text-Light__': 'SFCompactText-Light|.SFCompactText-Light',
  '__SF-Compact-Text-Medium__': 'SFCompactText-Medium|.SFCompactText-Medium',
  '__SF-Compact-Text-Semibold__': 'SFCompactText-Semibold|.SFCompactText-Semibold',
  '__SF-Compact-Text-Bold__': 'SFCompactText-Bold|.SFCompactText-Bold',
  '__SF-Compact-Text-Heavy__': 'SFCompactText-Heavy|.SFCompactText-Heavy',
  '__SF-Compact-Text-Italic__': 'SFCompactText-Italic|.SFCompactText-Italic',
  '__SF-Compact-Text-Light-Italic__': 'SFCompactText-LightItalic|.SFCompactText-LightItalic',
  '__SF-Compact-Text-Medium-Italic__': 'SFCompactText-MediumItalic|.SFCompactText-MediumItalic',
  '__SF-Compact-Text-Semibold-Italic__': 'SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic',
  '__SF-Compact-Text-Bold-Italic__': 'SFCompactText-BoldItalic|.SFCompactText-BoldItalic',
  '__SF-Compact-Text-Heavy-Italic__': 'SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic',
  '__SF-UI-Display-Condensed-Regular__': '.SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular',
  '__SF-UI-Display-Condensed-Ultralight__':
    '.SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight',
  '__SF-UI-Display-Condensed-Thin__': '.SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin',
  '__SF-UI-Display-Condensed-Light__': '.SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light',
  '__SF-UI-Display-Condensed-Medium__': '.SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium',
  '__SF-UI-Display-Condensed-Semibold__': '.SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold',
  '__SF-UI-Display-Condensed-Bold__': '.SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold',
  '__SF-UI-Display-Condensed-Heavy__': '.SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy',
  '__SF-UI-Display-Condensed-Black__': '.SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black',
  '__SF-UI-Display-Regular__': '.SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay',
  '__SF-UI-Display-Ultralight__': '.SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight',
  '__SF-UI-Display-Thin__': '.SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin',
  '__SF-UI-Display-Light__': '.SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light',
  '__SF-UI-Display-Medium__': '.SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium',
  '__SF-UI-Display-Semibold__': '.SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold',
  '__SF-UI-Display-Bold__': '.SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold',
  '__SF-UI-Display-Heavy__': '.SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy',
  '__SF-UI-Display-Black__': '.SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black',
  '__SF-UI-Display-Italic__': '.SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic',
  '__SF-UI-Display-Ultralight-Italic__':
    '.SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic',
  '__SF-UI-Display-Thin-Italic__': '.SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic',
  '__SF-UI-Display-Light-Italic__': '.SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic',
  '__SF-UI-Display-Medium-Italic__':
    '.SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic',
  '__SF-UI-Display-Semibold-Italic__':
    '.SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic',
  '__SF-UI-Display-Bold-Italic__': '.SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic',
  '__SF-UI-Display-Heavy-Italic__': '.SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic',
  '__SF-UI-Display-Black-Italic__': '.SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic',
  '__SF-UI-Text-Condensed-Regular__': '.SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular',
  '__SF-UI-Text-Condensed-Light__': '.SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light',
  '__SF-UI-Text-Condensed-Medium__': '.SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium',
  '__SF-UI-Text-Condensed-Semibold__': '.SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold',
  '__SF-UI-Text-Condensed-Bold__': '.SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold',
  '__SF-UI-Text-Condensed-Heavy__': '.SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy',
  '__SF-Compact-Rounded-Regular__': 'SFCompactRounded-Regular|.SFCompactRounded-Regular',
  '__SF-Compact-Rounded-Ultralight__': 'SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight',
  '__SF-Compact-Rounded-Thin__': 'SFCompactRounded-Thin|.SFCompactRounded-Thin',
  '__SF-Compact-Rounded-Light__': 'SFCompactRounded-Light|.SFCompactRounded-Light',
  '__SF-Compact-Rounded-Medium__': 'SFCompactRounded-Medium|.SFCompactRounded-Medium',
  '__SF-Compact-Rounded-Semibold__': 'SFCompactRounded-Semibold|.SFCompactRounded-Semibold',
  '__SF-Compact-Rounded-Bold__': 'SFCompactRounded-Bold|.SFCompactRounded-Bold',
  '__SF-Compact-Rounded-Heavy__': 'SFCompactRounded-Heavy|.SFCompactRounded-Heavy',
  '__SF-Compact-Rounded-Black__': 'SFCompactRounded-Black|.SFCompactRounded-Black',
};
var fontFamilies = safeFonts;
var systemFontFamilyName = 'System Default';
var LocalFontSource = class {
  constructor() {
    __publicField(
      this,
      'name',
      'local',
      /* Local */
    );
    __publicField(this, 'fontFamilies', [],);
    __publicField(this, 'byFamilyName', /* @__PURE__ */ new Map(),);
    __publicField(this, 'fontAliasBySelector', /* @__PURE__ */ new Map(),);
    __publicField(this, 'fontAliases', /* @__PURE__ */ new Map(),);
  }
  getFontFamilyByName(family,) {
    var _a;
    return (_a = this.byFamilyName.get(family,)) != null ? _a : null;
  }
  // TODO: these are duplicated across implementations of FontSource
  // When adding a third source, we should abstract them
  createFontFamily(family,) {
    const fontFamily = { name: family, fonts: [], source: this.name, };
    this.addFontFamily(fontFamily,);
    return fontFamily;
  }
  addFontFamily(fontFamily,) {
    this.fontFamilies.push(fontFamily,);
    this.byFamilyName.set(fontFamily.name, fontFamily,);
  }
  // end of duplication
  importFonts() {
    const fonts = [];
    for (const family of Object.keys(fontFamilies,)) {
      const members = fontFamilies[family];
      if (!members) {
        continue;
      }
      const fontFamily = this.createFontFamily(family,);
      for (const variant of Object.keys(members,)) {
        const member = members[variant];
        if (!member) {
          continue;
        }
        const { selector, weight, } = member;
        const font = {
          variant,
          selector,
          weight,
          family: fontFamily,
        };
        fontFamily.fonts.push(font,);
      }
      fonts.push(...fontFamily.fonts,);
    }
    for (const [key7, value,] of Object.entries(fontAliases,)) {
      this.addFontAlias(key7, value,);
    }
    const { fontFamily: systemFontFamily, aliases, } = this.getSystemFontFamily();
    this.addFontFamily(systemFontFamily,);
    for (const [key7, value,] of aliases) {
      this.addFontAlias(key7, value,);
    }
    fonts.push(...systemFontFamily.fonts,);
    return fonts;
  }
  addFontAlias(key7, value,) {
    this.fontAliases.set(key7, value,);
    this.fontAliasBySelector.set(value, key7,);
  }
  getSystemFontFamily() {
    const fontFamilies2 = (
      // System fonts - Taken from https://furbo.org/stuff/systemfonts-new.html - "All Platforms" section
      'system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif'
    );
    const fontFamily = { name: systemFontFamilyName, fonts: [], source: this.name, };
    const aliases = /* @__PURE__ */ new Map();
    const weights = [400, 100, 200, 300, 500, 600, 700, 800, 900,];
    const styles = ['normal', 'italic',];
    for (const style of styles) {
      for (const weight of weights) {
        const variant = createVariantName(weight, style,);
        const alias = `__SystemDefault-${weight}-${style}__`;
        const font = {
          variant,
          selector: alias,
          style,
          weight,
          family: fontFamily,
        };
        fontFamily.fonts.push(font,);
        aliases.set(alias, fontFamilies2,);
      }
    }
    return { fontFamily, aliases, };
  }
  getFontAliasBySelector(selector,) {
    return this.fontAliasBySelector.get(selector,) || null;
  }
  getFontSelectorByAlias(alias,) {
    return this.fontAliases.get(alias,) || null;
  }
  /** Font family aliases are in the format of `__Alias-Name__` */
  isFontFamilyAlias(value,) {
    if (value && /^__.*__$/u.exec(value,)) {
      return true;
    }
    return false;
  }
};
var fontWeightNames = {
  '100': 'Thin',
  '200': 'Extra Light',
  '300': 'Light',
  '400': 'Normal',
  '500': 'Medium',
  '600': 'Semi Bold',
  '700': 'Bold',
  '800': 'Extra Bold',
  '900': 'Black',
};
function createVariantName(weight, style,) {
  const friendlyStyle = style === 'normal' ? 'Regular' : 'Italic';
  if (weight === 400) {
    return friendlyStyle;
  }
  if (style !== 'normal') {
    return `${fontWeightNames[weight]} ${friendlyStyle}`;
  }
  return `${fontWeightNames[weight]}`;
}
var FontStore = class {
  constructor() {
    __publicField(this, 'enabled', false,);
    __publicField(this, 'bySelector', /* @__PURE__ */ new Map(),);
    __publicField(this, 'getGoogleFontsListPromise',);
    __publicField(this, 'getFontshareFontsListPromise',);
    __publicField(this, 'loadedSelectors', /* @__PURE__ */ new Set(),);
    __publicField(this, 'googleFamilyNames', /* @__PURE__ */ new Set(),);
    __publicField(this, 'local',);
    __publicField(this, 'google',);
    __publicField(this, 'fontshare',);
    __publicField(this, 'framer',);
    __publicField(this, 'custom',);
    this.local = new LocalFontSource();
    this.google = new GoogleFontSource();
    this.fontshare = new FontshareSource();
    this.framer = new FramerFontSource();
    this.custom = new CustomFontSource();
    this.bySelector = /* @__PURE__ */ new Map();
    this.importLocalFonts();
  }
  addFont(font,) {
    this.bySelector.set(font.selector, font,);
  }
  getAvailableFonts() {
    return Array.from(this.bySelector.values(),);
  }
  importLocalFonts() {
    for (const font of this.local.importFonts()) {
      this.addFont(font,);
      this.loadFont(font,);
    }
  }
  async importGoogleFonts() {
    if (!this.getGoogleFontsListPromise) {
      this.getGoogleFontsListPromise = runtime.fetchGoogleFontsList();
      const googleFonts = await this.getGoogleFontsListPromise;
      for (const font of this.google.importFonts(googleFonts,)) {
        this.googleFamilyNames.add(font.family.name.toLowerCase(),);
        this.addFont(font,);
      }
    }
    return this.getGoogleFontsListPromise;
  }
  async importFontshareFonts() {
    if (!this.getFontshareFontsListPromise) {
      this.getFontshareFontsListPromise = runtime.fetchFontshareFontsList();
      const fontshareFonts = await this.getFontshareFontsListPromise;
      for (const font of this.fontshare.importFonts(fontshareFonts,)) {
        if (!this.googleFamilyNames.has(font.family.name.toLowerCase(),)) {
          this.addFont(font,);
        }
      }
    }
    return this.getFontshareFontsListPromise;
  }
  importFramerFonts(fonts,) {
    this.framer.importFonts(fonts,).forEach((font,) => {
      this.addFont(font,);
    },);
  }
  importCustomFonts(assets,) {
    this.bySelector.forEach((_, key7,) => {
      if (key7.startsWith(customFontSelectorPrefix,)) {
        this.bySelector.delete(key7,);
      }
    },);
    for (const font of this.custom.importFonts(assets,)) {
      this.addFont(font,);
    }
  }
  getFontFamily(info,) {
    const fontFamily = this[info.source].getFontFamilyByName(info.name,);
    return fontFamily;
  }
  getFontBySelector(selector, createFont = true,) {
    if (selector.startsWith(customFontSelectorPrefix,)) {
      return this.custom.getFontBySelector(selector, createFont,);
    }
    return this.bySelector.get(selector,);
  }
  // Function called by draft to get font properties for a selector, before the (google) font is available in the store
  // It replaces a previous function that created Font instances and added them to the store
  // on the fly while rendering drafts, which caused issues (overriding real google font info with fake instances with partial data).
  // Ideally this should not happen, but that's a fix for another day
  getDraftPropertiesBySelector(selector,) {
    const font = this.getFontBySelector(selector,);
    if (font) {
      return {
        style: font.style,
        weight: font.weight,
        variant: font.variant,
        family: font.family.name,
        source: font.family.source,
        category: font.category,
      };
    }
    const googleLocator = this.google.parseSelector(selector,);
    if (googleLocator) {
      const fontVariant = GoogleFontSource.parseVariant(googleLocator.variant,);
      if (fontVariant) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: googleLocator.variant,
          family: googleLocator.name,
          source: 'google',
          category: void 0,
        };
      }
    }
    const fontshareLocator = this.fontshare.parseSelector(selector,);
    if (fontshareLocator) {
      const fontVariant = FontshareSource.parseVariant(fontshareLocator.variant,);
      if (fontVariant) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: fontshareLocator.variant,
          family: fontshareLocator.name,
          source: 'fontshare',
          category: void 0,
        };
      }
    }
    const framerFontDraftProperties = FramerFontSource.getDraftFontPropertiesBySelector(selector,);
    if (framerFontDraftProperties) {
      return framerFontDraftProperties;
    }
    return null;
  }
  isSelectorLoaded(selector,) {
    return this.loadedSelectors.has(selector,);
  }
  /**
   * Load a single font
   */
  async loadFont(font,) {
    if (this.isSelectorLoaded(font.selector,)) {
      return 0;
    }
    const source = font.family.source;
    switch (source) {
      case 'local':
        this.loadedSelectors.add(font.selector,);
        return 1;
      case 'framer':
        if (import_process4.default.env.NODE_ENV !== 'test') {
          await isFontReady(font.family.name, font.style, font.weight,);
        }
        this.loadedSelectors.add(font.selector,);
        return 1;
      case 'google':
      case 'fontshare':
      case 'custom':
        if (!font.file) {
          return Promise.reject(`Unable to load font: ${font.selector}`,);
        }
        await loadFont(
          {
            family: font.family.name,
            url: font.file,
            weight: font.weight,
            style: font.style,
          },
          document,
        );
        this.loadedSelectors.add(font.selector,);
        return 1;
      default:
        assertNever(source,);
    }
  }
  async loadFontsFromSelectors(selectors,) {
    if (!this.enabled) {
      return [];
    }
    const googleFontsRequested = selectors.some((selector,) => selector.startsWith(googleFontSelectorPrefix,));
    const fontshareFontsRequested = selectors.some((selector,) => selector.startsWith(fontsharePrefix,));
    if (googleFontsRequested || fontshareFontsRequested) {
      try {
        await this.importGoogleFonts();
      } catch (error) {
        warnOnce2('Failed to load Google fonts:', error,);
      }
      try {
        await this.importFontshareFonts();
      } catch (error) {
        warnOnce2('Failed to load Fontshare fonts:', error,);
      }
    }
    const fonts = selectors.map((s,) => this.bySelector.get(s,)).filter((f,) => !!f);
    return Promise.allSettled(fonts.map((f,) => this.loadFont(f,)),);
  }
  async loadFonts(fontSelectors,) {
    const results = await this.loadFontsFromSelectors(fontSelectors,);
    const newlyLoadedFontCount = results.filter(
      (result,) => result.status === 'fulfilled' && result.value === 1,
      /* Loaded */
    ).length;
    return { newlyLoadedFontCount, };
  }
  // Deprecated methods that are kept for backwards compatibility with any compiled code that might still be using them
  /**
   * @deprecated This method’s API is confusing as 1) it works for all fonts,
   * not just missing ones, 2) it supports both async/await and a callback,
   * but the callback is called only if *all* fonts have been loaded. Use
   * `loadFonts` instead.
   */
  async loadMissingFonts(fontSelectors, fontsLoadedCallback,) {
    const selectors = fontSelectors.filter((selector,) => {
      return !fontStore.isSelectorLoaded(selector,);
    },);
    if (selectors.length === 0) {
      return;
    }
    await fontStore.loadWebFontsFromSelectors(selectors,);
    const isEachFontLoaded = selectors.every((selector,) => {
      return fontStore.isSelectorLoaded(selector,);
    },);
    if (isEachFontLoaded && fontsLoadedCallback) {
      fontsLoadedCallback();
    }
  }
  /**
   * @deprecated This method is misleading as it works with all fonts, not
   * just web fonts. Use `loadFonts` instead. (In Framer, “web fonts” has a
   * specific meaning: it refers to Google/Fontshare fonts and exludes custom
   * and local fonts. See e.g. `WebFontStore` and the “Web”/“Custom” toggle in
   * the font picker in the UI. More context: https://github.com/framer/FramerStudio/pull/15778#discussion_r1395120760)
   */
  async loadWebFontsFromSelectors(selectors,) {
    return this.loadFontsFromSelectors(selectors,);
  }
  // defaultFont doesn’t seem to be used anywhere in our code (except tests),
  // but keeping it for backwards compatibility with any compiled code.
  /** @deprecated This will be removed in the future. Don’t use it. */
  get defaultFont() {
    const defaultFont = this.getFontBySelector('Inter',);
    assert(defaultFont, 'Can\u2019t find Inter font',);
    return defaultFont;
  }
};
var fontStore = /* @__PURE__ */ new FontStore();
Promise.allSettled = Promise.allSettled || ((promises,) =>
  Promise.all(
    promises.map(
      (p,) => p.then((v,) => ({ status: 'fulfilled', value: v, })).catch((e,) => ({ status: 'rejected', reason: e, })),
    ),
  ));
function useFontLoadStatus(fontSelectors = [], timeout = 5e3,) {
  const missingFontSelectors = fontSelectors.filter((s,) => !fontStore.isSelectorLoaded(s,));
  const [fontLoadStatus, setFontLoadStatus,] = React95.useState(
    missingFontSelectors.length ? 'loading' : 'done',
  );
  React95.useEffect(() => {
    if (!missingFontSelectors.length) {
      return;
    }
    setFontLoadStatus('loading',);
    const timer = setTimeout(() => {
      setFontLoadStatus('timeout',);
    }, timeout,);
    fontStore.loadFonts(missingFontSelectors,).then(() => {
      clearTimeout(timer,);
      setFontLoadStatus('done',);
    },);
  }, [fontSelectors.join(', ',), missingFontSelectors.join(', ',),],);
  return fontLoadStatus;
}
function isShallowEqualArray(a, b,) {
  return a.length === b.length && a.every((v, i,) => v === b[i]);
}
function TextStyleSheet() {
  React96.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, [],);
  return null;
}
var Text = /* @__PURE__ */ React96.forwardRef(function Text2(props, forwardedRef,) {
  var _a, _b;
  const parentSize = useParentSize();
  const layoutId = useLayoutId2(props,);
  const fallbackLayoutRef = useRef15(null,);
  const layoutRef = forwardedRef != null ? forwardedRef : fallbackLayoutRef;
  const { navigate, getRoute, } = useRouter();
  const currentRoute = useCurrentRoute();
  useRoutePreloader((_a = props.preload) != null ? _a : [],);
  const onCanvas = useIsOnFramerCanvas();
  const matchesCurrentRoute = useLinkMatchesRoute(props.__link,);
  const fontLoadStatus = useFontLoadStatus(props.fonts,);
  useMeasureLayout(props, layoutRef,);
  const { fonts, __fromCanvasComponent, } = props;
  const prevFontsRef = useRef15([],);
  const fontsDidChange = !isShallowEqualArray((_b = prevFontsRef.current) != null ? _b : [], fonts != null ? fonts : [],);
  prevFontsRef.current = fonts;
  useEffect112(() => {
    if (!fontsDidChange || !fonts) {
      return;
    }
    fontStore.loadFonts(fonts,).then(({ newlyLoadedFontCount, },) => {
      if (!__fromCanvasComponent || !layoutRef.current || RenderTarget.current() !== 'CANVAS') {
        return;
      }
      if (newlyLoadedFontCount === 0) {
        return;
      }
      measureClosestComponentContainer(layoutRef.current,);
    },);
  }, [fonts,],);
  const implicitPathVariables = useImplicitPathVariables();
  const interceptPageLinks = React96.useCallback(
    (event,) => {
      const anchorElement = findAnchorElement(event.target, layoutRef.current,);
      if (event.metaKey || !navigate || !anchorElement) {
        return;
      }
      const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables,);
      if (didNavigate) {
        event.preventDefault();
      }
    },
    [navigate, implicitPathVariables,],
  );
  useEffect112(() => {
    var _a2;
    (_a2 = layoutRef.current) == null ? void 0 : _a2.addEventListener('click', interceptPageLinks,);
    const ref = layoutRef.current;
    return () => ref == null ? void 0 : ref.removeEventListener('click', interceptPageLinks,);
  }, [interceptPageLinks,],);
  const rawHTML = React96.useMemo(() => {
    if (!props.rawHTML || onCanvas || !getRoute || !currentRoute) {
      return props.rawHTML;
    }
    return replaceFramerPageLinks(props.rawHTML, getRoute, currentRoute, implicitPathVariables,);
  }, [props.rawHTML, getRoute, onCanvas, currentRoute, implicitPathVariables,],);
  return /* @__PURE__ */ React96.createElement(
    TextComponent,
    {
      ...props,
      innerRef: layoutRef,
      layoutId,
      parentSize,
      fontLoadStatus,
      rawHTML,
      matchesCurrentRoute,
    },
  );
},);
var TextComponent = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    constructor() {
      super(...arguments,);
      __publicField(this, 'editorText',);
      __publicField(this, 'setElement', (element,) => {
        if (this.props.innerRef) {
          this.props.innerRef.current = element;
        }
        this.setLayerElement(element,);
      },);
      __publicField(this, 'renderMain', (inCodeComponent,) => {
        countNodeRender();
        const {
          font,
          visible,
          alignment,
          willChangeTransform,
          opacity,
          id: id3,
          layoutId,
          className,
          transition,
          variants,
          name,
          __fromCanvasComponent,
          _initialStyle,
          widthType,
          heightType,
          _usesDOMRect,
          autoSize,
          style: styleProp,
          fontLoadStatus,
          matchesCurrentRoute,
          preload,
          tabIndex,
          ...rest
        } = this.props;
        if (!visible) {
          return null;
        }
        const isHidden2 = this.props.isEditable && this.props.environment() === 'CANVAS';
        const justifyContent = convertVerticalAlignment(this.props.verticalAlignment,);
        const style = {
          outline: 'none',
          display: 'flex',
          flexDirection: 'column',
          justifyContent,
          opacity: isHidden2 ? 0 : opacity,
          flexShrink: 0,
        };
        if (_initialStyle) {
          for (const key7 in _initialStyle) {
            if (key7.startsWith('--framer',)) {
              asRecord(style,)[key7] = asRecord(_initialStyle,)[key7];
            }
          }
        }
        const dataProps = {
          'data-framer-component-type': 'Text',
          'data-framer-name': name,
        };
        if (autoSize) {
          asRecord(dataProps,)['data-framer-component-text-autosized'] = 'true';
        }
        this.collectLayout(style, inCodeComponent,);
        collectFiltersFromProps(this.props, style,);
        collectTextShadowsForProps(this.props, style,);
        if (style.opacity === 1 || style.opacity === void 0) {
          delete style.opacity;
        }
        if (willChangeTransform) {
          forceLayerBackingWithCSSProperties(style,);
        }
        let rawHTML = this.props.rawHTML;
        const text = this.getOverrideText() || this.props.text;
        if (isString22(text,)) {
          if (rawHTML) {
            rawHTML = replaceDraftHTMLWithText(rawHTML, text,);
          } else {
            rawHTML = `<p style="font: ${font}">${text}</p>`;
          }
        }
        if (this.props.style) {
          Object.assign(style, this.props.style,);
        }
        const centeringTransformTemplate = this.transformTemplate;
        if (centeringTransformTemplate) {
          Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center,),);
        }
        if (rawHTML) {
          style.lineHeight = '1px';
          style.fontSize = '0px';
          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'loading') {
            style.visibility = 'hidden';
          }
          if (RenderTarget.current() === 'CANVAS' && fontLoadStatus === 'timeout') {
            style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
          }
          Object.assign(style, styleProp,);
          if (alignment) {
            asRecord(style,)['--framer-text-alignment'] = alignment;
          }
          const tabIndexProps = getTabIndexProps(tabIndex,);
          return /* @__PURE__ */ React96.createElement(
            motion.div,
            {
              layoutId,
              id: id3,
              ...tabIndexProps,
              ...dataProps,
              ...rest,
              style,
              transformTemplate: centeringTransformTemplate,
              dangerouslySetInnerHTML: { __html: rawHTML, },
              'data-center': this.props.center,
              className: cx(className, matchesCurrentRoute && 'isCurrent',),
              transition,
              variants,
              ref: this.setElement,
            },
          );
        }
      },);
    }
    get frame() {
      return calculateRect(this.props, this.props.parentSize || 0, false,);
    }
    getOverrideText() {
      const { _forwardedOverrideId, _forwardedOverrides, id: id3, } = this.props;
      const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id3;
      if (forwardedOverrideId && _forwardedOverrides) {
        const text = _forwardedOverrides[forwardedOverrideId];
        if (isString22(text,)) {
          return text;
        }
      }
    }
    render() {
      return /* @__PURE__ */ React96.createElement(
        React96.Fragment,
        null,
        /* @__PURE__ */ React96.createElement(ComponentContainerContext.Consumer, null, this.renderMain,),
        /* @__PURE__ */ React96.createElement(TextStyleSheet, null,),
      );
    }
    collectLayout(style, inCodeComponent,) {
      if (this.props.withExternalLayout) {
        return;
      }
      const frame2 = this.frame;
      const {
        rotation,
        autoSize,
        positionSticky,
        positionStickyTop,
        positionStickyRight,
        positionStickyBottom,
        positionStickyLeft,
        width: externalWidth,
        height: externalHeight,
        _usesDOMRect,
        positionFixed,
        positionAbsolute,
      } = this.props;
      const rotate = Animatable.getNumber(rotation,);
      const isDOMLayoutAutoSized = _usesDOMRect && (externalWidth === 'auto' || externalHeight === 'auto');
      if (frame2 && !isDOMLayoutAutoSized && RenderTarget.hasRestrictions()) {
        Object.assign(style, {
          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4,)}deg)`,
          // Using “auto” fixes wrapping problems where our size calculation does not work out well when zooming the
          // text (due to rendering differences).
          // TODO: When the `autoSize` prop is removed, it's safe to leave
          // this at `${frame.width}px`, because all auto cases will be
          // handled by DOM layout in the `else` side of the conditional
          width: autoSize ? 'auto' : `${frame2.width}px`,
          minWidth: `${frame2.width}px`,
          height: `${frame2.height}px`,
        },);
      } else {
        const { left, right, top, bottom, } = this.props;
        let width;
        let height;
        if (autoSize) {
          width = 'auto';
          height = 'auto';
        } else {
          if (!isFiniteNumber(left,) || !isFiniteNumber(right,)) {
            width = externalWidth;
          }
          if (!isFiniteNumber(top,) || !isFiniteNumber(bottom,)) {
            height = externalHeight;
          }
        }
        Object.assign(style, {
          left,
          right,
          top,
          bottom,
          width,
          height,
          rotate,
        },);
      }
      const onCanvas = RenderTarget.current() === 'CANVAS';
      if (positionSticky) {
        if (!onCanvas || inCodeComponent) {
          style.position = 'sticky';
          style.willChange = 'transform';
          style.zIndex = 1;
          style.top = positionStickyTop;
          style.right = positionStickyRight;
          style.bottom = positionStickyBottom;
          style.left = positionStickyLeft;
        }
      } else if (onCanvas && (positionFixed || positionAbsolute)) {
        style.position = 'absolute';
      }
    }
    get transformTemplate() {
      const { _usesDOMRect, widthType, heightType, __fromCanvasComponent, } = this.props;
      if (this.props.transformTemplate) {
        return this.props.transformTemplate;
      }
      const frame2 = this.frame;
      const isDOMLayoutAutoSized = _usesDOMRect && (widthType === 2 || heightType === 2);
      const hasTransformTemplate = !frame2 || !RenderTarget.hasRestrictions() || __fromCanvasComponent || isDOMLayoutAutoSized;
      if (hasTransformTemplate) {
        return transformTemplate(this.props.center,);
      }
    }
  },
    __publicField(_a, 'supportsConstraints', true,),
    __publicField(_a, 'defaultTextProps', {
      opacity: void 0,
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0,
      _constraints: {
        enabled: true,
        aspectRatio: null,
      },
      rotation: 0,
      visible: true,
      alignment: void 0,
      verticalAlignment: 'top',
      shadows: [],
      font: '16px ' + deviceFont(),
    },),
    __publicField(_a, 'defaultProps', {
      ...Layer.defaultProps,
      ..._a.defaultTextProps,
      isEditable: false,
      environment: RenderTarget.current,
      withExternalLayout: false,
      fontLoadStatus: 'loading',
    },),
    _a;
})();
var linkTag = '(?:<a[^>]*>)?';
var linkClosingTag = '(?:</a>)?';
var outerTag = '<[^>]+>';
var outerClosingTag = '</[^>]+>';
var blockTag = '<(?:div|span)[^>]*>';
var blockClosingTag = '</(?:div|span)>';
var inlineTag = '<[^>]+>';
var inlineClosingTag = '</[^>]+>';
var textContentRegex = new RegExp(
  `^(${linkTag}${outerTag}${blockTag}${inlineTag}).*?(${inlineClosingTag}).*?(${blockClosingTag}${outerClosingTag}${linkClosingTag})$`,
  //                                              ^^^ this is the content we want to replace
  //                                                                      ^^^ this is the content we want to discard
  's',
  // let the "." also match newlines
);
function replaceDraftHTMLWithText(rawHTML, text,) {
  return rawHTML.replace(
    textContentRegex,
    (_, openingTags, inlineClosingTag2, closingTags,) => openingTags + text + inlineClosingTag2 + '<br>' + closingTags,
  );
}
function convertVerticalAlignment(verticalAlignment,) {
  switch (verticalAlignment) {
    case 'top':
      return 'flex-start';
    case 'center':
      return 'center';
    case 'bottom':
      return 'flex-end';
  }
}
function getTabIndexProps(tabIndex,) {
  if (tabIndex === void 0) {
    return {};
  }
  return { tabIndex, };
}
var keys22 = /* @__PURE__ */ new Map();
var InternalID = class {
  constructor(id3,) {
    this.id = id3;
    __publicField(this, '_link', null,);
    __publicField(this, '_urllink', null,);
  }
  add(str,) {
    return InternalID.forKey(this.id + str,);
  }
  toString() {
    return this.id;
  }
  get link() {
    const res = this._link;
    if (res) {
      return res;
    }
    return this._link = '#' + this.id;
  }
  get urlLink() {
    const res = this._urllink;
    if (res) {
      return res;
    }
    return this._urllink = 'url(#' + this.id + ')';
  }
  static forKey(key7,) {
    let res = keys22.get(key7,);
    if (res) {
      return res;
    }
    res = new InternalID('a' + (1e3 + keys22.size) + 'z',);
    keys22.set(key7, res,);
    return res;
  }
};
var PathSegment = class {
  constructor(value,) {
    __publicField(this, '__class', 'PathSegment',);
    __publicField(this, 'x', 0,);
    __publicField(this, 'y', 0,);
    __publicField(this, 'handleMirroring', 'straight',);
    __publicField(this, 'handleOutX', 0,);
    __publicField(this, 'handleOutY', 0,);
    __publicField(this, 'handleInX', 0,);
    __publicField(this, 'handleInY', 0,);
    __publicField(this, 'radius', 0,);
    if (value) {
      Object.assign(this, value,);
    }
  }
  merge(value,) {
    return Object.assign(Object.create(Object.getPrototypeOf(this,),), this, value,);
  }
};
__publicField(PathSegment, 'displayName', 'WithClassDiscriminatorMixin(PathSegment)',);
PathSegment.prototype.__class = 'PathSegment';
((PathSegment2,) => {
  PathSegment2.point = (pathSegment,) => {
    return { x: pathSegment.x, y: pathSegment.y, };
  };
  PathSegment2.handleOut = (pathSegment,) => {
    return { x: pathSegment.handleOutX, y: pathSegment.handleOutY, };
  };
  PathSegment2.handleIn = (pathSegment,) => {
    return { x: pathSegment.handleInX, y: pathSegment.handleInY, };
  };
  PathSegment2.calculatedHandleOut = (pathSegment,) => {
    switch (pathSegment.handleMirroring) {
      case 'symmetric':
      case 'disconnected':
      case 'asymmetric':
        return Point.add((0, PathSegment2.point)(pathSegment,), (0, PathSegment2.handleOut)(pathSegment,),);
      default:
        return { x: pathSegment.x, y: pathSegment.y, };
    }
  };
  PathSegment2.calculatedHandleIn = (pathSegment,) => {
    switch (pathSegment.handleMirroring) {
      case 'symmetric':
        return Point.subtract((0, PathSegment2.point)(pathSegment,), (0, PathSegment2.handleOut)(pathSegment,),);
      case 'disconnected':
      case 'asymmetric':
        return Point.add((0, PathSegment2.point)(pathSegment,), (0, PathSegment2.handleIn)(pathSegment,),);
      default:
        return (0, PathSegment2.point)(pathSegment,);
    }
  };
  PathSegment2.curveDefault = (points, index,) => {
    if (points.length > 2) {
      let pointBefore;
      let pointAfter;
      if (index === 0) {
        pointBefore = points[points.length - 1];
      } else {
        pointBefore = points[index - 1];
      }
      if (index === points.length - 1) {
        pointAfter = points[0];
      } else {
        pointAfter = points[index + 1];
      }
      assert(pointBefore, 'pointBefore should be defined',);
      assert(pointAfter, 'pointAfter should be defined',);
      const delta = Point.subtract((0, PathSegment2.point)(pointAfter,), (0, PathSegment2.point)(pointBefore,),);
      return { x: delta.x / 4, y: delta.y / 4, };
    }
    return { x: 10, y: 10, };
  };
})(PathSegment || (PathSegment = {}),);
var key5 = 'pathSegments';
function withPath(target,) {
  return key5 in target;
}
var pathDefaults = {
  pathSegments: [],
  pathClosed: false,
};
function toSVGPath(withPaths, translate = { x: 0, y: 0, }, canvasMode = 'CANVAS',) {
  let pathElements = [];
  let paths = [];
  if (Array.isArray(withPaths,)) {
    paths = withPaths;
  } else {
    paths = [withPaths,];
  }
  paths.forEach((path,) => {
    const { pathClosed, pathSegments, } = path;
    const segmentCount = pathSegments.length;
    if (segmentCount === 0) {
      return '';
    }
    for (let i = 0; i < segmentCount; i++) {
      const segment = pathSegments[i];
      assert(segment, 'Path segment must be defined',);
      let nextSegment;
      let prevSegment;
      const isFirstSegment = i === 0;
      const isLastSegment = i === segmentCount - 1;
      if (!isLastSegment) {
        nextSegment = pathSegments[i + 1];
      } else if (pathClosed) {
        nextSegment = pathSegments[0];
      }
      if (!isFirstSegment) {
        prevSegment = pathSegments[i - 1];
      } else if (pathClosed) {
        prevSegment = pathSegments[segmentCount - 1];
      }
      if (i === 0) {
        pathElements.push('M',);
      } else if (prevSegment && isStraightCurve(prevSegment, segment,)) {
        pathElements.push('L',);
      }
      pathElements.push(segment.x + translate.x, segment.y + translate.y,);
      if (nextSegment && !isStraightCurve(segment, nextSegment,)) {
        const handleOut = PathSegment.calculatedHandleOut(segment,);
        const handleIn = PathSegment.calculatedHandleIn(nextSegment,);
        pathElements.push(
          'C',
          handleOut.x + translate.x,
          handleOut.y + translate.y,
          handleIn.x + translate.x,
          handleIn.y + translate.y,
        );
      }
      if (isLastSegment && nextSegment) {
        if (isStraightCurve(segment, nextSegment,)) {
          pathElements.push('Z',);
        } else {
          pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, 'Z',);
        }
      }
    }
  },);
  if (canvasMode === 'EXPORT' || canvasMode === 'PREVIEW') {
    pathElements = pathElements.map((value,) => isFiniteNumber(value,) ? roundedNumberString(value, 3,) : value);
  }
  return pathElements.join(' ',);
}
function isStraightCurve(fromSegment, toSegment,) {
  const fromStraight = fromSegment.handleMirroring === 'straight' || fromSegment.handleOutX === 0 && fromSegment.handleOutY === 0;
  const toStraight = toSegment.handleMirroring === 'straight' || toSegment.handleInX === 0 && toSegment.handleInY === 0;
  return fromStraight && toStraight;
}
var svgElementAttributeDefaults = {
  stroke: 'none',
  strokeWidth: 1,
  strokeLinecap: 'butt',
  strokeLinejoin: 'miter',
  strokeMiterlimit: 4,
  strokeDasharray: '0',
  strokeDashoffset: 0,
  strokeOpacity: 1,
  fill: 'black',
  fillRule: 'nonzero',
  fillOpacity: 1,
};
function createTransformValues(baseTransform, mode,) {
  let { x, y, } = baseTransform;
  const { width, height, rotation, } = baseTransform;
  if (mode === 'resetXYKeepFraction') {
    x = x - Math.floor(x,);
    y = y - Math.floor(y,);
  } else if (mode === 'resetXY') {
    x = 0;
    y = 0;
  }
  return { x, y, width, height, rotation, };
}
function getTransformMode(isRootVectorNode, includeTransform,) {
  if (includeTransform !== void 0) {
    if (includeTransform) {
      return 'asIs';
    }
  } else {
    if (!isRootVectorNode) {
      return 'asIs';
    }
  }
  if (isRootVectorNode) {
    return 'resetXYKeepFraction';
  } else {
    return 'resetXY';
  }
}
function transformValues(rect, rotation, isRootVectorNode, includeTransform,) {
  const transformMode = getTransformMode(isRootVectorNode, includeTransform,);
  const baseTransform = { ...rect, rotation, };
  const transform2 = createTransformValues(baseTransform, transformMode,);
  return transform2;
}
function transformString(transform2,) {
  if (transform2 === void 0) {
    return void 0;
  }
  const { x, y, rotation, width, height, } = transform2;
  let result;
  if (x !== 0 || y !== 0) {
    result = `translate(${roundedNumberString(x, 3,)} ${roundedNumberString(y, 3,)})`;
  }
  if (rotation !== 0) {
    const roundedRotation = roundedNumberString(rotation, 4,);
    const roundedWidth = roundedNumberString(width / 2, 3,);
    const roundedHeight = roundedNumberString(height / 2, 3,);
    const rotationString = `rotate(${roundedRotation} ${roundedWidth} ${roundedHeight})`;
    result = result ? `${result} ${rotationString}` : rotationString;
  }
  return result;
}
var LinearGradientElement = class extends Component12 {
  render() {
    const { id: id3, stops, x1, x2, y1, y2, } = this.props;
    return /* @__PURE__ */ React97.createElement(
      'linearGradient',
      { id: id3, x1, x2, y1, y2, },
      stops.map((stop, idx,) => {
        return /* @__PURE__ */ React97.createElement('stop', {
          key: idx,
          offset: stop.position,
          stopColor: stop.color,
          stopOpacity: stop.alpha,
        },);
      },),
    );
  }
};
var RadialGradientElement = class extends Component12 {
  render() {
    const { centerAnchorX, centerAnchorY, id: id3, widthFactor, heightFactor, stops, } = this.props;
    return /* @__PURE__ */ React97.createElement(
      'radialGradient',
      {
        id: id3,
        cy: centerAnchorY,
        cx: centerAnchorX,
        r: widthFactor,
        gradientTransform: `translate(${centerAnchorX}, ${centerAnchorY}) scale(1 ${
          heightFactor / widthFactor
        }) translate(-${centerAnchorX}, -${centerAnchorY})`,
      },
      stops.map((stop, idx,) => {
        return /* @__PURE__ */ React97.createElement('stop', {
          key: idx,
          offset: stop.position,
          stopColor: stop.color,
          stopOpacity: stop.alpha,
        },);
      },),
    );
  }
};
var SVGRoot = class extends Component13 {
  render() {
    const { children, frame: frame2, innerRef, } = this.props;
    const { width, height, } = frame2;
    const fx = Math.floor(frame2.x,);
    const fy = Math.floor(frame2.y,);
    const svgStyle = {
      position: 'absolute',
      width: Math.ceil(width,),
      height: Math.ceil(height,),
      overflow: 'visible',
      display: 'block',
      transform: `translate(${fx}px, ${fy}px)`,
    };
    Layer.applyWillChange(this.props, svgStyle, false,);
    return /* @__PURE__ */ React98.createElement(
      'svg',
      {
        width: '100%',
        height: '100%',
        xmlns: 'http://www.w3.org/2000/svg',
        xmlnsXlink: 'http://www.w3.org/1999/xlink',
        style: svgStyle,
        ref: innerRef,
      },
      children,
    );
  }
};
var Vector = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    render() {
      var _a2, _b;
      countNodeRender();
      const {
        opacity,
        calculatedPath,
        d,
        insideStroke,
        shapeId,
        strokeEnabled,
        strokeClipId,
        strokeWidth,
        idAttribute,
        rect,
        shadows,
        strokeAlpha,
        name,
        includeTransform,
        isRootVectorNode,
        rotation,
        id: id3,
        lineCap,
        lineJoin,
        strokeColor,
        strokeMiterLimit,
        strokeDashArray,
        strokeDashOffset,
        fill,
        variants,
        transition,
      } = this.props;
      if (!id3 || !shapeId || !strokeClipId) {
        return null;
      }
      const rotate = (_b = (_a2 = this.props.rotate) != null ? _a2 : rotation) != null ? _b : 0;
      const { target, } = RenderEnvironment;
      const transform2 = transformValues(rect, rotate, isRootVectorNode, includeTransform,);
      let vectorFill;
      let fillAlpha = 0;
      let imagePattern;
      let linearGradient;
      let radialGradient;
      if (isString22(fill,) || Color.isColorObject(fill,)) {
        const fillColor = Color.isColorObject(fill,) ? fill.initialValue || Color.toRgbString(fill,) : fill;
        if (fillColor !== 'transparent') {
          vectorFill = fillColor;
          fillAlpha = ConvertColor.getAlpha(vectorFill,);
        }
      } else if (LinearGradient.isLinearGradient(fill,)) {
        linearGradient = elementPropertiesForLinearGradient(fill, id3,);
        vectorFill = `url(#${linearGradient.id})`;
        fillAlpha = 1;
      } else if (RadialGradient.isRadialGradient(fill,)) {
        radialGradient = elementPropertiesForRadialGradient(fill, id3,);
        vectorFill = `url(#${radialGradient.id})`;
        fillAlpha = 1;
      } else if (BackgroundImage.isImageObject(fill,)) {
        imagePattern = imagePatternPropsForFill(fill, transform2, id3, includeTransform,);
        if (imagePattern) {
          vectorFill = `url(#${imagePattern.id})`;
          fillAlpha = 1;
        }
      }
      if (vectorFill === svgElementAttributeDefaults.fill) {
        vectorFill = void 0;
      }
      if (vectorFill === void 0) {
        vectorFill = 'transparent';
      }
      const fillEnabled = vectorFill !== void 0 && vectorFill !== 'transparent' && fillAlpha !== 0;
      if (!fillEnabled && !strokeEnabled) {
        fillAlpha = 1;
      }
      let mainElement;
      let strokeClipPath = null;
      let shapeReference = null;
      let strokeElement = null;
      let pathTranslate;
      let elementTransform;
      const translatePaths = target === 'EXPORT';
      if (transform2.rotation === 0 && translatePaths) {
        pathTranslate = transform2;
      } else {
        pathTranslate = { x: 0, y: 0, };
        elementTransform = transformString(transform2,);
      }
      const pathAttributes = {
        d: d != null ? d : toSVGPath(calculatedPath, pathTranslate, target,),
        transform: elementTransform,
      };
      const svgStrokeAttributes = {};
      if (strokeEnabled && strokeWidth !== 0) {
        svgStrokeAttributes.strokeWidth = strokeWidth;
        svgStrokeAttributes.stroke = strokeColor;
        svgStrokeAttributes.strokeLinecap = lineCap;
        svgStrokeAttributes.strokeLinejoin = lineJoin;
        if (lineJoin === 'miter') {
          svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;
        }
        svgStrokeAttributes.strokeDasharray = strokeDashArray;
        if (strokeDashOffset !== 0) {
          svgStrokeAttributes.strokeDashoffset = strokeDashOffset;
        }
      }
      for (const key7 in svgElementAttributeDefaults) {
        if (asRecord(svgStrokeAttributes,)[key7] === asRecord(svgElementAttributeDefaults,)[key7]) {
          asRecord(svgStrokeAttributes,)[key7] = void 0;
        }
      }
      const internalShapeId = InternalID.forKey(shapeId,);
      const internalStrokeClipId = InternalID.forKey(strokeClipId,);
      const shadow = shadowForShape(
        shadows,
        rect,
        internalShapeId,
        fillAlpha,
        strokeAlpha,
        strokeWidth,
        internalStrokeClipId,
        svgStrokeAttributes,
      );
      const currentName = target === 'PREVIEW' ? name || void 0 : void 0;
      if (shadow.insetElement !== null || shadow.outsetElement !== null || insideStroke) {
        pathAttributes.id = internalShapeId.id;
        shapeReference = /* @__PURE__ */ React99.createElement(motion.path, { ...{ ...pathAttributes, }, variants, transition, },);
        if (shadow.needsStrokeClip || insideStroke) {
          strokeClipPath = /* @__PURE__ */ React99.createElement(
            'clipPath',
            { id: internalStrokeClipId.id, },
            /* @__PURE__ */ React99.createElement('use', { xlinkHref: internalShapeId.link, },),
          );
        }
        if (shadow.insetElement !== null && strokeEnabled && strokeWidth && strokeWidth > 0) {
          mainElement = /* @__PURE__ */ React99.createElement('use', {
            xlinkHref: internalShapeId.link,
            fill: vectorFill,
            strokeOpacity: '0',
            name: currentName,
          },);
          strokeElement = /* @__PURE__ */ React99.createElement(
            'use',
            {
              xlinkHref: internalShapeId.link,
              clipPath: internalStrokeClipId.urlLink,
              fill: 'transparent',
              ...svgStrokeAttributes,
              strokeWidth,
            },
          );
        } else {
          mainElement = /* @__PURE__ */ React99.createElement(
            'use',
            {
              xlinkHref: internalShapeId.link,
              fill: vectorFill,
              clipPath: internalStrokeClipId.urlLink,
              ...svgStrokeAttributes,
              strokeWidth,
              name: currentName,
            },
          );
        }
      } else {
        pathAttributes.id = idAttribute;
        mainElement = /* @__PURE__ */ React99.createElement(
          motion.path,
          {
            ...{
              ...pathAttributes,
              fill: vectorFill,
              ...svgStrokeAttributes,
            },
            name: currentName,
            variants,
            transition,
          },
        );
      }
      const imagePatternElement = imagePattern
        ? /* @__PURE__ */ React99.createElement(
          ImagePatternElement,
          {
            ...imagePattern,
            repeat: BackgroundImage.isImageObject(fill,) && fill.fit === 'tile',
          },
        )
        : void 0;
      let gradient;
      if (linearGradient) {
        gradient = /* @__PURE__ */ React99.createElement(LinearGradientElement, { ...linearGradient, },);
      } else if (radialGradient) {
        gradient = /* @__PURE__ */ React99.createElement(RadialGradientElement, { ...radialGradient, },);
      }
      let defs = null;
      if (shapeReference || strokeClipPath || shadow.definition && shadow.definition.length || gradient || imagePatternElement) {
        defs = /* @__PURE__ */ React99.createElement(
          'defs',
          null,
          shapeReference,
          strokeClipPath,
          shadow.definition,
          gradient,
          imagePatternElement,
        );
      }
      const opacityValue = opacity != null ? opacity : variants ? 1 : void 0;
      if (defs === null && shadow.outsetElement === null && shadow.insetElement === null && strokeElement === null) {
        mainElement = /* @__PURE__ */ React99.createElement(
          motion.path,
          {
            ...{
              ...pathAttributes,
              fill: vectorFill,
              ...svgStrokeAttributes,
            },
            opacity: opacityValue,
            variants,
            transition,
            name: currentName,
          },
        );
        return this.renderElement(mainElement,);
      }
      return this.renderElement(
        /* @__PURE__ */ React99.createElement(
          motion.g,
          { opacity: opacityValue, variants, transition, },
          defs,
          shadow.outsetElement,
          mainElement,
          shadow.insetElement,
          strokeElement,
        ),
      );
    }
    renderElement(element,) {
      var _a2, _b;
      const { isRootVectorNode, width, height, rect, willChangeTransform, includeTransform, } = this.props;
      const frame2 = (_b = (_a2 = this.props.frame) != null ? _a2 : rect) != null ? _b : { x: 0, y: 0, width: 100, height: 100, };
      if (!isRootVectorNode) {
        return element;
      }
      if (includeTransform) {
        return element;
      }
      return /* @__PURE__ */ React99.createElement(
        SVGRoot,
        {
          frame: frame2,
          width,
          height,
          willChangeTransform,
          innerRef: this.setLayerElement,
        },
        element,
      );
    }
  },
    __publicField(_a, 'defaultVectorProps', {
      isRootVectorNode: false,
      name: null,
      includeTransform: void 0,
      defaultFillColor: void 0,
      defaultStrokeColor: void 0,
      defaultStrokeWidth: void 0,
      defaultStrokeAlignment: 'center',
      width: 100,
      height: 100,
      rotation: 0,
      rotate: void 0,
      frame: void 0,
      opacity: void 0,
      calculatedPath: [],
      d: void 0,
      shapeId: void 0,
      insideStroke: false,
      strokeEnabled: true,
      strokeClipId: void 0,
      strokeWidth: void 0,
      idAttribute: void 0,
      transition: void 0,
      shadows: [],
      strokeAlpha: 1,
      rect: { x: 0, y: 0, width: 0, height: 0, },
      lineCap: 'butt',
      strokeColor: '#0AF',
      lineJoin: 'miter',
      strokeMiterLimit: 4,
      strokeDashArray: '0',
      strokeDashOffset: 0,
      fill: 'rgba(0,170,255,0.5)',
    },),
    __publicField(_a, 'defaultProps', {
      ...Layer.defaultProps,
      ..._a.defaultVectorProps,
    },),
    _a;
})();
var VectorGroup = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    render() {
      countNodeRender();
      const {
        id: id3,
        name: nameProp,
        opacity,
        visible,
        targetName,
        defaultName,
        children,
        includeTransform,
        x,
        y,
        width,
        height,
        rotation,
        isRootVectorNode,
      } = this.props;
      if (!visible) {
        return null;
      }
      const { target, } = RenderEnvironment;
      const rect = { x, y, width, height, };
      const transform2 = transformValues(rect, rotation, isRootVectorNode, includeTransform,);
      const addNames = target === 'PREVIEW';
      let name = void 0;
      if (addNames) {
        if (targetName) {
          name = targetName;
        } else if (nameProp) {
          name = nameProp;
        } else {
          name = defaultName;
        }
      }
      return this.renderElement(
        /* @__PURE__ */ React100.createElement(
          'g',
          { transform: transformString(transform2,), ...{ id: id3, name, opacity, }, },
          children,
        ),
      );
    }
    renderElement(element,) {
      const { isRootVectorNode, width, height, frame: frame2, willChangeTransform, includeTransform, } = this.props;
      if (!isRootVectorNode) {
        return element;
      }
      if (includeTransform) {
        return element;
      }
      return /* @__PURE__ */ React100.createElement(
        SVGRoot,
        {
          frame: frame2,
          width,
          height,
          willChangeTransform,
          innerRef: this.setLayerElement,
        },
        element,
      );
    }
  },
    __publicField(_a, 'defaultVectorGroupProps', {
      name: void 0,
      opacity: void 0,
      visible: true,
      x: 0,
      y: 0,
      rotation: 0,
      width: 100,
      height: 100,
      targetName: void 0,
      defaultName: '',
      isRootVectorNode: false,
      includeTransform: void 0,
      frame: { x: 0, y: 0, width: 100, height: 100, },
    },),
    __publicField(_a, 'defaultProps', {
      ...Layer.defaultProps,
      ..._a.defaultVectorGroupProps,
    },),
    _a;
})();
var _CanvasStore = class {
  constructor() {
    __publicField(this, 'canvas', { children: [], },);
    __publicField(this, 'listeners', [],);
    __publicField(this, 'ids', [],);
  }
  static shared(data2,) {
    if (data2) {
      const store = new _CanvasStore();
      store.setCanvas(data2,);
      return store;
    }
    if (!_CanvasStore.__shared) {
      _CanvasStore.__shared = new _CanvasStore();
    }
    return _CanvasStore.__shared;
  }
  updateNode(presentationNode,) {
    const id3 = presentationNode.props.id;
    let children = this.canvas.children;
    if (!children) {
      this.canvas.children = children = [];
    }
    let found = false;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if ((child == null ? void 0 : child.props.id) === id3) {
        found = true;
        children[i] = presentationNode;
        break;
      }
    }
    if (!found) {
      children.push(presentationNode,);
    }
    this.setCanvas(this.canvas,);
  }
  setCanvas(canvas,) {
    if (!canvas.children) {
      return;
    }
    this.canvas = canvas;
    this.listeners.forEach((l, at,) => {
      const id3 = this.ids[at];
      if (!id3) {
        return;
      }
      const data2 = findNodeFor(canvas, id3,);
      l.setState({ data: data2, },);
    },);
  }
  registerListener(listener, idOrName,) {
    this.listeners.push(listener,);
    this.ids.push(idOrName,);
    return findNodeFor(this.canvas, idOrName,);
  }
  removeListener(listener,) {
    const at = this.listeners.indexOf(listener,);
    if (at === -1) {
      return;
    }
    this.listeners.splice(at, 1,);
    this.ids.splice(at, 1,);
  }
};
var CanvasStore = _CanvasStore;
__publicField(CanvasStore, '__shared', null,);
var builtInComponents = { Frame, Vector, Stack, VectorGroup, SVG, Text, DeprecatedComponentContainer, };
var DesignComponent = class extends Component14 {
  _typeForName(name,) {
    const builtIn = asRecord(builtInComponents,)[name];
    if (builtIn) {
      return builtIn;
    }
    const codeComponent = runtime.componentLoader.componentForIdentifier(name,);
    if (codeComponent && isReactDefinition(codeComponent,)) {
      return codeComponent.class;
    }
    return Frame;
  }
  _renderData(presentation, componentProps, topLevelProps,) {
    asRecord(safeWindow,)['__checkBudget__']();
    const { componentClass, name, } = presentation;
    let { props, children, } = presentation;
    props = { ...props, _constraints: { enabled: false, }, };
    const type = this._typeForName(componentClass,);
    if (!type) {
      return null;
    }
    if (topLevelProps) {
      const { style, ...rest } = props;
      props = { ...rest, ...topLevelProps, _initialStyle: style, };
    }
    if (!props.size && props._sizeOfMasterOnCanvas) {
      if (!props.width) {
        props.width = props._sizeOfMasterOnCanvas.width;
      }
      if (!props.height) {
        props.height = props._sizeOfMasterOnCanvas.height;
      }
    }
    if (name && componentProps.hasOwnProperty(name,)) {
      if (componentClass === 'Text') {
        const text = componentProps[name];
        if (text) {
          props = { ...props, text: componentProps[name], };
        }
      } else {
        const orig = props.background;
        const background = { src: componentProps[name], fit: orig.fit, };
        props = { ...props, background, };
      }
    }
    const c = children && children.map((child,) => this._renderData(child, componentProps, void 0,));
    children = children ? c : [];
    return React101.createElement(type, props, children,);
  }
  render() {
    asRecord(safeWindow,)['__checkBudget__']();
    const data2 = this.state.data;
    if (!data2) {
      throw new Error('Unable to connect to canvas data store.',);
    }
    return this._renderData(this.state.data, this.props, this.props,);
  }
};
function isNode(id3, presentation,) {
  const { name, props, } = presentation;
  return props && props.id === id3 || name === id3;
}
function findNodeFor(presentation, id3,) {
  if (!presentation) {
    return null;
  }
  if (isNode(id3, presentation,)) {
    return presentation;
  }
  const { children, } = presentation;
  if (!children || !isArray(children,)) {
    return null;
  }
  for (const child of children) {
    if (isNode(id3, child,)) {
      return child;
    }
  }
  for (const child of children) {
    const result = findNodeFor(child, id3,);
    if (result) {
      return result;
    }
  }
  return null;
}
function createDesignComponent(canvasStore, id3, propertyControls, width = 200, height = 200,) {
  var _a;
  return _a = class extends DesignComponent {
    static rect(props,) {
      const constraintValues = ConstraintValues.fromProperties(props,);
      const parentSizeInfo = props.parentSize ? { sizing: props.parentSize, positioning: props.parentSize, viewport: null, } : null;
      return ConstraintValues.toRect(constraintValues, parentSizeInfo, null,);
    }
    static size(props, parentSize, freeSpace,) {
      const constraintValues = ConstraintValues.fromProperties(props,);
      return ConstraintValues.toSize(constraintValues, parentSize || null, null, freeSpace,);
    }
    constructor(props, context,) {
      super(props, context,);
      const data2 = canvasStore.registerListener(this, id3,);
      this.state = { data: data2, };
    }
    render() {
      const maybeRenderWithProvider = (renderNode,) => {
        const nodeId = nodeIdFromString(id3,);
        if (!this.state.data && renderNode) {
          asRecord(safeWindow,)['__checkBudget__']();
          const el = renderNode(nodeId,);
          if (el && React101.isValidElement(el,) && typeof el.type !== 'string') {
            return React101.createElement(WithOverride(el.type, this.props,), el.props,);
          }
        }
        return super.render();
      };
      return /* @__PURE__ */ React101.createElement(RenderNodeContext.Consumer, null, maybeRenderWithProvider,);
    }
    componentWillUnmount() {
      canvasStore.removeListener(this,);
    }
  },
    __publicField(_a, 'displayName', `DesignComponent(${id3})`,),
    __publicField(_a, 'propertyControls', propertyControls,),
    __publicField(_a, 'supportsConstraints', true,),
    __publicField(_a, 'defaultProps', {
      _sizeOfMasterOnCanvas: {
        width,
        height,
      },
    },),
    _a;
}
var RenderNodeContext = React101.createContext(null,);
var RenderNodeProvider = RenderNodeContext.Provider;
var localPackageFallbackIdentifier = '|local|';
function CustomProperties({
  children,
  customProperties,
},) {
  return /* @__PURE__ */ React1022.createElement('div', { style: customProperties, }, children,);
}
var Image2 = /* @__PURE__ */ React103.forwardRef(function Image3(props, ref,) {
  const { background, children, alt, ...rest } = props;
  const style = { ...rest.style, };
  if (background) {
    delete style.background;
  }
  const MotionComponent = htmlElementAsMotionComponent(props.as,);
  return /* @__PURE__ */ React103.createElement(
    MotionComponent,
    { ...rest, style, ref, },
    background && /* @__PURE__ */ React103.createElement(BackgroundImageComponent, { image: background, alt, },),
    children,
  );
},);
function convertPresentationTree(node, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache = false,) {
  const cachedNode = getCachedNode && getCachedNode(node,);
  if (cachedNode) {
    return cachedNode;
  }
  let children;
  if (isCodeComponentContainerPresentation(node,)) {
    children = convertCodeComponentContainer(
      componentDefinitionProvider,
      node,
      converter,
      getCachedNode,
      skipCodeComponentPropsCache,
    );
  } else if (node.children) {
    children = node.children.map(
      (n,) =>
        convertPresentationTree(
          n,
          converter,
          componentDefinitionProvider,
          getCachedNode,
          skipCodeComponentPropsCache,
        ),
    );
  }
  return converter(node, children,);
}
function isCodeComponentContainerPresentation(value,) {
  return !!value.codeComponentIdentifier;
}
function convertCodeComponentContainer(componentDefinitionProvider, node, converter, getCachedNode, skipCodeComponentPropsCache = false,) {
  var _a;
  const codeComponentChildren = node.getComponentChildren ? node.getComponentChildren(componentDefinitionProvider,) : [];
  const codeComponentSlots = node.getComponentSlotChildren ? node.getComponentSlotChildren(componentDefinitionProvider,) : {};
  let codeComponentPresentation;
  const props = node.getCodeComponentProps
    ? node.getCodeComponentProps(componentDefinitionProvider, { skipCache: skipCodeComponentPropsCache, },)
    : void 0;
  if (node.cache.codeComponentPresentation) {
    codeComponentPresentation = node.cache.codeComponentPresentation;
    if (!isShallowEqualArray(codeComponentPresentation.children, codeComponentChildren,)) {
      codeComponentPresentation.cache.reactElement = null;
      codeComponentPresentation.children = codeComponentChildren;
    }
    if (!isEqual(codeComponentPresentation.props, props,)) {
      codeComponentPresentation.cache.reactElement = null;
      codeComponentPresentation.cache.props = null;
      codeComponentPresentation.props = props;
    }
  } else {
    const { id: containerId, codeComponentIdentifier: identifier, codeComponentPackageVersion, } = node;
    node.cache.codeComponentPresentation = codeComponentPresentation = new CodeComponentPresentation(
      containerId + identifier,
      identifier,
      codeComponentPackageVersion,
      props,
      codeComponentChildren,
    );
  }
  codeComponentPresentation.props.placeholders = node.cache.placeholders;
  const slotKeys = Object.keys(codeComponentSlots,);
  if (slotKeys.length) {
    codeComponentPresentation.props = { ...codeComponentPresentation.props, };
    codeComponentPresentation.props.__slotKeys = slotKeys;
    for (const slotKey of slotKeys) {
      const slotChildren = (_a = codeComponentSlots[slotKey]) == null ? void 0 : _a.map(
        (child,) =>
          convertPresentationTree(
            child,
            converter,
            componentDefinitionProvider,
            getCachedNode,
            skipCodeComponentPropsCache,
          ),
      );
      codeComponentPresentation.props[slotKey] = slotChildren;
    }
  }
  return [
    converter(
      codeComponentPresentation,
      codeComponentPresentation.children.map(
        (child,) =>
          convertPresentationTree(
            child,
            converter,
            componentDefinitionProvider,
            getCachedNode,
            skipCodeComponentPropsCache,
          ),
      ),
    ),
  ];
}
var CodeComponentPresentation = class {
  constructor(id3, componentIdentifier, packageVersion, props, children, codeOverrideIdentifier,) {
    this.id = id3;
    this.componentIdentifier = componentIdentifier;
    this.packageVersion = packageVersion;
    this.props = props;
    this.children = children;
    this.codeOverrideIdentifier = codeOverrideIdentifier;
    __publicField(this, 'cache', {},);
  }
  getProps() {
    return {
      ...this.props,
      id: this.id,
      key: this.id,
    };
  }
  rect(_parentSizeInfo,) {
    return { x: 0, y: 0, width: 0, height: 0, };
  }
};
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&#39;',
};
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source,);
function escapeHTML2(str,) {
  return str && reHasUnescapedHtml.test(str,)
    ? str.replace(reUnescapedHtml, (chr,) => {
      var _a;
      return (_a = htmlEscapes[chr]) != null ? _a : '';
    },)
    : str || '';
}
var deprecatedRichTextPlaceholder = '{{ text-placeholder }}';
var richTextWrapperClassName = 'rich-text-wrapper';
var DeprecatedRichText = /* @__PURE__ */ React104.forwardRef(
  function Text3(props, forwardedRef,) {
    var _a, _b;
    const {
      id: id3,
      name,
      html,
      htmlFromDesign,
      text,
      textFromDesign,
      fonts = [],
      width,
      height,
      left,
      right,
      top,
      bottom,
      center,
      className,
      stylesPresetsClassName,
      visible = true,
      opacity,
      rotation = 0,
      verticalAlignment = 'top',
      isEditable = false,
      willChangeTransform,
      environment: environment2 = RenderTarget.current,
      withExternalLayout = false,
      positionSticky,
      positionStickyTop,
      positionStickyRight,
      positionStickyBottom,
      positionStickyLeft,
      __htmlStructure,
      __fromCanvasComponent = false,
      _forwardedOverrideId,
      _forwardedOverrides,
      _usesDOMRect,
      children,
      ...rest
    } = props;
    const parentSize = useParentSize();
    const layoutId = useLayoutId2(props,);
    const fallbackLayoutRef = useRef16(null,);
    const layoutRef = forwardedRef != null ? forwardedRef : fallbackLayoutRef;
    const { navigate, getRoute, } = useRouter();
    const currentRoute = useCurrentRoute();
    useRoutePreloader((_a = props.preload) != null ? _a : [],);
    useMeasureLayout(props, layoutRef,);
    const inCodeComponent = React104.useContext(ComponentContainerContext,);
    const isOnCanvas = useIsOnFramerCanvas();
    let textOrOverride = text;
    const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id3;
    if (forwardedOverrideId && _forwardedOverrides) {
      const override = _forwardedOverrides[forwardedOverrideId];
      if (typeof override === 'string') {
        textOrOverride = override;
      }
    }
    let innerHTML = '';
    if (textOrOverride) {
      const escapedText = escapeHTML2(textOrOverride,);
      innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText,) : `<p>${escapedText}</p>`;
    } else if (html) {
      innerHTML = html;
    } else if (textFromDesign) {
      const escapedText = escapeHTML2(textFromDesign,);
      innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText,) : `<p>${escapedText}</p>`;
    } else if (htmlFromDesign) {
      innerHTML = htmlFromDesign;
    }
    const implicitPathVariables = useImplicitPathVariables();
    const innerHTMLWithReplacedFramerPageLinks = React104.useMemo(() => {
      if (isOnCanvas || !getRoute || !currentRoute) {
        return innerHTML;
      }
      return replaceFramerPageLinks(innerHTML, getRoute, currentRoute, implicitPathVariables,);
    }, [isOnCanvas, innerHTML, getRoute, currentRoute, implicitPathVariables,],);
    React104.useEffect(() => {
      const container = layoutRef.current;
      if (container === null) {
        return;
      }
      function interceptPageLinks(event,) {
        const anchorElement = findAnchorElement(event.target, layoutRef.current,);
        if (event.metaKey || !navigate || !anchorElement || anchorElement.getAttribute('target',) === '_blank') {
          return;
        }
        const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables,);
        if (didNavigate) {
          event.preventDefault();
        }
      }
      container.addEventListener('click', interceptPageLinks,);
      return () => {
        container.removeEventListener('click', interceptPageLinks,);
      };
    }, [navigate, implicitPathVariables,],);
    useLoadFonts(fonts, __fromCanvasComponent, layoutRef,);
    React104.useInsertionEffect(() => {
      injectComponentCSSRules();
    }, [],);
    if (!visible) {
      return null;
    }
    const isHidden2 = isEditable && environment2() === 'CANVAS';
    const style = {
      outline: 'none',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: convertVerticalAlignment2(verticalAlignment,),
      opacity: isHidden2 ? 0 : opacity,
      flexShrink: 0,
    };
    const restrictedRenderTarget = RenderTarget.hasRestrictions();
    const frame2 = calculateRect(props, parentSize || 0, false,);
    const isAutoSized2 = _usesDOMRect && (width === 'auto' || height === 'auto');
    const hasTransformTemplate = !!props.transformTemplate || !frame2 || !restrictedRenderTarget || __fromCanvasComponent || isAutoSized2;
    const template = hasTransformTemplate ? (_b = props.transformTemplate) != null ? _b : transformTemplate(center,) : void 0;
    if (!withExternalLayout) {
      if (frame2 && restrictedRenderTarget && !isAutoSized2) {
        const rotate = Animatable.getNumber(rotation,).toFixed(4,);
        style.transform = `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate}deg)`;
        style.width = frame2.width;
        style.minWidth = frame2.width;
        style.height = frame2.height;
      } else {
        style.left = left;
        style.right = right;
        style.top = top;
        style.bottom = bottom;
        style.width = width;
        style.height = height;
        style.rotate = rotation;
      }
      if (positionSticky) {
        if (!isOnCanvas || inCodeComponent) {
          style.position = 'sticky';
          style.willChange = 'transform';
          style.zIndex = 1;
          style.top = positionStickyTop;
          style.right = positionStickyRight;
          style.bottom = positionStickyBottom;
          style.left = positionStickyLeft;
        }
      } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
        style.position = 'absolute';
      }
    }
    collectFiltersFromProps(props, style,);
    collectTextShadowsForProps(props, style,);
    if (willChangeTransform) {
      forceLayerBackingWithCSSProperties(style,);
    }
    Object.assign(style, props.style,);
    return /* @__PURE__ */ React104.createElement(
      motion.div,
      {
        id: id3,
        ref: layoutRef,
        ...rest,
        style,
        layoutId,
        'data-framer-name': name,
        'data-framer-component-type': 'DeprecatedRichText',
        'data-center': center,
        className: cx(className, stylesPresetsClassName, richTextWrapperClassName,),
        transformTemplate: template,
        dangerouslySetInnerHTML: { __html: innerHTMLWithReplacedFramerPageLinks, },
      },
    );
  },
);
function convertVerticalAlignment2(verticalAlignment,) {
  switch (verticalAlignment) {
    case 'top':
      return 'flex-start';
    case 'center':
      return 'center';
    case 'bottom':
      return 'flex-end';
  }
}
function useLoadFonts(fonts, fromCanvasComponent, containerRef,) {
  const prevFontsRef = useRef16([],);
  if (!isShallowEqualArray(prevFontsRef.current, fonts,)) {
    prevFontsRef.current = fonts;
    fontStore.loadFonts(fonts,).then(({ newlyLoadedFontCount, },) => {
      if (!fromCanvasComponent || !containerRef.current || RenderTarget.current() !== 'CANVAS') {
        return;
      }
      if (newlyLoadedFontCount > 0) {
        measureClosestComponentContainer(containerRef.current,);
      }
    },);
  }
}
var FitText = /* @__PURE__ */ forwardRef52(
  ({ viewBoxScale, viewBox, children, ...props }, ref,) => {
    return /* @__PURE__ */ React105.createElement(
      motion.svg,
      { ref, ...props, viewBox, },
      /* @__PURE__ */ React105.createElement(
        motion.foreignObject,
        {
          width: '100%',
          height: '100%',
          className: 'framer-fit-text',
          transform: `scale(${viewBoxScale})`,
          style: { overflow: 'visible', transformOrigin: 'center center', },
        },
        children,
      ),
    );
  },
);
var RichTextContainer = /* @__PURE__ */ forwardRef52(
  (props, ref,) => {
    var _a;
    const {
      __fromCanvasComponent = false,
      _forwardedOverrideId,
      _forwardedOverrides,
      _usesDOMRect,
      as,
      bottom,
      center,
      children,
      environment: environment2 = RenderTarget.current,
      fonts = [],
      height,
      isEditable = false,
      left,
      name,
      opacity,
      positionSticky,
      positionStickyBottom,
      positionStickyLeft,
      positionStickyRight,
      positionStickyTop,
      right,
      rotation = 0,
      style,
      _initialStyle,
      stylesPresetsClassNames,
      text: plainText,
      top,
      verticalAlignment = 'top',
      visible = true,
      width,
      willChangeTransform,
      withExternalLayout = false,
      viewBox,
      viewBoxScale = 1,
      ...rest
    } = props;
    const parentSize = useParentSize();
    const isOnCanvas = useIsOnFramerCanvas();
    const inCodeComponent = useContext162(ComponentContainerContext,);
    const layoutId = useLayoutId2(props,);
    const fallbackRef = useRef17(null,);
    const containerRef = ref != null ? ref : fallbackRef;
    useMeasureLayout(props, containerRef,);
    useLoadFonts(fonts, __fromCanvasComponent, containerRef,);
    useInsertionEffect42(() => {
      injectComponentCSSRules();
    }, [],);
    if (!visible) {
      return null;
    }
    const isHidden2 = isEditable && environment2() === 'CANVAS';
    const containerStyle = {
      outline: 'none',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: convertVerticalAlignment2(verticalAlignment,),
      opacity: isHidden2 ? 0 : opacity,
      flexShrink: 0,
    };
    const restrictedRenderTarget = RenderTarget.hasRestrictions();
    const frame2 = calculateRect(props, parentSize || 0, false,);
    const isAutoSized2 = _usesDOMRect && (width === 'auto' || height === 'auto');
    const hasTransformTemplate = !!props.transformTemplate || !frame2 || !restrictedRenderTarget || __fromCanvasComponent || isAutoSized2;
    const template = hasTransformTemplate ? (_a = props.transformTemplate) != null ? _a : transformTemplate(center,) : void 0;
    if (!withExternalLayout) {
      if (frame2 && restrictedRenderTarget && !isAutoSized2) {
        const rotate = Animatable.getNumber(rotation,).toFixed(4,);
        containerStyle.transform = `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate}deg)`;
        containerStyle.width = frame2.width;
        containerStyle.minWidth = frame2.width;
        containerStyle.height = frame2.height;
      } else {
        containerStyle.left = left;
        containerStyle.right = right;
        containerStyle.top = top;
        containerStyle.bottom = bottom;
        containerStyle.width = width;
        containerStyle.height = height;
        containerStyle.rotate = rotation;
      }
      if (positionSticky) {
        if (!isOnCanvas || inCodeComponent) {
          containerStyle.position = 'sticky';
          containerStyle.willChange = 'transform';
          containerStyle.zIndex = 1;
          containerStyle.top = positionStickyTop;
          containerStyle.right = positionStickyRight;
          containerStyle.bottom = positionStickyBottom;
          containerStyle.left = positionStickyLeft;
        }
      } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
        containerStyle.position = 'absolute';
      }
    }
    collectFiltersFromProps(props, containerStyle,);
    collectTextShadowsForProps(props, containerStyle,);
    if (willChangeTransform) {
      forceLayerBackingWithCSSProperties(containerStyle,);
    }
    Object.assign(containerStyle, _initialStyle, style,);
    if (layoutId) {
      rest.layout = 'preserve-aspect';
    }
    const Component15 = htmlElementAsMotionComponent(props.as,);
    if (isString22(props.viewBox,)) {
      if (props.as !== void 0) {
        return /* @__PURE__ */ React105.createElement(
          Component15,
          {
            ...rest,
            ref: containerRef,
            style: containerStyle,
            layoutId,
            transformTemplate: template,
            'data-framer-name': name,
            'data-framer-component-type': 'RichTextContainer',
          },
          /* @__PURE__ */ React105.createElement(
            FitText,
            {
              viewBox,
              viewBoxScale,
              style: { width: '100%', height: '100%', },
            },
            children && styleRichTextChildren(children, stylesPresetsClassNames, plainText,),
          ),
        );
      } else {
        return /* @__PURE__ */ React105.createElement(
          FitText,
          {
            ...rest,
            ref: containerRef,
            style: containerStyle,
            layoutId,
            viewBox,
            viewBoxScale,
            transformTemplate: template,
            'data-framer-name': name,
            'data-framer-component-type': 'RichTextContainer',
          },
          children && styleRichTextChildren(children, stylesPresetsClassNames, plainText,),
        );
      }
    }
    return /* @__PURE__ */ React105.createElement(
      Component15,
      {
        ...rest,
        ref: containerRef,
        style: containerStyle,
        layoutId,
        transformTemplate: template,
        'data-framer-name': name,
        'data-framer-component-type': 'RichTextContainer',
      },
      children && styleRichTextChildren(children, stylesPresetsClassNames, plainText,),
    );
  },
);
function styleRichTextChildren(element, stylesPresetsClassNames, plainText,) {
  let children = Children22.toArray(element.props.children,);
  if (isString22(plainText,)) {
    children = children.slice(0, 1,);
  }
  children = children.map((child,) => {
    if (isValidElement22(child,)) {
      return styleRichTextChildren(child, stylesPresetsClassNames, plainText,);
    }
    if (isString22(plainText,)) {
      return plainText;
    }
    return child;
  },);
  const { ['data-preset-tag']: dataPresetTag, ...props } = element.props;
  if (isString22(element.type,) || isMotionComponent(element.type,)) {
    const tag = dataPresetTag || unwrapMotionComponent(element.type,) || element.type;
    const stylesPresetClassName = isString22(tag,) ? stylesPresetsClassNames == null ? void 0 : stylesPresetsClassNames[tag] : void 0;
    props.className = cx('framer-text', props.className, stylesPresetClassName,);
  }
  return cloneElement22(element, props, ...children,);
}
var RichText = /* @__PURE__ */ forwardRef52(
  ({ children, html, htmlFromDesign, ...props }, ref,) => {
    const content = html || children || htmlFromDesign;
    if (isString22(content,)) {
      if (!props.stylesPresetsClassName && isObject2(props.stylesPresetsClassNames,)) {
        props.stylesPresetsClassName = Object.values(props.stylesPresetsClassNames,).join(' ',);
      }
      const contentProp = {
        // We need to use the original prop name.
        [isString22(html,) ? 'html' : 'htmlFromDesign']: content,
      };
      return /* @__PURE__ */ React105.createElement(DeprecatedRichText, { ...props, ...contentProp, ref, },);
    }
    if (!props.stylesPresetsClassNames && isString22(props.stylesPresetsClassName,)) {
      const [h1, h2, h3, p, a,] = props.stylesPresetsClassName.split(' ',);
      if (h1 === void 0 || h2 === void 0 || h3 === void 0 || p === void 0 || a === void 0) {
        console.warn(`Encountered invalid stylesPresetsClassNames: ${props.stylesPresetsClassNames}`,);
      } else {
        props.stylesPresetsClassNames = { h1, h2, h3, p, a, };
      }
    }
    return /* @__PURE__ */ React105.createElement(RichTextContainer, { ...props, ref, }, isValidElement22(content,) ? content : void 0,);
  },
);
var key6 = 'calculatedPaths';
function withShape(target,) {
  return key6 in target;
}
var Size = /* @__PURE__ */ (() => {
  function Size2(width, height,) {
    return { width, height, };
  }
  Size2.equals = (sizeA, sizeB,) => {
    if (sizeA === sizeB) {
      return true;
    }
    if (!sizeA || !sizeB) {
      return false;
    }
    return sizeA.width === sizeB.width && sizeA.height === sizeB.height;
  };
  Size2.update = (fromSize, toSize, keepAspectRatio = false,) => {
    let { width, height, } = fromSize;
    const sizeRatio = width / height;
    width = toSize.width !== void 0 ? toSize.width : width;
    height = toSize.height !== void 0 ? toSize.height : height;
    if (keepAspectRatio) {
      if (toSize.width === void 0 && toSize.height !== void 0) {
        width = toSize.height * sizeRatio;
      }
      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) {
        height = toSize.width / sizeRatio;
      }
    }
    return { width, height, };
  };
  Size2.subtract = (sizeA, sizeB,) => {
    return {
      width: Math.max(0, sizeA.width - sizeB.width,),
      height: Math.max(0, sizeA.height - sizeB.height,),
    };
  };
  Size2.zero = Size2(0, 0,);
  Size2.isZero = function (size2,) {
    return size2 === Size2.zero || size2.width === 0 && size2.height === 0;
  };
  Size2.defaultIfZero = function (width, height, size2,) {
    if (Size2.isZero(size2,)) {
      return Size2(width, height,);
    }
    return size2;
  };
  return Size2;
})();
function annotateTypeOnStringify(ctor, typeName,) {
  const existingToJSON = ctor.prototype.toJSON;
  ctor.prototype.toJSON = function () {
    const base = existingToJSON ? existingToJSON.apply(this,) : this;
    return Object.assign({}, base, { __type__: typeName, },);
  };
  return ctor;
}
function isOfAnnotatedType(object, typeName,) {
  return object && object.__type__ && object.__type__ === typeName;
}
var frameFromElement = (element,) => {
  const frame2 = Rect.fromRect(element.getBoundingClientRect(),);
  frame2.x = frame2.x + safeWindow.scrollX;
  frame2.y = frame2.y + safeWindow.scrollY;
  return frame2;
};
var frameFromElements = (elements,) => {
  return Rect.merge(...elements.map(frameFromElement,),);
};
var convertToPageFrame = (frame2, element,) => {
  const point2 = convertToPagePoint(frame2, element,);
  return {
    x: point2.x,
    y: point2.y,
    width: frame2.width,
    height: frame2.height,
  };
};
var convertFromPageFrame = (frame2, element,) => {
  const point2 = convertFromPagePoint(frame2, element,);
  return {
    x: point2.x,
    y: point2.y,
    width: frame2.width,
    height: frame2.height,
  };
};
var getPageFrame = (element,) => {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + safeWindow.scrollX,
    y: rect.top + safeWindow.scrollY,
    width: rect.width,
    height: rect.height,
  };
};
var fromEventForPage = (event,) => {
  return {
    x: event.pageX,
    y: event.pageY,
  };
};
var fromEventForClient = (event,) => {
  return {
    x: event.clientX,
    y: event.clientY,
  };
};
var convertToPagePoint = (point2, element,) => {
  const frame2 = getPageFrame(element,);
  return {
    x: point2.x + frame2.x,
    y: point2.y + frame2.y,
  };
};
var convertFromPagePoint = (point2, element,) => {
  const frame2 = getPageFrame(element,);
  return {
    x: point2.x - frame2.x,
    y: point2.y - frame2.y,
  };
};
var dispatchKeyDownEvent = (keyCode, options = {},) => {
  const keyboardEvent = new KeyboardEvent('keydown', {
    bubbles: true,
    keyCode,
    ...options,
  },);
  const activeElement = document.activeElement;
  if (activeElement) {
    activeElement.dispatchEvent(keyboardEvent,);
  }
};
var DOM = {
  frameFromElement,
  frameFromElements,
  convertToPageFrame,
  convertFromPageFrame,
  getPageFrame,
  fromEventForPage,
  fromEventForClient,
  convertToPagePoint,
  convertFromPagePoint,
};
function gradientForShape(nodeId, node,) {
  if (LinearGradient.isLinearGradient(node.fill,)) {
    return elementPropertiesForLinearGradient(node.fill, nodeId,);
  }
  if (RadialGradient.isRadialGradient(node.fill,)) {
    return elementPropertiesForRadialGradient(node.fill, nodeId,);
  }
  return void 0;
}
function throttle(fn, time22,) {
  let previous = 0;
  let timeout;
  const later = (...args) => {
    previous = Date.now();
    timeout = void 0;
    fn(...args,);
  };
  return (...args) => {
    const now2 = Date.now();
    const remaining = time22 - (now2 - previous);
    if (remaining <= 0 || remaining > time22) {
      if (timeout) {
        safeWindow.clearTimeout(timeout,);
        timeout = void 0;
      }
      previous = now2;
      fn(...args,);
    } else if (!timeout) {
      timeout = safeWindow.setTimeout(later, remaining, ...args,);
    }
  };
}
function addActionControls(action, title, controls,) {
  runtime.addActionControls(action, title, controls,);
}
function addFonts(component, passedFonts, flags,) {
  const fonts = convertMixedFontArrayToFontBundles(passedFonts,);
  if (
    !(flags == null ? void 0 : flags.supportsExplicitInterCodegen) && // Only emit an `explicitInter: false` bundle if we don’t already have one.
    !fonts.some((font,) => font.explicitInter === false)
  ) {
    fonts.push({ explicitInter: false, fonts: [], },);
  }
  Object.assign(component, { fonts, },);
}
function getFonts(component,) {
  const fonts = component.fonts;
  return fonts != null ? fonts : [];
}
function getFontsFromSharedStyle(fonts,) {
  if (fonts.length === 0) {
    return [{ explicitInter: false, fonts: [], },];
  }
  return convertMixedFontArrayToFontBundles(fonts,);
}
function getFontsFromComponentPreset(fonts,) {
  if (fonts.length === 0) {
    return [{ explicitInter: false, fonts: [], },];
  }
  return convertMixedFontArrayToFontBundles(fonts,);
}
function convertMixedFontArrayToFontBundles(fonts,) {
  const oldFontBundle = { explicitInter: false, fonts: [], };
  const fontBundles = [];
  for (const fontOrBundle of fonts) {
    if (isComponentFontBundle(fontOrBundle,)) {
      fontBundles.push(fontOrBundle,);
    } else {
      oldFontBundle.fonts.push(upgradeComponentFontV1(fontOrBundle,),);
    }
  }
  if (oldFontBundle.fonts.length > 0) {
    fontBundles.push(oldFontBundle,);
  }
  return fontBundles;
}
var componentFontBundleKey = 'explicitInter';
function isComponentFontBundle(font,) {
  return componentFontBundleKey in font;
}
function upgradeComponentFontV1(font,) {
  let source;
  if (font.url.startsWith('https://fonts.gstatic.com/s/',)) {
    source = 'google';
  } else if (font.url.startsWith('https://framerusercontent.com/third-party-assets/fontshare/',)) {
    source = 'fontshare';
  } else {
    source = 'custom';
  }
  return {
    ...font,
    source,
  };
}
function loadJSON(url,) {
  return fetch(url, { mode: 'cors', },).then((res,) => res.json());
}
function inspectObjectType(item,) {
  let className;
  if (
    (item.constructor !== null ? item.constructor.name : void 0) !== null &&
    (item.constructor !== null ? item.constructor.name : void 0) !== 'Object'
  ) {
    return item.constructor.name;
  }
  const extract = function (str,) {
    if (!str) {
      return null;
    }
    const regex2 = /\[object (\w+)\]/;
    const match = regex2.exec(str,);
    if (match) {
      return match[1];
    }
    return null;
  };
  if (item.toString) {
    className = extract(item.toString(),);
    if (className) {
      return className;
    }
  }
  if (item.constructor !== null ? item.constructor.toString : void 0) {
    className = extract(item.constructor !== null ? item.constructor.toString() : void 0,);
    if (className) {
      return className.replace('Constructor', '',);
    }
  }
  return 'Object';
}
function inspect(item, max, l,) {
  if (max === void 0) {
    max = 5;
  }
  if (l === void 0) {
    l = 0;
  }
  if (item === null) {
    return 'null';
  }
  if (item === void 0) {
    return 'undefined';
  }
  if (isObject2(item,) && isFunction(item.toInspect,)) {
    return item.toInspect();
  }
  if (isString22(item,)) {
    return `"${item}"`;
  }
  if (isNumber2(item,)) {
    return `${item}`;
  }
  if (isFunction(item,)) {
    let code = item.toString().slice('function '.length,).replace(/\n/g, '',).replace(/\s+/g, ' ',);
    const limit = 50;
    if (code.length > limit && l > 0) {
      code = `${code.slice(0, +limit + 1 || void 0,).trim()}\u2026 }`;
    }
    return `<Function ${code}>`;
  }
  if (isArray(item,)) {
    if (l > max) {
      return '[...]';
    }
    return `[${item.map((i,) => inspect(i, max, (l || 0) + 1,)).join(', ',)}]`;
  }
  if (isObject2(item,)) {
    let objectInfo;
    const objectType = inspectObjectType(item,);
    if (/HTML\w+?Element/.test(objectType,)) {
      return `<${objectType}>`;
    }
    if (l > max) {
      objectInfo = '{...}';
    } else {
      const itemKeys = Object.keys(item,);
      objectInfo = `{${itemKeys.map((k,) => `${k}:${inspect(item[k], max, (l || 0) + 1,)}`).join(', ',)}}`;
    }
    if (objectType === 'Object') {
      return objectInfo;
    }
    return `<${objectType} ${objectInfo}>`;
  }
  return `${item}`;
}
function print(...args) {
  const line = args.map((arg,) => {
    return inspect(arg,);
  },).join(', ',);
  console.log(line,);
}
function initialRouteComponent(component,) {
  if (!component) {
    return null;
  }
  if (withPreload(component,)) {
    return null;
  }
  return component;
}
function useInitialRouteComponent(routes, homeNodeId,) {
  var _a;
  const InitialRouteComponent = (_a = routes[homeNodeId]) == null ? void 0 : _a.page;
  const [RouteComponent, setRouteComponent,] = useState22(
    initialRouteComponent(InitialRouteComponent,),
  );
  useEffect132(() => {
    if (withPreload(InitialRouteComponent,)) {
      InitialRouteComponent.preload().then(setRouteComponent,);
    }
  }, [],);
  return RouteComponent;
}
var package_default = {
  name: 'framer',
  version: '2.4.1',
  main: 'build/index.js',
  type: 'module',
  exports: {
    '.': './build/index.js',
    './package.json': './package.json',
    './*': './build/*',
  },
  files: [
    'build',
    'CHANGELOG.md',
    'README.md',
    'LICENSE.md',
    'postinstall.cjs',
  ],
  types: './build/index.d.ts',
  author: 'Framer',
  license: 'MIT',
  scripts: {
    prepublishOnly: 'make build',
    coverage: 'yarn :jest --coverage',
    lint: 'yarn :eslint ./src --ext .ts,.tsx --format codeframe --quiet',
    'lint:fix': 'yarn lint --fix --cache',
    test: 'yarn :jest',
    watch: 'yarn :jest --watch',
    postinstall: 'node postinstall.cjs',
  },
  dependencies: {
    '@framerjs/router': 'workspace:*',
    '@juggle/resize-observer': '^3.3.1',
    eventemitter3: '^3.1.0',
    fontfaceobserver: '^2.1.0',
    'hoist-non-react-statics': '^3.3.2',
    hsluv: '^0.0.3',
  },
  devDependencies: {
    '@microsoft/api-extractor': '^7.42.3',
    '@testing-library/dom': '^8.19.1',
    '@testing-library/jest-dom': '^5.16.5',
    '@testing-library/react': '^13.4.0',
    '@testing-library/user-event': '^14.4.3',
    '@types/google.fonts': '1.0.3',
    '@types/hsluv': 'https://github.com/framer/typed_hsluv#bump',
    '@types/node': '^18.17.15',
    '@types/react': '^18.0.26',
    '@types/react-dom': '^18.0.10',
    '@types/yargs': '^17.0.19',
    '@typescript-eslint/eslint-plugin': '^6.16.0',
    '@typescript-eslint/parser': '^6.16.0',
    chalk: '^4.1.2',
    eslint: '^8.56.0',
    immutable: '^3.8.2',
    'jest-diff': '^29.3.1',
    'jest-junit': '^15.0.0',
    react: '^18.2.0',
    'react-dom': '^18.2.0',
    semver: '^7.5.2',
    typescript: '^5.3.3',
    yargs: '^17.6.2',
  },
  peerDependencies: {
    'framer-motion': '11.0.7',
    react: '^18.2.0',
    'react-dom': '^18.2.0',
  },
  tsdoc: {
    tsdocFlavor: 'AEDoc',
  },
  framer: {
    components: [
      {
        name: 'Scroll',
        children: true,
        properties: [
          {
            key: 'direction',
            title: 'Direction',
            kind: 'enum',
            options: [
              'horizontal',
              'vertical',
              'both',
            ],
          },
        ],
      },
      {
        name: 'Page',
      },
    ],
  },
};
var { version, } = package_default;
MotionValue.prototype.addChild = function ({ transformer = (v,) => v, },) {
  const child = motionValue(transformer(this.get(),),);
  this.onChange((v,) => child.set(transformer(v,),));
  return child;
};
if (false) {
  MainLoop.start();
}
export {
  _injectRuntime,
  addActionControls,
  addFonts,
  addPointerEvent,
  addPointerInfo,
  addPropertyControls,
  addScaleCorrector,
  AnchorLinkTarget,
  Animatable,
  animate2 as animate,
  AnimatePresence,
  AnimateSharedLayout,
  animateValue,
  animateVisualElement,
  animationControls,
  animations,
  annotateTypeOnStringify,
  anticipate,
  AnyInterpolation,
  AutomaticLayoutIds,
  BackgroundImage,
  backgroundImageFromProps,
  backIn,
  backInOut,
  backOut,
  BezierAnimator,
  BoxShadow,
  buildTransform,
  calcLength,
  calculateRect,
  callEach,
  cancelFrame,
  cancelSync,
  CanvasStore,
  checkTargetForNewValues,
  circIn,
  circInOut,
  circOut,
  clamp,
  collectVisualStyleFromProps,
  Color,
  color,
  ColorFormat,
  ColorMixModelType,
  combinedCSSRulesForPreview,
  complex,
  ComponentContainerContext,
  ComponentPresetsConsumer,
  ComponentPresetsProvider,
  ComponentViewportProvider,
  ConstraintMask,
  constraintsEnabled,
  ConstraintValues,
  Container,
  ControlType,
  ConvertColor,
  convertPresentationTree,
  convertPropsToDeviceOptions,
  createBox,
  createData,
  createDesignComponent,
  createDomMotionComponent,
  createFramerPageLink,
  createMotionComponent,
  createScopedAnimate,
  cssBackgroundSize,
  cubicBezier,
  CustomCursorHost,
  CustomProperties,
  cx,
  CycleVariantState,
  Data,
  DataContext,
  DataObserver,
  DataObserverContext,
  debounce,
  defaultDeviceProps,
  delay,
  DeprecatedComponentContainer,
  DeprecatedFrameWithEvents,
  DeprecatedLayoutGroupContext,
  DeprecatedLayoutGroupContext as LayoutGroupContext,
  Device,
  DeviceCodeComponent,
  devicePresets,
  DimensionType,
  disableInstantTransitions,
  dispatchKeyDownEvent,
  distance,
  distance2D,
  DOM,
  domAnimation,
  domMax,
  DragControls,
  Draggable,
  easeIn,
  easeInOut,
  easeOut,
  EmptyState,
  environment,
  ErrorPlaceholder,
  executeInRenderEnvironment,
  filterProps,
  finiteNumber,
  FlatTree,
  Floating,
  FontSourceNames,
  fontStore,
  forceLayerBackingWithCSSProperties,
  fraction,
  Frame,
  frame,
  frameData,
  frameFromElement,
  frameFromElements,
  FramerAnimation,
  framerAppearAnimationScriptKey,
  framerAppearEffects,
  framerAppearIdKey,
  framerAppearTransformTemplateToken,
  FramerEvent,
  FramerEventListener,
  FramerEventSession,
  FrameWithMotion,
  GamepadContext,
  GeneratedComponentContext,
  getComponentSize,
  getDevicePreset,
  getFonts,
  getFontsFromComponentPreset,
  getFontsFromSharedStyle,
  getMeasurableCodeComponentChildren,
  getMergedConstraintsProps,
  getPropertyControls,
  getWhereExpressionFromPathVariables,
  gradientForShape,
  Image2 as Image,
  imagePatternPropsForFill,
  imageUrlForAsset,
  inferInitialRouteFromPath,
  injectComponentCSSRules,
  installFlexboxGapWorkaroundIfNeeded,
  InternalID,
  interpolate,
  invariant,
  inView,
  isAnimatable2 as isAnimatable,
  isBrowser,
  isDesignDefinition,
  isDragActive,
  isEqual,
  isFiniteNumber,
  isFractionDimension,
  isFramerGamepadKeydownData,
  isFramerPageLink,
  isGapEnabled,
  isMotionComponent,
  isMotionValue2 as isMotionValue,
  isOfAnnotatedType,
  isOverride,
  isReactDefinition,
  isRelativeNumber,
  isShallowEqualArray,
  isStraightCurve,
  isValidMotionProp,
  Layer,
  LayoutGroup,
  LayoutIdContext,
  lazy,
  LazyMotion,
  LazyValue,
  LibraryFeaturesProvider,
  Line,
  LinearGradient,
  Link,
  loadFont,
  loadJSON,
  localPackageFallbackIdentifier,
  localShadowFrame,
  m,
  MainLoop,
  makePaddingString,
  makeUseVisualState,
  memoize2 as memoize,
  mirrorEasing,
  mix,
  modulate,
  motion,
  MotionConfig,
  MotionConfigContext,
  MotionContext,
  MotionGlobalConfig,
  MotionSetup,
  MotionValue,
  motionValue,
  NavigateTo,
  NavigationCallbackProvider,
  NavigationConsumer,
  NavigationTransitionType,
  NavigationWrapper as Navigation,
  NotFoundError,
  ObservableObject,
  optimizeAppear,
  optimizeAppearTransformTemplate,
  optimizedAppearDataAttribute,
  paddingFromProps,
  Page3 as Page,
  PageEffectsProvider,
  PageRoot,
  ParentSizeState,
  parseFramerPageLink,
  pathDefaults,
  PathSegment,
  PathVariablesContext,
  pipe,
  Point,
  PresenceContext,
  print,
  progress,
  PropertyOverrides,
  PropertyStore,
  propsForLink,
  px,
  QueryEngine,
  RadialGradient,
  Rect,
  removeHiddenBreakpointLayers,
  RenderNodeProvider,
  RenderTarget,
  Reorder,
  resolveLink,
  ResolveLinks,
  resolveMotionValue,
  resolvePageScope,
  reverseEasing,
  RichText,
  roundedNumber,
  roundedNumberString,
  roundWithOffset,
  Scroll,
  scroll,
  scrollInfo,
  setGlobalRenderEnvironment,
  Shadow,
  sharedSVGManager,
  shouldOpenLinkInNewTab,
  Size,
  spring,
  SpringAnimator,
  SSRVariants,
  Stack,
  stagger,
  startAnimation,
  startOptimizedAppearAnimation,
  steps,
  StyleSheetContext,
  SVG,
  SwitchLayoutGroupContext,
  sync,
  systemFontFamilyName,
  Text,
  throttle,
  toFlexDirection,
  toJustifyOrAlignment,
  toSVGPath,
  transform,
  transformString,
  transformTemplate,
  unwrapMotionComponent,
  useActiveTargetCallback,
  useActiveVariantCallback,
  useAddVariantProps,
  useAnimate,
  useAnimatedState,
  useAnimatedState as useDeprecatedAnimatedState,
  useAnimation,
  useAnimationControls,
  useAnimationFrame,
  useBreakpointVariants,
  useComponentViewport,
  useConstant2 as useConstant,
  useCurrentPathVariables,
  useCurrentRouteId,
  useCustomCursors,
  useCycle,
  useDataRecord,
  useDomEvent,
  useDragControls,
  useDynamicRefs,
  useElementScroll,
  useForceUpdate,
  useGamepad,
  useHotkey,
  useHydratedBreakpointVariants,
  useInitialRouteComponent,
  useInstantLayoutTransition,
  useInstantTransition,
  useInvertedScale,
  useInvertedScale as useDeprecatedInvertedScale,
  useInView,
  useIsInCurrentNavigationTarget,
  useIsomorphicLayoutEffect,
  useIsOnFramerCanvas,
  useIsPresent,
  useLocale,
  useLocaleCode,
  useLocaleInfo,
  useLocalizationInfo,
  useMeasureLayout,
  useMotionTemplate,
  useMotionValue,
  useMotionValueEvent,
  useNavigate,
  useNavigation,
  useObserveData,
  useOnAppear,
  useOnCurrentTargetChange,
  useOnVariantChange,
  useOverlayState,
  usePageEffects,
  usePresence,
  usePrototypeNavigate,
  useProvidedWindow,
  useQueryData,
  useReducedMotion,
  useReducedMotionConfig,
  useRenderEnvironment,
  useResetProjection,
  useRoute,
  useRouteAnchor,
  useRouteElementId,
  useRouteHandler,
  useRouter,
  useScroll,
  useSpring,
  useTime,
  useTransform,
  useUnmountEffect,
  useVariantState,
  useVelocity,
  useViewportScroll,
  useWillChange,
  ValueInterpolation,
  valueToDimensionType,
  VariantSelector,
  Vector,
  VectorGroup,
  version,
  VisualElement,
  visualElementStore,
  warning,
  WindowContext,
  withCSS,
  withFX,
  withGeneratedLayoutId,
  withMappedReactProps,
  withMeasuredSize,
  WithNavigator,
  withOpacity,
  WithOverride,
  withParallaxTransform,
  withPath,
  withShape,
  withStyleAppearEffect,
  withVariantAppearEffect,
  withVariantFX,
  wrap,
};
/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/



